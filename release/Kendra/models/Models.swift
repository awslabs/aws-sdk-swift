// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessControlListConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyPath = "KeyPath"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyPath = keyPath {
            try encodeContainer.encode(keyPath, forKey: .keyPath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPath)
        keyPath = keyPathDecoded
    }
}

extension AccessControlListConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessControlListConfiguration(keyPath: \(String(describing: keyPath)))"}
}

/// <p>Access Control List files for the documents in a data source. For
///             the format of the file, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html">Access control for S3 data
///                 sources</a>.</p>
public struct AccessControlListConfiguration: Equatable {
    /// <p>Path to the AWS S3 bucket that contains the ACL files.</p>
    public let keyPath: String?

    public init (
        keyPath: String? = nil
    )
    {
        self.keyPath = keyPath
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AclConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedGroupsColumnName = "AllowedGroupsColumnName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedGroupsColumnName = allowedGroupsColumnName {
            try encodeContainer.encode(allowedGroupsColumnName, forKey: .allowedGroupsColumnName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedGroupsColumnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedGroupsColumnName)
        allowedGroupsColumnName = allowedGroupsColumnNameDecoded
    }
}

extension AclConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AclConfiguration(allowedGroupsColumnName: \(String(describing: allowedGroupsColumnName)))"}
}

/// <p>Provides information about the column that should be used for
///             filtering the query response by groups.</p>
public struct AclConfiguration: Equatable {
    /// <p>A list of groups, separated by semi-colons, that filters a query
    ///             response based on user context. The document is only returned to
    ///             users that are in one of the groups specified in the
    ///                 <code>UserContext</code> field of the <code>Query</code>
    ///             operation.</p>
    public let allowedGroupsColumnName: String?

    public init (
        allowedGroupsColumnName: String? = nil
    )
    {
        self.allowedGroupsColumnName = allowedGroupsColumnName
    }
}

extension AdditionalResultAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
        case valueType = "ValueType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let valueType = valueType {
            try encodeContainer.encode(valueType.rawValue, forKey: .valueType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueTypeDecoded = try containerValues.decodeIfPresent(AdditionalResultAttributeValueType.self, forKey: .valueType)
        valueType = valueTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(AdditionalResultAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension AdditionalResultAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdditionalResultAttribute(key: \(String(describing: key)), value: \(String(describing: value)), valueType: \(String(describing: valueType)))"}
}

/// <p>An attribute returned from an index query.</p>
public struct AdditionalResultAttribute: Equatable {
    /// <p>The key that identifies the attribute.</p>
    public let key: String?
    /// <p>An object that contains the attribute value.</p>
    public let value: AdditionalResultAttributeValue?
    /// <p>The data type of the <code>Value</code> property.</p>
    public let valueType: AdditionalResultAttributeValueType?

    public init (
        key: String? = nil,
        value: AdditionalResultAttributeValue? = nil,
        valueType: AdditionalResultAttributeValueType? = nil
    )
    {
        self.key = key
        self.value = value
        self.valueType = valueType
    }
}

extension AdditionalResultAttributeValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case textWithHighlightsValue = "TextWithHighlightsValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let textWithHighlightsValue = textWithHighlightsValue {
            try encodeContainer.encode(textWithHighlightsValue, forKey: .textWithHighlightsValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textWithHighlightsValueDecoded = try containerValues.decodeIfPresent(TextWithHighlights.self, forKey: .textWithHighlightsValue)
        textWithHighlightsValue = textWithHighlightsValueDecoded
    }
}

extension AdditionalResultAttributeValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdditionalResultAttributeValue(textWithHighlightsValue: \(String(describing: textWithHighlightsValue)))"}
}

/// <p>An attribute returned with a document from a search.</p>
public struct AdditionalResultAttributeValue: Equatable {
    /// <p>The text associated with the attribute and information about the
    ///             highlight to apply to the text.</p>
    public let textWithHighlightsValue: TextWithHighlights?

    public init (
        textWithHighlightsValue: TextWithHighlights? = nil
    )
    {
        self.textWithHighlightsValue = textWithHighlightsValue
    }
}

public enum AdditionalResultAttributeValueType {
    case textWithHighlightsValue
    case sdkUnknown(String)
}

extension AdditionalResultAttributeValueType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AdditionalResultAttributeValueType] {
        return [
            .textWithHighlightsValue,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .textWithHighlightsValue: return "TEXT_WITH_HIGHLIGHTS_VALUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AdditionalResultAttributeValueType(rawValue: rawValue) ?? AdditionalResultAttributeValueType.sdkUnknown(rawValue)
    }
}

extension AttributeFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case andAllFilters = "AndAllFilters"
        case containsAll = "ContainsAll"
        case containsAny = "ContainsAny"
        case equalsTo = "EqualsTo"
        case greaterThan = "GreaterThan"
        case greaterThanOrEquals = "GreaterThanOrEquals"
        case lessThan = "LessThan"
        case lessThanOrEquals = "LessThanOrEquals"
        case notFilter = "NotFilter"
        case orAllFilters = "OrAllFilters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andAllFilters = andAllFilters {
            var andAllFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .andAllFilters)
            for attributefilterlist0 in andAllFilters {
                try andAllFiltersContainer.encode(attributefilterlist0)
            }
        }
        if let containsAll = containsAll {
            try encodeContainer.encode(containsAll, forKey: .containsAll)
        }
        if let containsAny = containsAny {
            try encodeContainer.encode(containsAny, forKey: .containsAny)
        }
        if let equalsTo = equalsTo {
            try encodeContainer.encode(equalsTo, forKey: .equalsTo)
        }
        if let greaterThan = greaterThan {
            try encodeContainer.encode(greaterThan, forKey: .greaterThan)
        }
        if let greaterThanOrEquals = greaterThanOrEquals {
            try encodeContainer.encode(greaterThanOrEquals, forKey: .greaterThanOrEquals)
        }
        if let lessThan = lessThan {
            try encodeContainer.encode(lessThan, forKey: .lessThan)
        }
        if let lessThanOrEquals = lessThanOrEquals {
            try encodeContainer.encode(lessThanOrEquals, forKey: .lessThanOrEquals)
        }
        if let notFilter = notFilter {
            try encodeContainer.encode(notFilter.value, forKey: .notFilter)
        }
        if let orAllFilters = orAllFilters {
            var orAllFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orAllFilters)
            for attributefilterlist0 in orAllFilters {
                try orAllFiltersContainer.encode(attributefilterlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let andAllFiltersContainer = try containerValues.decodeIfPresent([AttributeFilter?].self, forKey: .andAllFilters)
        var andAllFiltersDecoded0:[AttributeFilter]? = nil
        if let andAllFiltersContainer = andAllFiltersContainer {
            andAllFiltersDecoded0 = [AttributeFilter]()
            for structure0 in andAllFiltersContainer {
                if let structure0 = structure0 {
                    andAllFiltersDecoded0?.append(structure0)
                }
            }
        }
        andAllFilters = andAllFiltersDecoded0
        let orAllFiltersContainer = try containerValues.decodeIfPresent([AttributeFilter?].self, forKey: .orAllFilters)
        var orAllFiltersDecoded0:[AttributeFilter]? = nil
        if let orAllFiltersContainer = orAllFiltersContainer {
            orAllFiltersDecoded0 = [AttributeFilter]()
            for structure0 in orAllFiltersContainer {
                if let structure0 = structure0 {
                    orAllFiltersDecoded0?.append(structure0)
                }
            }
        }
        orAllFilters = orAllFiltersDecoded0
        let notFilterDecoded = try containerValues.decodeIfPresent(Box<AttributeFilter>.self, forKey: .notFilter)
        notFilter = notFilterDecoded
        let equalsToDecoded = try containerValues.decodeIfPresent(DocumentAttribute.self, forKey: .equalsTo)
        equalsTo = equalsToDecoded
        let containsAllDecoded = try containerValues.decodeIfPresent(DocumentAttribute.self, forKey: .containsAll)
        containsAll = containsAllDecoded
        let containsAnyDecoded = try containerValues.decodeIfPresent(DocumentAttribute.self, forKey: .containsAny)
        containsAny = containsAnyDecoded
        let greaterThanDecoded = try containerValues.decodeIfPresent(DocumentAttribute.self, forKey: .greaterThan)
        greaterThan = greaterThanDecoded
        let greaterThanOrEqualsDecoded = try containerValues.decodeIfPresent(DocumentAttribute.self, forKey: .greaterThanOrEquals)
        greaterThanOrEquals = greaterThanOrEqualsDecoded
        let lessThanDecoded = try containerValues.decodeIfPresent(DocumentAttribute.self, forKey: .lessThan)
        lessThan = lessThanDecoded
        let lessThanOrEqualsDecoded = try containerValues.decodeIfPresent(DocumentAttribute.self, forKey: .lessThanOrEquals)
        lessThanOrEquals = lessThanOrEqualsDecoded
    }
}

extension AttributeFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributeFilter(andAllFilters: \(String(describing: andAllFilters)), containsAll: \(String(describing: containsAll)), containsAny: \(String(describing: containsAny)), equalsTo: \(String(describing: equalsTo)), greaterThan: \(String(describing: greaterThan)), greaterThanOrEquals: \(String(describing: greaterThanOrEquals)), lessThan: \(String(describing: lessThan)), lessThanOrEquals: \(String(describing: lessThanOrEquals)), notFilter: \(String(describing: notFilter)), orAllFilters: \(String(describing: orAllFilters)))"}
}

/// <p>Provides filtering the query results based on document
///          attributes.</p>
///          <p>When you use the <code>AndAllFilters</code> or
///             <code>OrAllFilters</code>, filters you can use 2 layers under the
///          first attribute filter. For example, you can use:</p>
///          <p>
///             <code><AndAllFilters></code>
///          </p>
///          <ol>
///             <li>
///                <p>
///                   <code> <OrAllFilters></code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code> <EqualTo></code>
///                </p>
///             </li>
///          </ol>
///          <p>If you use more than 2 layers, you receive a
///             <code>ValidationException</code> exception with the message
///             "<code>AttributeFilter</code> cannot have a depth of more than
///          2."</p>
public struct AttributeFilter: Equatable {
    /// <p>Performs a logical <code>AND</code> operation on all supplied
    ///          filters.</p>
    public let andAllFilters: [AttributeFilter]?
    /// <p>Returns true when a document contains all of the specified document
    ///          attributes. This filter is only applicable to
    ///             <code>StringListValue</code> metadata.</p>
    public let containsAll: DocumentAttribute?
    /// <p>Returns true when a document contains any of the specified document
    ///          attributes. This filter is only applicable to
    ///             <code>StringListValue</code> metadata.</p>
    public let containsAny: DocumentAttribute?
    /// <p>Performs an equals operation on two document attributes.</p>
    public let equalsTo: DocumentAttribute?
    /// <p>Performs a greater than operation on two document attributes. Use
    ///          with a document attribute of type <code>Integer</code> or
    ///             <code>Long</code>.</p>
    public let greaterThan: DocumentAttribute?
    /// <p>Performs a greater or equals than operation on two document
    ///          attributes. Use with a document attribute of type <code>Integer</code>
    ///          or <code>Long</code>.</p>
    public let greaterThanOrEquals: DocumentAttribute?
    /// <p>Performs a less than operation on two document attributes. Use with
    ///          a document attribute of type <code>Integer</code> or
    ///          <code>Long</code>.</p>
    public let lessThan: DocumentAttribute?
    /// <p>Performs a less than or equals operation on two document attributes.
    ///          Use with a document attribute of type <code>Integer</code> or
    ///             <code>Long</code>.</p>
    public let lessThanOrEquals: DocumentAttribute?
    /// <p>Performs a logical <code>NOT</code> operation on all supplied
    ///          filters.</p>
    public let notFilter: Box<AttributeFilter>?
    /// <p>Performs a logical <code>OR</code> operation on all supplied
    ///          filters.</p>
    public let orAllFilters: [AttributeFilter]?

    public init (
        andAllFilters: [AttributeFilter]? = nil,
        containsAll: DocumentAttribute? = nil,
        containsAny: DocumentAttribute? = nil,
        equalsTo: DocumentAttribute? = nil,
        greaterThan: DocumentAttribute? = nil,
        greaterThanOrEquals: DocumentAttribute? = nil,
        lessThan: DocumentAttribute? = nil,
        lessThanOrEquals: DocumentAttribute? = nil,
        notFilter: Box<AttributeFilter>? = nil,
        orAllFilters: [AttributeFilter]? = nil
    )
    {
        self.andAllFilters = andAllFilters
        self.containsAll = containsAll
        self.containsAny = containsAny
        self.equalsTo = equalsTo
        self.greaterThan = greaterThan
        self.greaterThanOrEquals = greaterThanOrEquals
        self.lessThan = lessThan
        self.lessThanOrEquals = lessThanOrEquals
        self.notFilter = notFilter
        self.orAllFilters = orAllFilters
    }
}

public struct BatchDeleteDocumentInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteDocumentInput>
    public typealias MOutput = OperationOutput<BatchDeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteDocumentOutputError>
}

extension BatchDeleteDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteDocumentInput(dataSourceSyncJobMetricTarget: \(String(describing: dataSourceSyncJobMetricTarget)), documentIdList: \(String(describing: documentIdList)), indexId: \(String(describing: indexId)))"}
}

extension BatchDeleteDocumentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceSyncJobMetricTarget = "DataSourceSyncJobMetricTarget"
        case documentIdList = "DocumentIdList"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceSyncJobMetricTarget = dataSourceSyncJobMetricTarget {
            try encodeContainer.encode(dataSourceSyncJobMetricTarget, forKey: .dataSourceSyncJobMetricTarget)
        }
        if let documentIdList = documentIdList {
            var documentIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentIdList)
            for documentidlist0 in documentIdList {
                try documentIdListContainer.encode(documentidlist0)
            }
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct BatchDeleteDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteDocumentInput>
    public typealias MOutput = OperationOutput<BatchDeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteDocumentOutputError>
}

public struct BatchDeleteDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteDocumentInput>
    public typealias MOutput = OperationOutput<BatchDeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteDocumentOutputError>
}

public struct BatchDeleteDocumentInput: Equatable {
    /// <p>Maps a particular data source sync job to a particular data
    ///             source.</p>
    public let dataSourceSyncJobMetricTarget: DataSourceSyncJobMetricTarget?
    /// <p>One or more identifiers for documents to delete from the index.</p>
    public let documentIdList: [String]?
    /// <p>The identifier of the index that contains the documents to
    ///       delete.</p>
    public let indexId: String?

    public init (
        dataSourceSyncJobMetricTarget: DataSourceSyncJobMetricTarget? = nil,
        documentIdList: [String]? = nil,
        indexId: String? = nil
    )
    {
        self.dataSourceSyncJobMetricTarget = dataSourceSyncJobMetricTarget
        self.documentIdList = documentIdList
        self.indexId = indexId
    }
}

struct BatchDeleteDocumentInputBody: Equatable {
    public let indexId: String?
    public let documentIdList: [String]?
    public let dataSourceSyncJobMetricTarget: DataSourceSyncJobMetricTarget?
}

extension BatchDeleteDocumentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSourceSyncJobMetricTarget = "DataSourceSyncJobMetricTarget"
        case documentIdList = "DocumentIdList"
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let documentIdListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .documentIdList)
        var documentIdListDecoded0:[String]? = nil
        if let documentIdListContainer = documentIdListContainer {
            documentIdListDecoded0 = [String]()
            for string0 in documentIdListContainer {
                if let string0 = string0 {
                    documentIdListDecoded0?.append(string0)
                }
            }
        }
        documentIdList = documentIdListDecoded0
        let dataSourceSyncJobMetricTargetDecoded = try containerValues.decodeIfPresent(DataSourceSyncJobMetricTarget.self, forKey: .dataSourceSyncJobMetricTarget)
        dataSourceSyncJobMetricTarget = dataSourceSyncJobMetricTargetDecoded
    }
}

extension BatchDeleteDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteDocumentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteDocumentOutputResponse(failedDocuments: \(String(describing: failedDocuments)))"}
}

extension BatchDeleteDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteDocumentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedDocuments = output.failedDocuments
        } else {
            self.failedDocuments = nil
        }
    }
}

public struct BatchDeleteDocumentOutputResponse: Equatable {
    /// <p>A list of documents that could not be removed from the index. Each
    ///       entry contains an error message that indicates why the document couldn't
    ///       be removed from the index.</p>
    public let failedDocuments: [BatchDeleteDocumentResponseFailedDocument]?

    public init (
        failedDocuments: [BatchDeleteDocumentResponseFailedDocument]? = nil
    )
    {
        self.failedDocuments = failedDocuments
    }
}

struct BatchDeleteDocumentOutputResponseBody: Equatable {
    public let failedDocuments: [BatchDeleteDocumentResponseFailedDocument]?
}

extension BatchDeleteDocumentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedDocuments = "FailedDocuments"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedDocumentsContainer = try containerValues.decodeIfPresent([BatchDeleteDocumentResponseFailedDocument?].self, forKey: .failedDocuments)
        var failedDocumentsDecoded0:[BatchDeleteDocumentResponseFailedDocument]? = nil
        if let failedDocumentsContainer = failedDocumentsContainer {
            failedDocumentsDecoded0 = [BatchDeleteDocumentResponseFailedDocument]()
            for structure0 in failedDocumentsContainer {
                if let structure0 = structure0 {
                    failedDocumentsDecoded0?.append(structure0)
                }
            }
        }
        failedDocuments = failedDocumentsDecoded0
    }
}

extension BatchDeleteDocumentResponseFailedDocument: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchDeleteDocumentResponseFailedDocument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteDocumentResponseFailedDocument(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), id: \(String(describing: id)))"}
}

/// <p>Provides information about documents that could not be removed
///             from an index by the <code>BatchDeleteDocument</code>
///             operation.</p>
public struct BatchDeleteDocumentResponseFailedDocument: Equatable {
    /// <p>The error code for why the document couldn't be removed from the
    ///             index.</p>
    public let errorCode: ErrorCode?
    /// <p>An explanation for why the document couldn't be removed from the
    ///             index.</p>
    public let errorMessage: String?
    /// <p>The identifier of the document that couldn't be removed from the
    ///             index.</p>
    public let id: String?

    public init (
        errorCode: ErrorCode? = nil,
        errorMessage: String? = nil,
        id: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.id = id
    }
}

public struct BatchPutDocumentInputBodyMiddleware: Middleware {
    public let id: String = "BatchPutDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutDocumentInput>
    public typealias MOutput = OperationOutput<BatchPutDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutDocumentOutputError>
}

extension BatchPutDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutDocumentInput(documents: \(String(describing: documents)), indexId: \(String(describing: indexId)), roleArn: \(String(describing: roleArn)))"}
}

extension BatchPutDocumentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documents = "Documents"
        case indexId = "IndexId"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documents = documents {
            var documentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documents)
            for documentlist0 in documents {
                try documentsContainer.encode(documentlist0)
            }
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct BatchPutDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "BatchPutDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutDocumentInput>
    public typealias MOutput = OperationOutput<BatchPutDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutDocumentOutputError>
}

public struct BatchPutDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchPutDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutDocumentInput>
    public typealias MOutput = OperationOutput<BatchPutDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutDocumentOutputError>
}

public struct BatchPutDocumentInput: Equatable {
    /// <p>One or more documents to add to the index.</p>
    ///          <p>Documents can include custom attributes. For example,
    ///       'DataSourceId' and 'DataSourceSyncJobId' are custom
    ///       attributes that provide information on the synchronization
    ///       of documents running on a data source. Note,
    ///       'DataSourceSyncJobId' could be an optional custom attribute
    ///       as Amazon Kendra will use the ID of a running sync job.</p>
    ///          <p>Documents have the following file size limits.</p>
    ///          <ul>
    ///             <li>
    ///                <p>5 MB total size for inline documents</p>
    ///             </li>
    ///             <li>
    ///                <p>50 MB total size for files from an S3 bucket</p>
    ///             </li>
    ///             <li>
    ///                <p>5 MB extracted text for any file</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about file size and transaction per second
    ///       quotas, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas</a>.</p>
    public let documents: [Document]?
    /// <p>The identifier of the index to add the documents to. You need to
    ///       create the index first using the <code>CreateIndex</code>
    ///       operation.</p>
    public let indexId: String?
    /// <p>The Amazon Resource Name (ARN) of a role that is allowed to run the
    ///         <code>BatchPutDocument</code> operation. For more information, see
    ///         <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM
    ///         Roles for Amazon Kendra</a>.</p>
    public let roleArn: String?

    public init (
        documents: [Document]? = nil,
        indexId: String? = nil,
        roleArn: String? = nil
    )
    {
        self.documents = documents
        self.indexId = indexId
        self.roleArn = roleArn
    }
}

struct BatchPutDocumentInputBody: Equatable {
    public let indexId: String?
    public let roleArn: String?
    public let documents: [Document]?
}

extension BatchPutDocumentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documents = "Documents"
        case indexId = "IndexId"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let documentsContainer = try containerValues.decodeIfPresent([Document?].self, forKey: .documents)
        var documentsDecoded0:[Document]? = nil
        if let documentsContainer = documentsContainer {
            documentsDecoded0 = [Document]()
            for structure0 in documentsContainer {
                if let structure0 = structure0 {
                    documentsDecoded0?.append(structure0)
                }
            }
        }
        documents = documentsDecoded0
    }
}

extension BatchPutDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchPutDocumentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutDocumentOutputResponse(failedDocuments: \(String(describing: failedDocuments)))"}
}

extension BatchPutDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchPutDocumentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedDocuments = output.failedDocuments
        } else {
            self.failedDocuments = nil
        }
    }
}

public struct BatchPutDocumentOutputResponse: Equatable {
    /// <p>A list of documents that were not added to the index because the
    ///       document failed a validation check. Each document contains an error
    ///       message that indicates why the document couldn't be added to the
    ///       index.</p>
    ///          <p>If there was an error adding a document to an index the error is
    ///       reported in your AWS CloudWatch log. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/cloudwatch-logs.html">Monitoring
    ///         Amazon Kendra with Amazon CloudWatch Logs</a>
    ///          </p>
    public let failedDocuments: [BatchPutDocumentResponseFailedDocument]?

    public init (
        failedDocuments: [BatchPutDocumentResponseFailedDocument]? = nil
    )
    {
        self.failedDocuments = failedDocuments
    }
}

struct BatchPutDocumentOutputResponseBody: Equatable {
    public let failedDocuments: [BatchPutDocumentResponseFailedDocument]?
}

extension BatchPutDocumentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedDocuments = "FailedDocuments"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedDocumentsContainer = try containerValues.decodeIfPresent([BatchPutDocumentResponseFailedDocument?].self, forKey: .failedDocuments)
        var failedDocumentsDecoded0:[BatchPutDocumentResponseFailedDocument]? = nil
        if let failedDocumentsContainer = failedDocumentsContainer {
            failedDocumentsDecoded0 = [BatchPutDocumentResponseFailedDocument]()
            for structure0 in failedDocumentsContainer {
                if let structure0 = structure0 {
                    failedDocumentsDecoded0?.append(structure0)
                }
            }
        }
        failedDocuments = failedDocumentsDecoded0
    }
}

extension BatchPutDocumentResponseFailedDocument: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchPutDocumentResponseFailedDocument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutDocumentResponseFailedDocument(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), id: \(String(describing: id)))"}
}

/// <p>Provides information about a document that could not be
///             indexed.</p>
public struct BatchPutDocumentResponseFailedDocument: Equatable {
    /// <p>The type of error that caused the document to fail to be
    ///             indexed.</p>
    public let errorCode: ErrorCode?
    /// <p>A description of the reason why the document could not be
    ///             indexed.</p>
    public let errorMessage: String?
    /// <p>The unique identifier of the document.</p>
    public let id: String?

    public init (
        errorCode: ErrorCode? = nil,
        errorMessage: String? = nil,
        id: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.id = id
    }
}

extension CapacityUnitsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queryCapacityUnits = "QueryCapacityUnits"
        case storageCapacityUnits = "StorageCapacityUnits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryCapacityUnits = queryCapacityUnits {
            try encodeContainer.encode(queryCapacityUnits, forKey: .queryCapacityUnits)
        }
        if let storageCapacityUnits = storageCapacityUnits {
            try encodeContainer.encode(storageCapacityUnits, forKey: .storageCapacityUnits)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageCapacityUnitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .storageCapacityUnits)
        storageCapacityUnits = storageCapacityUnitsDecoded
        let queryCapacityUnitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queryCapacityUnits)
        queryCapacityUnits = queryCapacityUnitsDecoded
    }
}

extension CapacityUnitsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CapacityUnitsConfiguration(queryCapacityUnits: \(String(describing: queryCapacityUnits)), storageCapacityUnits: \(String(describing: storageCapacityUnits)))"}
}

/// <p>Specifies capacity units configured for your index. You can add
///             and remove capacity units to tune an index to your
///             requirements.</p>
public struct CapacityUnitsConfiguration: Equatable {
    /// <p>The amount of extra query capacity for an index. Each capacity
    ///             unit provides 0.5 queries per second and 40,000 queries per
    ///             day.</p>
    public let queryCapacityUnits: Int?
    /// <p>The amount of extra storage capacity for an index. Each capacity
    ///             unit provides 150 Gb of storage space or 500,000 documents,
    ///             whichever is reached first.</p>
    public let storageCapacityUnits: Int?

    public init (
        queryCapacityUnits: Int? = nil,
        storageCapacityUnits: Int? = nil
    )
    {
        self.queryCapacityUnits = queryCapacityUnits
        self.storageCapacityUnits = storageCapacityUnits
    }
}

public struct ClearQuerySuggestionsInputBodyMiddleware: Middleware {
    public let id: String = "ClearQuerySuggestionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ClearQuerySuggestionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ClearQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ClearQuerySuggestionsInput>
    public typealias MOutput = OperationOutput<ClearQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ClearQuerySuggestionsOutputError>
}

extension ClearQuerySuggestionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClearQuerySuggestionsInput(indexId: \(String(describing: indexId)))"}
}

extension ClearQuerySuggestionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct ClearQuerySuggestionsInputHeadersMiddleware: Middleware {
    public let id: String = "ClearQuerySuggestionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ClearQuerySuggestionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ClearQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ClearQuerySuggestionsInput>
    public typealias MOutput = OperationOutput<ClearQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ClearQuerySuggestionsOutputError>
}

public struct ClearQuerySuggestionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ClearQuerySuggestionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ClearQuerySuggestionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ClearQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ClearQuerySuggestionsInput>
    public typealias MOutput = OperationOutput<ClearQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ClearQuerySuggestionsOutputError>
}

public struct ClearQuerySuggestionsInput: Equatable {
    /// <p>The identifier of the index you want to clear query suggestions from.</p>
    public let indexId: String?

    public init (
        indexId: String? = nil
    )
    {
        self.indexId = indexId
    }
}

struct ClearQuerySuggestionsInputBody: Equatable {
    public let indexId: String?
}

extension ClearQuerySuggestionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension ClearQuerySuggestionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ClearQuerySuggestionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ClearQuerySuggestionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ClearQuerySuggestionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClearQuerySuggestionsOutputResponse()"}
}

extension ClearQuerySuggestionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ClearQuerySuggestionsOutputResponse: Equatable {

    public init() {}
}

struct ClearQuerySuggestionsOutputResponseBody: Equatable {
}

extension ClearQuerySuggestionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ClickFeedback: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clickTime = "ClickTime"
        case resultId = "ResultId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clickTime = clickTime {
            try encodeContainer.encode(clickTime.timeIntervalSince1970, forKey: .clickTime)
        }
        if let resultId = resultId {
            try encodeContainer.encode(resultId, forKey: .resultId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultId)
        resultId = resultIdDecoded
        let clickTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .clickTime)
        clickTime = clickTimeDecoded
    }
}

extension ClickFeedback: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClickFeedback(clickTime: \(String(describing: clickTime)), resultId: \(String(describing: resultId)))"}
}

/// <p>Gathers information about when a particular result was clicked by
///             a user. Your application uses the <code>SubmitFeedback</code>
///             operation to provide click information.</p>
public struct ClickFeedback: Equatable {
    /// <p>The Unix timestamp of the date and time that the result was
    ///             clicked.</p>
    public let clickTime: Date?
    /// <p>The unique identifier of the search result that was
    ///             clicked.</p>
    public let resultId: String?

    public init (
        clickTime: Date? = nil,
        resultId: String? = nil
    )
    {
        self.clickTime = clickTime
        self.resultId = resultId
    }
}

extension ColumnConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeDetectingColumns = "ChangeDetectingColumns"
        case documentDataColumnName = "DocumentDataColumnName"
        case documentIdColumnName = "DocumentIdColumnName"
        case documentTitleColumnName = "DocumentTitleColumnName"
        case fieldMappings = "FieldMappings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeDetectingColumns = changeDetectingColumns {
            var changeDetectingColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .changeDetectingColumns)
            for changedetectingcolumns0 in changeDetectingColumns {
                try changeDetectingColumnsContainer.encode(changedetectingcolumns0)
            }
        }
        if let documentDataColumnName = documentDataColumnName {
            try encodeContainer.encode(documentDataColumnName, forKey: .documentDataColumnName)
        }
        if let documentIdColumnName = documentIdColumnName {
            try encodeContainer.encode(documentIdColumnName, forKey: .documentIdColumnName)
        }
        if let documentTitleColumnName = documentTitleColumnName {
            try encodeContainer.encode(documentTitleColumnName, forKey: .documentTitleColumnName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentIdColumnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentIdColumnName)
        documentIdColumnName = documentIdColumnNameDecoded
        let documentDataColumnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentDataColumnName)
        documentDataColumnName = documentDataColumnNameDecoded
        let documentTitleColumnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentTitleColumnName)
        documentTitleColumnName = documentTitleColumnNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let changeDetectingColumnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .changeDetectingColumns)
        var changeDetectingColumnsDecoded0:[String]? = nil
        if let changeDetectingColumnsContainer = changeDetectingColumnsContainer {
            changeDetectingColumnsDecoded0 = [String]()
            for string0 in changeDetectingColumnsContainer {
                if let string0 = string0 {
                    changeDetectingColumnsDecoded0?.append(string0)
                }
            }
        }
        changeDetectingColumns = changeDetectingColumnsDecoded0
    }
}

extension ColumnConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnConfiguration(changeDetectingColumns: \(String(describing: changeDetectingColumns)), documentDataColumnName: \(String(describing: documentDataColumnName)), documentIdColumnName: \(String(describing: documentIdColumnName)), documentTitleColumnName: \(String(describing: documentTitleColumnName)), fieldMappings: \(String(describing: fieldMappings)))"}
}

/// <p>Provides information about how Amazon Kendra should use the columns of
///             a database in an index.</p>
public struct ColumnConfiguration: Equatable {
    /// <p>One to five columns that indicate when a document in the database
    ///             has changed.</p>
    public let changeDetectingColumns: [String]?
    /// <p>The column that contains the contents of the document.</p>
    public let documentDataColumnName: String?
    /// <p>The column that provides the document's unique identifier.</p>
    public let documentIdColumnName: String?
    /// <p>The column that contains the title of the document.</p>
    public let documentTitleColumnName: String?
    /// <p>An array of objects that map database column names to the
    ///             corresponding fields in an index. You must first create the fields
    ///             in the index using the <code>UpdateIndex</code> operation.</p>
    public let fieldMappings: [DataSourceToIndexFieldMapping]?

    public init (
        changeDetectingColumns: [String]? = nil,
        documentDataColumnName: String? = nil,
        documentIdColumnName: String? = nil,
        documentTitleColumnName: String? = nil,
        fieldMappings: [DataSourceToIndexFieldMapping]? = nil
    )
    {
        self.changeDetectingColumns = changeDetectingColumns
        self.documentDataColumnName = documentDataColumnName
        self.documentIdColumnName = documentIdColumnName
        self.documentTitleColumnName = documentTitleColumnName
        self.fieldMappings = fieldMappings
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfluenceAttachmentConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentFieldMappings = "AttachmentFieldMappings"
        case crawlAttachments = "CrawlAttachments"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentFieldMappings = attachmentFieldMappings {
            var attachmentFieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentFieldMappings)
            for confluenceattachmentfieldmappingslist0 in attachmentFieldMappings {
                try attachmentFieldMappingsContainer.encode(confluenceattachmentfieldmappingslist0)
            }
        }
        if crawlAttachments != false {
            try encodeContainer.encode(crawlAttachments, forKey: .crawlAttachments)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlAttachmentsDecoded = try containerValues.decode(Bool.self, forKey: .crawlAttachments)
        crawlAttachments = crawlAttachmentsDecoded
        let attachmentFieldMappingsContainer = try containerValues.decodeIfPresent([ConfluenceAttachmentToIndexFieldMapping?].self, forKey: .attachmentFieldMappings)
        var attachmentFieldMappingsDecoded0:[ConfluenceAttachmentToIndexFieldMapping]? = nil
        if let attachmentFieldMappingsContainer = attachmentFieldMappingsContainer {
            attachmentFieldMappingsDecoded0 = [ConfluenceAttachmentToIndexFieldMapping]()
            for structure0 in attachmentFieldMappingsContainer {
                if let structure0 = structure0 {
                    attachmentFieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        attachmentFieldMappings = attachmentFieldMappingsDecoded0
    }
}

extension ConfluenceAttachmentConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfluenceAttachmentConfiguration(attachmentFieldMappings: \(String(describing: attachmentFieldMappings)), crawlAttachments: \(String(describing: crawlAttachments)))"}
}

/// <p>Specifies the attachment settings for the Confluence data source.
///             Attachment settings are optional, if you don't specify settings
///             attachments, Amazon Kendra won't index them.</p>
public struct ConfluenceAttachmentConfiguration: Equatable {
    /// <p>Defines how attachment metadata fields should be mapped to index
    ///             fields. Before you can map a field, you must first create an index
    ///             field with a matching type using the console or the
    ///                 <code>UpdateIndex</code> operation.</p>
    ///         <p>If you specify the <code>AttachentFieldMappings</code> parameter,
    ///             you must specify at least one field mapping.</p>
    public let attachmentFieldMappings: [ConfluenceAttachmentToIndexFieldMapping]?
    /// <p>Indicates whether Amazon Kendra indexes attachments to the pages and blogs
    ///             in the Confluence data source. </p>
    public let crawlAttachments: Bool

    public init (
        attachmentFieldMappings: [ConfluenceAttachmentToIndexFieldMapping]? = nil,
        crawlAttachments: Bool = false
    )
    {
        self.attachmentFieldMappings = attachmentFieldMappings
        self.crawlAttachments = crawlAttachments
    }
}

public enum ConfluenceAttachmentFieldName {
    case author
    case contentType
    case createdDate
    case displayUrl
    case fileSize
    case itemType
    case parentId
    case spaceKey
    case spaceName
    case url
    case version
    case sdkUnknown(String)
}

extension ConfluenceAttachmentFieldName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfluenceAttachmentFieldName] {
        return [
            .author,
            .contentType,
            .createdDate,
            .displayUrl,
            .fileSize,
            .itemType,
            .parentId,
            .spaceKey,
            .spaceName,
            .url,
            .version,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .author: return "AUTHOR"
        case .contentType: return "CONTENT_TYPE"
        case .createdDate: return "CREATED_DATE"
        case .displayUrl: return "DISPLAY_URL"
        case .fileSize: return "FILE_SIZE"
        case .itemType: return "ITEM_TYPE"
        case .parentId: return "PARENT_ID"
        case .spaceKey: return "SPACE_KEY"
        case .spaceName: return "SPACE_NAME"
        case .url: return "URL"
        case .version: return "VERSION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfluenceAttachmentFieldName(rawValue: rawValue) ?? ConfluenceAttachmentFieldName.sdkUnknown(rawValue)
    }
}

extension ConfluenceAttachmentToIndexFieldMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceFieldName = "DataSourceFieldName"
        case dateFieldFormat = "DateFieldFormat"
        case indexFieldName = "IndexFieldName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceFieldName = dataSourceFieldName {
            try encodeContainer.encode(dataSourceFieldName.rawValue, forKey: .dataSourceFieldName)
        }
        if let dateFieldFormat = dateFieldFormat {
            try encodeContainer.encode(dateFieldFormat, forKey: .dateFieldFormat)
        }
        if let indexFieldName = indexFieldName {
            try encodeContainer.encode(indexFieldName, forKey: .indexFieldName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceFieldNameDecoded = try containerValues.decodeIfPresent(ConfluenceAttachmentFieldName.self, forKey: .dataSourceFieldName)
        dataSourceFieldName = dataSourceFieldNameDecoded
        let dateFieldFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateFieldFormat)
        dateFieldFormat = dateFieldFormatDecoded
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
    }
}

extension ConfluenceAttachmentToIndexFieldMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfluenceAttachmentToIndexFieldMapping(dataSourceFieldName: \(String(describing: dataSourceFieldName)), dateFieldFormat: \(String(describing: dateFieldFormat)), indexFieldName: \(String(describing: indexFieldName)))"}
}

/// <p>Defines the mapping between a field in the Confluence data source
///             to a Amazon Kendra index field.</p>
///         <p>You must first create the index field using the
///                 <code>UpdateIndex</code> operation. </p>
public struct ConfluenceAttachmentToIndexFieldMapping: Equatable {
    /// <p>The name of the field in the data source. </p>
    ///         <p>You must first create the index field using the
    ///                 <code>UpdateIndex</code> operation. </p>
    public let dataSourceFieldName: ConfluenceAttachmentFieldName?
    /// <p>The format for date fields in the data source. If the field
    ///             specified in <code>DataSourceFieldName</code> is a date field you
    ///             must specify the date format. If the field is not a date field, an
    ///             exception is thrown.</p>
    public let dateFieldFormat: String?
    /// <p>The name of the index field to map to the Confluence data source
    ///             field. The index field type must match the Confluence field
    ///             type.</p>
    public let indexFieldName: String?

    public init (
        dataSourceFieldName: ConfluenceAttachmentFieldName? = nil,
        dateFieldFormat: String? = nil,
        indexFieldName: String? = nil
    )
    {
        self.dataSourceFieldName = dataSourceFieldName
        self.dateFieldFormat = dateFieldFormat
        self.indexFieldName = indexFieldName
    }
}

extension ConfluenceBlogConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blogFieldMappings = "BlogFieldMappings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blogFieldMappings = blogFieldMappings {
            var blogFieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blogFieldMappings)
            for confluenceblogfieldmappingslist0 in blogFieldMappings {
                try blogFieldMappingsContainer.encode(confluenceblogfieldmappingslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blogFieldMappingsContainer = try containerValues.decodeIfPresent([ConfluenceBlogToIndexFieldMapping?].self, forKey: .blogFieldMappings)
        var blogFieldMappingsDecoded0:[ConfluenceBlogToIndexFieldMapping]? = nil
        if let blogFieldMappingsContainer = blogFieldMappingsContainer {
            blogFieldMappingsDecoded0 = [ConfluenceBlogToIndexFieldMapping]()
            for structure0 in blogFieldMappingsContainer {
                if let structure0 = structure0 {
                    blogFieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        blogFieldMappings = blogFieldMappingsDecoded0
    }
}

extension ConfluenceBlogConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfluenceBlogConfiguration(blogFieldMappings: \(String(describing: blogFieldMappings)))"}
}

/// <p>Specifies the blog settings for the Confluence data source. Blogs
///             are always indexed unless filtered from the index by the
///                 <code>ExclusionPatterns</code> or <code>InclusionPatterns</code>
///             fields in the <code>ConfluenceConfiguration</code> type.</p>
public struct ConfluenceBlogConfiguration: Equatable {
    /// <p>Defines how blog metadata fields should be mapped to index fields.
    ///             Before you can map a field, you must first create an index field
    ///             with a matching type using the console or the
    ///                 <code>UpdateIndex</code> operation.</p>
    ///         <p>If you specify the <code>BlogFieldMappings</code> parameter, you
    ///             must specify at least one field mapping.</p>
    public let blogFieldMappings: [ConfluenceBlogToIndexFieldMapping]?

    public init (
        blogFieldMappings: [ConfluenceBlogToIndexFieldMapping]? = nil
    )
    {
        self.blogFieldMappings = blogFieldMappings
    }
}

public enum ConfluenceBlogFieldName {
    case author
    case displayUrl
    case itemType
    case labels
    case publishDate
    case spaceKey
    case spaceName
    case url
    case version
    case sdkUnknown(String)
}

extension ConfluenceBlogFieldName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfluenceBlogFieldName] {
        return [
            .author,
            .displayUrl,
            .itemType,
            .labels,
            .publishDate,
            .spaceKey,
            .spaceName,
            .url,
            .version,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .author: return "AUTHOR"
        case .displayUrl: return "DISPLAY_URL"
        case .itemType: return "ITEM_TYPE"
        case .labels: return "LABELS"
        case .publishDate: return "PUBLISH_DATE"
        case .spaceKey: return "SPACE_KEY"
        case .spaceName: return "SPACE_NAME"
        case .url: return "URL"
        case .version: return "VERSION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfluenceBlogFieldName(rawValue: rawValue) ?? ConfluenceBlogFieldName.sdkUnknown(rawValue)
    }
}

extension ConfluenceBlogToIndexFieldMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceFieldName = "DataSourceFieldName"
        case dateFieldFormat = "DateFieldFormat"
        case indexFieldName = "IndexFieldName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceFieldName = dataSourceFieldName {
            try encodeContainer.encode(dataSourceFieldName.rawValue, forKey: .dataSourceFieldName)
        }
        if let dateFieldFormat = dateFieldFormat {
            try encodeContainer.encode(dateFieldFormat, forKey: .dateFieldFormat)
        }
        if let indexFieldName = indexFieldName {
            try encodeContainer.encode(indexFieldName, forKey: .indexFieldName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceFieldNameDecoded = try containerValues.decodeIfPresent(ConfluenceBlogFieldName.self, forKey: .dataSourceFieldName)
        dataSourceFieldName = dataSourceFieldNameDecoded
        let dateFieldFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateFieldFormat)
        dateFieldFormat = dateFieldFormatDecoded
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
    }
}

extension ConfluenceBlogToIndexFieldMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfluenceBlogToIndexFieldMapping(dataSourceFieldName: \(String(describing: dataSourceFieldName)), dateFieldFormat: \(String(describing: dateFieldFormat)), indexFieldName: \(String(describing: indexFieldName)))"}
}

/// <p>Defines the mapping between a blog field in the Confluence data
///             source to a Amazon Kendra index field.</p>
///         <p>You must first create the index field using the
///                 <code>UpdateIndex</code> operation. </p>
public struct ConfluenceBlogToIndexFieldMapping: Equatable {
    /// <p>The name of the field in the data source. </p>
    public let dataSourceFieldName: ConfluenceBlogFieldName?
    /// <p>The format for date fields in the data source. If the field
    ///             specified in <code>DataSourceFieldName</code> is a date field you
    ///             must specify the date format. If the field is not a date field, an
    ///             exception is thrown.</p>
    public let dateFieldFormat: String?
    /// <p>The name of the index field to map to the Confluence data source
    ///             field. The index field type must match the Confluence field
    ///             type.</p>
    public let indexFieldName: String?

    public init (
        dataSourceFieldName: ConfluenceBlogFieldName? = nil,
        dateFieldFormat: String? = nil,
        indexFieldName: String? = nil
    )
    {
        self.dataSourceFieldName = dataSourceFieldName
        self.dateFieldFormat = dateFieldFormat
        self.indexFieldName = indexFieldName
    }
}

extension ConfluenceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentConfiguration = "AttachmentConfiguration"
        case blogConfiguration = "BlogConfiguration"
        case exclusionPatterns = "ExclusionPatterns"
        case inclusionPatterns = "InclusionPatterns"
        case pageConfiguration = "PageConfiguration"
        case secretArn = "SecretArn"
        case serverUrl = "ServerUrl"
        case spaceConfiguration = "SpaceConfiguration"
        case version = "Version"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentConfiguration = attachmentConfiguration {
            try encodeContainer.encode(attachmentConfiguration, forKey: .attachmentConfiguration)
        }
        if let blogConfiguration = blogConfiguration {
            try encodeContainer.encode(blogConfiguration, forKey: .blogConfiguration)
        }
        if let exclusionPatterns = exclusionPatterns {
            var exclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in exclusionPatterns {
                try exclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let inclusionPatterns = inclusionPatterns {
            var inclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in inclusionPatterns {
                try inclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let pageConfiguration = pageConfiguration {
            try encodeContainer.encode(pageConfiguration, forKey: .pageConfiguration)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let serverUrl = serverUrl {
            try encodeContainer.encode(serverUrl, forKey: .serverUrl)
        }
        if let spaceConfiguration = spaceConfiguration {
            try encodeContainer.encode(spaceConfiguration, forKey: .spaceConfiguration)
        }
        if let version = version {
            try encodeContainer.encode(version.rawValue, forKey: .version)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(ConfluenceVersion.self, forKey: .version)
        version = versionDecoded
        let spaceConfigurationDecoded = try containerValues.decodeIfPresent(ConfluenceSpaceConfiguration.self, forKey: .spaceConfiguration)
        spaceConfiguration = spaceConfigurationDecoded
        let pageConfigurationDecoded = try containerValues.decodeIfPresent(ConfluencePageConfiguration.self, forKey: .pageConfiguration)
        pageConfiguration = pageConfigurationDecoded
        let blogConfigurationDecoded = try containerValues.decodeIfPresent(ConfluenceBlogConfiguration.self, forKey: .blogConfiguration)
        blogConfiguration = blogConfigurationDecoded
        let attachmentConfigurationDecoded = try containerValues.decodeIfPresent(ConfluenceAttachmentConfiguration.self, forKey: .attachmentConfiguration)
        attachmentConfiguration = attachmentConfigurationDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(DataSourceVpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let inclusionPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .inclusionPatterns)
        var inclusionPatternsDecoded0:[String]? = nil
        if let inclusionPatternsContainer = inclusionPatternsContainer {
            inclusionPatternsDecoded0 = [String]()
            for string0 in inclusionPatternsContainer {
                if let string0 = string0 {
                    inclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        inclusionPatterns = inclusionPatternsDecoded0
        let exclusionPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exclusionPatterns)
        var exclusionPatternsDecoded0:[String]? = nil
        if let exclusionPatternsContainer = exclusionPatternsContainer {
            exclusionPatternsDecoded0 = [String]()
            for string0 in exclusionPatternsContainer {
                if let string0 = string0 {
                    exclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        exclusionPatterns = exclusionPatternsDecoded0
    }
}

extension ConfluenceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfluenceConfiguration(attachmentConfiguration: \(String(describing: attachmentConfiguration)), blogConfiguration: \(String(describing: blogConfiguration)), exclusionPatterns: \(String(describing: exclusionPatterns)), inclusionPatterns: \(String(describing: inclusionPatterns)), pageConfiguration: \(String(describing: pageConfiguration)), secretArn: \(String(describing: secretArn)), serverUrl: \(String(describing: serverUrl)), spaceConfiguration: \(String(describing: spaceConfiguration)), version: \(String(describing: version)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

/// <p>Provides configuration information for data sources that connect
///             to Confluence.</p>
public struct ConfluenceConfiguration: Equatable {
    /// <p>Specifies configuration information for indexing attachments to
    ///             Confluence blogs and pages.</p>
    public let attachmentConfiguration: ConfluenceAttachmentConfiguration?
    /// <p> Specifies configuration information for indexing Confluence
    ///             blogs.</p>
    public let blogConfiguration: ConfluenceBlogConfiguration?
    /// <p>A list of regular expression patterns that apply to a URL on the
    ///             Confluence server. An exclusion pattern can apply to a blog post, a
    ///             page, a space, or an attachment. Items that match the pattern are
    ///             excluded from the index. Items that don't match the pattern are
    ///             included in the index. If a item matches both an exclusion pattern
    ///             and an inclusion pattern, the item isn't included in the
    ///             index.</p>
    public let exclusionPatterns: [String]?
    /// <p>A list of regular expression patterns that apply to a URL on the
    ///             Confluence server. An inclusion pattern can apply to a blog post, a
    ///             page, a space, or an attachment. Items that match the patterns are
    ///             included in the index. Items that don't match the pattern are
    ///             excluded from the index. If an item matches both an inclusion
    ///             pattern and an exclusion pattern, the item isn't included in the
    ///             index.</p>
    public let inclusionPatterns: [String]?
    /// <p>Specifies configuration information for indexing Confluence
    ///             pages.</p>
    public let pageConfiguration: ConfluencePageConfiguration?
    /// <p>The Amazon Resource Name (ARN) of an AWS Secrets Manager secret
    ///             that contains the key/value pairs required to connect to your
    ///             Confluence server. The secret must contain a JSON structure with the
    ///             following keys:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>username - The user name or email address of a user with
    ///                     administrative privileges for the Confluence server.</p>
    ///             </li>
    ///             <li>
    ///                 <p>password - The password associated with the user logging
    ///                     in to the Confluence server.</p>
    ///             </li>
    ///          </ul>
    public let secretArn: String?
    /// <p>The URL of your Confluence instance. Use the full URL of the
    ///             server. For example, <code>https://server.example.com:port/</code>.
    ///             You can also use an IP address, for example,
    ///                 <code>https://192.168.1.113/</code>.</p>
    public let serverUrl: String?
    /// <p>Specifies configuration information for indexing Confluence
    ///             spaces.</p>
    public let spaceConfiguration: ConfluenceSpaceConfiguration?
    /// <p>Specifies the version of the Confluence installation that you are
    ///             connecting to.</p>
    public let version: ConfluenceVersion?
    /// <p>Specifies the information for connecting to an Amazon VPC.</p>
    public let vpcConfiguration: DataSourceVpcConfiguration?

    public init (
        attachmentConfiguration: ConfluenceAttachmentConfiguration? = nil,
        blogConfiguration: ConfluenceBlogConfiguration? = nil,
        exclusionPatterns: [String]? = nil,
        inclusionPatterns: [String]? = nil,
        pageConfiguration: ConfluencePageConfiguration? = nil,
        secretArn: String? = nil,
        serverUrl: String? = nil,
        spaceConfiguration: ConfluenceSpaceConfiguration? = nil,
        version: ConfluenceVersion? = nil,
        vpcConfiguration: DataSourceVpcConfiguration? = nil
    )
    {
        self.attachmentConfiguration = attachmentConfiguration
        self.blogConfiguration = blogConfiguration
        self.exclusionPatterns = exclusionPatterns
        self.inclusionPatterns = inclusionPatterns
        self.pageConfiguration = pageConfiguration
        self.secretArn = secretArn
        self.serverUrl = serverUrl
        self.spaceConfiguration = spaceConfiguration
        self.version = version
        self.vpcConfiguration = vpcConfiguration
    }
}

extension ConfluencePageConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pageFieldMappings = "PageFieldMappings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pageFieldMappings = pageFieldMappings {
            var pageFieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pageFieldMappings)
            for confluencepagefieldmappingslist0 in pageFieldMappings {
                try pageFieldMappingsContainer.encode(confluencepagefieldmappingslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageFieldMappingsContainer = try containerValues.decodeIfPresent([ConfluencePageToIndexFieldMapping?].self, forKey: .pageFieldMappings)
        var pageFieldMappingsDecoded0:[ConfluencePageToIndexFieldMapping]? = nil
        if let pageFieldMappingsContainer = pageFieldMappingsContainer {
            pageFieldMappingsDecoded0 = [ConfluencePageToIndexFieldMapping]()
            for structure0 in pageFieldMappingsContainer {
                if let structure0 = structure0 {
                    pageFieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        pageFieldMappings = pageFieldMappingsDecoded0
    }
}

extension ConfluencePageConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfluencePageConfiguration(pageFieldMappings: \(String(describing: pageFieldMappings)))"}
}

/// <p>Specifies the page settings for the Confluence data source.</p>
public struct ConfluencePageConfiguration: Equatable {
    /// <p>Defines how page metadata fields should be mapped to index fields.
    ///             Before you can map a field, you must first create an index field
    ///             with a matching type using the console or the
    ///                 <code>UpdateIndex</code> operation.</p>
    ///         <p>If you specify the <code>PageFieldMappings</code> parameter, you
    ///             must specify at least one field mapping.</p>
    public let pageFieldMappings: [ConfluencePageToIndexFieldMapping]?

    public init (
        pageFieldMappings: [ConfluencePageToIndexFieldMapping]? = nil
    )
    {
        self.pageFieldMappings = pageFieldMappings
    }
}

public enum ConfluencePageFieldName {
    case author
    case contentStatus
    case createdDate
    case displayUrl
    case itemType
    case labels
    case modifiedDate
    case parentId
    case spaceKey
    case spaceName
    case url
    case version
    case sdkUnknown(String)
}

extension ConfluencePageFieldName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfluencePageFieldName] {
        return [
            .author,
            .contentStatus,
            .createdDate,
            .displayUrl,
            .itemType,
            .labels,
            .modifiedDate,
            .parentId,
            .spaceKey,
            .spaceName,
            .url,
            .version,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .author: return "AUTHOR"
        case .contentStatus: return "CONTENT_STATUS"
        case .createdDate: return "CREATED_DATE"
        case .displayUrl: return "DISPLAY_URL"
        case .itemType: return "ITEM_TYPE"
        case .labels: return "LABELS"
        case .modifiedDate: return "MODIFIED_DATE"
        case .parentId: return "PARENT_ID"
        case .spaceKey: return "SPACE_KEY"
        case .spaceName: return "SPACE_NAME"
        case .url: return "URL"
        case .version: return "VERSION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfluencePageFieldName(rawValue: rawValue) ?? ConfluencePageFieldName.sdkUnknown(rawValue)
    }
}

extension ConfluencePageToIndexFieldMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceFieldName = "DataSourceFieldName"
        case dateFieldFormat = "DateFieldFormat"
        case indexFieldName = "IndexFieldName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceFieldName = dataSourceFieldName {
            try encodeContainer.encode(dataSourceFieldName.rawValue, forKey: .dataSourceFieldName)
        }
        if let dateFieldFormat = dateFieldFormat {
            try encodeContainer.encode(dateFieldFormat, forKey: .dateFieldFormat)
        }
        if let indexFieldName = indexFieldName {
            try encodeContainer.encode(indexFieldName, forKey: .indexFieldName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceFieldNameDecoded = try containerValues.decodeIfPresent(ConfluencePageFieldName.self, forKey: .dataSourceFieldName)
        dataSourceFieldName = dataSourceFieldNameDecoded
        let dateFieldFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateFieldFormat)
        dateFieldFormat = dateFieldFormatDecoded
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
    }
}

extension ConfluencePageToIndexFieldMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfluencePageToIndexFieldMapping(dataSourceFieldName: \(String(describing: dataSourceFieldName)), dateFieldFormat: \(String(describing: dateFieldFormat)), indexFieldName: \(String(describing: indexFieldName)))"}
}

/// <p>Defines the mapping between a field in the Confluence data source
///             to a Amazon Kendra index field.</p>
///         <p>You must first create the index field using the
///                 <code>UpdateIndex</code> operation. </p>
public struct ConfluencePageToIndexFieldMapping: Equatable {
    /// <p>The name of the field in the data source. </p>
    public let dataSourceFieldName: ConfluencePageFieldName?
    /// <p>The format for date fields in the data source. If the field
    ///             specified in <code>DataSourceFieldName</code> is a date field you
    ///             must specify the date format. If the field is not a date field, an
    ///             exception is thrown.</p>
    public let dateFieldFormat: String?
    /// <p>The name of the index field to map to the Confluence data source
    ///             field. The index field type must match the Confluence field
    ///             type.</p>
    public let indexFieldName: String?

    public init (
        dataSourceFieldName: ConfluencePageFieldName? = nil,
        dateFieldFormat: String? = nil,
        indexFieldName: String? = nil
    )
    {
        self.dataSourceFieldName = dataSourceFieldName
        self.dateFieldFormat = dateFieldFormat
        self.indexFieldName = indexFieldName
    }
}

extension ConfluenceSpaceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlArchivedSpaces = "CrawlArchivedSpaces"
        case crawlPersonalSpaces = "CrawlPersonalSpaces"
        case excludeSpaces = "ExcludeSpaces"
        case includeSpaces = "IncludeSpaces"
        case spaceFieldMappings = "SpaceFieldMappings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if crawlArchivedSpaces != false {
            try encodeContainer.encode(crawlArchivedSpaces, forKey: .crawlArchivedSpaces)
        }
        if crawlPersonalSpaces != false {
            try encodeContainer.encode(crawlPersonalSpaces, forKey: .crawlPersonalSpaces)
        }
        if let excludeSpaces = excludeSpaces {
            var excludeSpacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeSpaces)
            for confluencespacelist0 in excludeSpaces {
                try excludeSpacesContainer.encode(confluencespacelist0)
            }
        }
        if let includeSpaces = includeSpaces {
            var includeSpacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeSpaces)
            for confluencespacelist0 in includeSpaces {
                try includeSpacesContainer.encode(confluencespacelist0)
            }
        }
        if let spaceFieldMappings = spaceFieldMappings {
            var spaceFieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .spaceFieldMappings)
            for confluencespacefieldmappingslist0 in spaceFieldMappings {
                try spaceFieldMappingsContainer.encode(confluencespacefieldmappingslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlPersonalSpacesDecoded = try containerValues.decode(Bool.self, forKey: .crawlPersonalSpaces)
        crawlPersonalSpaces = crawlPersonalSpacesDecoded
        let crawlArchivedSpacesDecoded = try containerValues.decode(Bool.self, forKey: .crawlArchivedSpaces)
        crawlArchivedSpaces = crawlArchivedSpacesDecoded
        let includeSpacesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .includeSpaces)
        var includeSpacesDecoded0:[String]? = nil
        if let includeSpacesContainer = includeSpacesContainer {
            includeSpacesDecoded0 = [String]()
            for string0 in includeSpacesContainer {
                if let string0 = string0 {
                    includeSpacesDecoded0?.append(string0)
                }
            }
        }
        includeSpaces = includeSpacesDecoded0
        let excludeSpacesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludeSpaces)
        var excludeSpacesDecoded0:[String]? = nil
        if let excludeSpacesContainer = excludeSpacesContainer {
            excludeSpacesDecoded0 = [String]()
            for string0 in excludeSpacesContainer {
                if let string0 = string0 {
                    excludeSpacesDecoded0?.append(string0)
                }
            }
        }
        excludeSpaces = excludeSpacesDecoded0
        let spaceFieldMappingsContainer = try containerValues.decodeIfPresent([ConfluenceSpaceToIndexFieldMapping?].self, forKey: .spaceFieldMappings)
        var spaceFieldMappingsDecoded0:[ConfluenceSpaceToIndexFieldMapping]? = nil
        if let spaceFieldMappingsContainer = spaceFieldMappingsContainer {
            spaceFieldMappingsDecoded0 = [ConfluenceSpaceToIndexFieldMapping]()
            for structure0 in spaceFieldMappingsContainer {
                if let structure0 = structure0 {
                    spaceFieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        spaceFieldMappings = spaceFieldMappingsDecoded0
    }
}

extension ConfluenceSpaceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfluenceSpaceConfiguration(crawlArchivedSpaces: \(String(describing: crawlArchivedSpaces)), crawlPersonalSpaces: \(String(describing: crawlPersonalSpaces)), excludeSpaces: \(String(describing: excludeSpaces)), includeSpaces: \(String(describing: includeSpaces)), spaceFieldMappings: \(String(describing: spaceFieldMappings)))"}
}

/// <p>Specifies the configuration for indexing Confluence spaces.</p>
public struct ConfluenceSpaceConfiguration: Equatable {
    /// <p>Specifies whether Amazon Kendra should index archived spaces.</p>
    public let crawlArchivedSpaces: Bool
    /// <p>Specifies whether Amazon Kendra should index personal spaces. Users can
    ///             add restrictions to items in personal spaces. If personal spaces are
    ///             indexed, queries without user context information may return
    ///             restricted items from a personal space in their results. For more
    ///             information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html">Filtering on
    ///                 user context</a>.</p>
    public let crawlPersonalSpaces: Bool
    /// <p>A list of space keys of Confluence spaces. If you include a key,
    ///             the blogs, documents, and attachments in the space are not indexed.
    ///             If a space is in both the <code>ExcludeSpaces</code> and the
    ///                 <code>IncludeSpaces</code> list, the space is excluded.</p>
    public let excludeSpaces: [String]?
    /// <p>A list of space keys for Confluence spaces. If you include a key,
    ///             the blogs, documents, and attachments in the space are indexed.
    ///             Spaces that aren't in the list aren't indexed. A space in the list
    ///             must exist. Otherwise, Amazon Kendra logs an error when the data source is
    ///             synchronized. If a space is in both the <code>IncludeSpaces</code>
    ///             and the <code>ExcludeSpaces</code> list, the space is
    ///             excluded.</p>
    public let includeSpaces: [String]?
    /// <p>Defines how space metadata fields should be mapped to index
    ///             fields. Before you can map a field, you must first create an index
    ///             field with a matching type using the console or the
    ///                 <code>UpdateIndex</code> operation.</p>
    ///         <p>If you specify the <code>SpaceFieldMappings</code> parameter, you
    ///             must specify at least one field mapping.</p>
    public let spaceFieldMappings: [ConfluenceSpaceToIndexFieldMapping]?

    public init (
        crawlArchivedSpaces: Bool = false,
        crawlPersonalSpaces: Bool = false,
        excludeSpaces: [String]? = nil,
        includeSpaces: [String]? = nil,
        spaceFieldMappings: [ConfluenceSpaceToIndexFieldMapping]? = nil
    )
    {
        self.crawlArchivedSpaces = crawlArchivedSpaces
        self.crawlPersonalSpaces = crawlPersonalSpaces
        self.excludeSpaces = excludeSpaces
        self.includeSpaces = includeSpaces
        self.spaceFieldMappings = spaceFieldMappings
    }
}

public enum ConfluenceSpaceFieldName {
    case displayUrl
    case itemType
    case spaceKey
    case url
    case sdkUnknown(String)
}

extension ConfluenceSpaceFieldName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfluenceSpaceFieldName] {
        return [
            .displayUrl,
            .itemType,
            .spaceKey,
            .url,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .displayUrl: return "DISPLAY_URL"
        case .itemType: return "ITEM_TYPE"
        case .spaceKey: return "SPACE_KEY"
        case .url: return "URL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfluenceSpaceFieldName(rawValue: rawValue) ?? ConfluenceSpaceFieldName.sdkUnknown(rawValue)
    }
}

extension ConfluenceSpaceToIndexFieldMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceFieldName = "DataSourceFieldName"
        case dateFieldFormat = "DateFieldFormat"
        case indexFieldName = "IndexFieldName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceFieldName = dataSourceFieldName {
            try encodeContainer.encode(dataSourceFieldName.rawValue, forKey: .dataSourceFieldName)
        }
        if let dateFieldFormat = dateFieldFormat {
            try encodeContainer.encode(dateFieldFormat, forKey: .dateFieldFormat)
        }
        if let indexFieldName = indexFieldName {
            try encodeContainer.encode(indexFieldName, forKey: .indexFieldName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceFieldNameDecoded = try containerValues.decodeIfPresent(ConfluenceSpaceFieldName.self, forKey: .dataSourceFieldName)
        dataSourceFieldName = dataSourceFieldNameDecoded
        let dateFieldFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateFieldFormat)
        dateFieldFormat = dateFieldFormatDecoded
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
    }
}

extension ConfluenceSpaceToIndexFieldMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfluenceSpaceToIndexFieldMapping(dataSourceFieldName: \(String(describing: dataSourceFieldName)), dateFieldFormat: \(String(describing: dateFieldFormat)), indexFieldName: \(String(describing: indexFieldName)))"}
}

/// <p>Defines the mapping between a field in the Confluence data source
///             to a Amazon Kendra index field.</p>
///         <p>You must first create the index field using the
///                 <code>UpdateIndex</code> operation. </p>
public struct ConfluenceSpaceToIndexFieldMapping: Equatable {
    /// <p>The name of the field in the data source. </p>
    public let dataSourceFieldName: ConfluenceSpaceFieldName?
    /// <p>The format for date fields in the data source. If the field
    ///             specified in <code>DataSourceFieldName</code> is a date field you
    ///             must specify the date format. If the field is not a date field, an
    ///             exception is thrown.</p>
    public let dateFieldFormat: String?
    /// <p>The name of the index field to map to the Confluence data source
    ///             field. The index field type must match the Confluence field
    ///             type.</p>
    public let indexFieldName: String?

    public init (
        dataSourceFieldName: ConfluenceSpaceFieldName? = nil,
        dateFieldFormat: String? = nil,
        indexFieldName: String? = nil
    )
    {
        self.dataSourceFieldName = dataSourceFieldName
        self.dateFieldFormat = dateFieldFormat
        self.indexFieldName = indexFieldName
    }
}

public enum ConfluenceVersion {
    case cloud
    case server
    case sdkUnknown(String)
}

extension ConfluenceVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfluenceVersion] {
        return [
            .cloud,
            .server,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloud: return "CLOUD"
        case .server: return "SERVER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfluenceVersion(rawValue: rawValue) ?? ConfluenceVersion.sdkUnknown(rawValue)
    }
}

extension ConnectionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseHost = "DatabaseHost"
        case databaseName = "DatabaseName"
        case databasePort = "DatabasePort"
        case secretArn = "SecretArn"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseHost = databaseHost {
            try encodeContainer.encode(databaseHost, forKey: .databaseHost)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let databasePort = databasePort {
            try encodeContainer.encode(databasePort, forKey: .databasePort)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseHostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseHost)
        databaseHost = databaseHostDecoded
        let databasePortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .databasePort)
        databasePort = databasePortDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
    }
}

extension ConnectionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionConfiguration(databaseHost: \(String(describing: databaseHost)), databaseName: \(String(describing: databaseName)), databasePort: \(String(describing: databasePort)), secretArn: \(String(describing: secretArn)), tableName: \(String(describing: tableName)))"}
}

/// <p>Provides the information necessary to connect to a
///             database.</p>
public struct ConnectionConfiguration: Equatable {
    /// <p>The name of the host for the database. Can be either a string
    ///             (host.subdomain.domain.tld) or an IPv4 or IPv6 address.</p>
    public let databaseHost: String?
    /// <p>The name of the database containing the document data.</p>
    public let databaseName: String?
    /// <p>The port that the database uses for connections.</p>
    public let databasePort: Int?
    /// <p>The Amazon Resource Name (ARN) of credentials stored in AWS
    ///             Secrets Manager. The credentials should be a user/password pair. For
    ///             more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-database.html">Using a
    ///                 Database Data Source</a>. For more information about AWS
    ///             Secrets Manager, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html"> What Is AWS
    ///                 Secrets Manager </a> in the <i>AWS Secrets
    ///                 Manager</i> user guide.</p>
    public let secretArn: String?
    /// <p>The name of the table that contains the document data.</p>
    public let tableName: String?

    public init (
        databaseHost: String? = nil,
        databaseName: String? = nil,
        databasePort: Int? = nil,
        secretArn: String? = nil,
        tableName: String? = nil
    )
    {
        self.databaseHost = databaseHost
        self.databaseName = databaseName
        self.databasePort = databasePort
        self.secretArn = secretArn
        self.tableName = tableName
    }
}

public enum ContentType {
    case html
    case msWord
    case pdf
    case plainText
    case ppt
    case sdkUnknown(String)
}

extension ContentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContentType] {
        return [
            .html,
            .msWord,
            .pdf,
            .plainText,
            .ppt,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .html: return "HTML"
        case .msWord: return "MS_WORD"
        case .pdf: return "PDF"
        case .plainText: return "PLAIN_TEXT"
        case .ppt: return "PPT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContentType(rawValue: rawValue) ?? ContentType.sdkUnknown(rawValue)
    }
}

public struct CreateDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "CreateDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSourceOutputError>
}

extension CreateDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataSourceInput(clientToken: \(String(describing: clientToken)), configuration: \(String(describing: configuration)), description: \(String(describing: description)), indexId: \(String(describing: indexId)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), schedule: \(String(describing: schedule)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case configuration = "Configuration"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case schedule = "Schedule"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSourceOutputError>
}

public struct CreateDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSourceOutputError>
}

public struct CreateDataSourceInput: Equatable {
    /// <p>A token that you provide to identify the request to create a data
    ///       source. Multiple calls to the <code>CreateDataSource</code> operation with
    ///       the same client token will create only one data source.</p>
    public var clientToken: String?
    /// <p>The connector configuration information that is required to access the
    ///       repository.</p>
    ///          <p>You can't specify the <code>Configuration</code> parameter when the
    ///         <code>Type</code> parameter is set to <code>CUSTOM</code>. If you do,
    ///       you receive a <code>ValidationException</code> exception.</p>
    ///          <p>The <code>Configuration</code> parameter is required for all other
    ///       data sources.</p>
    public let configuration: DataSourceConfiguration?
    /// <p>A description for the data source.</p>
    public let description: String?
    /// <p>The identifier of the index that should be associated with this data
    ///       source.</p>
    public let indexId: String?
    /// <p>A unique name for the data source. A data source name can't be changed
    ///       without deleting and recreating the data source.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of a role with permission to access the
    ///       data source. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM Roles for
    ///         Amazon Kendra</a>.</p>
    ///          <p>You can't specify the <code>RoleArn</code> parameter when the
    ///         <code>Type</code> parameter is set to <code>CUSTOM</code>. If you do,
    ///       you receive a <code>ValidationException</code> exception.</p>
    ///          <p>The <code>RoleArn</code> parameter is required for all other data
    ///       sources.</p>
    public let roleArn: String?
    /// <p>Sets the frequency that Amazon Kendra will check the documents in your
    ///       repository and update the index. If you don't set a schedule Amazon Kendra
    ///       will not periodically update the index. You can call the
    ///         <code>StartDataSourceSyncJob</code> operation to update the
    ///       index.</p>
    ///          <p>You can't specify the <code>Schedule</code> parameter when the
    ///         <code>Type</code> parameter is set to <code>CUSTOM</code>. If you do,
    ///       you receive a <code>ValidationException</code> exception.</p>
    public let schedule: String?
    /// <p>A list of key-value pairs that identify the data source. You can use
    ///       the tags to identify and organize your resources and to control access to
    ///       resources.</p>
    public let tags: [Tag]?
    /// <p>The type of repository that contains the data source.</p>
    public let type: DataSourceType?

    public init (
        clientToken: String? = nil,
        configuration: DataSourceConfiguration? = nil,
        description: String? = nil,
        indexId: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        schedule: String? = nil,
        tags: [Tag]? = nil,
        type: DataSourceType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.schedule = schedule
        self.tags = tags
        self.type = type
    }
}

struct CreateDataSourceInputBody: Equatable {
    public let name: String?
    public let indexId: String?
    public let type: DataSourceType?
    public let configuration: DataSourceConfiguration?
    public let description: String?
    public let schedule: String?
    public let roleArn: String?
    public let tags: [Tag]?
    public let clientToken: String?
}

extension CreateDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case configuration = "Configuration"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case schedule = "Schedule"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataSourceType.self, forKey: .type)
        type = typeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DataSourceConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistException" : self = .resourceAlreadyExistException(try ResourceAlreadyExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataSourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceAlreadyExistException(ResourceAlreadyExistException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataSourceOutputResponse(id: \(String(describing: id)))"}
}

extension CreateDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateDataSourceOutputResponse: Equatable {
    /// <p>A unique identifier for the data source.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct CreateDataSourceOutputResponseBody: Equatable {
    public let id: String?
}

extension CreateDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateFaqInputBodyMiddleware: Middleware {
    public let id: String = "CreateFaqInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFaqInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFaqInput>
    public typealias MOutput = OperationOutput<CreateFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFaqOutputError>
}

extension CreateFaqInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFaqInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), fileFormat: \(String(describing: fileFormat)), indexId: \(String(describing: indexId)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), s3Path: \(String(describing: s3Path)), tags: \(String(describing: tags)))"}
}

extension CreateFaqInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case fileFormat = "FileFormat"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case s3Path = "S3Path"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fileFormat = fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3Path = s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateFaqInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFaqInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFaqInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFaqInput>
    public typealias MOutput = OperationOutput<CreateFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFaqOutputError>
}

public struct CreateFaqInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFaqInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFaqInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFaqInput>
    public typealias MOutput = OperationOutput<CreateFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFaqOutputError>
}

public struct CreateFaqInput: Equatable {
    /// <p>A token that you provide to identify the request to create a FAQ. Multiple calls to
    ///             the <code>CreateFaqRequest</code> operation with the same client token will create only
    ///             one FAQ. </p>
    public var clientToken: String?
    /// <p>A description of the FAQ.</p>
    public let description: String?
    /// <p>The format of the input file. You can choose between a basic CSV format, a CSV format
    ///             that includes customs attributes in a header, and a JSON format that includes custom
    ///             attributes.</p>
    ///         <p>The format must match the format of the file stored in the S3 bucket identified in the
    ///                 <code>S3Path</code> parameter.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/in-creating-faq.html">Adding questions and
    ///             answers</a>.</p>
    public let fileFormat: FaqFileFormat?
    /// <p>The identifier of the index that contains the FAQ.</p>
    public let indexId: String?
    /// <p>The name that should be associated with the FAQ.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of a role with permission to access the S3 bucket that
    ///             contains the FAQs. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM Roles for Amazon Kendra</a>.</p>
    public let roleArn: String?
    /// <p>The S3 location of the FAQ input data.</p>
    public let s3Path: S3Path?
    /// <p>A list of key-value pairs that identify the FAQ. You can use the tags to identify and
    ///             organize your resources and to control access to resources.</p>
    public let tags: [Tag]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        fileFormat: FaqFileFormat? = nil,
        indexId: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        s3Path: S3Path? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.fileFormat = fileFormat
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.s3Path = s3Path
        self.tags = tags
    }
}

struct CreateFaqInputBody: Equatable {
    public let indexId: String?
    public let name: String?
    public let description: String?
    public let s3Path: S3Path?
    public let roleArn: String?
    public let tags: [Tag]?
    public let fileFormat: FaqFileFormat?
    public let clientToken: String?
}

extension CreateFaqInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case fileFormat = "FileFormat"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case s3Path = "S3Path"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(S3Path.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileFormatDecoded = try containerValues.decodeIfPresent(FaqFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateFaqOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFaqOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFaqOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFaqOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFaqOutputResponse(id: \(String(describing: id)))"}
}

extension CreateFaqOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFaqOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateFaqOutputResponse: Equatable {
    /// <p>The unique identifier of the FAQ.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct CreateFaqOutputResponseBody: Equatable {
    public let id: String?
}

extension CreateFaqOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateIndexInputBodyMiddleware: Middleware {
    public let id: String = "CreateIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIndexInput>
    public typealias MOutput = OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIndexOutputError>
}

extension CreateIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIndexInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), edition: \(String(describing: edition)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), serverSideEncryptionConfiguration: \(String(describing: serverSideEncryptionConfiguration)), tags: \(String(describing: tags)), userContextPolicy: \(String(describing: userContextPolicy)), userTokenConfigurations: \(String(describing: userTokenConfigurations)))"}
}

extension CreateIndexInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case edition = "Edition"
        case name = "Name"
        case roleArn = "RoleArn"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
        case userContextPolicy = "UserContextPolicy"
        case userTokenConfigurations = "UserTokenConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let edition = edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userContextPolicy = userContextPolicy {
            try encodeContainer.encode(userContextPolicy.rawValue, forKey: .userContextPolicy)
        }
        if let userTokenConfigurations = userTokenConfigurations {
            var userTokenConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userTokenConfigurations)
            for usertokenconfigurationlist0 in userTokenConfigurations {
                try userTokenConfigurationsContainer.encode(usertokenconfigurationlist0)
            }
        }
    }
}

public struct CreateIndexInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIndexInput>
    public typealias MOutput = OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIndexOutputError>
}

public struct CreateIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIndexInput>
    public typealias MOutput = OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIndexOutputError>
}

public struct CreateIndexInput: Equatable {
    /// <p>A token that you provide to identify the request to create an index.
    ///       Multiple calls to the <code>CreateIndex</code> operation with the same
    ///       client token will create only one index.</p>
    public var clientToken: String?
    /// <p>A description for the index.</p>
    public let description: String?
    /// <p>The Amazon Kendra edition to use for the index. Choose
    ///         <code>DEVELOPER_EDITION</code> for indexes intended for development,
    ///       testing, or proof of concept. Use <code>ENTERPRISE_EDITION</code> for your
    ///       production databases. Once you set the edition for an index, it can't be
    ///       changed. </p>
    ///          <p>The <code>Edition</code> parameter is optional. If you don't supply a
    ///       value, the default is <code>ENTERPRISE_EDITION</code>.</p>
    public let edition: IndexEdition?
    /// <p>The name for the new index.</p>
    public let name: String?
    /// <p>An AWS Identity and Access Management (IAM) role that gives
    ///       Amazon Kendra permissions to access your Amazon CloudWatch logs and
    ///       metrics. This is also the role used when you use the
    ///         <code>BatchPutDocument</code> operation to index documents from an
    ///       Amazon S3 bucket.</p>
    public let roleArn: String?
    /// <p>The identifier of the AWS KMS customer managed key (CMK) to use to
    ///       encrypt data indexed by Amazon Kendra. Amazon Kendra doesn't support
    ///       asymmetric CMKs.</p>
    public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
    /// <p>A list of key-value pairs that identify the index. You can use the
    ///       tags to identify and organize your resources and to control access to
    ///       resources.</p>
    public let tags: [Tag]?
    /// <p>The user context policy.</p>
    ///          <dl>
    ///             <dt>ATTRIBUTE_FILTER</dt>
    ///             <dd>
    ///                <p>All indexed content is searchable and displayable
    ///                   for all users. If there is an access control list, it
    ///                   is ignored. You can filter on user and group attributes.
    ///                </p>
    ///             </dd>
    ///             <dt>USER_TOKEN</dt>
    ///             <dd>
    ///                <p>Enables SSO and token-based user access control.
    ///                All documents with no access control and all documents
    ///                accessible to the user will be searchable and
    ///                displayable.
    ///                </p>
    ///             </dd>
    ///          </dl>
    public let userContextPolicy: UserContextPolicy?
    /// <p>The user token configuration.</p>
    public let userTokenConfigurations: [UserTokenConfiguration]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        edition: IndexEdition? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil,
        tags: [Tag]? = nil,
        userContextPolicy: UserContextPolicy? = nil,
        userTokenConfigurations: [UserTokenConfiguration]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.edition = edition
        self.name = name
        self.roleArn = roleArn
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
        self.userContextPolicy = userContextPolicy
        self.userTokenConfigurations = userTokenConfigurations
    }
}

struct CreateIndexInputBody: Equatable {
    public let name: String?
    public let edition: IndexEdition?
    public let roleArn: String?
    public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
    public let description: String?
    public let clientToken: String?
    public let tags: [Tag]?
    public let userTokenConfigurations: [UserTokenConfiguration]?
    public let userContextPolicy: UserContextPolicy?
}

extension CreateIndexInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case edition = "Edition"
        case name = "Name"
        case roleArn = "RoleArn"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
        case userContextPolicy = "UserContextPolicy"
        case userTokenConfigurations = "UserTokenConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let editionDecoded = try containerValues.decodeIfPresent(IndexEdition.self, forKey: .edition)
        edition = editionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userTokenConfigurationsContainer = try containerValues.decodeIfPresent([UserTokenConfiguration?].self, forKey: .userTokenConfigurations)
        var userTokenConfigurationsDecoded0:[UserTokenConfiguration]? = nil
        if let userTokenConfigurationsContainer = userTokenConfigurationsContainer {
            userTokenConfigurationsDecoded0 = [UserTokenConfiguration]()
            for structure0 in userTokenConfigurationsContainer {
                if let structure0 = structure0 {
                    userTokenConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        userTokenConfigurations = userTokenConfigurationsDecoded0
        let userContextPolicyDecoded = try containerValues.decodeIfPresent(UserContextPolicy.self, forKey: .userContextPolicy)
        userContextPolicy = userContextPolicyDecoded
    }
}

extension CreateIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistException" : self = .resourceAlreadyExistException(try ResourceAlreadyExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIndexOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceAlreadyExistException(ResourceAlreadyExistException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIndexOutputResponse(id: \(String(describing: id)))"}
}

extension CreateIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIndexOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateIndexOutputResponse: Equatable {
    /// <p>The unique identifier of the index. Use this identifier when you query
    ///       an index, set up a data source, or index a document.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct CreateIndexOutputResponseBody: Equatable {
    public let id: String?
}

extension CreateIndexOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateQuerySuggestionsBlockListInputBodyMiddleware: Middleware {
    public let id: String = "CreateQuerySuggestionsBlockListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQuerySuggestionsBlockListOutputError>
}

extension CreateQuerySuggestionsBlockListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateQuerySuggestionsBlockListInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), indexId: \(String(describing: indexId)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), sourceS3Path: \(String(describing: sourceS3Path)), tags: \(String(describing: tags)))"}
}

extension CreateQuerySuggestionsBlockListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sourceS3Path = sourceS3Path {
            try encodeContainer.encode(sourceS3Path, forKey: .sourceS3Path)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateQuerySuggestionsBlockListInputHeadersMiddleware: Middleware {
    public let id: String = "CreateQuerySuggestionsBlockListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQuerySuggestionsBlockListOutputError>
}

public struct CreateQuerySuggestionsBlockListInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateQuerySuggestionsBlockListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<CreateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQuerySuggestionsBlockListOutputError>
}

public struct CreateQuerySuggestionsBlockListInput: Equatable {
    /// <p>A token that you provide to identify the request to create a
    ///             query suggestions block list.</p>
    public var clientToken: String?
    /// <p>A user-friendly description for the block list.</p>
    ///         <p>For example, the description "List of all offensive words that can
    ///             appear in user queries and need to be blocked from suggestions."</p>
    public let description: String?
    /// <p>The identifier of the index you want to create a query suggestions block list for.</p>
    public let indexId: String?
    /// <p>A user friendly name for the block list.</p>
    ///         <p>For example, the block list named 'offensive-words' includes all
    ///             offensive words that could appear in user queries and need to be
    ///             blocked from suggestions.</p>
    public let name: String?
    /// <p>The IAM (Identity and Access Management) role used by Amazon Kendra to
    ///             access the block list text file in your S3 bucket.</p>
    ///         <p>You need permissions to the role ARN (Amazon Resource Name).
    ///             The role needs S3 read permissions to your file in S3 and needs
    ///             to give STS (Security Token Service) assume role permissions
    ///             to Amazon Kendra.</p>
    public let roleArn: String?
    /// <p>The S3 path to your block list text file in your S3 bucket.</p>
    ///         <p>Each block word or phrase should be on a separate line in a text file.</p>
    ///             <p>For information on the current quota limits for block lists, see
    ///                 <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
    ///                     for Amazon Kendra</a>.</p>
    public let sourceS3Path: S3Path?
    /// <p>A tag that you can assign to a block list that categorizes
    ///             the block list.</p>
    public let tags: [Tag]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        indexId: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        sourceS3Path: S3Path? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
        self.tags = tags
    }
}

struct CreateQuerySuggestionsBlockListInputBody: Equatable {
    public let indexId: String?
    public let name: String?
    public let description: String?
    public let sourceS3Path: S3Path?
    public let clientToken: String?
    public let roleArn: String?
    public let tags: [Tag]?
}

extension CreateQuerySuggestionsBlockListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateQuerySuggestionsBlockListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateQuerySuggestionsBlockListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateQuerySuggestionsBlockListOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateQuerySuggestionsBlockListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateQuerySuggestionsBlockListOutputResponse(id: \(String(describing: id)))"}
}

extension CreateQuerySuggestionsBlockListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateQuerySuggestionsBlockListOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateQuerySuggestionsBlockListOutputResponse: Equatable {
    /// <p>The unique identifier of the created block list.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct CreateQuerySuggestionsBlockListOutputResponseBody: Equatable {
    public let id: String?
}

extension CreateQuerySuggestionsBlockListOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateThesaurusInputBodyMiddleware: Middleware {
    public let id: String = "CreateThesaurusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThesaurusInput>
    public typealias MOutput = OperationOutput<CreateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThesaurusOutputError>
}

extension CreateThesaurusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThesaurusInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), indexId: \(String(describing: indexId)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), sourceS3Path: \(String(describing: sourceS3Path)), tags: \(String(describing: tags)))"}
}

extension CreateThesaurusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sourceS3Path = sourceS3Path {
            try encodeContainer.encode(sourceS3Path, forKey: .sourceS3Path)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateThesaurusInputHeadersMiddleware: Middleware {
    public let id: String = "CreateThesaurusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThesaurusInput>
    public typealias MOutput = OperationOutput<CreateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThesaurusOutputError>
}

public struct CreateThesaurusInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateThesaurusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThesaurusInput>
    public typealias MOutput = OperationOutput<CreateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThesaurusOutputError>
}

public struct CreateThesaurusInput: Equatable {
    /// <p>A token that you provide to identify the request to create a
    ///          thesaurus. Multiple calls to the <code>CreateThesaurus</code> operation
    ///          with the same client token will create only one index.
    ///       </p>
    public var clientToken: String?
    /// <p>The description for the new thesaurus.</p>
    public let description: String?
    /// <p>The unique identifier of the index for the new thesaurus.
    ///       </p>
    public let indexId: String?
    /// <p>The name for the new thesaurus.</p>
    public let name: String?
    /// <p>An AWS Identity and Access Management (IAM) role that gives Amazon Kendra permissions
    ///          to access thesaurus file specified in <code>SourceS3Path</code>.
    ///       </p>
    public let roleArn: String?
    /// <p>The thesaurus file Amazon S3 source path.
    ///       </p>
    public let sourceS3Path: S3Path?
    /// <p>A list of key-value pairs that identify the thesaurus. You can use
    ///          the tags to identify and organize your resources and to control
    ///          access to resources.
    ///       </p>
    public let tags: [Tag]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        indexId: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        sourceS3Path: S3Path? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
        self.tags = tags
    }
}

struct CreateThesaurusInputBody: Equatable {
    public let indexId: String?
    public let name: String?
    public let description: String?
    public let roleArn: String?
    public let tags: [Tag]?
    public let sourceS3Path: S3Path?
    public let clientToken: String?
}

extension CreateThesaurusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateThesaurusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThesaurusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThesaurusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThesaurusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThesaurusOutputResponse(id: \(String(describing: id)))"}
}

extension CreateThesaurusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateThesaurusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateThesaurusOutputResponse: Equatable {
    /// <p>The unique identifier of the thesaurus.
    ///       </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct CreateThesaurusOutputResponseBody: Equatable {
    public let id: String?
}

extension CreateThesaurusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DataSourceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confluenceConfiguration = "ConfluenceConfiguration"
        case databaseConfiguration = "DatabaseConfiguration"
        case googleDriveConfiguration = "GoogleDriveConfiguration"
        case oneDriveConfiguration = "OneDriveConfiguration"
        case s3Configuration = "S3Configuration"
        case salesforceConfiguration = "SalesforceConfiguration"
        case serviceNowConfiguration = "ServiceNowConfiguration"
        case sharePointConfiguration = "SharePointConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confluenceConfiguration = confluenceConfiguration {
            try encodeContainer.encode(confluenceConfiguration, forKey: .confluenceConfiguration)
        }
        if let databaseConfiguration = databaseConfiguration {
            try encodeContainer.encode(databaseConfiguration, forKey: .databaseConfiguration)
        }
        if let googleDriveConfiguration = googleDriveConfiguration {
            try encodeContainer.encode(googleDriveConfiguration, forKey: .googleDriveConfiguration)
        }
        if let oneDriveConfiguration = oneDriveConfiguration {
            try encodeContainer.encode(oneDriveConfiguration, forKey: .oneDriveConfiguration)
        }
        if let s3Configuration = s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
        if let salesforceConfiguration = salesforceConfiguration {
            try encodeContainer.encode(salesforceConfiguration, forKey: .salesforceConfiguration)
        }
        if let serviceNowConfiguration = serviceNowConfiguration {
            try encodeContainer.encode(serviceNowConfiguration, forKey: .serviceNowConfiguration)
        }
        if let sharePointConfiguration = sharePointConfiguration {
            try encodeContainer.encode(sharePointConfiguration, forKey: .sharePointConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(S3DataSourceConfiguration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let sharePointConfigurationDecoded = try containerValues.decodeIfPresent(SharePointConfiguration.self, forKey: .sharePointConfiguration)
        sharePointConfiguration = sharePointConfigurationDecoded
        let databaseConfigurationDecoded = try containerValues.decodeIfPresent(DatabaseConfiguration.self, forKey: .databaseConfiguration)
        databaseConfiguration = databaseConfigurationDecoded
        let salesforceConfigurationDecoded = try containerValues.decodeIfPresent(SalesforceConfiguration.self, forKey: .salesforceConfiguration)
        salesforceConfiguration = salesforceConfigurationDecoded
        let oneDriveConfigurationDecoded = try containerValues.decodeIfPresent(OneDriveConfiguration.self, forKey: .oneDriveConfiguration)
        oneDriveConfiguration = oneDriveConfigurationDecoded
        let serviceNowConfigurationDecoded = try containerValues.decodeIfPresent(ServiceNowConfiguration.self, forKey: .serviceNowConfiguration)
        serviceNowConfiguration = serviceNowConfigurationDecoded
        let confluenceConfigurationDecoded = try containerValues.decodeIfPresent(ConfluenceConfiguration.self, forKey: .confluenceConfiguration)
        confluenceConfiguration = confluenceConfigurationDecoded
        let googleDriveConfigurationDecoded = try containerValues.decodeIfPresent(GoogleDriveConfiguration.self, forKey: .googleDriveConfiguration)
        googleDriveConfiguration = googleDriveConfigurationDecoded
    }
}

extension DataSourceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSourceConfiguration(confluenceConfiguration: \(String(describing: confluenceConfiguration)), databaseConfiguration: \(String(describing: databaseConfiguration)), googleDriveConfiguration: \(String(describing: googleDriveConfiguration)), oneDriveConfiguration: \(String(describing: oneDriveConfiguration)), s3Configuration: \(String(describing: s3Configuration)), salesforceConfiguration: \(String(describing: salesforceConfiguration)), serviceNowConfiguration: \(String(describing: serviceNowConfiguration)), sharePointConfiguration: \(String(describing: sharePointConfiguration)))"}
}

/// <p>Configuration information for a Amazon Kendra data source.</p>
public struct DataSourceConfiguration: Equatable {
    /// <p>Provides configuration information for connecting to a Confluence
    ///             data source.</p>
    public let confluenceConfiguration: ConfluenceConfiguration?
    /// <p>Provides information necessary to create a data source connector
    ///             for a database.</p>
    public let databaseConfiguration: DatabaseConfiguration?
    /// <p>Provides configuration for data sources that connect to Google
    ///             Drive. </p>
    public let googleDriveConfiguration: GoogleDriveConfiguration?
    /// <p>Provides configuration for data sources that connect to Microsoft
    ///             OneDrive.</p>
    public let oneDriveConfiguration: OneDriveConfiguration?
    /// <p>Provides information to create a data source connector for a
    ///             document repository in an Amazon S3 bucket.</p>
    public let s3Configuration: S3DataSourceConfiguration?
    /// <p>Provides configuration information for data sources that connect
    ///             to a Salesforce site.</p>
    public let salesforceConfiguration: SalesforceConfiguration?
    /// <p>Provides configuration for data sources that connect to ServiceNow
    ///             instances.</p>
    public let serviceNowConfiguration: ServiceNowConfiguration?
    /// <p>Provides information necessary to create a data source connector
    ///             for a Microsoft SharePoint site.</p>
    public let sharePointConfiguration: SharePointConfiguration?

    public init (
        confluenceConfiguration: ConfluenceConfiguration? = nil,
        databaseConfiguration: DatabaseConfiguration? = nil,
        googleDriveConfiguration: GoogleDriveConfiguration? = nil,
        oneDriveConfiguration: OneDriveConfiguration? = nil,
        s3Configuration: S3DataSourceConfiguration? = nil,
        salesforceConfiguration: SalesforceConfiguration? = nil,
        serviceNowConfiguration: ServiceNowConfiguration? = nil,
        sharePointConfiguration: SharePointConfiguration? = nil
    )
    {
        self.confluenceConfiguration = confluenceConfiguration
        self.databaseConfiguration = databaseConfiguration
        self.googleDriveConfiguration = googleDriveConfiguration
        self.oneDriveConfiguration = oneDriveConfiguration
        self.s3Configuration = s3Configuration
        self.salesforceConfiguration = salesforceConfiguration
        self.serviceNowConfiguration = serviceNowConfiguration
        self.sharePointConfiguration = sharePointConfiguration
    }
}

public enum DataSourceStatus {
    case active
    case creating
    case deleting
    case failed
    case updating
    case sdkUnknown(String)
}

extension DataSourceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSourceStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSourceStatus(rawValue: rawValue) ?? DataSourceStatus.sdkUnknown(rawValue)
    }
}

extension DataSourceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataSourceType.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DataSourceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSourceSummary(createdAt: \(String(describing: createdAt)), id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)), type: \(String(describing: type)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Summary information for a Amazon Kendra data source. Returned in a call
///             to the <code>DescribeDataSource</code> operation.</p>
public struct DataSourceSummary: Equatable {
    /// <p>The UNIX datetime that the data source was created.</p>
    public let createdAt: Date?
    /// <p>The unique identifier for the data source.</p>
    public let id: String?
    /// <p>The name of the data source.</p>
    public let name: String?
    /// <p>The status of the data source. When the status is
    ///                 <code>ACTIVE</code> the data source is ready to use.</p>
    public let status: DataSourceStatus?
    /// <p>The type of the data source.</p>
    public let type: DataSourceType?
    /// <p>The UNIX datetime that the data source was lasted updated. </p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        id: String? = nil,
        name: String? = nil,
        status: DataSourceStatus? = nil,
        type: DataSourceType? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.id = id
        self.name = name
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension DataSourceSyncJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceErrorCode = "DataSourceErrorCode"
        case endTime = "EndTime"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case executionId = "ExecutionId"
        case metrics = "Metrics"
        case startTime = "StartTime"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceErrorCode = dataSourceErrorCode {
            try encodeContainer.encode(dataSourceErrorCode, forKey: .dataSourceErrorCode)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let metrics = metrics {
            try encodeContainer.encode(metrics, forKey: .metrics)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataSourceSyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let dataSourceErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceErrorCode)
        dataSourceErrorCode = dataSourceErrorCodeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(DataSourceSyncJobMetrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension DataSourceSyncJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSourceSyncJob(dataSourceErrorCode: \(String(describing: dataSourceErrorCode)), endTime: \(String(describing: endTime)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), executionId: \(String(describing: executionId)), metrics: \(String(describing: metrics)), startTime: \(String(describing: startTime)), status: \(String(describing: status)))"}
}

/// <p>Provides information about a synchronization job.</p>
public struct DataSourceSyncJob: Equatable {
    /// <p>If the reason that the synchronization failed is due to an error
    ///             with the underlying data source, this field contains a code that
    ///             identifies the error.</p>
    public let dataSourceErrorCode: String?
    /// <p>The UNIX datetime that the synchronization job was
    ///             completed.</p>
    public let endTime: Date?
    /// <p>If the <code>Status</code> field is set to <code>FAILED</code>,
    ///             the <code>ErrorCode</code> field contains a the reason that the
    ///             synchronization failed.</p>
    public let errorCode: ErrorCode?
    /// <p>If the <code>Status</code> field is set to <code>ERROR</code>, the
    ///                 <code>ErrorMessage</code> field contains a description of the
    ///             error that caused the synchronization to fail.</p>
    public let errorMessage: String?
    /// <p>A unique identifier for the synchronization job.</p>
    public let executionId: String?
    /// <p>Maps a batch delete document request to a specific data source
    ///             sync job. This is optional and should only be supplied when
    ///             documents are deleted by a data source connector.</p>
    public let metrics: DataSourceSyncJobMetrics?
    /// <p>The UNIX datetime that the synchronization job was started.</p>
    public let startTime: Date?
    /// <p>The execution status of the synchronization job. When the
    ///                 <code>Status</code> field is set to <code>SUCCEEDED</code>, the
    ///             synchronization job is done. If the status code is set to
    ///                 <code>FAILED</code>, the <code>ErrorCode</code> and
    ///                 <code>ErrorMessage</code> fields give you the reason for the
    ///             failure.</p>
    public let status: DataSourceSyncJobStatus?

    public init (
        dataSourceErrorCode: String? = nil,
        endTime: Date? = nil,
        errorCode: ErrorCode? = nil,
        errorMessage: String? = nil,
        executionId: String? = nil,
        metrics: DataSourceSyncJobMetrics? = nil,
        startTime: Date? = nil,
        status: DataSourceSyncJobStatus? = nil
    )
    {
        self.dataSourceErrorCode = dataSourceErrorCode
        self.endTime = endTime
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.executionId = executionId
        self.metrics = metrics
        self.startTime = startTime
        self.status = status
    }
}

extension DataSourceSyncJobMetricTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceId = "DataSourceId"
        case dataSourceSyncJobId = "DataSourceSyncJobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let dataSourceSyncJobId = dataSourceSyncJobId {
            try encodeContainer.encode(dataSourceSyncJobId, forKey: .dataSourceSyncJobId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let dataSourceSyncJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceSyncJobId)
        dataSourceSyncJobId = dataSourceSyncJobIdDecoded
    }
}

extension DataSourceSyncJobMetricTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSourceSyncJobMetricTarget(dataSourceId: \(String(describing: dataSourceId)), dataSourceSyncJobId: \(String(describing: dataSourceSyncJobId)))"}
}

/// <p>Maps a particular data source sync job to a particular data
///             source.</p>
public struct DataSourceSyncJobMetricTarget: Equatable {
    /// <p>The ID of the data source that is running the sync job.</p>
    public let dataSourceId: String?
    /// <p>The ID of the sync job that is running on the data source.</p>
    ///         <p>If the ID of a sync job is not provided and there is a sync job
    ///             running, then the ID of this sync job is used and metrics are
    ///             generated for this sync job.</p>
    ///         <p>If the ID of a sync job is not provided and there is no sync job
    ///             running, then no metrics are generated and documents are
    ///             indexed/deleted at the index level without sync job metrics included.</p>
    public let dataSourceSyncJobId: String?

    public init (
        dataSourceId: String? = nil,
        dataSourceSyncJobId: String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.dataSourceSyncJobId = dataSourceSyncJobId
    }
}

extension DataSourceSyncJobMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentsAdded = "DocumentsAdded"
        case documentsDeleted = "DocumentsDeleted"
        case documentsFailed = "DocumentsFailed"
        case documentsModified = "DocumentsModified"
        case documentsScanned = "DocumentsScanned"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentsAdded = documentsAdded {
            try encodeContainer.encode(documentsAdded, forKey: .documentsAdded)
        }
        if let documentsDeleted = documentsDeleted {
            try encodeContainer.encode(documentsDeleted, forKey: .documentsDeleted)
        }
        if let documentsFailed = documentsFailed {
            try encodeContainer.encode(documentsFailed, forKey: .documentsFailed)
        }
        if let documentsModified = documentsModified {
            try encodeContainer.encode(documentsModified, forKey: .documentsModified)
        }
        if let documentsScanned = documentsScanned {
            try encodeContainer.encode(documentsScanned, forKey: .documentsScanned)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentsAddedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentsAdded)
        documentsAdded = documentsAddedDecoded
        let documentsModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentsModified)
        documentsModified = documentsModifiedDecoded
        let documentsDeletedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentsDeleted)
        documentsDeleted = documentsDeletedDecoded
        let documentsFailedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentsFailed)
        documentsFailed = documentsFailedDecoded
        let documentsScannedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentsScanned)
        documentsScanned = documentsScannedDecoded
    }
}

extension DataSourceSyncJobMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSourceSyncJobMetrics(documentsAdded: \(String(describing: documentsAdded)), documentsDeleted: \(String(describing: documentsDeleted)), documentsFailed: \(String(describing: documentsFailed)), documentsModified: \(String(describing: documentsModified)), documentsScanned: \(String(describing: documentsScanned)))"}
}

/// <p>Maps a batch delete document request to a specific data source
///             sync job. This is optional and should only be supplied when
///             documents are deleted by a data source connector.</p>
public struct DataSourceSyncJobMetrics: Equatable {
    /// <p>The number of documents added from the data source up to now in
    ///             the data source sync.</p>
    public let documentsAdded: String?
    /// <p>The number of documents deleted from the data source up to now in
    ///             the data source sync run.</p>
    public let documentsDeleted: String?
    /// <p>The number of documents that failed to sync from the data source
    ///             up to now in the data source sync run.</p>
    public let documentsFailed: String?
    /// <p>The number of documents modified in the data source up to now in
    ///             the data source sync run.</p>
    public let documentsModified: String?
    /// <p>The current number of documents crawled by the current sync job in
    ///             the data source.</p>
    public let documentsScanned: String?

    public init (
        documentsAdded: String? = nil,
        documentsDeleted: String? = nil,
        documentsFailed: String? = nil,
        documentsModified: String? = nil,
        documentsScanned: String? = nil
    )
    {
        self.documentsAdded = documentsAdded
        self.documentsDeleted = documentsDeleted
        self.documentsFailed = documentsFailed
        self.documentsModified = documentsModified
        self.documentsScanned = documentsScanned
    }
}

public enum DataSourceSyncJobStatus {
    case aborted
    case failed
    case incomplete
    case stopping
    case succeeded
    case syncing
    case syncingIndexing
    case sdkUnknown(String)
}

extension DataSourceSyncJobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSourceSyncJobStatus] {
        return [
            .aborted,
            .failed,
            .incomplete,
            .stopping,
            .succeeded,
            .syncing,
            .syncingIndexing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aborted: return "ABORTED"
        case .failed: return "FAILED"
        case .incomplete: return "INCOMPLETE"
        case .stopping: return "STOPPING"
        case .succeeded: return "SUCCEEDED"
        case .syncing: return "SYNCING"
        case .syncingIndexing: return "SYNCING_INDEXING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSourceSyncJobStatus(rawValue: rawValue) ?? DataSourceSyncJobStatus.sdkUnknown(rawValue)
    }
}

extension DataSourceToIndexFieldMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceFieldName = "DataSourceFieldName"
        case dateFieldFormat = "DateFieldFormat"
        case indexFieldName = "IndexFieldName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceFieldName = dataSourceFieldName {
            try encodeContainer.encode(dataSourceFieldName, forKey: .dataSourceFieldName)
        }
        if let dateFieldFormat = dateFieldFormat {
            try encodeContainer.encode(dateFieldFormat, forKey: .dateFieldFormat)
        }
        if let indexFieldName = indexFieldName {
            try encodeContainer.encode(indexFieldName, forKey: .indexFieldName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceFieldName)
        dataSourceFieldName = dataSourceFieldNameDecoded
        let dateFieldFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateFieldFormat)
        dateFieldFormat = dateFieldFormatDecoded
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
    }
}

extension DataSourceToIndexFieldMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSourceToIndexFieldMapping(dataSourceFieldName: \(String(describing: dataSourceFieldName)), dateFieldFormat: \(String(describing: dateFieldFormat)), indexFieldName: \(String(describing: indexFieldName)))"}
}

/// <p>Maps a column or attribute in the data source to an index field.
///             You must first create the fields in the index using the
///                 <code>UpdateIndex</code> operation.</p>
public struct DataSourceToIndexFieldMapping: Equatable {
    /// <p>The name of the column or attribute in the data source.</p>
    public let dataSourceFieldName: String?
    /// <p>The type of data stored in the column or attribute.</p>
    public let dateFieldFormat: String?
    /// <p>The name of the field in the index.</p>
    public let indexFieldName: String?

    public init (
        dataSourceFieldName: String? = nil,
        dateFieldFormat: String? = nil,
        indexFieldName: String? = nil
    )
    {
        self.dataSourceFieldName = dataSourceFieldName
        self.dateFieldFormat = dateFieldFormat
        self.indexFieldName = indexFieldName
    }
}

public enum DataSourceType {
    case confluence
    case custom
    case database
    case googledrive
    case onedrive
    case s3
    case salesforce
    case servicenow
    case sharepoint
    case sdkUnknown(String)
}

extension DataSourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSourceType] {
        return [
            .confluence,
            .custom,
            .database,
            .googledrive,
            .onedrive,
            .s3,
            .salesforce,
            .servicenow,
            .sharepoint,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .confluence: return "CONFLUENCE"
        case .custom: return "CUSTOM"
        case .database: return "DATABASE"
        case .googledrive: return "GOOGLEDRIVE"
        case .onedrive: return "ONEDRIVE"
        case .s3: return "S3"
        case .salesforce: return "SALESFORCE"
        case .servicenow: return "SERVICENOW"
        case .sharepoint: return "SHAREPOINT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
    }
}

extension DataSourceVpcConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension DataSourceVpcConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSourceVpcConfiguration(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)))"}
}

/// <p>Provides information for connecting to an Amazon VPC.</p>
public struct DataSourceVpcConfiguration: Equatable {
    /// <p>A list of identifiers of security groups within your Amazon VPC.
    ///             The security groups should enable Amazon Kendra to connect to the data
    ///             source.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of identifiers for subnets within your Amazon VPC. The
    ///             subnets should be able to connect to each other in the VPC, and they
    ///             should have outgoing access to the Internet through a NAT
    ///             device.</p>
    public let subnetIds: [String]?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
    }
}

extension DatabaseConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aclConfiguration = "AclConfiguration"
        case columnConfiguration = "ColumnConfiguration"
        case connectionConfiguration = "ConnectionConfiguration"
        case databaseEngineType = "DatabaseEngineType"
        case sqlConfiguration = "SqlConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclConfiguration = aclConfiguration {
            try encodeContainer.encode(aclConfiguration, forKey: .aclConfiguration)
        }
        if let columnConfiguration = columnConfiguration {
            try encodeContainer.encode(columnConfiguration, forKey: .columnConfiguration)
        }
        if let connectionConfiguration = connectionConfiguration {
            try encodeContainer.encode(connectionConfiguration, forKey: .connectionConfiguration)
        }
        if let databaseEngineType = databaseEngineType {
            try encodeContainer.encode(databaseEngineType.rawValue, forKey: .databaseEngineType)
        }
        if let sqlConfiguration = sqlConfiguration {
            try encodeContainer.encode(sqlConfiguration, forKey: .sqlConfiguration)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseEngineTypeDecoded = try containerValues.decodeIfPresent(DatabaseEngineType.self, forKey: .databaseEngineType)
        databaseEngineType = databaseEngineTypeDecoded
        let connectionConfigurationDecoded = try containerValues.decodeIfPresent(ConnectionConfiguration.self, forKey: .connectionConfiguration)
        connectionConfiguration = connectionConfigurationDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(DataSourceVpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let columnConfigurationDecoded = try containerValues.decodeIfPresent(ColumnConfiguration.self, forKey: .columnConfiguration)
        columnConfiguration = columnConfigurationDecoded
        let aclConfigurationDecoded = try containerValues.decodeIfPresent(AclConfiguration.self, forKey: .aclConfiguration)
        aclConfiguration = aclConfigurationDecoded
        let sqlConfigurationDecoded = try containerValues.decodeIfPresent(SqlConfiguration.self, forKey: .sqlConfiguration)
        sqlConfiguration = sqlConfigurationDecoded
    }
}

extension DatabaseConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatabaseConfiguration(aclConfiguration: \(String(describing: aclConfiguration)), columnConfiguration: \(String(describing: columnConfiguration)), connectionConfiguration: \(String(describing: connectionConfiguration)), databaseEngineType: \(String(describing: databaseEngineType)), sqlConfiguration: \(String(describing: sqlConfiguration)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

/// <p>Provides the information necessary to connect a database to an
///             index. </p>
public struct DatabaseConfiguration: Equatable {
    /// <p>Information about the database column that provides information
    ///             for user context filtering.</p>
    public let aclConfiguration: AclConfiguration?
    /// <p>Information about where the index should get the document
    ///             information from the database.</p>
    public let columnConfiguration: ColumnConfiguration?
    /// <p>The information necessary to connect to a database.</p>
    public let connectionConfiguration: ConnectionConfiguration?
    /// <p>The type of database engine that runs the database.</p>
    public let databaseEngineType: DatabaseEngineType?
    /// <p>Provides information about how Amazon Kendra uses quote marks around SQL
    ///             identifiers when querying a database data source.</p>
    public let sqlConfiguration: SqlConfiguration?
    /// <p>Provides information for connecting to an Amazon VPC.</p>
    public let vpcConfiguration: DataSourceVpcConfiguration?

    public init (
        aclConfiguration: AclConfiguration? = nil,
        columnConfiguration: ColumnConfiguration? = nil,
        connectionConfiguration: ConnectionConfiguration? = nil,
        databaseEngineType: DatabaseEngineType? = nil,
        sqlConfiguration: SqlConfiguration? = nil,
        vpcConfiguration: DataSourceVpcConfiguration? = nil
    )
    {
        self.aclConfiguration = aclConfiguration
        self.columnConfiguration = columnConfiguration
        self.connectionConfiguration = connectionConfiguration
        self.databaseEngineType = databaseEngineType
        self.sqlConfiguration = sqlConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

public enum DatabaseEngineType {
    case rdsAuroraMysql
    case rdsAuroraPostgresql
    case rdsMysql
    case rdsPostgresql
    case sdkUnknown(String)
}

extension DatabaseEngineType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatabaseEngineType] {
        return [
            .rdsAuroraMysql,
            .rdsAuroraPostgresql,
            .rdsMysql,
            .rdsPostgresql,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rdsAuroraMysql: return "RDS_AURORA_MYSQL"
        case .rdsAuroraPostgresql: return "RDS_AURORA_POSTGRESQL"
        case .rdsMysql: return "RDS_MYSQL"
        case .rdsPostgresql: return "RDS_POSTGRESQL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatabaseEngineType(rawValue: rawValue) ?? DatabaseEngineType.sdkUnknown(rawValue)
    }
}

public struct DeleteDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataSourceOutputError>
}

extension DeleteDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataSourceInput(id: \(String(describing: id)), indexId: \(String(describing: indexId)))"}
}

extension DeleteDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DeleteDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataSourceOutputError>
}

public struct DeleteDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataSourceOutputError>
}

public struct DeleteDataSourceInput: Equatable {
    /// <p>The unique identifier of the data source to delete.</p>
    public let id: String?
    /// <p>The unique identifier of the index associated with the data
    ///       source.</p>
    public let indexId: String?

    public init (
        id: String? = nil,
        indexId: String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DeleteDataSourceInputBody: Equatable {
    public let id: String?
    public let indexId: String?
}

extension DeleteDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DeleteDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataSourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataSourceOutputResponse()"}
}

extension DeleteDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDataSourceOutputResponse: Equatable {

    public init() {}
}

struct DeleteDataSourceOutputResponseBody: Equatable {
}

extension DeleteDataSourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteFaqInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFaqInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFaqInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFaqInput>
    public typealias MOutput = OperationOutput<DeleteFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFaqOutputError>
}

extension DeleteFaqInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFaqInput(id: \(String(describing: id)), indexId: \(String(describing: indexId)))"}
}

extension DeleteFaqInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DeleteFaqInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFaqInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFaqInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFaqInput>
    public typealias MOutput = OperationOutput<DeleteFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFaqOutputError>
}

public struct DeleteFaqInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFaqInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFaqInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFaqInput>
    public typealias MOutput = OperationOutput<DeleteFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFaqOutputError>
}

public struct DeleteFaqInput: Equatable {
    /// <p>The identifier of the FAQ to remove.</p>
    public let id: String?
    /// <p>The index to remove the FAQ from.</p>
    public let indexId: String?

    public init (
        id: String? = nil,
        indexId: String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DeleteFaqInputBody: Equatable {
    public let id: String?
    public let indexId: String?
}

extension DeleteFaqInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DeleteFaqOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFaqOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFaqOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFaqOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFaqOutputResponse()"}
}

extension DeleteFaqOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFaqOutputResponse: Equatable {

    public init() {}
}

struct DeleteFaqOutputResponseBody: Equatable {
}

extension DeleteFaqOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteIndexInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIndexInput>
    public typealias MOutput = OperationOutput<DeleteIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIndexOutputError>
}

extension DeleteIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIndexInput(id: \(String(describing: id)))"}
}

extension DeleteIndexInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteIndexInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIndexInput>
    public typealias MOutput = OperationOutput<DeleteIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIndexOutputError>
}

public struct DeleteIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIndexInput>
    public typealias MOutput = OperationOutput<DeleteIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIndexOutputError>
}

public struct DeleteIndexInput: Equatable {
    /// <p>The identifier of the index to delete.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteIndexInputBody: Equatable {
    public let id: String?
}

extension DeleteIndexInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIndexOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIndexOutputResponse()"}
}

extension DeleteIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIndexOutputResponse: Equatable {

    public init() {}
}

struct DeleteIndexOutputResponseBody: Equatable {
}

extension DeleteIndexOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteQuerySuggestionsBlockListInputBodyMiddleware: Middleware {
    public let id: String = "DeleteQuerySuggestionsBlockListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteQuerySuggestionsBlockListOutputError>
}

extension DeleteQuerySuggestionsBlockListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteQuerySuggestionsBlockListInput(id: \(String(describing: id)), indexId: \(String(describing: indexId)))"}
}

extension DeleteQuerySuggestionsBlockListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DeleteQuerySuggestionsBlockListInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteQuerySuggestionsBlockListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteQuerySuggestionsBlockListOutputError>
}

public struct DeleteQuerySuggestionsBlockListInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteQuerySuggestionsBlockListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<DeleteQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteQuerySuggestionsBlockListOutputError>
}

public struct DeleteQuerySuggestionsBlockListInput: Equatable {
    /// <p>The unique identifier of the block list that needs to be deleted.</p>
    public let id: String?
    /// <p>The identifier of the you want to delete a block list from.</p>
    public let indexId: String?

    public init (
        id: String? = nil,
        indexId: String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DeleteQuerySuggestionsBlockListInputBody: Equatable {
    public let indexId: String?
    public let id: String?
}

extension DeleteQuerySuggestionsBlockListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteQuerySuggestionsBlockListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteQuerySuggestionsBlockListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteQuerySuggestionsBlockListOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteQuerySuggestionsBlockListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteQuerySuggestionsBlockListOutputResponse()"}
}

extension DeleteQuerySuggestionsBlockListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteQuerySuggestionsBlockListOutputResponse: Equatable {

    public init() {}
}

struct DeleteQuerySuggestionsBlockListOutputResponseBody: Equatable {
}

extension DeleteQuerySuggestionsBlockListOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteThesaurusInputBodyMiddleware: Middleware {
    public let id: String = "DeleteThesaurusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThesaurusInput>
    public typealias MOutput = OperationOutput<DeleteThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThesaurusOutputError>
}

extension DeleteThesaurusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThesaurusInput(id: \(String(describing: id)), indexId: \(String(describing: indexId)))"}
}

extension DeleteThesaurusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DeleteThesaurusInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteThesaurusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThesaurusInput>
    public typealias MOutput = OperationOutput<DeleteThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThesaurusOutputError>
}

public struct DeleteThesaurusInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteThesaurusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThesaurusInput>
    public typealias MOutput = OperationOutput<DeleteThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThesaurusOutputError>
}

public struct DeleteThesaurusInput: Equatable {
    /// <p>The identifier of the thesaurus to delete.</p>
    public let id: String?
    /// <p>The identifier of the index associated with the thesaurus to delete.</p>
    public let indexId: String?

    public init (
        id: String? = nil,
        indexId: String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DeleteThesaurusInputBody: Equatable {
    public let id: String?
    public let indexId: String?
}

extension DeleteThesaurusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DeleteThesaurusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThesaurusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThesaurusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThesaurusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThesaurusOutputResponse()"}
}

extension DeleteThesaurusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteThesaurusOutputResponse: Equatable {

    public init() {}
}

struct DeleteThesaurusOutputResponseBody: Equatable {
}

extension DeleteThesaurusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataSourceInput>
    public typealias MOutput = OperationOutput<DescribeDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataSourceOutputError>
}

extension DescribeDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataSourceInput(id: \(String(describing: id)), indexId: \(String(describing: indexId)))"}
}

extension DescribeDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DescribeDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataSourceInput>
    public typealias MOutput = OperationOutput<DescribeDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataSourceOutputError>
}

public struct DescribeDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataSourceInput>
    public typealias MOutput = OperationOutput<DescribeDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataSourceOutputError>
}

public struct DescribeDataSourceInput: Equatable {
    /// <p>The unique identifier of the data source to describe.</p>
    public let id: String?
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: String?

    public init (
        id: String? = nil,
        indexId: String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DescribeDataSourceInputBody: Equatable {
    public let id: String?
    public let indexId: String?
}

extension DescribeDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DescribeDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataSourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataSourceOutputResponse(configuration: \(String(describing: configuration)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), errorMessage: \(String(describing: errorMessage)), id: \(String(describing: id)), indexId: \(String(describing: indexId)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), schedule: \(String(describing: schedule)), status: \(String(describing: status)), type: \(String(describing: type)), updatedAt: \(String(describing: updatedAt)))"}
}

extension DescribeDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.description = output.description
            self.errorMessage = output.errorMessage
            self.id = output.id
            self.indexId = output.indexId
            self.name = output.name
            self.roleArn = output.roleArn
            self.schedule = output.schedule
            self.status = output.status
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.configuration = nil
            self.createdAt = nil
            self.description = nil
            self.errorMessage = nil
            self.id = nil
            self.indexId = nil
            self.name = nil
            self.roleArn = nil
            self.schedule = nil
            self.status = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct DescribeDataSourceOutputResponse: Equatable {
    /// <p>Information that describes where the data source is located and how
    ///       the data source is configured. The specific information in the description
    ///       depends on the data source provider.</p>
    public let configuration: DataSourceConfiguration?
    /// <p>The Unix timestamp of when the data source was created.</p>
    public let createdAt: Date?
    /// <p>The description of the data source.</p>
    public let description: String?
    /// <p>When the <code>Status</code> field value is <code>FAILED</code>, the
    ///         <code>ErrorMessage</code> field contains a description of the error that
    ///       caused the data source to fail.</p>
    public let errorMessage: String?
    /// <p>The identifier of the data source.</p>
    public let id: String?
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: String?
    /// <p>The name that you gave the data source when it was created.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the role that enables the data
    ///       source to access its resources.</p>
    public let roleArn: String?
    /// <p>The schedule that Amazon Kendra will update the data source.</p>
    public let schedule: String?
    /// <p>The current status of the data source. When the status is
    ///         <code>ACTIVE</code> the data source is ready to use. When the status is
    ///         <code>FAILED</code>, the <code>ErrorMessage</code> field contains the
    ///       reason that the data source failed.</p>
    public let status: DataSourceStatus?
    /// <p>The type of the data source.</p>
    public let type: DataSourceType?
    /// <p>The Unix timestamp of when the data source was last updated.</p>
    public let updatedAt: Date?

    public init (
        configuration: DataSourceConfiguration? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        errorMessage: String? = nil,
        id: String? = nil,
        indexId: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        schedule: String? = nil,
        status: DataSourceStatus? = nil,
        type: DataSourceType? = nil,
        updatedAt: Date? = nil
    )
    {
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.errorMessage = errorMessage
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.schedule = schedule
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct DescribeDataSourceOutputResponseBody: Equatable {
    public let id: String?
    public let indexId: String?
    public let name: String?
    public let type: DataSourceType?
    public let configuration: DataSourceConfiguration?
    public let createdAt: Date?
    public let updatedAt: Date?
    public let description: String?
    public let status: DataSourceStatus?
    public let schedule: String?
    public let roleArn: String?
    public let errorMessage: String?
}

extension DescribeDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case createdAt = "CreatedAt"
        case description = "Description"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case schedule = "Schedule"
        case status = "Status"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataSourceType.self, forKey: .type)
        type = typeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DataSourceConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

public struct DescribeFaqInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFaqInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFaqInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFaqInput>
    public typealias MOutput = OperationOutput<DescribeFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFaqOutputError>
}

extension DescribeFaqInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFaqInput(id: \(String(describing: id)), indexId: \(String(describing: indexId)))"}
}

extension DescribeFaqInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DescribeFaqInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFaqInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFaqInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFaqInput>
    public typealias MOutput = OperationOutput<DescribeFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFaqOutputError>
}

public struct DescribeFaqInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFaqInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFaqInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFaqOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFaqInput>
    public typealias MOutput = OperationOutput<DescribeFaqOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFaqOutputError>
}

public struct DescribeFaqInput: Equatable {
    /// <p>The unique identifier of the FAQ.</p>
    public let id: String?
    /// <p>The identifier of the index that contains the FAQ.</p>
    public let indexId: String?

    public init (
        id: String? = nil,
        indexId: String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DescribeFaqInputBody: Equatable {
    public let id: String?
    public let indexId: String?
}

extension DescribeFaqInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DescribeFaqOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFaqOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFaqOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFaqOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFaqOutputResponse(createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), errorMessage: \(String(describing: errorMessage)), fileFormat: \(String(describing: fileFormat)), id: \(String(describing: id)), indexId: \(String(describing: indexId)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), s3Path: \(String(describing: s3Path)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

extension DescribeFaqOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFaqOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.description = output.description
            self.errorMessage = output.errorMessage
            self.fileFormat = output.fileFormat
            self.id = output.id
            self.indexId = output.indexId
            self.name = output.name
            self.roleArn = output.roleArn
            self.s3Path = output.s3Path
            self.status = output.status
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.errorMessage = nil
            self.fileFormat = nil
            self.id = nil
            self.indexId = nil
            self.name = nil
            self.roleArn = nil
            self.s3Path = nil
            self.status = nil
            self.updatedAt = nil
        }
    }
}

public struct DescribeFaqOutputResponse: Equatable {
    /// <p>The date and time that the FAQ was created.</p>
    public let createdAt: Date?
    /// <p>The description of the FAQ that you provided when it was created.</p>
    public let description: String?
    /// <p>If the <code>Status</code> field is <code>FAILED</code>, the <code>ErrorMessage</code>
    ///             field contains the reason why the FAQ failed.</p>
    public let errorMessage: String?
    /// <p>The file format used by the input files for the FAQ.</p>
    public let fileFormat: FaqFileFormat?
    /// <p>The identifier of the FAQ.</p>
    public let id: String?
    /// <p>The identifier of the index that contains the FAQ.</p>
    public let indexId: String?
    /// <p>The name that you gave the FAQ when it was created.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the role that provides access to the S3 bucket
    ///             containing the input files for the FAQ.</p>
    public let roleArn: String?
    /// <p>Information required to find a specific file in an Amazon S3
    ///             bucket.</p>
    public let s3Path: S3Path?
    /// <p>The status of the FAQ. It is ready to use when the status is
    ///             <code>ACTIVE</code>.</p>
    public let status: FaqStatus?
    /// <p>The date and time that the FAQ was last updated.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        description: String? = nil,
        errorMessage: String? = nil,
        fileFormat: FaqFileFormat? = nil,
        id: String? = nil,
        indexId: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        s3Path: S3Path? = nil,
        status: FaqStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.errorMessage = errorMessage
        self.fileFormat = fileFormat
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.s3Path = s3Path
        self.status = status
        self.updatedAt = updatedAt
    }
}

struct DescribeFaqOutputResponseBody: Equatable {
    public let id: String?
    public let indexId: String?
    public let name: String?
    public let description: String?
    public let createdAt: Date?
    public let updatedAt: Date?
    public let s3Path: S3Path?
    public let status: FaqStatus?
    public let roleArn: String?
    public let errorMessage: String?
    public let fileFormat: FaqFileFormat?
}

extension DescribeFaqOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case errorMessage = "ErrorMessage"
        case fileFormat = "FileFormat"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case s3Path = "S3Path"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(S3Path.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FaqStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(FaqFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
    }
}

public struct DescribeIndexInputBodyMiddleware: Middleware {
    public let id: String = "DescribeIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIndexInput>
    public typealias MOutput = OperationOutput<DescribeIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIndexOutputError>
}

extension DescribeIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIndexInput(id: \(String(describing: id)))"}
}

extension DescribeIndexInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribeIndexInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIndexInput>
    public typealias MOutput = OperationOutput<DescribeIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIndexOutputError>
}

public struct DescribeIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIndexInput>
    public typealias MOutput = OperationOutput<DescribeIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIndexOutputError>
}

public struct DescribeIndexInput: Equatable {
    /// <p>The name of the index to describe.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeIndexInputBody: Equatable {
    public let id: String?
}

extension DescribeIndexInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIndexOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIndexOutputResponse(capacityUnits: \(String(describing: capacityUnits)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), documentMetadataConfigurations: \(String(describing: documentMetadataConfigurations)), edition: \(String(describing: edition)), errorMessage: \(String(describing: errorMessage)), id: \(String(describing: id)), indexStatistics: \(String(describing: indexStatistics)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), serverSideEncryptionConfiguration: \(String(describing: serverSideEncryptionConfiguration)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)), userContextPolicy: \(String(describing: userContextPolicy)), userTokenConfigurations: \(String(describing: userTokenConfigurations)))"}
}

extension DescribeIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIndexOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.capacityUnits = output.capacityUnits
            self.createdAt = output.createdAt
            self.description = output.description
            self.documentMetadataConfigurations = output.documentMetadataConfigurations
            self.edition = output.edition
            self.errorMessage = output.errorMessage
            self.id = output.id
            self.indexStatistics = output.indexStatistics
            self.name = output.name
            self.roleArn = output.roleArn
            self.serverSideEncryptionConfiguration = output.serverSideEncryptionConfiguration
            self.status = output.status
            self.updatedAt = output.updatedAt
            self.userContextPolicy = output.userContextPolicy
            self.userTokenConfigurations = output.userTokenConfigurations
        } else {
            self.capacityUnits = nil
            self.createdAt = nil
            self.description = nil
            self.documentMetadataConfigurations = nil
            self.edition = nil
            self.errorMessage = nil
            self.id = nil
            self.indexStatistics = nil
            self.name = nil
            self.roleArn = nil
            self.serverSideEncryptionConfiguration = nil
            self.status = nil
            self.updatedAt = nil
            self.userContextPolicy = nil
            self.userTokenConfigurations = nil
        }
    }
}

public struct DescribeIndexOutputResponse: Equatable {
    /// <p>For Enterprise edition indexes, you can choose to use additional
    ///       capacity to meet the needs of your application. This contains the capacity
    ///       units used for the index. A 0 for the query capacity or the storage
    ///       capacity indicates that the index is using the default capacity for the
    ///       index.</p>
    public let capacityUnits: CapacityUnitsConfiguration?
    /// <p>The Unix datetime that the index was created.</p>
    public let createdAt: Date?
    /// <p>The description of the index.</p>
    public let description: String?
    /// <p>Configuration settings for any metadata applied to the documents in
    ///       the index.</p>
    public let documentMetadataConfigurations: [DocumentMetadataConfiguration]?
    /// <p>The Amazon Kendra edition used for the index. You decide the edition
    ///       when you create the index.</p>
    public let edition: IndexEdition?
    /// <p>When th e<code>Status</code> field value is <code>FAILED</code>, the
    ///         <code>ErrorMessage</code> field contains a message that explains
    ///       why.</p>
    public let errorMessage: String?
    /// <p>The name of the index.</p>
    public let id: String?
    /// <p>Provides information about the number of FAQ questions and answers and
    ///       the number of text documents indexed.</p>
    public let indexStatistics: IndexStatistics?
    /// <p>The name of the index.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that gives Amazon Kendra
    ///       permission to write to your Amazon Cloudwatch logs.</p>
    public let roleArn: String?
    /// <p>The identifier of the AWS KMS customer master key (CMK) used to
    ///       encrypt your data. Amazon Kendra doesn't support asymmetric CMKs.</p>
    public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
    /// <p>The current status of the index. When the value is
    ///       <code>ACTIVE</code>, the index is ready for use. If the
    ///         <code>Status</code> field value is <code>FAILED</code>, the
    ///         <code>ErrorMessage</code> field contains a message that explains
    ///       why.</p>
    public let status: IndexStatus?
    /// <p>The Unix datetime that the index was last updated.</p>
    public let updatedAt: Date?
    /// <p>The user context policy for the Amazon Kendra index.</p>
    public let userContextPolicy: UserContextPolicy?
    /// <p>The user token configuration for the Amazon Kendra index.</p>
    public let userTokenConfigurations: [UserTokenConfiguration]?

    public init (
        capacityUnits: CapacityUnitsConfiguration? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        documentMetadataConfigurations: [DocumentMetadataConfiguration]? = nil,
        edition: IndexEdition? = nil,
        errorMessage: String? = nil,
        id: String? = nil,
        indexStatistics: IndexStatistics? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil,
        status: IndexStatus? = nil,
        updatedAt: Date? = nil,
        userContextPolicy: UserContextPolicy? = nil,
        userTokenConfigurations: [UserTokenConfiguration]? = nil
    )
    {
        self.capacityUnits = capacityUnits
        self.createdAt = createdAt
        self.description = description
        self.documentMetadataConfigurations = documentMetadataConfigurations
        self.edition = edition
        self.errorMessage = errorMessage
        self.id = id
        self.indexStatistics = indexStatistics
        self.name = name
        self.roleArn = roleArn
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.status = status
        self.updatedAt = updatedAt
        self.userContextPolicy = userContextPolicy
        self.userTokenConfigurations = userTokenConfigurations
    }
}

struct DescribeIndexOutputResponseBody: Equatable {
    public let name: String?
    public let id: String?
    public let edition: IndexEdition?
    public let roleArn: String?
    public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
    public let status: IndexStatus?
    public let description: String?
    public let createdAt: Date?
    public let updatedAt: Date?
    public let documentMetadataConfigurations: [DocumentMetadataConfiguration]?
    public let indexStatistics: IndexStatistics?
    public let errorMessage: String?
    public let capacityUnits: CapacityUnitsConfiguration?
    public let userTokenConfigurations: [UserTokenConfiguration]?
    public let userContextPolicy: UserContextPolicy?
}

extension DescribeIndexOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capacityUnits = "CapacityUnits"
        case createdAt = "CreatedAt"
        case description = "Description"
        case documentMetadataConfigurations = "DocumentMetadataConfigurations"
        case edition = "Edition"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case indexStatistics = "IndexStatistics"
        case name = "Name"
        case roleArn = "RoleArn"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case status = "Status"
        case updatedAt = "UpdatedAt"
        case userContextPolicy = "UserContextPolicy"
        case userTokenConfigurations = "UserTokenConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let editionDecoded = try containerValues.decodeIfPresent(IndexEdition.self, forKey: .edition)
        edition = editionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IndexStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let documentMetadataConfigurationsContainer = try containerValues.decodeIfPresent([DocumentMetadataConfiguration?].self, forKey: .documentMetadataConfigurations)
        var documentMetadataConfigurationsDecoded0:[DocumentMetadataConfiguration]? = nil
        if let documentMetadataConfigurationsContainer = documentMetadataConfigurationsContainer {
            documentMetadataConfigurationsDecoded0 = [DocumentMetadataConfiguration]()
            for structure0 in documentMetadataConfigurationsContainer {
                if let structure0 = structure0 {
                    documentMetadataConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        documentMetadataConfigurations = documentMetadataConfigurationsDecoded0
        let indexStatisticsDecoded = try containerValues.decodeIfPresent(IndexStatistics.self, forKey: .indexStatistics)
        indexStatistics = indexStatisticsDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let capacityUnitsDecoded = try containerValues.decodeIfPresent(CapacityUnitsConfiguration.self, forKey: .capacityUnits)
        capacityUnits = capacityUnitsDecoded
        let userTokenConfigurationsContainer = try containerValues.decodeIfPresent([UserTokenConfiguration?].self, forKey: .userTokenConfigurations)
        var userTokenConfigurationsDecoded0:[UserTokenConfiguration]? = nil
        if let userTokenConfigurationsContainer = userTokenConfigurationsContainer {
            userTokenConfigurationsDecoded0 = [UserTokenConfiguration]()
            for structure0 in userTokenConfigurationsContainer {
                if let structure0 = structure0 {
                    userTokenConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        userTokenConfigurations = userTokenConfigurationsDecoded0
        let userContextPolicyDecoded = try containerValues.decodeIfPresent(UserContextPolicy.self, forKey: .userContextPolicy)
        userContextPolicy = userContextPolicyDecoded
    }
}

public struct DescribeQuerySuggestionsBlockListInputBodyMiddleware: Middleware {
    public let id: String = "DescribeQuerySuggestionsBlockListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeQuerySuggestionsBlockListOutputError>
}

extension DescribeQuerySuggestionsBlockListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeQuerySuggestionsBlockListInput(id: \(String(describing: id)), indexId: \(String(describing: indexId)))"}
}

extension DescribeQuerySuggestionsBlockListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DescribeQuerySuggestionsBlockListInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeQuerySuggestionsBlockListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeQuerySuggestionsBlockListOutputError>
}

public struct DescribeQuerySuggestionsBlockListInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeQuerySuggestionsBlockListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<DescribeQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeQuerySuggestionsBlockListOutputError>
}

public struct DescribeQuerySuggestionsBlockListInput: Equatable {
    /// <p>The unique identifier of the block list.</p>
    public let id: String?
    /// <p>The identifier of the index for the block list.</p>
    public let indexId: String?

    public init (
        id: String? = nil,
        indexId: String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DescribeQuerySuggestionsBlockListInputBody: Equatable {
    public let indexId: String?
    public let id: String?
}

extension DescribeQuerySuggestionsBlockListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeQuerySuggestionsBlockListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeQuerySuggestionsBlockListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeQuerySuggestionsBlockListOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeQuerySuggestionsBlockListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeQuerySuggestionsBlockListOutputResponse(createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), errorMessage: \(String(describing: errorMessage)), fileSizeBytes: \(String(describing: fileSizeBytes)), id: \(String(describing: id)), indexId: \(String(describing: indexId)), itemCount: \(String(describing: itemCount)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), sourceS3Path: \(String(describing: sourceS3Path)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

extension DescribeQuerySuggestionsBlockListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeQuerySuggestionsBlockListOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.description = output.description
            self.errorMessage = output.errorMessage
            self.fileSizeBytes = output.fileSizeBytes
            self.id = output.id
            self.indexId = output.indexId
            self.itemCount = output.itemCount
            self.name = output.name
            self.roleArn = output.roleArn
            self.sourceS3Path = output.sourceS3Path
            self.status = output.status
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.errorMessage = nil
            self.fileSizeBytes = nil
            self.id = nil
            self.indexId = nil
            self.itemCount = nil
            self.name = nil
            self.roleArn = nil
            self.sourceS3Path = nil
            self.status = nil
            self.updatedAt = nil
        }
    }
}

public struct DescribeQuerySuggestionsBlockListOutputResponse: Equatable {
    /// <p>Shows the date-time a block list for query suggestions was last created.</p>
    public let createdAt: Date?
    /// <p>Shows the description for the block list.</p>
    public let description: String?
    /// <p>Shows the error message with details when there are issues in
    ///             processing the block list.</p>
    public let errorMessage: String?
    /// <p>Shows the current size of the block list text file in S3.</p>
    public let fileSizeBytes: Int?
    /// <p>Shows the unique identifier of the block list.</p>
    public let id: String?
    /// <p>Shows the identifier of the index for the block list.</p>
    public let indexId: String?
    /// <p>Shows the current number of valid, non-empty words or phrases in
    ///             the block list text file.</p>
    public let itemCount: Int?
    /// <p>Shows the name of the block list.</p>
    public let name: String?
    /// <p>Shows the current IAM (Identity and Access Management) role used by
    ///             Amazon Kendra to access the block list text file in S3.</p>
    ///         <p>The role needs S3 read permissions to your file in S3 and needs to
    ///             give STS (Security Token Service) assume role permissions to
    ///             Amazon Kendra.</p>
    public let roleArn: String?
    /// <p>Shows the current S3 path to your block list text file in your S3 bucket.</p>
    ///         <p>Each block word or phrase should be on a separate line in a text file.</p>
    ///         <p>For information on the current quota limits for block lists, see
    ///             <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
    ///                 for Amazon Kendra</a>.</p>
    public let sourceS3Path: S3Path?
    /// <p>Shows whether the current status of the block list is
    ///             <code>ACTIVE</code> or <code>INACTIVE</code>.</p>
    public let status: QuerySuggestionsBlockListStatus?
    /// <p>Shows the date-time a block list for query suggestions was last updated.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        description: String? = nil,
        errorMessage: String? = nil,
        fileSizeBytes: Int? = nil,
        id: String? = nil,
        indexId: String? = nil,
        itemCount: Int? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        sourceS3Path: S3Path? = nil,
        status: QuerySuggestionsBlockListStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.errorMessage = errorMessage
        self.fileSizeBytes = fileSizeBytes
        self.id = id
        self.indexId = indexId
        self.itemCount = itemCount
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
        self.status = status
        self.updatedAt = updatedAt
    }
}

struct DescribeQuerySuggestionsBlockListOutputResponseBody: Equatable {
    public let indexId: String?
    public let id: String?
    public let name: String?
    public let description: String?
    public let status: QuerySuggestionsBlockListStatus?
    public let errorMessage: String?
    public let createdAt: Date?
    public let updatedAt: Date?
    public let sourceS3Path: S3Path?
    public let itemCount: Int?
    public let fileSizeBytes: Int?
    public let roleArn: String?
}

extension DescribeQuerySuggestionsBlockListOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case errorMessage = "ErrorMessage"
        case fileSizeBytes = "FileSizeBytes"
        case id = "Id"
        case indexId = "IndexId"
        case itemCount = "ItemCount"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuerySuggestionsBlockListStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let fileSizeBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fileSizeBytes)
        fileSizeBytes = fileSizeBytesDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

public struct DescribeQuerySuggestionsConfigInputBodyMiddleware: Middleware {
    public let id: String = "DescribeQuerySuggestionsConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeQuerySuggestionsConfigInput>
    public typealias MOutput = OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeQuerySuggestionsConfigOutputError>
}

extension DescribeQuerySuggestionsConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeQuerySuggestionsConfigInput(indexId: \(String(describing: indexId)))"}
}

extension DescribeQuerySuggestionsConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DescribeQuerySuggestionsConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeQuerySuggestionsConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeQuerySuggestionsConfigInput>
    public typealias MOutput = OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeQuerySuggestionsConfigOutputError>
}

public struct DescribeQuerySuggestionsConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeQuerySuggestionsConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeQuerySuggestionsConfigInput>
    public typealias MOutput = OperationOutput<DescribeQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeQuerySuggestionsConfigOutputError>
}

public struct DescribeQuerySuggestionsConfigInput: Equatable {
    /// <p>The identifier of the index you want to describe query suggestions
    ///             settings for.</p>
    public let indexId: String?

    public init (
        indexId: String? = nil
    )
    {
        self.indexId = indexId
    }
}

struct DescribeQuerySuggestionsConfigInputBody: Equatable {
    public let indexId: String?
}

extension DescribeQuerySuggestionsConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DescribeQuerySuggestionsConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeQuerySuggestionsConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeQuerySuggestionsConfigOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeQuerySuggestionsConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeQuerySuggestionsConfigOutputResponse(includeQueriesWithoutUserInformation: \(String(describing: includeQueriesWithoutUserInformation)), lastClearTime: \(String(describing: lastClearTime)), lastSuggestionsBuildTime: \(String(describing: lastSuggestionsBuildTime)), minimumNumberOfQueryingUsers: \(String(describing: minimumNumberOfQueryingUsers)), minimumQueryCount: \(String(describing: minimumQueryCount)), mode: \(String(describing: mode)), queryLogLookBackWindowInDays: \(String(describing: queryLogLookBackWindowInDays)), status: \(String(describing: status)), totalSuggestionsCount: \(String(describing: totalSuggestionsCount)))"}
}

extension DescribeQuerySuggestionsConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeQuerySuggestionsConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.includeQueriesWithoutUserInformation = output.includeQueriesWithoutUserInformation
            self.lastClearTime = output.lastClearTime
            self.lastSuggestionsBuildTime = output.lastSuggestionsBuildTime
            self.minimumNumberOfQueryingUsers = output.minimumNumberOfQueryingUsers
            self.minimumQueryCount = output.minimumQueryCount
            self.mode = output.mode
            self.queryLogLookBackWindowInDays = output.queryLogLookBackWindowInDays
            self.status = output.status
            self.totalSuggestionsCount = output.totalSuggestionsCount
        } else {
            self.includeQueriesWithoutUserInformation = nil
            self.lastClearTime = nil
            self.lastSuggestionsBuildTime = nil
            self.minimumNumberOfQueryingUsers = nil
            self.minimumQueryCount = nil
            self.mode = nil
            self.queryLogLookBackWindowInDays = nil
            self.status = nil
            self.totalSuggestionsCount = nil
        }
    }
}

public struct DescribeQuerySuggestionsConfigOutputResponse: Equatable {
    /// <p>Shows whether Amazon Kendra uses all queries or only uses queries that
    ///             include user information to generate query suggestions.</p>
    public let includeQueriesWithoutUserInformation: Bool?
    /// <p>Shows the date-time query suggestions for an index was last cleared.</p>
    ///         <p>After you clear suggestions, Amazon Kendra learns new suggestions based
    ///             on new queries added to the query log from the time you cleared suggestions.
    ///             Amazon Kendra only considers re-occurences of a query from the time you cleared
    ///             suggestions. </p>
    public let lastClearTime: Date?
    /// <p>Shows the date-time query suggestions for an index was last updated.</p>
    public let lastSuggestionsBuildTime: Date?
    /// <p>Shows the minimum number of unique users who must search a query in
    ///             order for the query to be eligible to suggest to your users.</p>
    public let minimumNumberOfQueryingUsers: Int?
    /// <p>Shows the minimum number of times a query must be searched in order for
    ///             the query to be eligible to suggest to your users.</p>
    public let minimumQueryCount: Int?
    /// <p>Shows whether query suggestions are currently in
    ///             <code>ENABLED</code> mode or <code>LEARN_ONLY</code> mode.</p>
    ///         <p>By default, Amazon Kendra enables query suggestions.<code>LEARN_ONLY</code>
    ///             turns off query suggestions for your users. You can change the mode using
    ///             the <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_UpdateQuerySuggestionsConfig.html">UpdateQuerySuggestionsConfig</a>
    ///             operation.</p>
    public let mode: Mode?
    /// <p>Shows how recent your queries are in your query log time
    ///             window (in days).</p>
    public let queryLogLookBackWindowInDays: Int?
    /// <p>Shows whether the status of query suggestions settings is currently
    ///             Active or Updating.</p>
    ///         <p>Active means the current settings apply and Updating means your
    ///             changed settings are in the process of applying.</p>
    public let status: QuerySuggestionsStatus?
    /// <p>Shows the current total count of query suggestions for an index.</p>
    ///         <p>This count can change when you update your query suggestions settings,
    ///             if you filter out certain queries from suggestions using a block list,
    ///             and as the query log accumulates more queries for Amazon Kendra to learn from.</p>
    public let totalSuggestionsCount: Int?

    public init (
        includeQueriesWithoutUserInformation: Bool? = nil,
        lastClearTime: Date? = nil,
        lastSuggestionsBuildTime: Date? = nil,
        minimumNumberOfQueryingUsers: Int? = nil,
        minimumQueryCount: Int? = nil,
        mode: Mode? = nil,
        queryLogLookBackWindowInDays: Int? = nil,
        status: QuerySuggestionsStatus? = nil,
        totalSuggestionsCount: Int? = nil
    )
    {
        self.includeQueriesWithoutUserInformation = includeQueriesWithoutUserInformation
        self.lastClearTime = lastClearTime
        self.lastSuggestionsBuildTime = lastSuggestionsBuildTime
        self.minimumNumberOfQueryingUsers = minimumNumberOfQueryingUsers
        self.minimumQueryCount = minimumQueryCount
        self.mode = mode
        self.queryLogLookBackWindowInDays = queryLogLookBackWindowInDays
        self.status = status
        self.totalSuggestionsCount = totalSuggestionsCount
    }
}

struct DescribeQuerySuggestionsConfigOutputResponseBody: Equatable {
    public let mode: Mode?
    public let status: QuerySuggestionsStatus?
    public let queryLogLookBackWindowInDays: Int?
    public let includeQueriesWithoutUserInformation: Bool?
    public let minimumNumberOfQueryingUsers: Int?
    public let minimumQueryCount: Int?
    public let lastSuggestionsBuildTime: Date?
    public let lastClearTime: Date?
    public let totalSuggestionsCount: Int?
}

extension DescribeQuerySuggestionsConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includeQueriesWithoutUserInformation = "IncludeQueriesWithoutUserInformation"
        case lastClearTime = "LastClearTime"
        case lastSuggestionsBuildTime = "LastSuggestionsBuildTime"
        case minimumNumberOfQueryingUsers = "MinimumNumberOfQueryingUsers"
        case minimumQueryCount = "MinimumQueryCount"
        case mode = "Mode"
        case queryLogLookBackWindowInDays = "QueryLogLookBackWindowInDays"
        case status = "Status"
        case totalSuggestionsCount = "TotalSuggestionsCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(Mode.self, forKey: .mode)
        mode = modeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuerySuggestionsStatus.self, forKey: .status)
        status = statusDecoded
        let queryLogLookBackWindowInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queryLogLookBackWindowInDays)
        queryLogLookBackWindowInDays = queryLogLookBackWindowInDaysDecoded
        let includeQueriesWithoutUserInformationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeQueriesWithoutUserInformation)
        includeQueriesWithoutUserInformation = includeQueriesWithoutUserInformationDecoded
        let minimumNumberOfQueryingUsersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumNumberOfQueryingUsers)
        minimumNumberOfQueryingUsers = minimumNumberOfQueryingUsersDecoded
        let minimumQueryCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumQueryCount)
        minimumQueryCount = minimumQueryCountDecoded
        let lastSuggestionsBuildTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSuggestionsBuildTime)
        lastSuggestionsBuildTime = lastSuggestionsBuildTimeDecoded
        let lastClearTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastClearTime)
        lastClearTime = lastClearTimeDecoded
        let totalSuggestionsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalSuggestionsCount)
        totalSuggestionsCount = totalSuggestionsCountDecoded
    }
}

public struct DescribeThesaurusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeThesaurusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThesaurusInput>
    public typealias MOutput = OperationOutput<DescribeThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThesaurusOutputError>
}

extension DescribeThesaurusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThesaurusInput(id: \(String(describing: id)), indexId: \(String(describing: indexId)))"}
}

extension DescribeThesaurusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct DescribeThesaurusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeThesaurusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThesaurusInput>
    public typealias MOutput = OperationOutput<DescribeThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThesaurusOutputError>
}

public struct DescribeThesaurusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeThesaurusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThesaurusInput>
    public typealias MOutput = OperationOutput<DescribeThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThesaurusOutputError>
}

public struct DescribeThesaurusInput: Equatable {
    /// <p>The identifier of the thesaurus to describe.</p>
    public let id: String?
    /// <p>The identifier of the index associated with the thesaurus to describe.</p>
    public let indexId: String?

    public init (
        id: String? = nil,
        indexId: String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct DescribeThesaurusInputBody: Equatable {
    public let id: String?
    public let indexId: String?
}

extension DescribeThesaurusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension DescribeThesaurusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThesaurusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThesaurusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThesaurusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThesaurusOutputResponse(createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), errorMessage: \(String(describing: errorMessage)), fileSizeBytes: \(String(describing: fileSizeBytes)), id: \(String(describing: id)), indexId: \(String(describing: indexId)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), sourceS3Path: \(String(describing: sourceS3Path)), status: \(String(describing: status)), synonymRuleCount: \(String(describing: synonymRuleCount)), termCount: \(String(describing: termCount)), updatedAt: \(String(describing: updatedAt)))"}
}

extension DescribeThesaurusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeThesaurusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.description = output.description
            self.errorMessage = output.errorMessage
            self.fileSizeBytes = output.fileSizeBytes
            self.id = output.id
            self.indexId = output.indexId
            self.name = output.name
            self.roleArn = output.roleArn
            self.sourceS3Path = output.sourceS3Path
            self.status = output.status
            self.synonymRuleCount = output.synonymRuleCount
            self.termCount = output.termCount
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.errorMessage = nil
            self.fileSizeBytes = nil
            self.id = nil
            self.indexId = nil
            self.name = nil
            self.roleArn = nil
            self.sourceS3Path = nil
            self.status = nil
            self.synonymRuleCount = nil
            self.termCount = nil
            self.updatedAt = nil
        }
    }
}

public struct DescribeThesaurusOutputResponse: Equatable {
    /// <p>The Unix datetime that the thesaurus was created.</p>
    public let createdAt: Date?
    /// <p>The thesaurus description.</p>
    public let description: String?
    /// <p>When the <code>Status</code> field value is <code>FAILED</code>, the
    ///          <code>ErrorMessage</code> field provides more information.
    ///       </p>
    public let errorMessage: String?
    /// <p>The size of the thesaurus file in bytes.</p>
    public let fileSizeBytes: Int?
    /// <p>The identifier of the thesaurus.</p>
    public let id: String?
    /// <p>The identifier of the index associated with the thesaurus to describe.</p>
    public let indexId: String?
    /// <p>The thesaurus name.</p>
    public let name: String?
    /// <p>An AWS Identity and Access Management (IAM) role that gives Amazon Kendra permissions
    ///          to access thesaurus file specified in <code>SourceS3Path</code>.
    ///       </p>
    public let roleArn: String?
    /// <p>Information required to find a specific file in an Amazon S3
    ///             bucket.</p>
    public let sourceS3Path: S3Path?
    /// <p>The current status of the thesaurus. When the value is <code>ACTIVE</code>,
    ///          queries are able to use the thesaurus. If the <code>Status</code> field value
    ///          is <code>FAILED</code>, the <code>ErrorMessage</code> field provides
    ///          more information.
    ///       </p>
    ///          <p>If the status is <code>ACTIVE_BUT_UPDATE_FAILED</code>, it means
    ///       that Amazon Kendra could not ingest the new thesaurus file. The old
    ///       thesaurus file is still active.
    ///       </p>
    public let status: ThesaurusStatus?
    /// <p>The number of synonym rules in the thesaurus file.</p>
    public let synonymRuleCount: Int?
    /// <p>The number of unique terms in the thesaurus file. For example, the
    ///         synonyms <code>a,b,c</code> and <code>a=>d</code>, the term
    ///         count would be 4.
    ///       </p>
    public let termCount: Int?
    /// <p>The Unix datetime that the thesaurus was last updated.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        description: String? = nil,
        errorMessage: String? = nil,
        fileSizeBytes: Int? = nil,
        id: String? = nil,
        indexId: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        sourceS3Path: S3Path? = nil,
        status: ThesaurusStatus? = nil,
        synonymRuleCount: Int? = nil,
        termCount: Int? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.errorMessage = errorMessage
        self.fileSizeBytes = fileSizeBytes
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
        self.status = status
        self.synonymRuleCount = synonymRuleCount
        self.termCount = termCount
        self.updatedAt = updatedAt
    }
}

struct DescribeThesaurusOutputResponseBody: Equatable {
    public let id: String?
    public let indexId: String?
    public let name: String?
    public let description: String?
    public let status: ThesaurusStatus?
    public let errorMessage: String?
    public let createdAt: Date?
    public let updatedAt: Date?
    public let roleArn: String?
    public let sourceS3Path: S3Path?
    public let fileSizeBytes: Int?
    public let termCount: Int?
    public let synonymRuleCount: Int?
}

extension DescribeThesaurusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case errorMessage = "ErrorMessage"
        case fileSizeBytes = "FileSizeBytes"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
        case status = "Status"
        case synonymRuleCount = "SynonymRuleCount"
        case termCount = "TermCount"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ThesaurusStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
        let fileSizeBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fileSizeBytes)
        fileSizeBytes = fileSizeBytesDecoded
        let termCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .termCount)
        termCount = termCountDecoded
        let synonymRuleCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .synonymRuleCount)
        synonymRuleCount = synonymRuleCountDecoded
    }
}

extension Document: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlList = "AccessControlList"
        case attributes = "Attributes"
        case blob = "Blob"
        case contentType = "ContentType"
        case id = "Id"
        case s3Path = "S3Path"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = accessControlList {
            var accessControlListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessControlList)
            for principallist0 in accessControlList {
                try accessControlListContainer.encode(principallist0)
            }
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for documentattributelist0 in attributes {
                try attributesContainer.encode(documentattributelist0)
            }
        }
        if let blob = blob {
            try encodeContainer.encode(blob.base64EncodedString(), forKey: .blob)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let s3Path = s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let blobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .blob)
        blob = blobDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(S3Path.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let attributesContainer = try containerValues.decodeIfPresent([DocumentAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[DocumentAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [DocumentAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let accessControlListContainer = try containerValues.decodeIfPresent([Principal?].self, forKey: .accessControlList)
        var accessControlListDecoded0:[Principal]? = nil
        if let accessControlListContainer = accessControlListContainer {
            accessControlListDecoded0 = [Principal]()
            for structure0 in accessControlListContainer {
                if let structure0 = structure0 {
                    accessControlListDecoded0?.append(structure0)
                }
            }
        }
        accessControlList = accessControlListDecoded0
        let contentTypeDecoded = try containerValues.decodeIfPresent(ContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension Document: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Document(accessControlList: \(String(describing: accessControlList)), attributes: \(String(describing: attributes)), blob: \(String(describing: blob)), contentType: \(String(describing: contentType)), id: \(String(describing: id)), s3Path: \(String(describing: s3Path)), title: \(String(describing: title)))"}
}

/// <p>A document in an index.</p>
public struct Document: Equatable {
    /// <p>Information to use for user context filtering.</p>
    public let accessControlList: [Principal]?
    /// <p>Custom attributes to apply to the document. Use the custom
    ///             attributes to provide additional information for searching, to
    ///             provide facets for refining searches, and to provide additional
    ///             information in the query response.</p>
    public let attributes: [DocumentAttribute]?
    /// <p>The contents of the document. </p>
    ///         <p>Documents passed to the <code>Blob</code> parameter must be base64
    ///             encoded. Your code might not need to encode the document file bytes
    ///             if you're using an AWS SDK to call Amazon Kendra operations. If you are
    ///             calling the Amazon Kendra endpoint directly using REST, you must base64
    ///             encode the contents before sending.</p>
    public let blob: Data?
    /// <p>The file type of the document in the <code>Blob</code>
    ///             field.</p>
    public let contentType: ContentType?
    /// <p>A unique identifier of the document in the index.</p>
    public let id: String?
    /// <p>Information required to find a specific file in an Amazon S3
    ///             bucket.</p>
    public let s3Path: S3Path?
    /// <p>The title of the document.</p>
    public let title: String?

    public init (
        accessControlList: [Principal]? = nil,
        attributes: [DocumentAttribute]? = nil,
        blob: Data? = nil,
        contentType: ContentType? = nil,
        id: String? = nil,
        s3Path: S3Path? = nil,
        title: String? = nil
    )
    {
        self.accessControlList = accessControlList
        self.attributes = attributes
        self.blob = blob
        self.contentType = contentType
        self.id = id
        self.s3Path = s3Path
        self.title = title
    }
}

extension DocumentAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(DocumentAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension DocumentAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentAttribute(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A custom attribute value assigned to a document. </p>
public struct DocumentAttribute: Equatable {
    /// <p>The identifier for the attribute.</p>
    public let key: String?
    /// <p>The value of the attribute.</p>
    public let value: DocumentAttributeValue?

    public init (
        key: String? = nil,
        value: DocumentAttributeValue? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension DocumentAttributeValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dateValue = "DateValue"
        case longValue = "LongValue"
        case stringListValue = "StringListValue"
        case stringValue = "StringValue"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .dateValue(dateValue):
                if let dateValue = dateValue {
                    try container.encode(dateValue.timeIntervalSince1970, forKey: .dateValue)
                }
            case let .longValue(longValue):
                if let longValue = longValue {
                    try container.encode(longValue, forKey: .longValue)
                }
            case let .stringListValue(stringListValue):
                if let stringListValue = stringListValue {
                    var stringListValueContainer = container.nestedUnkeyedContainer(forKey: .stringListValue)
                    for documentattributestringlistvalue0 in stringListValue {
                        try stringListValueContainer.encode(documentattributestringlistvalue0)
                    }
                }
            case let .stringValue(stringValue):
                if let stringValue = stringValue {
                    try container.encode(stringValue, forKey: .stringValue)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringValueDecoded = try values.decodeIfPresent(String.self, forKey: .stringValue)
        if let stringValue = stringValueDecoded {
            self = .stringValue(stringValue)
            return
        }
        let stringListValueContainer = try values.decodeIfPresent([String?].self, forKey: .stringListValue)
        var stringListValueDecoded0:[String]? = nil
        if let stringListValueContainer = stringListValueContainer {
            stringListValueDecoded0 = [String]()
            for string0 in stringListValueContainer {
                if let string0 = string0 {
                    stringListValueDecoded0?.append(string0)
                }
            }
        }
        if let stringListValue = stringListValueDecoded0 {
            self = .stringListValue(stringListValue)
            return
        }
        let longValueDecoded = try values.decodeIfPresent(Int.self, forKey: .longValue)
        if let longValue = longValueDecoded {
            self = .longValue(longValue)
            return
        }
        let dateValueDecoded = try values.decodeIfPresent(Date.self, forKey: .dateValue)
        if let dateValue = dateValueDecoded {
            self = .dateValue(dateValue)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The value of a custom document attribute. You can only provide one
///             value for a custom attribute.</p>
public enum DocumentAttributeValue: Equatable {
    /// <p>A string, such as "department".</p>
    case stringValue(String?)
    /// <p>A list of strings. </p>
    case stringListValue([String]?)
    /// <p>A long integer value.</p>
    case longValue(Int?)
    /// <p>A date expressed as an ISO 8601 string.</p>
    case dateValue(Date?)
    case sdkUnknown(String?)
}

extension DocumentAttributeValueCountPair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case documentAttributeValue = "DocumentAttributeValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let documentAttributeValue = documentAttributeValue {
            try encodeContainer.encode(documentAttributeValue, forKey: .documentAttributeValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentAttributeValueDecoded = try containerValues.decodeIfPresent(DocumentAttributeValue.self, forKey: .documentAttributeValue)
        documentAttributeValue = documentAttributeValueDecoded
        let countDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .count)
        count = countDecoded
    }
}

extension DocumentAttributeValueCountPair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentAttributeValueCountPair(count: \(String(describing: count)), documentAttributeValue: \(String(describing: documentAttributeValue)))"}
}

/// <p>Provides the count of documents that match a particular attribute
///             when doing a faceted search.</p>
public struct DocumentAttributeValueCountPair: Equatable {
    /// <p>The number of documents in the response that have the attribute
    ///             value for the key.</p>
    public let count: Int?
    /// <p>The value of the attribute. For example, "HR."</p>
    public let documentAttributeValue: DocumentAttributeValue?

    public init (
        count: Int? = nil,
        documentAttributeValue: DocumentAttributeValue? = nil
    )
    {
        self.count = count
        self.documentAttributeValue = documentAttributeValue
    }
}

public enum DocumentAttributeValueType {
    case dateValue
    case longValue
    case stringListValue
    case stringValue
    case sdkUnknown(String)
}

extension DocumentAttributeValueType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentAttributeValueType] {
        return [
            .dateValue,
            .longValue,
            .stringListValue,
            .stringValue,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dateValue: return "DATE_VALUE"
        case .longValue: return "LONG_VALUE"
        case .stringListValue: return "STRING_LIST_VALUE"
        case .stringValue: return "STRING_VALUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentAttributeValueType(rawValue: rawValue) ?? DocumentAttributeValueType.sdkUnknown(rawValue)
    }
}

extension DocumentMetadataConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case relevance = "Relevance"
        case search = "Search"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let relevance = relevance {
            try encodeContainer.encode(relevance, forKey: .relevance)
        }
        if let search = search {
            try encodeContainer.encode(search, forKey: .search)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DocumentAttributeValueType.self, forKey: .type)
        type = typeDecoded
        let relevanceDecoded = try containerValues.decodeIfPresent(Relevance.self, forKey: .relevance)
        relevance = relevanceDecoded
        let searchDecoded = try containerValues.decodeIfPresent(Search.self, forKey: .search)
        search = searchDecoded
    }
}

extension DocumentMetadataConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentMetadataConfiguration(name: \(String(describing: name)), relevance: \(String(describing: relevance)), search: \(String(describing: search)), type: \(String(describing: type)))"}
}

/// <p>Specifies the properties of a custom index field.</p>
public struct DocumentMetadataConfiguration: Equatable {
    /// <p>The name of the index field.</p>
    public let name: String?
    /// <p>Provides manual tuning parameters to determine how the field
    ///             affects the search results.</p>
    public let relevance: Relevance?
    /// <p>Provides information about how the field is used during a
    ///             search.</p>
    public let search: Search?
    /// <p>The data type of the index field. </p>
    public let type: DocumentAttributeValueType?

    public init (
        name: String? = nil,
        relevance: Relevance? = nil,
        search: Search? = nil,
        type: DocumentAttributeValueType? = nil
    )
    {
        self.name = name
        self.relevance = relevance
        self.search = search
        self.type = type
    }
}

extension DocumentRelevanceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case relevance = "Relevance"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let relevance = relevance {
            try encodeContainer.encode(relevance, forKey: .relevance)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let relevanceDecoded = try containerValues.decodeIfPresent(Relevance.self, forKey: .relevance)
        relevance = relevanceDecoded
    }
}

extension DocumentRelevanceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentRelevanceConfiguration(name: \(String(describing: name)), relevance: \(String(describing: relevance)))"}
}

/// <p>Overrides the document relevance properties of a custom index field.</p>
public struct DocumentRelevanceConfiguration: Equatable {
    /// <p>The name of the tuning configuration to override document relevance
    ///          at the index level.</p>
    public let name: String?
    /// <p>Provides information for manually tuning the relevance of a field
    ///             in a search. When a query includes terms that match the field, the
    ///             results are given a boost in the response based on these tuning
    ///             parameters.</p>
    public let relevance: Relevance?

    public init (
        name: String? = nil,
        relevance: Relevance? = nil
    )
    {
        self.name = name
        self.relevance = relevance
    }
}

extension DocumentsMetadataConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Prefix = "S3Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Prefix = s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension DocumentsMetadataConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentsMetadataConfiguration(s3Prefix: \(String(describing: s3Prefix)))"}
}

/// <p>Document metadata files that contain information such as the
///             document access control information, source URI, document author,
///             and custom attributes. Each metadata file contains metadata about a
///             single document.</p>
public struct DocumentsMetadataConfiguration: Equatable {
    /// <p>A prefix used to filter metadata configuration files in the AWS S3
    ///             bucket. The S3 bucket might contain multiple metadata files. Use
    ///                 <code>S3Prefix</code> to include only the desired metadata
    ///             files.</p>
    public let s3Prefix: String?

    public init (
        s3Prefix: String? = nil
    )
    {
        self.s3Prefix = s3Prefix
    }
}

public enum ErrorCode {
    case internalError
    case invalidRequest
    case sdkUnknown(String)
}

extension ErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ErrorCode] {
        return [
            .internalError,
            .invalidRequest,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalError: return "InternalError"
        case .invalidRequest: return "InvalidRequest"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
    }
}

extension Facet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentAttributeKey = "DocumentAttributeKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentAttributeKey = documentAttributeKey {
            try encodeContainer.encode(documentAttributeKey, forKey: .documentAttributeKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentAttributeKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentAttributeKey)
        documentAttributeKey = documentAttributeKeyDecoded
    }
}

extension Facet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Facet(documentAttributeKey: \(String(describing: documentAttributeKey)))"}
}

/// <p>Information about a document attribute</p>
public struct Facet: Equatable {
    /// <p>The unique key for the document attribute.</p>
    public let documentAttributeKey: String?

    public init (
        documentAttributeKey: String? = nil
    )
    {
        self.documentAttributeKey = documentAttributeKey
    }
}

extension FacetResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentAttributeKey = "DocumentAttributeKey"
        case documentAttributeValueCountPairs = "DocumentAttributeValueCountPairs"
        case documentAttributeValueType = "DocumentAttributeValueType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentAttributeKey = documentAttributeKey {
            try encodeContainer.encode(documentAttributeKey, forKey: .documentAttributeKey)
        }
        if let documentAttributeValueCountPairs = documentAttributeValueCountPairs {
            var documentAttributeValueCountPairsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentAttributeValueCountPairs)
            for documentattributevaluecountpairlist0 in documentAttributeValueCountPairs {
                try documentAttributeValueCountPairsContainer.encode(documentattributevaluecountpairlist0)
            }
        }
        if let documentAttributeValueType = documentAttributeValueType {
            try encodeContainer.encode(documentAttributeValueType.rawValue, forKey: .documentAttributeValueType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentAttributeKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentAttributeKey)
        documentAttributeKey = documentAttributeKeyDecoded
        let documentAttributeValueTypeDecoded = try containerValues.decodeIfPresent(DocumentAttributeValueType.self, forKey: .documentAttributeValueType)
        documentAttributeValueType = documentAttributeValueTypeDecoded
        let documentAttributeValueCountPairsContainer = try containerValues.decodeIfPresent([DocumentAttributeValueCountPair?].self, forKey: .documentAttributeValueCountPairs)
        var documentAttributeValueCountPairsDecoded0:[DocumentAttributeValueCountPair]? = nil
        if let documentAttributeValueCountPairsContainer = documentAttributeValueCountPairsContainer {
            documentAttributeValueCountPairsDecoded0 = [DocumentAttributeValueCountPair]()
            for structure0 in documentAttributeValueCountPairsContainer {
                if let structure0 = structure0 {
                    documentAttributeValueCountPairsDecoded0?.append(structure0)
                }
            }
        }
        documentAttributeValueCountPairs = documentAttributeValueCountPairsDecoded0
    }
}

extension FacetResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FacetResult(documentAttributeKey: \(String(describing: documentAttributeKey)), documentAttributeValueCountPairs: \(String(describing: documentAttributeValueCountPairs)), documentAttributeValueType: \(String(describing: documentAttributeValueType)))"}
}

/// <p>The facet values for the documents in the response.</p>
public struct FacetResult: Equatable {
    /// <p>The key for the facet values. This is the same as the
    ///             <code>DocumentAttributeKey</code> provided in the query.</p>
    public let documentAttributeKey: String?
    /// <p>An array of key/value pairs, where the key is the value of the
    ///          attribute and the count is the number of documents that share the key
    ///          value.</p>
    public let documentAttributeValueCountPairs: [DocumentAttributeValueCountPair]?
    /// <p>The data type of the facet value. This is the same as the type
    ///          defined for the index field when it was created.</p>
    public let documentAttributeValueType: DocumentAttributeValueType?

    public init (
        documentAttributeKey: String? = nil,
        documentAttributeValueCountPairs: [DocumentAttributeValueCountPair]? = nil,
        documentAttributeValueType: DocumentAttributeValueType? = nil
    )
    {
        self.documentAttributeKey = documentAttributeKey
        self.documentAttributeValueCountPairs = documentAttributeValueCountPairs
        self.documentAttributeValueType = documentAttributeValueType
    }
}

public enum FaqFileFormat {
    case csv
    case csvWithHeader
    case json
    case sdkUnknown(String)
}

extension FaqFileFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FaqFileFormat] {
        return [
            .csv,
            .csvWithHeader,
            .json,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .csvWithHeader: return "CSV_WITH_HEADER"
        case .json: return "JSON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FaqFileFormat(rawValue: rawValue) ?? FaqFileFormat.sdkUnknown(rawValue)
    }
}

extension FaqStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexedQuestionAnswersCount = "IndexedQuestionAnswersCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if indexedQuestionAnswersCount != 0 {
            try encodeContainer.encode(indexedQuestionAnswersCount, forKey: .indexedQuestionAnswersCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexedQuestionAnswersCountDecoded = try containerValues.decode(Int.self, forKey: .indexedQuestionAnswersCount)
        indexedQuestionAnswersCount = indexedQuestionAnswersCountDecoded
    }
}

extension FaqStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FaqStatistics(indexedQuestionAnswersCount: \(String(describing: indexedQuestionAnswersCount)))"}
}

/// <p>Provides statistical information about the FAQ questions and
///             answers contained in an index.</p>
public struct FaqStatistics: Equatable {
    /// <p>The total number of FAQ questions and answers contained in the
    ///             index.</p>
    public let indexedQuestionAnswersCount: Int

    public init (
        indexedQuestionAnswersCount: Int = 0
    )
    {
        self.indexedQuestionAnswersCount = indexedQuestionAnswersCount
    }
}

public enum FaqStatus {
    case active
    case creating
    case deleting
    case failed
    case updating
    case sdkUnknown(String)
}

extension FaqStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FaqStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FaqStatus(rawValue: rawValue) ?? FaqStatus.sdkUnknown(rawValue)
    }
}

extension FaqSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case fileFormat = "FileFormat"
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let fileFormat = fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FaqStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(FaqFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
    }
}

extension FaqSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FaqSummary(createdAt: \(String(describing: createdAt)), fileFormat: \(String(describing: fileFormat)), id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Provides information about a frequently asked questions and answer
///             contained in an index.</p>
public struct FaqSummary: Equatable {
    /// <p>The UNIX datetime that the FAQ was added to the index.</p>
    public let createdAt: Date?
    /// <p>The file type used to create the FAQ. </p>
    public let fileFormat: FaqFileFormat?
    /// <p>The unique identifier of the FAQ.</p>
    public let id: String?
    /// <p>The name that you assigned the FAQ when you created or updated the
    ///             FAQ.</p>
    public let name: String?
    /// <p>The current status of the FAQ. When the status is
    ///                 <code>ACTIVE</code> the FAQ is ready for use.</p>
    public let status: FaqStatus?
    /// <p>The UNIX datetime that the FAQ was last updated.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        fileFormat: FaqFileFormat? = nil,
        id: String? = nil,
        name: String? = nil,
        status: FaqStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.fileFormat = fileFormat
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct GetQuerySuggestionsInputBodyMiddleware: Middleware {
    public let id: String = "GetQuerySuggestionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQuerySuggestionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQuerySuggestionsInput>
    public typealias MOutput = OperationOutput<GetQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQuerySuggestionsOutputError>
}

extension GetQuerySuggestionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQuerySuggestionsInput(indexId: \(String(describing: indexId)), maxSuggestionsCount: \(String(describing: maxSuggestionsCount)), queryText: \(String(describing: queryText)))"}
}

extension GetQuerySuggestionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
        case maxSuggestionsCount = "MaxSuggestionsCount"
        case queryText = "QueryText"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxSuggestionsCount = maxSuggestionsCount {
            try encodeContainer.encode(maxSuggestionsCount, forKey: .maxSuggestionsCount)
        }
        if let queryText = queryText {
            try encodeContainer.encode(queryText, forKey: .queryText)
        }
    }
}

public struct GetQuerySuggestionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetQuerySuggestionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQuerySuggestionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQuerySuggestionsInput>
    public typealias MOutput = OperationOutput<GetQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQuerySuggestionsOutputError>
}

public struct GetQuerySuggestionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetQuerySuggestionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQuerySuggestionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQuerySuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQuerySuggestionsInput>
    public typealias MOutput = OperationOutput<GetQuerySuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQuerySuggestionsOutputError>
}

public struct GetQuerySuggestionsInput: Equatable {
    /// <p>The identifier of the index you want to get query suggestions from.</p>
    public let indexId: String?
    /// <p>The maximum number of query suggestions you want to show
    ///             to your users.</p>
    public let maxSuggestionsCount: Int?
    /// <p>The text of a user's query to generate query suggestions.</p>
    ///         <p>A query is suggested if the query prefix matches
    ///             what a user starts to type as their query.</p>
    ///         <p>Amazon Kendra does not show any suggestions if a user
    ///             types fewer than two characters or more than 60 characters.
    ///             A query must also have at least one search result and contain
    ///             at least one word of more than four characters.</p>
    public let queryText: String?

    public init (
        indexId: String? = nil,
        maxSuggestionsCount: Int? = nil,
        queryText: String? = nil
    )
    {
        self.indexId = indexId
        self.maxSuggestionsCount = maxSuggestionsCount
        self.queryText = queryText
    }
}

struct GetQuerySuggestionsInputBody: Equatable {
    public let indexId: String?
    public let queryText: String?
    public let maxSuggestionsCount: Int?
}

extension GetQuerySuggestionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
        case maxSuggestionsCount = "MaxSuggestionsCount"
        case queryText = "QueryText"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let queryTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryText)
        queryText = queryTextDecoded
        let maxSuggestionsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxSuggestionsCount)
        maxSuggestionsCount = maxSuggestionsCountDecoded
    }
}

extension GetQuerySuggestionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQuerySuggestionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQuerySuggestionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQuerySuggestionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQuerySuggestionsOutputResponse(querySuggestionsId: \(String(describing: querySuggestionsId)), suggestions: \(String(describing: suggestions)))"}
}

extension GetQuerySuggestionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetQuerySuggestionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.querySuggestionsId = output.querySuggestionsId
            self.suggestions = output.suggestions
        } else {
            self.querySuggestionsId = nil
            self.suggestions = nil
        }
    }
}

public struct GetQuerySuggestionsOutputResponse: Equatable {
    /// <p>The unique identifier for a list of query suggestions for an index.</p>
    public let querySuggestionsId: String?
    /// <p>A list of query suggestions for an index.</p>
    public let suggestions: [Suggestion]?

    public init (
        querySuggestionsId: String? = nil,
        suggestions: [Suggestion]? = nil
    )
    {
        self.querySuggestionsId = querySuggestionsId
        self.suggestions = suggestions
    }
}

struct GetQuerySuggestionsOutputResponseBody: Equatable {
    public let querySuggestionsId: String?
    public let suggestions: [Suggestion]?
}

extension GetQuerySuggestionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case querySuggestionsId = "QuerySuggestionsId"
        case suggestions = "Suggestions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let querySuggestionsIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .querySuggestionsId)
        querySuggestionsId = querySuggestionsIdDecoded
        let suggestionsContainer = try containerValues.decodeIfPresent([Suggestion?].self, forKey: .suggestions)
        var suggestionsDecoded0:[Suggestion]? = nil
        if let suggestionsContainer = suggestionsContainer {
            suggestionsDecoded0 = [Suggestion]()
            for structure0 in suggestionsContainer {
                if let structure0 = structure0 {
                    suggestionsDecoded0?.append(structure0)
                }
            }
        }
        suggestions = suggestionsDecoded0
    }
}

extension GoogleDriveConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludeMimeTypes = "ExcludeMimeTypes"
        case excludeSharedDrives = "ExcludeSharedDrives"
        case excludeUserAccounts = "ExcludeUserAccounts"
        case exclusionPatterns = "ExclusionPatterns"
        case fieldMappings = "FieldMappings"
        case inclusionPatterns = "InclusionPatterns"
        case secretArn = "SecretArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeMimeTypes = excludeMimeTypes {
            var excludeMimeTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeMimeTypes)
            for excludemimetypeslist0 in excludeMimeTypes {
                try excludeMimeTypesContainer.encode(excludemimetypeslist0)
            }
        }
        if let excludeSharedDrives = excludeSharedDrives {
            var excludeSharedDrivesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeSharedDrives)
            for excludeshareddriveslist0 in excludeSharedDrives {
                try excludeSharedDrivesContainer.encode(excludeshareddriveslist0)
            }
        }
        if let excludeUserAccounts = excludeUserAccounts {
            var excludeUserAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeUserAccounts)
            for excludeuseraccountslist0 in excludeUserAccounts {
                try excludeUserAccountsContainer.encode(excludeuseraccountslist0)
            }
        }
        if let exclusionPatterns = exclusionPatterns {
            var exclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in exclusionPatterns {
                try exclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let inclusionPatterns = inclusionPatterns {
            var inclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in inclusionPatterns {
                try inclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let inclusionPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .inclusionPatterns)
        var inclusionPatternsDecoded0:[String]? = nil
        if let inclusionPatternsContainer = inclusionPatternsContainer {
            inclusionPatternsDecoded0 = [String]()
            for string0 in inclusionPatternsContainer {
                if let string0 = string0 {
                    inclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        inclusionPatterns = inclusionPatternsDecoded0
        let exclusionPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exclusionPatterns)
        var exclusionPatternsDecoded0:[String]? = nil
        if let exclusionPatternsContainer = exclusionPatternsContainer {
            exclusionPatternsDecoded0 = [String]()
            for string0 in exclusionPatternsContainer {
                if let string0 = string0 {
                    exclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        exclusionPatterns = exclusionPatternsDecoded0
        let fieldMappingsContainer = try containerValues.decodeIfPresent([DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let excludeMimeTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludeMimeTypes)
        var excludeMimeTypesDecoded0:[String]? = nil
        if let excludeMimeTypesContainer = excludeMimeTypesContainer {
            excludeMimeTypesDecoded0 = [String]()
            for string0 in excludeMimeTypesContainer {
                if let string0 = string0 {
                    excludeMimeTypesDecoded0?.append(string0)
                }
            }
        }
        excludeMimeTypes = excludeMimeTypesDecoded0
        let excludeUserAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludeUserAccounts)
        var excludeUserAccountsDecoded0:[String]? = nil
        if let excludeUserAccountsContainer = excludeUserAccountsContainer {
            excludeUserAccountsDecoded0 = [String]()
            for string0 in excludeUserAccountsContainer {
                if let string0 = string0 {
                    excludeUserAccountsDecoded0?.append(string0)
                }
            }
        }
        excludeUserAccounts = excludeUserAccountsDecoded0
        let excludeSharedDrivesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludeSharedDrives)
        var excludeSharedDrivesDecoded0:[String]? = nil
        if let excludeSharedDrivesContainer = excludeSharedDrivesContainer {
            excludeSharedDrivesDecoded0 = [String]()
            for string0 in excludeSharedDrivesContainer {
                if let string0 = string0 {
                    excludeSharedDrivesDecoded0?.append(string0)
                }
            }
        }
        excludeSharedDrives = excludeSharedDrivesDecoded0
    }
}

extension GoogleDriveConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GoogleDriveConfiguration(excludeMimeTypes: \(String(describing: excludeMimeTypes)), excludeSharedDrives: \(String(describing: excludeSharedDrives)), excludeUserAccounts: \(String(describing: excludeUserAccounts)), exclusionPatterns: \(String(describing: exclusionPatterns)), fieldMappings: \(String(describing: fieldMappings)), inclusionPatterns: \(String(describing: inclusionPatterns)), secretArn: \(String(describing: secretArn)))"}
}

/// <p>Provides configuration information for data sources that connect
///             to Google Drive.</p>
public struct GoogleDriveConfiguration: Equatable {
    /// <p>A list of MIME types to exclude from the index. All documents
    ///             matching the specified MIME type are excluded. </p>
    ///         <p>For a list of MIME types, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data
    ///                 source</a>.</p>
    public let excludeMimeTypes: [String]?
    /// <p>A list of identifiers or shared drives to exclude from the index.
    ///             All files and folders stored on the shared drive are
    ///             excluded.</p>
    public let excludeSharedDrives: [String]?
    /// <p>A list of email addresses of the users. Documents owned by these
    ///             users are excluded from the index. Documents shared with excluded
    ///             users are indexed unless they are excluded in another way.</p>
    public let excludeUserAccounts: [String]?
    /// <p>A list of regular expression patterns that apply to the path on
    ///             Google Drive. Items that match the pattern are excluded from the
    ///             index from both shared drives and users' My Drives. Items that don't
    ///             match the pattern are included in the index. If an item matches both
    ///             an exclusion pattern and an inclusion pattern, it is excluded from
    ///             the index.</p>
    public let exclusionPatterns: [String]?
    /// <p>Defines mapping between a field in the Google Drive and a Amazon Kendra
    ///             index field.</p>
    ///         <p>If you are using the console, you can define index fields when
    ///             creating the mapping. If you are using the API, you must first
    ///             create the field using the <code>UpdateIndex</code>
    ///             operation.</p>
    public let fieldMappings: [DataSourceToIndexFieldMapping]?
    /// <p>A list of regular expression patterns that apply to path on Google
    ///             Drive. Items that match the pattern are included in the index from
    ///             both shared drives and users' My Drives. Items that don't match the
    ///             pattern are excluded from the index. If an item matches both an
    ///             inclusion pattern and an exclusion pattern, it is excluded from the
    ///             index.</p>
    public let inclusionPatterns: [String]?
    /// <p>The Amazon Resource Name (ARN) of a AWS Secrets Manager secret
    ///             that contains the credentials required to connect to Google Drive.
    ///             For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data
    ///                 source</a>.</p>
    public let secretArn: String?

    public init (
        excludeMimeTypes: [String]? = nil,
        excludeSharedDrives: [String]? = nil,
        excludeUserAccounts: [String]? = nil,
        exclusionPatterns: [String]? = nil,
        fieldMappings: [DataSourceToIndexFieldMapping]? = nil,
        inclusionPatterns: [String]? = nil,
        secretArn: String? = nil
    )
    {
        self.excludeMimeTypes = excludeMimeTypes
        self.excludeSharedDrives = excludeSharedDrives
        self.excludeUserAccounts = excludeUserAccounts
        self.exclusionPatterns = exclusionPatterns
        self.fieldMappings = fieldMappings
        self.inclusionPatterns = inclusionPatterns
        self.secretArn = secretArn
    }
}

extension Highlight: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
        case topAnswer = "TopAnswer"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if topAnswer != false {
            try encodeContainer.encode(topAnswer, forKey: .topAnswer)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let topAnswerDecoded = try containerValues.decode(Bool.self, forKey: .topAnswer)
        topAnswer = topAnswerDecoded
        let typeDecoded = try containerValues.decodeIfPresent(HighlightType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Highlight: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Highlight(beginOffset: \(String(describing: beginOffset)), endOffset: \(String(describing: endOffset)), topAnswer: \(String(describing: topAnswer)), type: \(String(describing: type)))"}
}

/// <p>Provides information that you can use to highlight a search result
///             so that your users can quickly identify terms in the
///             response.</p>
public struct Highlight: Equatable {
    /// <p>The zero-based location in the response string where the highlight
    ///             starts.</p>
    public let beginOffset: Int?
    /// <p>The zero-based location in the response string where the highlight
    ///             ends.</p>
    public let endOffset: Int?
    /// <p>Indicates whether the response is the best response. True if this
    ///             is the best response; otherwise, false.</p>
    public let topAnswer: Bool
    /// <p>The highlight type. </p>
    public let type: HighlightType?

    public init (
        beginOffset: Int? = nil,
        endOffset: Int? = nil,
        topAnswer: Bool = false,
        type: HighlightType? = nil
    )
    {
        self.beginOffset = beginOffset
        self.endOffset = endOffset
        self.topAnswer = topAnswer
        self.type = type
    }
}

public enum HighlightType {
    case standard
    case thesaurusSynonym
    case sdkUnknown(String)
}

extension HighlightType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HighlightType] {
        return [
            .standard,
            .thesaurusSynonym,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .standard: return "STANDARD"
        case .thesaurusSynonym: return "THESAURUS_SYNONYM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HighlightType(rawValue: rawValue) ?? HighlightType.sdkUnknown(rawValue)
    }
}

extension IndexConfigurationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case edition = "Edition"
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let edition = edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let editionDecoded = try containerValues.decodeIfPresent(IndexEdition.self, forKey: .edition)
        edition = editionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IndexStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IndexConfigurationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IndexConfigurationSummary(createdAt: \(String(describing: createdAt)), edition: \(String(describing: edition)), id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>A summary of information about an index.</p>
public struct IndexConfigurationSummary: Equatable {
    /// <p>The Unix timestamp when the index was created.</p>
    public let createdAt: Date?
    /// <p>Indicates whether the index is a enterprise edition index or a
    ///             developer edition index. </p>
    public let edition: IndexEdition?
    /// <p>A unique identifier for the index. Use this to identify the index
    ///             when you are using operations such as <code>Query</code>,
    ///                 <code>DescribeIndex</code>, <code>UpdateIndex</code>, and
    ///                 <code>DeleteIndex</code>.</p>
    public let id: String?
    /// <p>The name of the index.</p>
    public let name: String?
    /// <p>The current status of the index. When the status is
    ///                 <code>ACTIVE</code>, the index is ready to search.</p>
    public let status: IndexStatus?
    /// <p>The Unix timestamp when the index was last updated by the
    ///                 <code>UpdateIndex</code> operation.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        edition: IndexEdition? = nil,
        id: String? = nil,
        name: String? = nil,
        status: IndexStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.edition = edition
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

public enum IndexEdition {
    case developerEdition
    case enterpriseEdition
    case sdkUnknown(String)
}

extension IndexEdition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IndexEdition] {
        return [
            .developerEdition,
            .enterpriseEdition,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .developerEdition: return "DEVELOPER_EDITION"
        case .enterpriseEdition: return "ENTERPRISE_EDITION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IndexEdition(rawValue: rawValue) ?? IndexEdition.sdkUnknown(rawValue)
    }
}

extension IndexStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case faqStatistics = "FaqStatistics"
        case textDocumentStatistics = "TextDocumentStatistics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let faqStatistics = faqStatistics {
            try encodeContainer.encode(faqStatistics, forKey: .faqStatistics)
        }
        if let textDocumentStatistics = textDocumentStatistics {
            try encodeContainer.encode(textDocumentStatistics, forKey: .textDocumentStatistics)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let faqStatisticsDecoded = try containerValues.decodeIfPresent(FaqStatistics.self, forKey: .faqStatistics)
        faqStatistics = faqStatisticsDecoded
        let textDocumentStatisticsDecoded = try containerValues.decodeIfPresent(TextDocumentStatistics.self, forKey: .textDocumentStatistics)
        textDocumentStatistics = textDocumentStatisticsDecoded
    }
}

extension IndexStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IndexStatistics(faqStatistics: \(String(describing: faqStatistics)), textDocumentStatistics: \(String(describing: textDocumentStatistics)))"}
}

/// <p>Provides information about the number of documents and the number
///             of questions and answers in an index.</p>
public struct IndexStatistics: Equatable {
    /// <p>The number of question and answer topics in the index.</p>
    public let faqStatistics: FaqStatistics?
    /// <p>The number of text documents indexed.</p>
    public let textDocumentStatistics: TextDocumentStatistics?

    public init (
        faqStatistics: FaqStatistics? = nil,
        textDocumentStatistics: TextDocumentStatistics? = nil
    )
    {
        self.faqStatistics = faqStatistics
        self.textDocumentStatistics = textDocumentStatistics
    }
}

public enum IndexStatus {
    case active
    case creating
    case deleting
    case failed
    case systemUpdating
    case updating
    case sdkUnknown(String)
}

extension IndexStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IndexStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .systemUpdating,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .systemUpdating: return "SYSTEM_UPDATING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IndexStatus(rawValue: rawValue) ?? IndexStatus.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JsonTokenTypeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupAttributeField = "GroupAttributeField"
        case userNameAttributeField = "UserNameAttributeField"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupAttributeField = groupAttributeField {
            try encodeContainer.encode(groupAttributeField, forKey: .groupAttributeField)
        }
        if let userNameAttributeField = userNameAttributeField {
            try encodeContainer.encode(userNameAttributeField, forKey: .userNameAttributeField)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameAttributeFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userNameAttributeField)
        userNameAttributeField = userNameAttributeFieldDecoded
        let groupAttributeFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupAttributeField)
        groupAttributeField = groupAttributeFieldDecoded
    }
}

extension JsonTokenTypeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JsonTokenTypeConfiguration(groupAttributeField: \(String(describing: groupAttributeField)), userNameAttributeField: \(String(describing: userNameAttributeField)))"}
}

/// <p>Configuration information for the JSON token type.</p>
public struct JsonTokenTypeConfiguration: Equatable {
    /// <p>The group attribute field.</p>
    public let groupAttributeField: String?
    /// <p>The user name attribute field.</p>
    public let userNameAttributeField: String?

    public init (
        groupAttributeField: String? = nil,
        userNameAttributeField: String? = nil
    )
    {
        self.groupAttributeField = groupAttributeField
        self.userNameAttributeField = userNameAttributeField
    }
}

extension JwtTokenTypeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case claimRegex = "ClaimRegex"
        case groupAttributeField = "GroupAttributeField"
        case issuer = "Issuer"
        case keyLocation = "KeyLocation"
        case secretManagerArn = "SecretManagerArn"
        case uRL = "URL"
        case userNameAttributeField = "UserNameAttributeField"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let claimRegex = claimRegex {
            try encodeContainer.encode(claimRegex, forKey: .claimRegex)
        }
        if let groupAttributeField = groupAttributeField {
            try encodeContainer.encode(groupAttributeField, forKey: .groupAttributeField)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let keyLocation = keyLocation {
            try encodeContainer.encode(keyLocation.rawValue, forKey: .keyLocation)
        }
        if let secretManagerArn = secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
        if let uRL = uRL {
            try encodeContainer.encode(uRL, forKey: .uRL)
        }
        if let userNameAttributeField = userNameAttributeField {
            try encodeContainer.encode(userNameAttributeField, forKey: .userNameAttributeField)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyLocationDecoded = try containerValues.decodeIfPresent(KeyLocation.self, forKey: .keyLocation)
        keyLocation = keyLocationDecoded
        let uRLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uRL)
        uRL = uRLDecoded
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
        let userNameAttributeFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userNameAttributeField)
        userNameAttributeField = userNameAttributeFieldDecoded
        let groupAttributeFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupAttributeField)
        groupAttributeField = groupAttributeFieldDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuer)
        issuer = issuerDecoded
        let claimRegexDecoded = try containerValues.decodeIfPresent(String.self, forKey: .claimRegex)
        claimRegex = claimRegexDecoded
    }
}

extension JwtTokenTypeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JwtTokenTypeConfiguration(claimRegex: \(String(describing: claimRegex)), groupAttributeField: \(String(describing: groupAttributeField)), issuer: \(String(describing: issuer)), keyLocation: \(String(describing: keyLocation)), secretManagerArn: \(String(describing: secretManagerArn)), uRL: \(String(describing: uRL)), userNameAttributeField: \(String(describing: userNameAttributeField)))"}
}

/// <p>Configuration information for the JWT token type.</p>
public struct JwtTokenTypeConfiguration: Equatable {
    /// <p>The regular expression that identifies the claim.</p>
    public let claimRegex: String?
    /// <p>The group attribute field.</p>
    public let groupAttributeField: String?
    /// <p>The issuer of the token.</p>
    public let issuer: String?
    /// <p>The location of the key.</p>
    public let keyLocation: KeyLocation?
    /// <p>The Amazon Resource Name (arn) of the secret.</p>
    public let secretManagerArn: String?
    /// <p>The signing key URL.</p>
    public let uRL: String?
    /// <p>The user name attribute field.</p>
    public let userNameAttributeField: String?

    public init (
        claimRegex: String? = nil,
        groupAttributeField: String? = nil,
        issuer: String? = nil,
        keyLocation: KeyLocation? = nil,
        secretManagerArn: String? = nil,
        uRL: String? = nil,
        userNameAttributeField: String? = nil
    )
    {
        self.claimRegex = claimRegex
        self.groupAttributeField = groupAttributeField
        self.issuer = issuer
        self.keyLocation = keyLocation
        self.secretManagerArn = secretManagerArn
        self.uRL = uRL
        self.userNameAttributeField = userNameAttributeField
    }
}

public enum KeyLocation {
    case secretManager
    case url
    case sdkUnknown(String)
}

extension KeyLocation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KeyLocation] {
        return [
            .secretManager,
            .url,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .secretManager: return "SECRET_MANAGER"
        case .url: return "URL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KeyLocation(rawValue: rawValue) ?? KeyLocation.sdkUnknown(rawValue)
    }
}

public struct ListDataSourceSyncJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListDataSourceSyncJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSourceSyncJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSourceSyncJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSourceSyncJobsInput>
    public typealias MOutput = OperationOutput<ListDataSourceSyncJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSourceSyncJobsOutputError>
}

extension ListDataSourceSyncJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSourceSyncJobsInput(id: \(String(describing: id)), indexId: \(String(describing: indexId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), startTimeFilter: \(String(describing: startTimeFilter)), statusFilter: \(String(describing: statusFilter)))"}
}

extension ListDataSourceSyncJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeFilter = "StartTimeFilter"
        case statusFilter = "StatusFilter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeFilter = startTimeFilter {
            try encodeContainer.encode(startTimeFilter, forKey: .startTimeFilter)
        }
        if let statusFilter = statusFilter {
            try encodeContainer.encode(statusFilter.rawValue, forKey: .statusFilter)
        }
    }
}

public struct ListDataSourceSyncJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDataSourceSyncJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSourceSyncJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSourceSyncJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSourceSyncJobsInput>
    public typealias MOutput = OperationOutput<ListDataSourceSyncJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSourceSyncJobsOutputError>
}

public struct ListDataSourceSyncJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDataSourceSyncJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSourceSyncJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSourceSyncJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSourceSyncJobsInput>
    public typealias MOutput = OperationOutput<ListDataSourceSyncJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSourceSyncJobsOutputError>
}

public struct ListDataSourceSyncJobsInput: Equatable {
    /// <p>The identifier of the data source.</p>
    public let id: String?
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: String?
    /// <p>The maximum number of synchronization jobs to return in the response.
    ///       If there are fewer results in the list, this response contains only the
    ///       actual results.</p>
    public let maxResults: Int?
    /// <p>If the result of the previous request to
    ///         <code>GetDataSourceSyncJobHistory</code> was truncated, include the
    ///         <code>NextToken</code> to fetch the next set of jobs.</p>
    public let nextToken: String?
    /// <p>When specified, the synchronization jobs returned in the list are
    ///       limited to jobs between the specified dates. </p>
    public let startTimeFilter: TimeRange?
    /// <p>When specified, only returns synchronization jobs with the
    ///         <code>Status</code> field equal to the specified status.</p>
    public let statusFilter: DataSourceSyncJobStatus?

    public init (
        id: String? = nil,
        indexId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTimeFilter: TimeRange? = nil,
        statusFilter: DataSourceSyncJobStatus? = nil
    )
    {
        self.id = id
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeFilter = startTimeFilter
        self.statusFilter = statusFilter
    }
}

struct ListDataSourceSyncJobsInputBody: Equatable {
    public let id: String?
    public let indexId: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let startTimeFilter: TimeRange?
    public let statusFilter: DataSourceSyncJobStatus?
}

extension ListDataSourceSyncJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeFilter = "StartTimeFilter"
        case statusFilter = "StatusFilter"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let startTimeFilterDecoded = try containerValues.decodeIfPresent(TimeRange.self, forKey: .startTimeFilter)
        startTimeFilter = startTimeFilterDecoded
        let statusFilterDecoded = try containerValues.decodeIfPresent(DataSourceSyncJobStatus.self, forKey: .statusFilter)
        statusFilter = statusFilterDecoded
    }
}

extension ListDataSourceSyncJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSourceSyncJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSourceSyncJobsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSourceSyncJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSourceSyncJobsOutputResponse(history: \(String(describing: history)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataSourceSyncJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDataSourceSyncJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.history = output.history
            self.nextToken = output.nextToken
        } else {
            self.history = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourceSyncJobsOutputResponse: Equatable {
    /// <p>A history of synchronization jobs for the data source.</p>
    public let history: [DataSourceSyncJob]?
    /// <p>The <code>GetDataSourceSyncJobHistory</code> operation returns a page
    ///       of vocabularies at a time. The maximum size of the page is set by the
    ///         <code>MaxResults</code> parameter. If there are more jobs in the list
    ///       than the page size, Amazon Kendra returns the NextPage token. Include the
    ///       token in the next request to the <code>GetDataSourceSyncJobHistory</code>
    ///       operation to return in the next page of jobs.</p>
    public let nextToken: String?

    public init (
        history: [DataSourceSyncJob]? = nil,
        nextToken: String? = nil
    )
    {
        self.history = history
        self.nextToken = nextToken
    }
}

struct ListDataSourceSyncJobsOutputResponseBody: Equatable {
    public let history: [DataSourceSyncJob]?
    public let nextToken: String?
}

extension ListDataSourceSyncJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case history = "History"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let historyContainer = try containerValues.decodeIfPresent([DataSourceSyncJob?].self, forKey: .history)
        var historyDecoded0:[DataSourceSyncJob]? = nil
        if let historyContainer = historyContainer {
            historyDecoded0 = [DataSourceSyncJob]()
            for structure0 in historyContainer {
                if let structure0 = structure0 {
                    historyDecoded0?.append(structure0)
                }
            }
        }
        history = historyDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDataSourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListDataSourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSourcesOutputError>
}

extension ListDataSourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSourcesInput(indexId: \(String(describing: indexId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataSourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDataSourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDataSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSourcesOutputError>
}

public struct ListDataSourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDataSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSourcesOutputError>
}

public struct ListDataSourcesInput: Equatable {
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: String?
    /// <p>The maximum number of data sources to return.</p>
    public let maxResults: Int?
    /// <p>If the previous response was incomplete (because there is more data to
    ///       retrieve), Amazon Kendra returns a pagination token in the response. You
    ///       can use this pagination token to retrieve the next set of data sources
    ///         (<code>DataSourceSummaryItems</code>). </p>
    public let nextToken: String?

    public init (
        indexId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody: Equatable {
    public let indexId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDataSourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDataSourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSourcesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSourcesOutputResponse(nextToken: \(String(describing: nextToken)), summaryItems: \(String(describing: summaryItems)))"}
}

extension ListDataSourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDataSourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaryItems = output.summaryItems
        } else {
            self.nextToken = nil
            self.summaryItems = nil
        }
    }
}

public struct ListDataSourcesOutputResponse: Equatable {
    /// <p>If the response is truncated, Amazon Kendra returns this token that you
    ///       can use in the subsequent request to retrieve the next set of data
    ///       sources. </p>
    public let nextToken: String?
    /// <p>An array of summary information for one or more data sources.</p>
    public let summaryItems: [DataSourceSummary]?

    public init (
        nextToken: String? = nil,
        summaryItems: [DataSourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaryItems = summaryItems
    }
}

struct ListDataSourcesOutputResponseBody: Equatable {
    public let summaryItems: [DataSourceSummary]?
    public let nextToken: String?
}

extension ListDataSourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case summaryItems = "SummaryItems"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryItemsContainer = try containerValues.decodeIfPresent([DataSourceSummary?].self, forKey: .summaryItems)
        var summaryItemsDecoded0:[DataSourceSummary]? = nil
        if let summaryItemsContainer = summaryItemsContainer {
            summaryItemsDecoded0 = [DataSourceSummary]()
            for structure0 in summaryItemsContainer {
                if let structure0 = structure0 {
                    summaryItemsDecoded0?.append(structure0)
                }
            }
        }
        summaryItems = summaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFaqsInputBodyMiddleware: Middleware {
    public let id: String = "ListFaqsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFaqsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFaqsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFaqsInput>
    public typealias MOutput = OperationOutput<ListFaqsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFaqsOutputError>
}

extension ListFaqsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFaqsInput(indexId: \(String(describing: indexId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFaqsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFaqsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFaqsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFaqsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFaqsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFaqsInput>
    public typealias MOutput = OperationOutput<ListFaqsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFaqsOutputError>
}

public struct ListFaqsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFaqsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFaqsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFaqsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFaqsInput>
    public typealias MOutput = OperationOutput<ListFaqsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFaqsOutputError>
}

public struct ListFaqsInput: Equatable {
    /// <p>The index that contains the FAQ lists.</p>
    public let indexId: String?
    /// <p>The maximum number of FAQs to return in the response. If there are fewer results in
    ///             the list, this response contains only the actual results.</p>
    public let maxResults: Int?
    /// <p>If the result of the previous request to <code>ListFaqs</code> was truncated, include
    ///             the <code>NextToken</code> to fetch the next set of FAQs.</p>
    public let nextToken: String?

    public init (
        indexId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFaqsInputBody: Equatable {
    public let indexId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListFaqsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFaqsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFaqsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFaqsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFaqsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFaqsOutputResponse(faqSummaryItems: \(String(describing: faqSummaryItems)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFaqsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFaqsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.faqSummaryItems = output.faqSummaryItems
            self.nextToken = output.nextToken
        } else {
            self.faqSummaryItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListFaqsOutputResponse: Equatable {
    /// <p>information about the FAQs associated with the specified index.</p>
    public let faqSummaryItems: [FaqSummary]?
    /// <p>The <code>ListFaqs</code> operation returns a page of FAQs at a time. The maximum size
    ///             of the page is set by the <code>MaxResults</code> parameter. If there are more jobs in
    ///             the list than the page size, Amazon Kendra returns the <code>NextPage</code> token.
    ///             Include the token in the next request to the <code>ListFaqs</code> operation to return
    ///             the next page of FAQs.</p>
    public let nextToken: String?

    public init (
        faqSummaryItems: [FaqSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.faqSummaryItems = faqSummaryItems
        self.nextToken = nextToken
    }
}

struct ListFaqsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let faqSummaryItems: [FaqSummary]?
}

extension ListFaqsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case faqSummaryItems = "FaqSummaryItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let faqSummaryItemsContainer = try containerValues.decodeIfPresent([FaqSummary?].self, forKey: .faqSummaryItems)
        var faqSummaryItemsDecoded0:[FaqSummary]? = nil
        if let faqSummaryItemsContainer = faqSummaryItemsContainer {
            faqSummaryItemsDecoded0 = [FaqSummary]()
            for structure0 in faqSummaryItemsContainer {
                if let structure0 = structure0 {
                    faqSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        faqSummaryItems = faqSummaryItemsDecoded0
    }
}

public struct ListIndicesInputBodyMiddleware: Middleware {
    public let id: String = "ListIndicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIndicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIndicesInput>
    public typealias MOutput = OperationOutput<ListIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIndicesOutputError>
}

extension ListIndicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIndicesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIndicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListIndicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListIndicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIndicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIndicesInput>
    public typealias MOutput = OperationOutput<ListIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIndicesOutputError>
}

public struct ListIndicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIndicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIndicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIndicesInput>
    public typealias MOutput = OperationOutput<ListIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIndicesOutputError>
}

public struct ListIndicesInput: Equatable {
    /// <p>The maximum number of data sources to return.</p>
    public let maxResults: Int?
    /// <p>If the previous response was incomplete (because there is more data to
    ///       retrieve), Amazon Kendra returns a pagination token in the response. You
    ///       can use this pagination token to retrieve the next set of indexes
    ///         (<code>DataSourceSummaryItems</code>). </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIndicesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListIndicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListIndicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIndicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIndicesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIndicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIndicesOutputResponse(indexConfigurationSummaryItems: \(String(describing: indexConfigurationSummaryItems)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIndicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIndicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.indexConfigurationSummaryItems = output.indexConfigurationSummaryItems
            self.nextToken = output.nextToken
        } else {
            self.indexConfigurationSummaryItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListIndicesOutputResponse: Equatable {
    /// <p>An array of summary information for one or more indexes.</p>
    public let indexConfigurationSummaryItems: [IndexConfigurationSummary]?
    /// <p>If the response is truncated, Amazon Kendra returns this token that you
    ///       can use in the subsequent request to retrieve the next set of
    ///       indexes.</p>
    public let nextToken: String?

    public init (
        indexConfigurationSummaryItems: [IndexConfigurationSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.indexConfigurationSummaryItems = indexConfigurationSummaryItems
        self.nextToken = nextToken
    }
}

struct ListIndicesOutputResponseBody: Equatable {
    public let indexConfigurationSummaryItems: [IndexConfigurationSummary]?
    public let nextToken: String?
}

extension ListIndicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexConfigurationSummaryItems = "IndexConfigurationSummaryItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexConfigurationSummaryItemsContainer = try containerValues.decodeIfPresent([IndexConfigurationSummary?].self, forKey: .indexConfigurationSummaryItems)
        var indexConfigurationSummaryItemsDecoded0:[IndexConfigurationSummary]? = nil
        if let indexConfigurationSummaryItemsContainer = indexConfigurationSummaryItemsContainer {
            indexConfigurationSummaryItemsDecoded0 = [IndexConfigurationSummary]()
            for structure0 in indexConfigurationSummaryItemsContainer {
                if let structure0 = structure0 {
                    indexConfigurationSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        indexConfigurationSummaryItems = indexConfigurationSummaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListQuerySuggestionsBlockListsInputBodyMiddleware: Middleware {
    public let id: String = "ListQuerySuggestionsBlockListsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQuerySuggestionsBlockListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQuerySuggestionsBlockListsInput>
    public typealias MOutput = OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQuerySuggestionsBlockListsOutputError>
}

extension ListQuerySuggestionsBlockListsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQuerySuggestionsBlockListsInput(indexId: \(String(describing: indexId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListQuerySuggestionsBlockListsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListQuerySuggestionsBlockListsInputHeadersMiddleware: Middleware {
    public let id: String = "ListQuerySuggestionsBlockListsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQuerySuggestionsBlockListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQuerySuggestionsBlockListsInput>
    public typealias MOutput = OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQuerySuggestionsBlockListsOutputError>
}

public struct ListQuerySuggestionsBlockListsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListQuerySuggestionsBlockListsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQuerySuggestionsBlockListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQuerySuggestionsBlockListsInput>
    public typealias MOutput = OperationOutput<ListQuerySuggestionsBlockListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQuerySuggestionsBlockListsOutputError>
}

public struct ListQuerySuggestionsBlockListsInput: Equatable {
    /// <p>The identifier of the index for a list of all block lists that exist for
    ///             that index.</p>
    ///         <p>For information on the current quota limits for block lists, see
    ///             <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
    ///                 for Amazon Kendra</a>.</p>
    public let indexId: String?
    /// <p>The maximum number of block lists to return.</p>
    public let maxResults: Int?
    /// <p>If the previous response was incomplete (because there is more data to retrieve),
    ///             Amazon Kendra returns a pagination token in the response. You can use this pagination
    ///             token to retrieve the next set of block lists (<code>BlockListSummaryItems</code>).</p>
    public let nextToken: String?

    public init (
        indexId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListQuerySuggestionsBlockListsInputBody: Equatable {
    public let indexId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListQuerySuggestionsBlockListsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListQuerySuggestionsBlockListsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQuerySuggestionsBlockListsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQuerySuggestionsBlockListsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQuerySuggestionsBlockListsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQuerySuggestionsBlockListsOutputResponse(blockListSummaryItems: \(String(describing: blockListSummaryItems)), nextToken: \(String(describing: nextToken)))"}
}

extension ListQuerySuggestionsBlockListsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListQuerySuggestionsBlockListsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.blockListSummaryItems = output.blockListSummaryItems
            self.nextToken = output.nextToken
        } else {
            self.blockListSummaryItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListQuerySuggestionsBlockListsOutputResponse: Equatable {
    /// <p>Summary items for a block list.</p>
    ///         <p>This includes summary items on the block list ID, block list name, when the
    ///             block list was created, when the block list was last updated, and the count
    ///             of block words/phrases in the block list.</p>
    ///         <p>For information on the current quota limits for block lists, see
    ///             <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
    ///                 for Amazon Kendra</a>.</p>
    public let blockListSummaryItems: [QuerySuggestionsBlockListSummary]?
    /// <p>If the response is truncated, Amazon Kendra returns this token that you can use
    ///             in the subsequent request to retrieve the next set of block lists.</p>
    public let nextToken: String?

    public init (
        blockListSummaryItems: [QuerySuggestionsBlockListSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.blockListSummaryItems = blockListSummaryItems
        self.nextToken = nextToken
    }
}

struct ListQuerySuggestionsBlockListsOutputResponseBody: Equatable {
    public let blockListSummaryItems: [QuerySuggestionsBlockListSummary]?
    public let nextToken: String?
}

extension ListQuerySuggestionsBlockListsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blockListSummaryItems = "BlockListSummaryItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockListSummaryItemsContainer = try containerValues.decodeIfPresent([QuerySuggestionsBlockListSummary?].self, forKey: .blockListSummaryItems)
        var blockListSummaryItemsDecoded0:[QuerySuggestionsBlockListSummary]? = nil
        if let blockListSummaryItemsContainer = blockListSummaryItemsContainer {
            blockListSummaryItemsDecoded0 = [QuerySuggestionsBlockListSummary]()
            for structure0 in blockListSummaryItemsContainer {
                if let structure0 = structure0 {
                    blockListSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        blockListSummaryItems = blockListSummaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the index, FAQ, or data source to
    ///       get a list of tags for.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of tags associated with the index, FAQ, or data source.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListThesauriInputBodyMiddleware: Middleware {
    public let id: String = "ListThesauriInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThesauriInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThesauriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThesauriInput>
    public typealias MOutput = OperationOutput<ListThesauriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThesauriOutputError>
}

extension ListThesauriInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThesauriInput(indexId: \(String(describing: indexId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListThesauriInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListThesauriInputHeadersMiddleware: Middleware {
    public let id: String = "ListThesauriInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThesauriInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThesauriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThesauriInput>
    public typealias MOutput = OperationOutput<ListThesauriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThesauriOutputError>
}

public struct ListThesauriInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThesauriInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThesauriInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThesauriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThesauriInput>
    public typealias MOutput = OperationOutput<ListThesauriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThesauriOutputError>
}

public struct ListThesauriInput: Equatable {
    /// <p>The identifier of the index associated with the thesaurus to list.</p>
    public let indexId: String?
    /// <p>The maximum number of thesauri to return.</p>
    public let maxResults: Int?
    /// <p>If the previous response was incomplete (because there is more data to retrieve),
    ///          Amazon Kendra returns a pagination token in the response. You can use this pagination token to
    ///          retrieve the next set of thesauri (<code>ThesaurusSummaryItems</code>).
    ///       </p>
    public let nextToken: String?

    public init (
        indexId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListThesauriInputBody: Equatable {
    public let indexId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListThesauriInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexId = "IndexId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListThesauriOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThesauriOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThesauriOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThesauriOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThesauriOutputResponse(nextToken: \(String(describing: nextToken)), thesaurusSummaryItems: \(String(describing: thesaurusSummaryItems)))"}
}

extension ListThesauriOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThesauriOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.thesaurusSummaryItems = output.thesaurusSummaryItems
        } else {
            self.nextToken = nil
            self.thesaurusSummaryItems = nil
        }
    }
}

public struct ListThesauriOutputResponse: Equatable {
    /// <p>If the response is truncated, Amazon Kendra returns this
    ///          token that you can use in the subsequent request to
    ///          retrieve the next set of thesauri.
    ///       </p>
    public let nextToken: String?
    /// <p>An array of summary information for one or more thesauruses.</p>
    public let thesaurusSummaryItems: [ThesaurusSummary]?

    public init (
        nextToken: String? = nil,
        thesaurusSummaryItems: [ThesaurusSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.thesaurusSummaryItems = thesaurusSummaryItems
    }
}

struct ListThesauriOutputResponseBody: Equatable {
    public let nextToken: String?
    public let thesaurusSummaryItems: [ThesaurusSummary]?
}

extension ListThesauriOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case thesaurusSummaryItems = "ThesaurusSummaryItems"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let thesaurusSummaryItemsContainer = try containerValues.decodeIfPresent([ThesaurusSummary?].self, forKey: .thesaurusSummaryItems)
        var thesaurusSummaryItemsDecoded0:[ThesaurusSummary]? = nil
        if let thesaurusSummaryItemsContainer = thesaurusSummaryItemsContainer {
            thesaurusSummaryItemsDecoded0 = [ThesaurusSummary]()
            for structure0 in thesaurusSummaryItemsContainer {
                if let structure0 = structure0 {
                    thesaurusSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        thesaurusSummaryItems = thesaurusSummaryItemsDecoded0
    }
}

public enum Mode {
    case enabled
    case learnOnly
    case sdkUnknown(String)
}

extension Mode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Mode] {
        return [
            .enabled,
            .learnOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enabled: return "ENABLED"
        case .learnOnly: return "LEARN_ONLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
    }
}

extension OneDriveConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case disableLocalGroups = "DisableLocalGroups"
        case exclusionPatterns = "ExclusionPatterns"
        case fieldMappings = "FieldMappings"
        case inclusionPatterns = "InclusionPatterns"
        case oneDriveUsers = "OneDriveUsers"
        case secretArn = "SecretArn"
        case tenantDomain = "TenantDomain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if disableLocalGroups != false {
            try encodeContainer.encode(disableLocalGroups, forKey: .disableLocalGroups)
        }
        if let exclusionPatterns = exclusionPatterns {
            var exclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in exclusionPatterns {
                try exclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let inclusionPatterns = inclusionPatterns {
            var inclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in inclusionPatterns {
                try inclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let oneDriveUsers = oneDriveUsers {
            try encodeContainer.encode(oneDriveUsers, forKey: .oneDriveUsers)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let tenantDomain = tenantDomain {
            try encodeContainer.encode(tenantDomain, forKey: .tenantDomain)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tenantDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tenantDomain)
        tenantDomain = tenantDomainDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let oneDriveUsersDecoded = try containerValues.decodeIfPresent(OneDriveUsers.self, forKey: .oneDriveUsers)
        oneDriveUsers = oneDriveUsersDecoded
        let inclusionPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .inclusionPatterns)
        var inclusionPatternsDecoded0:[String]? = nil
        if let inclusionPatternsContainer = inclusionPatternsContainer {
            inclusionPatternsDecoded0 = [String]()
            for string0 in inclusionPatternsContainer {
                if let string0 = string0 {
                    inclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        inclusionPatterns = inclusionPatternsDecoded0
        let exclusionPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exclusionPatterns)
        var exclusionPatternsDecoded0:[String]? = nil
        if let exclusionPatternsContainer = exclusionPatternsContainer {
            exclusionPatternsDecoded0 = [String]()
            for string0 in exclusionPatternsContainer {
                if let string0 = string0 {
                    exclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        exclusionPatterns = exclusionPatternsDecoded0
        let fieldMappingsContainer = try containerValues.decodeIfPresent([DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let disableLocalGroupsDecoded = try containerValues.decode(Bool.self, forKey: .disableLocalGroups)
        disableLocalGroups = disableLocalGroupsDecoded
    }
}

extension OneDriveConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OneDriveConfiguration(disableLocalGroups: \(String(describing: disableLocalGroups)), exclusionPatterns: \(String(describing: exclusionPatterns)), fieldMappings: \(String(describing: fieldMappings)), inclusionPatterns: \(String(describing: inclusionPatterns)), oneDriveUsers: \(String(describing: oneDriveUsers)), secretArn: \(String(describing: secretArn)), tenantDomain: \(String(describing: tenantDomain)))"}
}

/// <p>Provides configuration information for data sources that connect
///             to OneDrive.</p>
public struct OneDriveConfiguration: Equatable {
    /// <p>A Boolean value that specifies whether local
    ///       groups are disabled (<code>True</code>) or enabled (<code>False</code>).
    ///       </p>
    public let disableLocalGroups: Bool
    /// <p>List of regular expressions applied to documents. Items that match
    ///             the exclusion pattern are not indexed. If you provide both an
    ///             inclusion pattern and an exclusion pattern, any item that matches
    ///             the exclusion pattern isn't indexed. </p>
    ///         <p>The exclusion pattern is applied to the file name.</p>
    public let exclusionPatterns: [String]?
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that
    ///             map Microsoft OneDrive fields to custom fields in the Amazon Kendra
    ///             index. You must first create the index fields before you map
    ///             OneDrive fields.</p>
    public let fieldMappings: [DataSourceToIndexFieldMapping]?
    /// <p>A list of regular expression patterns. Documents that match the
    ///             pattern are included in the index. Documents that don't match the
    ///             pattern are excluded from the index. If a document matches both an
    ///             inclusion pattern and an exclusion pattern, the document is not
    ///             included in the index. </p>
    ///         <p>The exclusion pattern is applied to the file name.</p>
    public let inclusionPatterns: [String]?
    /// <p>A list of user accounts whose documents should be indexed.</p>
    public let oneDriveUsers: OneDriveUsers?
    /// <p>The Amazon Resource Name (ARN) of an AWS Secrets Manager secret
    ///             that contains the user name and password to connect to OneDrive. The
    ///             user namd should be the application ID for the OneDrive application,
    ///             and the password is the application key for the OneDrive
    ///             application.</p>
    public let secretArn: String?
    /// <p>The Azure Active Directory domain of the organization. </p>
    public let tenantDomain: String?

    public init (
        disableLocalGroups: Bool = false,
        exclusionPatterns: [String]? = nil,
        fieldMappings: [DataSourceToIndexFieldMapping]? = nil,
        inclusionPatterns: [String]? = nil,
        oneDriveUsers: OneDriveUsers? = nil,
        secretArn: String? = nil,
        tenantDomain: String? = nil
    )
    {
        self.disableLocalGroups = disableLocalGroups
        self.exclusionPatterns = exclusionPatterns
        self.fieldMappings = fieldMappings
        self.inclusionPatterns = inclusionPatterns
        self.oneDriveUsers = oneDriveUsers
        self.secretArn = secretArn
        self.tenantDomain = tenantDomain
    }
}

extension OneDriveUsers: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case oneDriveUserList = "OneDriveUserList"
        case oneDriveUserS3Path = "OneDriveUserS3Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oneDriveUserList = oneDriveUserList {
            var oneDriveUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oneDriveUserList)
            for onedriveuserlist0 in oneDriveUserList {
                try oneDriveUserListContainer.encode(onedriveuserlist0)
            }
        }
        if let oneDriveUserS3Path = oneDriveUserS3Path {
            try encodeContainer.encode(oneDriveUserS3Path, forKey: .oneDriveUserS3Path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oneDriveUserListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .oneDriveUserList)
        var oneDriveUserListDecoded0:[String]? = nil
        if let oneDriveUserListContainer = oneDriveUserListContainer {
            oneDriveUserListDecoded0 = [String]()
            for string0 in oneDriveUserListContainer {
                if let string0 = string0 {
                    oneDriveUserListDecoded0?.append(string0)
                }
            }
        }
        oneDriveUserList = oneDriveUserListDecoded0
        let oneDriveUserS3PathDecoded = try containerValues.decodeIfPresent(S3Path.self, forKey: .oneDriveUserS3Path)
        oneDriveUserS3Path = oneDriveUserS3PathDecoded
    }
}

extension OneDriveUsers: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OneDriveUsers(oneDriveUserList: \(String(describing: oneDriveUserList)), oneDriveUserS3Path: \(String(describing: oneDriveUserS3Path)))"}
}

/// <p>User accounts whose documents should be indexed.</p>
public struct OneDriveUsers: Equatable {
    /// <p>A list of users whose documents should be indexed. Specify the
    ///             user names in email format, for example,
    ///                 <code>username@tenantdomain</code>. If you need to index the
    ///             documents of more than 100 users, use the
    ///                 <code>OneDriveUserS3Path</code> field to specify the location of
    ///             a file containing a list of users.</p>
    public let oneDriveUserList: [String]?
    /// <p>The S3 bucket location of a file containing a list of users whose
    ///             documents should be indexed.</p>
    public let oneDriveUserS3Path: S3Path?

    public init (
        oneDriveUserList: [String]? = nil,
        oneDriveUserS3Path: S3Path? = nil
    )
    {
        self.oneDriveUserList = oneDriveUserList
        self.oneDriveUserS3Path = oneDriveUserS3Path
    }
}

public enum Order {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension Order : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Order] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Order(rawValue: rawValue) ?? Order.sdkUnknown(rawValue)
    }
}

extension Principal: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case access = "Access"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let access = access {
            try encodeContainer.encode(access.rawValue, forKey: .access)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PrincipalType.self, forKey: .type)
        type = typeDecoded
        let accessDecoded = try containerValues.decodeIfPresent(ReadAccessType.self, forKey: .access)
        access = accessDecoded
    }
}

extension Principal: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Principal(access: \(String(describing: access)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Provides user and group information for document access
///             filtering.</p>
public struct Principal: Equatable {
    /// <p>Whether to allow or deny access to the principal.</p>
    public let access: ReadAccessType?
    /// <p>The name of the user or group.</p>
    public let name: String?
    /// <p>The type of principal.</p>
    public let type: PrincipalType?

    public init (
        access: ReadAccessType? = nil,
        name: String? = nil,
        type: PrincipalType? = nil
    )
    {
        self.access = access
        self.name = name
        self.type = type
    }
}

public enum PrincipalType {
    case group
    case user
    case sdkUnknown(String)
}

extension PrincipalType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PrincipalType] {
        return [
            .group,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .group: return "GROUP"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
    }
}

public enum QueryIdentifiersEnclosingOption {
    case doubleQuotes
    case `none`
    case sdkUnknown(String)
}

extension QueryIdentifiersEnclosingOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QueryIdentifiersEnclosingOption] {
        return [
            .doubleQuotes,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .doubleQuotes: return "DOUBLE_QUOTES"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QueryIdentifiersEnclosingOption(rawValue: rawValue) ?? QueryIdentifiersEnclosingOption.sdkUnknown(rawValue)
    }
}

public struct QueryInputBodyMiddleware: Middleware {
    public let id: String = "QueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryInput>
    public typealias MOutput = OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryOutputError>
}

extension QueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryInput(attributeFilter: \(String(describing: attributeFilter)), documentRelevanceOverrideConfigurations: \(String(describing: documentRelevanceOverrideConfigurations)), facets: \(String(describing: facets)), indexId: \(String(describing: indexId)), pageNumber: \(String(describing: pageNumber)), pageSize: \(String(describing: pageSize)), queryResultTypeFilter: \(String(describing: queryResultTypeFilter)), queryText: \(String(describing: queryText)), requestedDocumentAttributes: \(String(describing: requestedDocumentAttributes)), sortingConfiguration: \(String(describing: sortingConfiguration)), userContext: \(String(describing: userContext)), visitorId: \(String(describing: visitorId)))"}
}

extension QueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeFilter = "AttributeFilter"
        case documentRelevanceOverrideConfigurations = "DocumentRelevanceOverrideConfigurations"
        case facets = "Facets"
        case indexId = "IndexId"
        case pageNumber = "PageNumber"
        case pageSize = "PageSize"
        case queryResultTypeFilter = "QueryResultTypeFilter"
        case queryText = "QueryText"
        case requestedDocumentAttributes = "RequestedDocumentAttributes"
        case sortingConfiguration = "SortingConfiguration"
        case userContext = "UserContext"
        case visitorId = "VisitorId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeFilter = attributeFilter {
            try encodeContainer.encode(attributeFilter, forKey: .attributeFilter)
        }
        if let documentRelevanceOverrideConfigurations = documentRelevanceOverrideConfigurations {
            var documentRelevanceOverrideConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentRelevanceOverrideConfigurations)
            for documentrelevanceoverrideconfigurationlist0 in documentRelevanceOverrideConfigurations {
                try documentRelevanceOverrideConfigurationsContainer.encode(documentrelevanceoverrideconfigurationlist0)
            }
        }
        if let facets = facets {
            var facetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .facets)
            for facetlist0 in facets {
                try facetsContainer.encode(facetlist0)
            }
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let pageNumber = pageNumber {
            try encodeContainer.encode(pageNumber, forKey: .pageNumber)
        }
        if let pageSize = pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let queryResultTypeFilter = queryResultTypeFilter {
            try encodeContainer.encode(queryResultTypeFilter.rawValue, forKey: .queryResultTypeFilter)
        }
        if let queryText = queryText {
            try encodeContainer.encode(queryText, forKey: .queryText)
        }
        if let requestedDocumentAttributes = requestedDocumentAttributes {
            var requestedDocumentAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requestedDocumentAttributes)
            for documentattributekeylist0 in requestedDocumentAttributes {
                try requestedDocumentAttributesContainer.encode(documentattributekeylist0)
            }
        }
        if let sortingConfiguration = sortingConfiguration {
            try encodeContainer.encode(sortingConfiguration, forKey: .sortingConfiguration)
        }
        if let userContext = userContext {
            try encodeContainer.encode(userContext, forKey: .userContext)
        }
        if let visitorId = visitorId {
            try encodeContainer.encode(visitorId, forKey: .visitorId)
        }
    }
}

public struct QueryInputHeadersMiddleware: Middleware {
    public let id: String = "QueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryInput>
    public typealias MOutput = OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryOutputError>
}

public struct QueryInputQueryItemMiddleware: Middleware {
    public let id: String = "QueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryInput>
    public typealias MOutput = OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryOutputError>
}

public struct QueryInput: Equatable {
    /// <p>Enables filtered searches based on document attributes. You can only
    ///          provide one attribute filter; however, the <code>AndAllFilters</code>,
    ///             <code>NotFilter</code>, and <code>OrAllFilters</code> parameters
    ///          contain a list of other filters.</p>
    ///          <p>The <code>AttributeFilter</code> parameter enables you to create a
    ///          set of filtering rules that a document must satisfy to be included in
    ///          the query results.</p>
    public let attributeFilter: AttributeFilter?
    /// <p>Overrides relevance tuning configurations of fields or attributes set at the index level.</p>
    ///          <p>If you use this API to override the relevance tuning configured at the index
    ///          level, but there is no relevance tuning configured at the index level, then Amazon Kendra does not apply any relevance tuning.</p>
    ///          <p>If there is relevance tuning configured at the index level, but you do not use this API
    ///          to override any relevance tuning in the index, then Amazon Kendra uses the relevance tuning that is configured at the index level.</p>
    ///          <p>If there is relevance tuning configured for fields at the index level,
    ///          but you use this API to override only some of these fields, then for the fields you did not override,
    ///          the importance is set to 1.</p>
    public let documentRelevanceOverrideConfigurations: [DocumentRelevanceConfiguration]?
    /// <p>An array of documents attributes. Amazon Kendra returns a count for
    ///          each attribute key specified. You can use this information to help
    ///          narrow the search for your user.</p>
    public let facets: [Facet]?
    /// <p>The unique identifier of the index to search. The identifier is
    ///          returned in the response from the <code>CreateIndex</code>
    ///          operation.</p>
    public let indexId: String?
    /// <p>Query results are returned in pages the size of the
    ///             <code>PageSize</code> parameter. By default, Amazon Kendra returns
    ///          the first page of results. Use this parameter to get result pages after
    ///          the first one.</p>
    public let pageNumber: Int?
    /// <p>Sets the number of results that are returned in each page of
    ///          results. The default page size is 10. The maximum number of results
    ///          returned is 100. If you ask for more than 100 results, only 100 are
    ///          returned.</p>
    public let pageSize: Int?
    /// <p>Sets the type of query. Only results for the specified query type
    ///          are returned.</p>
    public let queryResultTypeFilter: QueryResultType?
    /// <p>The text to search for.</p>
    public let queryText: String?
    /// <p>An array of document attributes to include in the response. No other
    ///          document attributes are included in the response. By default all
    ///          document attributes are included in the response. </p>
    public let requestedDocumentAttributes: [String]?
    /// <p>Provides information that determines how the results of the query
    ///          are sorted. You can set the field that Amazon Kendra should sort the results
    ///          on, and specify whether the results should be sorted in ascending or
    ///          descending order. In the case of ties in sorting the results, the
    ///          results are sorted by relevance.</p>
    ///          <p>If you don't provide sorting configuration, the results are sorted
    ///          by the relevance that Amazon Kendra determines for the result.</p>
    public let sortingConfiguration: SortingConfiguration?
    /// <p>The user context token.</p>
    public let userContext: UserContext?
    /// <p>Provides an identifier for a specific user. The
    ///             <code>VisitorId</code> should be a unique identifier, such as a
    ///          GUID. Don't use personally identifiable information, such as the user's
    ///          email address, as the <code>VisitorId</code>.</p>
    public let visitorId: String?

    public init (
        attributeFilter: AttributeFilter? = nil,
        documentRelevanceOverrideConfigurations: [DocumentRelevanceConfiguration]? = nil,
        facets: [Facet]? = nil,
        indexId: String? = nil,
        pageNumber: Int? = nil,
        pageSize: Int? = nil,
        queryResultTypeFilter: QueryResultType? = nil,
        queryText: String? = nil,
        requestedDocumentAttributes: [String]? = nil,
        sortingConfiguration: SortingConfiguration? = nil,
        userContext: UserContext? = nil,
        visitorId: String? = nil
    )
    {
        self.attributeFilter = attributeFilter
        self.documentRelevanceOverrideConfigurations = documentRelevanceOverrideConfigurations
        self.facets = facets
        self.indexId = indexId
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.queryResultTypeFilter = queryResultTypeFilter
        self.queryText = queryText
        self.requestedDocumentAttributes = requestedDocumentAttributes
        self.sortingConfiguration = sortingConfiguration
        self.userContext = userContext
        self.visitorId = visitorId
    }
}

struct QueryInputBody: Equatable {
    public let indexId: String?
    public let queryText: String?
    public let attributeFilter: AttributeFilter?
    public let facets: [Facet]?
    public let requestedDocumentAttributes: [String]?
    public let queryResultTypeFilter: QueryResultType?
    public let documentRelevanceOverrideConfigurations: [DocumentRelevanceConfiguration]?
    public let pageNumber: Int?
    public let pageSize: Int?
    public let sortingConfiguration: SortingConfiguration?
    public let userContext: UserContext?
    public let visitorId: String?
}

extension QueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeFilter = "AttributeFilter"
        case documentRelevanceOverrideConfigurations = "DocumentRelevanceOverrideConfigurations"
        case facets = "Facets"
        case indexId = "IndexId"
        case pageNumber = "PageNumber"
        case pageSize = "PageSize"
        case queryResultTypeFilter = "QueryResultTypeFilter"
        case queryText = "QueryText"
        case requestedDocumentAttributes = "RequestedDocumentAttributes"
        case sortingConfiguration = "SortingConfiguration"
        case userContext = "UserContext"
        case visitorId = "VisitorId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let queryTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryText)
        queryText = queryTextDecoded
        let attributeFilterDecoded = try containerValues.decodeIfPresent(AttributeFilter.self, forKey: .attributeFilter)
        attributeFilter = attributeFilterDecoded
        let facetsContainer = try containerValues.decodeIfPresent([Facet?].self, forKey: .facets)
        var facetsDecoded0:[Facet]? = nil
        if let facetsContainer = facetsContainer {
            facetsDecoded0 = [Facet]()
            for structure0 in facetsContainer {
                if let structure0 = structure0 {
                    facetsDecoded0?.append(structure0)
                }
            }
        }
        facets = facetsDecoded0
        let requestedDocumentAttributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .requestedDocumentAttributes)
        var requestedDocumentAttributesDecoded0:[String]? = nil
        if let requestedDocumentAttributesContainer = requestedDocumentAttributesContainer {
            requestedDocumentAttributesDecoded0 = [String]()
            for string0 in requestedDocumentAttributesContainer {
                if let string0 = string0 {
                    requestedDocumentAttributesDecoded0?.append(string0)
                }
            }
        }
        requestedDocumentAttributes = requestedDocumentAttributesDecoded0
        let queryResultTypeFilterDecoded = try containerValues.decodeIfPresent(QueryResultType.self, forKey: .queryResultTypeFilter)
        queryResultTypeFilter = queryResultTypeFilterDecoded
        let documentRelevanceOverrideConfigurationsContainer = try containerValues.decodeIfPresent([DocumentRelevanceConfiguration?].self, forKey: .documentRelevanceOverrideConfigurations)
        var documentRelevanceOverrideConfigurationsDecoded0:[DocumentRelevanceConfiguration]? = nil
        if let documentRelevanceOverrideConfigurationsContainer = documentRelevanceOverrideConfigurationsContainer {
            documentRelevanceOverrideConfigurationsDecoded0 = [DocumentRelevanceConfiguration]()
            for structure0 in documentRelevanceOverrideConfigurationsContainer {
                if let structure0 = structure0 {
                    documentRelevanceOverrideConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        documentRelevanceOverrideConfigurations = documentRelevanceOverrideConfigurationsDecoded0
        let pageNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pageNumber)
        pageNumber = pageNumberDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let sortingConfigurationDecoded = try containerValues.decodeIfPresent(SortingConfiguration.self, forKey: .sortingConfiguration)
        sortingConfiguration = sortingConfigurationDecoded
        let userContextDecoded = try containerValues.decodeIfPresent(UserContext.self, forKey: .userContext)
        userContext = userContextDecoded
        let visitorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .visitorId)
        visitorId = visitorIdDecoded
    }
}

extension QueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension QueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum QueryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension QueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryOutputResponse(facetResults: \(String(describing: facetResults)), queryId: \(String(describing: queryId)), resultItems: \(String(describing: resultItems)), totalNumberOfResults: \(String(describing: totalNumberOfResults)))"}
}

extension QueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: QueryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.facetResults = output.facetResults
            self.queryId = output.queryId
            self.resultItems = output.resultItems
            self.totalNumberOfResults = output.totalNumberOfResults
        } else {
            self.facetResults = nil
            self.queryId = nil
            self.resultItems = nil
            self.totalNumberOfResults = nil
        }
    }
}

public struct QueryOutputResponse: Equatable {
    /// <p>Contains the facet results. A <code>FacetResult</code> contains the
    ///          counts for each attribute key that was specified in the
    ///             <code>Facets</code> input parameter.</p>
    public let facetResults: [FacetResult]?
    /// <p>The unique identifier for the search. You use <code>QueryId</code>
    ///          to identify the search when using the feedback API.</p>
    public let queryId: String?
    /// <p>The results of the search.</p>
    public let resultItems: [QueryResultItem]?
    /// <p>The total number of items found by the search; however, you can only
    ///          retrieve up to 100 items. For example, if the search found 192 items,
    ///          you can only retrieve the first 100 of the items.</p>
    public let totalNumberOfResults: Int?

    public init (
        facetResults: [FacetResult]? = nil,
        queryId: String? = nil,
        resultItems: [QueryResultItem]? = nil,
        totalNumberOfResults: Int? = nil
    )
    {
        self.facetResults = facetResults
        self.queryId = queryId
        self.resultItems = resultItems
        self.totalNumberOfResults = totalNumberOfResults
    }
}

struct QueryOutputResponseBody: Equatable {
    public let queryId: String?
    public let resultItems: [QueryResultItem]?
    public let facetResults: [FacetResult]?
    public let totalNumberOfResults: Int?
}

extension QueryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case facetResults = "FacetResults"
        case queryId = "QueryId"
        case resultItems = "ResultItems"
        case totalNumberOfResults = "TotalNumberOfResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let resultItemsContainer = try containerValues.decodeIfPresent([QueryResultItem?].self, forKey: .resultItems)
        var resultItemsDecoded0:[QueryResultItem]? = nil
        if let resultItemsContainer = resultItemsContainer {
            resultItemsDecoded0 = [QueryResultItem]()
            for structure0 in resultItemsContainer {
                if let structure0 = structure0 {
                    resultItemsDecoded0?.append(structure0)
                }
            }
        }
        resultItems = resultItemsDecoded0
        let facetResultsContainer = try containerValues.decodeIfPresent([FacetResult?].self, forKey: .facetResults)
        var facetResultsDecoded0:[FacetResult]? = nil
        if let facetResultsContainer = facetResultsContainer {
            facetResultsDecoded0 = [FacetResult]()
            for structure0 in facetResultsContainer {
                if let structure0 = structure0 {
                    facetResultsDecoded0?.append(structure0)
                }
            }
        }
        facetResults = facetResultsDecoded0
        let totalNumberOfResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalNumberOfResults)
        totalNumberOfResults = totalNumberOfResultsDecoded
    }
}

extension QueryResultItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalAttributes = "AdditionalAttributes"
        case documentAttributes = "DocumentAttributes"
        case documentExcerpt = "DocumentExcerpt"
        case documentId = "DocumentId"
        case documentTitle = "DocumentTitle"
        case documentURI = "DocumentURI"
        case feedbackToken = "FeedbackToken"
        case id = "Id"
        case scoreAttributes = "ScoreAttributes"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAttributes = additionalAttributes {
            var additionalAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAttributes)
            for additionalresultattributelist0 in additionalAttributes {
                try additionalAttributesContainer.encode(additionalresultattributelist0)
            }
        }
        if let documentAttributes = documentAttributes {
            var documentAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentAttributes)
            for documentattributelist0 in documentAttributes {
                try documentAttributesContainer.encode(documentattributelist0)
            }
        }
        if let documentExcerpt = documentExcerpt {
            try encodeContainer.encode(documentExcerpt, forKey: .documentExcerpt)
        }
        if let documentId = documentId {
            try encodeContainer.encode(documentId, forKey: .documentId)
        }
        if let documentTitle = documentTitle {
            try encodeContainer.encode(documentTitle, forKey: .documentTitle)
        }
        if let documentURI = documentURI {
            try encodeContainer.encode(documentURI, forKey: .documentURI)
        }
        if let feedbackToken = feedbackToken {
            try encodeContainer.encode(feedbackToken, forKey: .feedbackToken)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let scoreAttributes = scoreAttributes {
            try encodeContainer.encode(scoreAttributes, forKey: .scoreAttributes)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QueryResultType.self, forKey: .type)
        type = typeDecoded
        let additionalAttributesContainer = try containerValues.decodeIfPresent([AdditionalResultAttribute?].self, forKey: .additionalAttributes)
        var additionalAttributesDecoded0:[AdditionalResultAttribute]? = nil
        if let additionalAttributesContainer = additionalAttributesContainer {
            additionalAttributesDecoded0 = [AdditionalResultAttribute]()
            for structure0 in additionalAttributesContainer {
                if let structure0 = structure0 {
                    additionalAttributesDecoded0?.append(structure0)
                }
            }
        }
        additionalAttributes = additionalAttributesDecoded0
        let documentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentId)
        documentId = documentIdDecoded
        let documentTitleDecoded = try containerValues.decodeIfPresent(TextWithHighlights.self, forKey: .documentTitle)
        documentTitle = documentTitleDecoded
        let documentExcerptDecoded = try containerValues.decodeIfPresent(TextWithHighlights.self, forKey: .documentExcerpt)
        documentExcerpt = documentExcerptDecoded
        let documentURIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentURI)
        documentURI = documentURIDecoded
        let documentAttributesContainer = try containerValues.decodeIfPresent([DocumentAttribute?].self, forKey: .documentAttributes)
        var documentAttributesDecoded0:[DocumentAttribute]? = nil
        if let documentAttributesContainer = documentAttributesContainer {
            documentAttributesDecoded0 = [DocumentAttribute]()
            for structure0 in documentAttributesContainer {
                if let structure0 = structure0 {
                    documentAttributesDecoded0?.append(structure0)
                }
            }
        }
        documentAttributes = documentAttributesDecoded0
        let scoreAttributesDecoded = try containerValues.decodeIfPresent(ScoreAttributes.self, forKey: .scoreAttributes)
        scoreAttributes = scoreAttributesDecoded
        let feedbackTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackToken)
        feedbackToken = feedbackTokenDecoded
    }
}

extension QueryResultItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryResultItem(additionalAttributes: \(String(describing: additionalAttributes)), documentAttributes: \(String(describing: documentAttributes)), documentExcerpt: \(String(describing: documentExcerpt)), documentId: \(String(describing: documentId)), documentTitle: \(String(describing: documentTitle)), documentURI: \(String(describing: documentURI)), feedbackToken: \(String(describing: feedbackToken)), id: \(String(describing: id)), scoreAttributes: \(String(describing: scoreAttributes)), type: \(String(describing: type)))"}
}

/// <p>A single query result.</p>
///          <p>A query result contains information about a document returned by the
///          query. This includes the original location of the document, a list of
///          attributes assigned to the document, and relevant text from the
///          document that satisfies the query.</p>
public struct QueryResultItem: Equatable {
    /// <p>One or more additional attributes associated with the query
    ///          result.</p>
    public let additionalAttributes: [AdditionalResultAttribute]?
    /// <p>An array of document attributes for the document that the query
    ///          result maps to. For example, the document author (Author) or the source
    ///          URI (SourceUri) of the document.</p>
    public let documentAttributes: [DocumentAttribute]?
    /// <p>An extract of the text in the document. Contains information about
    ///          highlighting the relevant terms in the excerpt.</p>
    public let documentExcerpt: TextWithHighlights?
    /// <p>The unique identifier for the document.</p>
    public let documentId: String?
    /// <p>The title of the document. Contains the text of the title and
    ///          information for highlighting the relevant terms in the title.</p>
    public let documentTitle: TextWithHighlights?
    /// <p>The URI of the original location of the document.</p>
    public let documentURI: String?
    /// <p>A token that identifies a particular result from a particular query.
    ///          Use this token to provide click-through feedback for the result. For
    ///          more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/submitting-feedback.html"> Submitting feedback
    ///          </a>.</p>
    public let feedbackToken: String?
    /// <p>The unique identifier for the query result.</p>
    public let id: String?
    /// <p>Indicates the confidence that Amazon Kendra has that a result matches the
    ///          query that you provided. Each result is placed into a bin that
    ///          indicates the confidence, <code>VERY_HIGH</code>, <code>HIGH</code>,
    ///             <code>MEDIUM</code> and <code>LOW</code>. You can use the score to
    ///          determine if a response meets the confidence needed for your
    ///          application.</p>
    ///          <p>The field is only set to <code>LOW</code> when the <code>Type</code>
    ///          field is set to <code>DOCUMENT</code> and Amazon Kendra is not confident that
    ///          the result matches the query.</p>
    public let scoreAttributes: ScoreAttributes?
    /// <p>The type of document. </p>
    public let type: QueryResultType?

    public init (
        additionalAttributes: [AdditionalResultAttribute]? = nil,
        documentAttributes: [DocumentAttribute]? = nil,
        documentExcerpt: TextWithHighlights? = nil,
        documentId: String? = nil,
        documentTitle: TextWithHighlights? = nil,
        documentURI: String? = nil,
        feedbackToken: String? = nil,
        id: String? = nil,
        scoreAttributes: ScoreAttributes? = nil,
        type: QueryResultType? = nil
    )
    {
        self.additionalAttributes = additionalAttributes
        self.documentAttributes = documentAttributes
        self.documentExcerpt = documentExcerpt
        self.documentId = documentId
        self.documentTitle = documentTitle
        self.documentURI = documentURI
        self.feedbackToken = feedbackToken
        self.id = id
        self.scoreAttributes = scoreAttributes
        self.type = type
    }
}

public enum QueryResultType {
    case answer
    case document
    case questionAnswer
    case sdkUnknown(String)
}

extension QueryResultType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QueryResultType] {
        return [
            .answer,
            .document,
            .questionAnswer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .answer: return "ANSWER"
        case .document: return "DOCUMENT"
        case .questionAnswer: return "QUESTION_ANSWER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QueryResultType(rawValue: rawValue) ?? QueryResultType.sdkUnknown(rawValue)
    }
}

public enum QuerySuggestionsBlockListStatus {
    case active
    case activeButUpdateFailed
    case creating
    case deleting
    case failed
    case updating
    case sdkUnknown(String)
}

extension QuerySuggestionsBlockListStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QuerySuggestionsBlockListStatus] {
        return [
            .active,
            .activeButUpdateFailed,
            .creating,
            .deleting,
            .failed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .activeButUpdateFailed: return "ACTIVE_BUT_UPDATE_FAILED"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QuerySuggestionsBlockListStatus(rawValue: rawValue) ?? QuerySuggestionsBlockListStatus.sdkUnknown(rawValue)
    }
}

extension QuerySuggestionsBlockListSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case id = "Id"
        case itemCount = "ItemCount"
        case name = "Name"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let itemCount = itemCount {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuerySuggestionsBlockListStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
    }
}

extension QuerySuggestionsBlockListSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuerySuggestionsBlockListSummary(createdAt: \(String(describing: createdAt)), id: \(String(describing: id)), itemCount: \(String(describing: itemCount)), name: \(String(describing: name)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Summary information on a query suggestions block list.</p>
///         <p>This includes information on the block list ID, block list name, when the
///             block list was created, when the block list was last updated, and the count
///             of block words/phrases in the block list.</p>
///         <p>For information on the current quota limits for block lists, see
///             <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
///                 for Amazon Kendra</a>.</p>
public struct QuerySuggestionsBlockListSummary: Equatable {
    /// <p>The date-time summary information for a query suggestions
    ///             block list was last created.</p>
    public let createdAt: Date?
    /// <p>The identifier of a block list.</p>
    public let id: String?
    /// <p>The number of items in the block list file.</p>
    public let itemCount: Int?
    /// <p>The name of the block list.</p>
    public let name: String?
    /// <p>The status of the block list.</p>
    public let status: QuerySuggestionsBlockListStatus?
    /// <p>The date-time the block list was last updated.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        id: String? = nil,
        itemCount: Int? = nil,
        name: String? = nil,
        status: QuerySuggestionsBlockListStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.id = id
        self.itemCount = itemCount
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

public enum QuerySuggestionsStatus {
    case active
    case updating
    case sdkUnknown(String)
}

extension QuerySuggestionsStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QuerySuggestionsStatus] {
        return [
            .active,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QuerySuggestionsStatus(rawValue: rawValue) ?? QuerySuggestionsStatus.sdkUnknown(rawValue)
    }
}

public enum ReadAccessType {
    case allow
    case deny
    case sdkUnknown(String)
}

extension ReadAccessType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReadAccessType] {
        return [
            .allow,
            .deny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "ALLOW"
        case .deny: return "DENY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReadAccessType(rawValue: rawValue) ?? ReadAccessType.sdkUnknown(rawValue)
    }
}

extension Relevance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case duration = "Duration"
        case freshness = "Freshness"
        case importance = "Importance"
        case rankOrder = "RankOrder"
        case valueImportanceMap = "ValueImportanceMap"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let freshness = freshness {
            try encodeContainer.encode(freshness, forKey: .freshness)
        }
        if let importance = importance {
            try encodeContainer.encode(importance, forKey: .importance)
        }
        if let rankOrder = rankOrder {
            try encodeContainer.encode(rankOrder.rawValue, forKey: .rankOrder)
        }
        if let valueImportanceMap = valueImportanceMap {
            var valueImportanceMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .valueImportanceMap)
            for (dictKey0, valueimportancemap0) in valueImportanceMap {
                try valueImportanceMapContainer.encode(valueimportancemap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freshnessDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .freshness)
        freshness = freshnessDecoded
        let importanceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .importance)
        importance = importanceDecoded
        let durationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .duration)
        duration = durationDecoded
        let rankOrderDecoded = try containerValues.decodeIfPresent(Order.self, forKey: .rankOrder)
        rankOrder = rankOrderDecoded
        let valueImportanceMapContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .valueImportanceMap)
        var valueImportanceMapDecoded0: [String:Int]? = nil
        if let valueImportanceMapContainer = valueImportanceMapContainer {
            valueImportanceMapDecoded0 = [String:Int]()
            for (key0, importance0) in valueImportanceMapContainer {
                if let importance0 = importance0 {
                    valueImportanceMapDecoded0?[key0] = importance0
                }
            }
        }
        valueImportanceMap = valueImportanceMapDecoded0
    }
}

extension Relevance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Relevance(duration: \(String(describing: duration)), freshness: \(String(describing: freshness)), importance: \(String(describing: importance)), rankOrder: \(String(describing: rankOrder)), valueImportanceMap: \(String(describing: valueImportanceMap)))"}
}

/// <p>Provides information for manually tuning the relevance of a field
///             in a search. When a query includes terms that match the field, the
///             results are given a boost in the response based on these tuning
///             parameters.</p>
public struct Relevance: Equatable {
    /// <p>Specifies the time period that the boost applies to. For example,
    ///             to make the boost apply to documents with the field value within the
    ///             last month, you would use "2628000s". Once the field value is beyond
    ///             the specified range, the effect of the boost drops off. The higher
    ///             the importance, the faster the effect drops off. If you don't
    ///             specify a value, the default is 3 months. The value of the field is
    ///             a numeric string followed by the character "s", for example "86400s"
    ///             for one day, or "604800s" for one week. </p>
    ///         <p>Only applies to <code>DATE</code> fields.</p>
    public let duration: String?
    /// <p>Indicates that this field determines how "fresh" a document is.
    ///             For example, if document 1 was created on November 5, and document 2
    ///             was created on October 31, document 1 is "fresher" than document 2.
    ///             You can only set the <code>Freshness</code> field on one
    ///                 <code>DATE</code> type field. Only applies to <code>DATE</code>
    ///             fields.</p>
    public let freshness: Bool?
    /// <p>The relative importance of the field in the search. Larger numbers
    ///             provide more of a boost than smaller numbers.</p>
    public let importance: Int?
    /// <p>Determines how values should be interpreted.</p>
    ///         <p>When the <code>RankOrder</code> field is <code>ASCENDING</code>,
    ///             higher numbers are better. For example, a document with a rating
    ///             score of 10 is higher ranking than a document with a rating score of
    ///             1.</p>
    ///         <p>When the <code>RankOrder</code> field is <code>DESCENDING</code>,
    ///             lower numbers are better. For example, in a task tracking
    ///             application, a priority 1 task is more important than a priority 5
    ///             task.</p>
    ///         <p>Only applies to <code>LONG</code> and <code>DOUBLE</code>
    ///             fields.</p>
    public let rankOrder: Order?
    /// <p>A list of values that should be given a different boost when they
    ///             appear in the result list. For example, if you are boosting a field
    ///             called "department," query terms that match the department field are
    ///             boosted in the result. However, you can add entries from the
    ///             department field to boost documents with those values higher. </p>
    ///         <p>For example, you can add entries to the map with names of
    ///             departments. If you add "HR",5 and "Legal",3 those departments are
    ///             given special attention when they appear in the metadata of a
    ///             document. When those terms appear they are given the specified
    ///             importance instead of the regular importance for the boost.</p>
    public let valueImportanceMap: [String:Int]?

    public init (
        duration: String? = nil,
        freshness: Bool? = nil,
        importance: Int? = nil,
        rankOrder: Order? = nil,
        valueImportanceMap: [String:Int]? = nil
    )
    {
        self.duration = duration
        self.freshness = freshness
        self.importance = importance
        self.rankOrder = rankOrder
        self.valueImportanceMap = valueImportanceMap
    }
}

extension RelevanceFeedback: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case relevanceValue = "RelevanceValue"
        case resultId = "ResultId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relevanceValue = relevanceValue {
            try encodeContainer.encode(relevanceValue.rawValue, forKey: .relevanceValue)
        }
        if let resultId = resultId {
            try encodeContainer.encode(resultId, forKey: .resultId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultId)
        resultId = resultIdDecoded
        let relevanceValueDecoded = try containerValues.decodeIfPresent(RelevanceType.self, forKey: .relevanceValue)
        relevanceValue = relevanceValueDecoded
    }
}

extension RelevanceFeedback: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RelevanceFeedback(relevanceValue: \(String(describing: relevanceValue)), resultId: \(String(describing: resultId)))"}
}

/// <p>Provides feedback on how relevant a document is to a search. Your
///             application uses the <code>SubmitFeedback</code> operation to
///             provide relevance information.</p>
public struct RelevanceFeedback: Equatable {
    /// <p>Whether to document was relevant or not relevant to the
    ///             search.</p>
    public let relevanceValue: RelevanceType?
    /// <p>The unique identifier of the search result that the user provided
    ///             relevance feedback for.</p>
    public let resultId: String?

    public init (
        relevanceValue: RelevanceType? = nil,
        resultId: String? = nil
    )
    {
        self.relevanceValue = relevanceValue
        self.resultId = resultId
    }
}

public enum RelevanceType {
    case notRelevant
    case relevant
    case sdkUnknown(String)
}

extension RelevanceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RelevanceType] {
        return [
            .notRelevant,
            .relevant,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notRelevant: return "NOT_RELEVANT"
        case .relevant: return "RELEVANT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RelevanceType(rawValue: rawValue) ?? RelevanceType.sdkUnknown(rawValue)
    }
}

extension ResourceAlreadyExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceAlreadyExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceUnavailableException(message: \(String(describing: message)))"}
}

extension ResourceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ResourceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3DataSourceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlListConfiguration = "AccessControlListConfiguration"
        case bucketName = "BucketName"
        case documentsMetadataConfiguration = "DocumentsMetadataConfiguration"
        case exclusionPatterns = "ExclusionPatterns"
        case inclusionPatterns = "InclusionPatterns"
        case inclusionPrefixes = "InclusionPrefixes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlListConfiguration = accessControlListConfiguration {
            try encodeContainer.encode(accessControlListConfiguration, forKey: .accessControlListConfiguration)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let documentsMetadataConfiguration = documentsMetadataConfiguration {
            try encodeContainer.encode(documentsMetadataConfiguration, forKey: .documentsMetadataConfiguration)
        }
        if let exclusionPatterns = exclusionPatterns {
            var exclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in exclusionPatterns {
                try exclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let inclusionPatterns = inclusionPatterns {
            var inclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in inclusionPatterns {
                try inclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let inclusionPrefixes = inclusionPrefixes {
            var inclusionPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPrefixes)
            for datasourceinclusionsexclusionsstrings0 in inclusionPrefixes {
                try inclusionPrefixesContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let inclusionPrefixesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .inclusionPrefixes)
        var inclusionPrefixesDecoded0:[String]? = nil
        if let inclusionPrefixesContainer = inclusionPrefixesContainer {
            inclusionPrefixesDecoded0 = [String]()
            for string0 in inclusionPrefixesContainer {
                if let string0 = string0 {
                    inclusionPrefixesDecoded0?.append(string0)
                }
            }
        }
        inclusionPrefixes = inclusionPrefixesDecoded0
        let inclusionPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .inclusionPatterns)
        var inclusionPatternsDecoded0:[String]? = nil
        if let inclusionPatternsContainer = inclusionPatternsContainer {
            inclusionPatternsDecoded0 = [String]()
            for string0 in inclusionPatternsContainer {
                if let string0 = string0 {
                    inclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        inclusionPatterns = inclusionPatternsDecoded0
        let exclusionPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exclusionPatterns)
        var exclusionPatternsDecoded0:[String]? = nil
        if let exclusionPatternsContainer = exclusionPatternsContainer {
            exclusionPatternsDecoded0 = [String]()
            for string0 in exclusionPatternsContainer {
                if let string0 = string0 {
                    exclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        exclusionPatterns = exclusionPatternsDecoded0
        let documentsMetadataConfigurationDecoded = try containerValues.decodeIfPresent(DocumentsMetadataConfiguration.self, forKey: .documentsMetadataConfiguration)
        documentsMetadataConfiguration = documentsMetadataConfigurationDecoded
        let accessControlListConfigurationDecoded = try containerValues.decodeIfPresent(AccessControlListConfiguration.self, forKey: .accessControlListConfiguration)
        accessControlListConfiguration = accessControlListConfigurationDecoded
    }
}

extension S3DataSourceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3DataSourceConfiguration(accessControlListConfiguration: \(String(describing: accessControlListConfiguration)), bucketName: \(String(describing: bucketName)), documentsMetadataConfiguration: \(String(describing: documentsMetadataConfiguration)), exclusionPatterns: \(String(describing: exclusionPatterns)), inclusionPatterns: \(String(describing: inclusionPatterns)), inclusionPrefixes: \(String(describing: inclusionPrefixes)))"}
}

/// <p>Provides configuration information for a data source to index
///             documents in an Amazon S3 bucket.</p>
public struct S3DataSourceConfiguration: Equatable {
    /// <p>Provides the path to the S3 bucket that contains the user context
    ///             filtering files for the data source. For the format of the file, see
    ///                 <a href="https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html">Access control for S3 data sources</a>.</p>
    public let accessControlListConfiguration: AccessControlListConfiguration?
    /// <p>The name of the bucket that contains the documents.</p>
    public let bucketName: String?
    /// <p>Document metadata files that contain information such as the
    ///             document access control information, source URI, document author,
    ///             and custom attributes. Each metadata file contains metadata about a
    ///             single document.</p>
    public let documentsMetadataConfiguration: DocumentsMetadataConfiguration?
    /// <p>A list of glob patterns for documents that should not be indexed.
    ///             If a document that matches an inclusion prefix or inclusion pattern
    ///             also matches an exclusion pattern, the document is not
    ///             indexed.</p>
    ///         <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a>
    ///             are:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <i>*.png , *.jpg</i> will exclude
    ///                     all PNG and JPEG image files in a directory
    ///                     (files with the extensions .png and .jpg).</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <i>*internal*</i> will exclude all
    ///                     files in a directory that contain 'internal' in the file name,
    ///                     such as 'internal', 'internal_only', 'company_internal'.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <i>**/*internal*</i> will exclude
    ///                     all internal-related files in a directory and its subdirectories.</p>
    ///             </li>
    ///          </ul>
    public let exclusionPatterns: [String]?
    /// <p>A list of glob patterns for documents that should be indexed. If a
    ///             document that matches an inclusion pattern also matches an exclusion
    ///             pattern, the document is not indexed.</p>
    ///         <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a>
    ///             are:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <i>*.txt</i> will include all text files
    ///                     in a directory (files with the extension .txt).</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <i>**/*.txt</i> will include all text
    ///                     files in a directory and its subdirectories.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <i>*tax*</i> will include all files in
    ///                     a directory that contain 'tax' in the file name, such as 'tax',
    ///                     'taxes', 'income_tax'.</p>
    ///             </li>
    ///          </ul>
    public let inclusionPatterns: [String]?
    /// <p>A list of S3 prefixes for the documents that should be included in
    ///             the index.</p>
    public let inclusionPrefixes: [String]?

    public init (
        accessControlListConfiguration: AccessControlListConfiguration? = nil,
        bucketName: String? = nil,
        documentsMetadataConfiguration: DocumentsMetadataConfiguration? = nil,
        exclusionPatterns: [String]? = nil,
        inclusionPatterns: [String]? = nil,
        inclusionPrefixes: [String]? = nil
    )
    {
        self.accessControlListConfiguration = accessControlListConfiguration
        self.bucketName = bucketName
        self.documentsMetadataConfiguration = documentsMetadataConfiguration
        self.exclusionPatterns = exclusionPatterns
        self.inclusionPatterns = inclusionPatterns
        self.inclusionPrefixes = inclusionPrefixes
    }
}

extension S3Path: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension S3Path: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Path(bucket: \(String(describing: bucket)), key: \(String(describing: key)))"}
}

/// <p>Information required to find a specific file in an Amazon S3
///             bucket.</p>
public struct S3Path: Equatable {
    /// <p>The name of the S3 bucket that contains the file.</p>
    public let bucket: String?
    /// <p>The name of the file.</p>
    public let key: String?

    public init (
        bucket: String? = nil,
        key: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
    }
}

extension SalesforceChatterFeedConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case fieldMappings = "FieldMappings"
        case includeFilterTypes = "IncludeFilterTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let includeFilterTypes = includeFilterTypes {
            var includeFilterTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeFilterTypes)
            for salesforcechatterfeedincludefiltertypes0 in includeFilterTypes {
                try includeFilterTypesContainer.encode(salesforcechatterfeedincludefiltertypes0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let includeFilterTypesContainer = try containerValues.decodeIfPresent([SalesforceChatterFeedIncludeFilterType?].self, forKey: .includeFilterTypes)
        var includeFilterTypesDecoded0:[SalesforceChatterFeedIncludeFilterType]? = nil
        if let includeFilterTypesContainer = includeFilterTypesContainer {
            includeFilterTypesDecoded0 = [SalesforceChatterFeedIncludeFilterType]()
            for string0 in includeFilterTypesContainer {
                if let string0 = string0 {
                    includeFilterTypesDecoded0?.append(string0)
                }
            }
        }
        includeFilterTypes = includeFilterTypesDecoded0
    }
}

extension SalesforceChatterFeedConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceChatterFeedConfiguration(documentDataFieldName: \(String(describing: documentDataFieldName)), documentTitleFieldName: \(String(describing: documentTitleFieldName)), fieldMappings: \(String(describing: fieldMappings)), includeFilterTypes: \(String(describing: includeFilterTypes)))"}
}

/// <p>Defines configuration for syncing a Salesforce chatter feed. The
///             contents of the object comes from the Salesforce FeedItem
///             table.</p>
public struct SalesforceChatterFeedConfiguration: Equatable {
    /// <p>The name of the column in the Salesforce FeedItem table that
    ///             contains the content to index. Typically this is the
    ///                 <code>Body</code> column.</p>
    public let documentDataFieldName: String?
    /// <p>The name of the column in the Salesforce FeedItem table that
    ///             contains the title of the document. This is typically the
    ///                 <code>Title</code> column.</p>
    public let documentTitleFieldName: String?
    /// <p>Maps fields from a Salesforce chatter feed into Amazon Kendra index
    ///             fields.</p>
    public let fieldMappings: [DataSourceToIndexFieldMapping]?
    /// <p>Filters the documents in the feed based on status of the user.
    ///             When you specify <code>ACTIVE_USERS</code> only documents from users
    ///             who have an active account are indexed. When you specify
    ///                 <code>STANDARD_USER</code> only documents for Salesforce
    ///             standard users are documented. You can specify both.</p>
    public let includeFilterTypes: [SalesforceChatterFeedIncludeFilterType]?

    public init (
        documentDataFieldName: String? = nil,
        documentTitleFieldName: String? = nil,
        fieldMappings: [DataSourceToIndexFieldMapping]? = nil,
        includeFilterTypes: [SalesforceChatterFeedIncludeFilterType]? = nil
    )
    {
        self.documentDataFieldName = documentDataFieldName
        self.documentTitleFieldName = documentTitleFieldName
        self.fieldMappings = fieldMappings
        self.includeFilterTypes = includeFilterTypes
    }
}

public enum SalesforceChatterFeedIncludeFilterType {
    case activeUser
    case standardUser
    case sdkUnknown(String)
}

extension SalesforceChatterFeedIncludeFilterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SalesforceChatterFeedIncludeFilterType] {
        return [
            .activeUser,
            .standardUser,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activeUser: return "ACTIVE_USER"
        case .standardUser: return "STANDARD_USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SalesforceChatterFeedIncludeFilterType(rawValue: rawValue) ?? SalesforceChatterFeedIncludeFilterType.sdkUnknown(rawValue)
    }
}

extension SalesforceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case chatterFeedConfiguration = "ChatterFeedConfiguration"
        case crawlAttachments = "CrawlAttachments"
        case excludeAttachmentFilePatterns = "ExcludeAttachmentFilePatterns"
        case includeAttachmentFilePatterns = "IncludeAttachmentFilePatterns"
        case knowledgeArticleConfiguration = "KnowledgeArticleConfiguration"
        case secretArn = "SecretArn"
        case serverUrl = "ServerUrl"
        case standardObjectAttachmentConfiguration = "StandardObjectAttachmentConfiguration"
        case standardObjectConfigurations = "StandardObjectConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatterFeedConfiguration = chatterFeedConfiguration {
            try encodeContainer.encode(chatterFeedConfiguration, forKey: .chatterFeedConfiguration)
        }
        if crawlAttachments != false {
            try encodeContainer.encode(crawlAttachments, forKey: .crawlAttachments)
        }
        if let excludeAttachmentFilePatterns = excludeAttachmentFilePatterns {
            var excludeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in excludeAttachmentFilePatterns {
                try excludeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let includeAttachmentFilePatterns = includeAttachmentFilePatterns {
            var includeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in includeAttachmentFilePatterns {
                try includeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let knowledgeArticleConfiguration = knowledgeArticleConfiguration {
            try encodeContainer.encode(knowledgeArticleConfiguration, forKey: .knowledgeArticleConfiguration)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let serverUrl = serverUrl {
            try encodeContainer.encode(serverUrl, forKey: .serverUrl)
        }
        if let standardObjectAttachmentConfiguration = standardObjectAttachmentConfiguration {
            try encodeContainer.encode(standardObjectAttachmentConfiguration, forKey: .standardObjectAttachmentConfiguration)
        }
        if let standardObjectConfigurations = standardObjectConfigurations {
            var standardObjectConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standardObjectConfigurations)
            for salesforcestandardobjectconfigurationlist0 in standardObjectConfigurations {
                try standardObjectConfigurationsContainer.encode(salesforcestandardobjectconfigurationlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let standardObjectConfigurationsContainer = try containerValues.decodeIfPresent([SalesforceStandardObjectConfiguration?].self, forKey: .standardObjectConfigurations)
        var standardObjectConfigurationsDecoded0:[SalesforceStandardObjectConfiguration]? = nil
        if let standardObjectConfigurationsContainer = standardObjectConfigurationsContainer {
            standardObjectConfigurationsDecoded0 = [SalesforceStandardObjectConfiguration]()
            for structure0 in standardObjectConfigurationsContainer {
                if let structure0 = structure0 {
                    standardObjectConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        standardObjectConfigurations = standardObjectConfigurationsDecoded0
        let knowledgeArticleConfigurationDecoded = try containerValues.decodeIfPresent(SalesforceKnowledgeArticleConfiguration.self, forKey: .knowledgeArticleConfiguration)
        knowledgeArticleConfiguration = knowledgeArticleConfigurationDecoded
        let chatterFeedConfigurationDecoded = try containerValues.decodeIfPresent(SalesforceChatterFeedConfiguration.self, forKey: .chatterFeedConfiguration)
        chatterFeedConfiguration = chatterFeedConfigurationDecoded
        let crawlAttachmentsDecoded = try containerValues.decode(Bool.self, forKey: .crawlAttachments)
        crawlAttachments = crawlAttachmentsDecoded
        let standardObjectAttachmentConfigurationDecoded = try containerValues.decodeIfPresent(SalesforceStandardObjectAttachmentConfiguration.self, forKey: .standardObjectAttachmentConfiguration)
        standardObjectAttachmentConfiguration = standardObjectAttachmentConfigurationDecoded
        let includeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .includeAttachmentFilePatterns)
        var includeAttachmentFilePatternsDecoded0:[String]? = nil
        if let includeAttachmentFilePatternsContainer = includeAttachmentFilePatternsContainer {
            includeAttachmentFilePatternsDecoded0 = [String]()
            for string0 in includeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    includeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        includeAttachmentFilePatterns = includeAttachmentFilePatternsDecoded0
        let excludeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludeAttachmentFilePatterns)
        var excludeAttachmentFilePatternsDecoded0:[String]? = nil
        if let excludeAttachmentFilePatternsContainer = excludeAttachmentFilePatternsContainer {
            excludeAttachmentFilePatternsDecoded0 = [String]()
            for string0 in excludeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    excludeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        excludeAttachmentFilePatterns = excludeAttachmentFilePatternsDecoded0
    }
}

extension SalesforceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceConfiguration(chatterFeedConfiguration: \(String(describing: chatterFeedConfiguration)), crawlAttachments: \(String(describing: crawlAttachments)), excludeAttachmentFilePatterns: \(String(describing: excludeAttachmentFilePatterns)), includeAttachmentFilePatterns: \(String(describing: includeAttachmentFilePatterns)), knowledgeArticleConfiguration: \(String(describing: knowledgeArticleConfiguration)), secretArn: \(String(describing: secretArn)), serverUrl: \(String(describing: serverUrl)), standardObjectAttachmentConfiguration: \(String(describing: standardObjectAttachmentConfiguration)), standardObjectConfigurations: \(String(describing: standardObjectConfigurations)))"}
}

/// <p>Provides configuration information for connecting to a Salesforce
///             data source.</p>
public struct SalesforceConfiguration: Equatable {
    /// <p>Specifies configuration information for Salesforce chatter
    ///             feeds.</p>
    public let chatterFeedConfiguration: SalesforceChatterFeedConfiguration?
    /// <p>Indicates whether Amazon Kendra should index attachments to Salesforce
    ///             objects.</p>
    public let crawlAttachments: Bool
    /// <p>A list of regular expression patterns. Documents that match the
    ///             patterns are excluded from the index. Documents that don't match the
    ///             patterns are included in the index. If a document matches both an
    ///             exclusion pattern and an inclusion pattern, the document is not
    ///             included in the index.</p>
    ///         <p>The regex is applied to the name of the attached file.</p>
    public let excludeAttachmentFilePatterns: [String]?
    /// <p>A list of regular expression patterns. Documents that match the
    ///             patterns are included in the index. Documents that don't match the
    ///             patterns are excluded from the index. If a document matches both an
    ///             inclusion pattern and an exclusion pattern, the document is not
    ///             included in the index.</p>
    ///         <p>The regex is applied to the name of the attached file.</p>
    public let includeAttachmentFilePatterns: [String]?
    /// <p>Specifies configuration information for the knowledge article
    ///             types that Amazon Kendra indexes. Amazon Kendra indexes standard knowledge
    ///             articles and the standard fields of knowledge articles, or the
    ///             custom fields of custom knowledge articles, but not both.</p>
    public let knowledgeArticleConfiguration: SalesforceKnowledgeArticleConfiguration?
    /// <p>The Amazon Resource Name (ARN) of an AWS Secrets Manager secret
    ///             that contains the key/value pairs required to connect to your
    ///             Salesforce instance. The secret must contain a JSON structure with
    ///             the following keys:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>authenticationUrl - The OAUTH endpoint that Amazon Kendra
    ///                     connects to get an OAUTH token. </p>
    ///             </li>
    ///             <li>
    ///                 <p>consumerKey - The application public key generated when
    ///                     you created your Salesforce application.</p>
    ///             </li>
    ///             <li>
    ///                 <p>consumerSecret - The application private key generated
    ///                     when you created your Salesforce application.</p>
    ///             </li>
    ///             <li>
    ///                 <p>password - The password associated with the user logging
    ///                     in to the Salesforce instance.</p>
    ///             </li>
    ///             <li>
    ///                 <p>securityToken - The token associated with the user account
    ///                     logging in to the Salesforce instance.</p>
    ///             </li>
    ///             <li>
    ///                 <p>username - The user name of the user logging in to the
    ///                     Salesforce instance.</p>
    ///             </li>
    ///          </ul>
    public let secretArn: String?
    /// <p>The instance URL for the Salesforce site that you want to
    ///             index.</p>
    public let serverUrl: String?
    /// <p>Provides configuration information for processing attachments to
    ///             Salesforce standard objects. </p>
    public let standardObjectAttachmentConfiguration: SalesforceStandardObjectAttachmentConfiguration?
    /// <p>Specifies the Salesforce standard objects that Amazon Kendra
    ///             indexes.</p>
    public let standardObjectConfigurations: [SalesforceStandardObjectConfiguration]?

    public init (
        chatterFeedConfiguration: SalesforceChatterFeedConfiguration? = nil,
        crawlAttachments: Bool = false,
        excludeAttachmentFilePatterns: [String]? = nil,
        includeAttachmentFilePatterns: [String]? = nil,
        knowledgeArticleConfiguration: SalesforceKnowledgeArticleConfiguration? = nil,
        secretArn: String? = nil,
        serverUrl: String? = nil,
        standardObjectAttachmentConfiguration: SalesforceStandardObjectAttachmentConfiguration? = nil,
        standardObjectConfigurations: [SalesforceStandardObjectConfiguration]? = nil
    )
    {
        self.chatterFeedConfiguration = chatterFeedConfiguration
        self.crawlAttachments = crawlAttachments
        self.excludeAttachmentFilePatterns = excludeAttachmentFilePatterns
        self.includeAttachmentFilePatterns = includeAttachmentFilePatterns
        self.knowledgeArticleConfiguration = knowledgeArticleConfiguration
        self.secretArn = secretArn
        self.serverUrl = serverUrl
        self.standardObjectAttachmentConfiguration = standardObjectAttachmentConfiguration
        self.standardObjectConfigurations = standardObjectConfigurations
    }
}

extension SalesforceCustomKnowledgeArticleTypeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case fieldMappings = "FieldMappings"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
    }
}

extension SalesforceCustomKnowledgeArticleTypeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceCustomKnowledgeArticleTypeConfiguration(documentDataFieldName: \(String(describing: documentDataFieldName)), documentTitleFieldName: \(String(describing: documentTitleFieldName)), fieldMappings: \(String(describing: fieldMappings)), name: \(String(describing: name)))"}
}

/// <p>Provides configuration information for indexing Salesforce custom
///             articles.</p>
public struct SalesforceCustomKnowledgeArticleTypeConfiguration: Equatable {
    /// <p>The name of the field in the custom knowledge article that
    ///             contains the document data to index.</p>
    public let documentDataFieldName: String?
    /// <p>The name of the field in the custom knowledge article that
    ///             contains the document title.</p>
    public let documentTitleFieldName: String?
    /// <p>One or more objects that map fields in the custom knowledge
    ///             article to fields in the Amazon Kendra index.</p>
    public let fieldMappings: [DataSourceToIndexFieldMapping]?
    /// <p>The name of the configuration.</p>
    public let name: String?

    public init (
        documentDataFieldName: String? = nil,
        documentTitleFieldName: String? = nil,
        fieldMappings: [DataSourceToIndexFieldMapping]? = nil,
        name: String? = nil
    )
    {
        self.documentDataFieldName = documentDataFieldName
        self.documentTitleFieldName = documentTitleFieldName
        self.fieldMappings = fieldMappings
        self.name = name
    }
}

extension SalesforceKnowledgeArticleConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customKnowledgeArticleTypeConfigurations = "CustomKnowledgeArticleTypeConfigurations"
        case includedStates = "IncludedStates"
        case standardKnowledgeArticleTypeConfiguration = "StandardKnowledgeArticleTypeConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customKnowledgeArticleTypeConfigurations = customKnowledgeArticleTypeConfigurations {
            var customKnowledgeArticleTypeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customKnowledgeArticleTypeConfigurations)
            for salesforcecustomknowledgearticletypeconfigurationlist0 in customKnowledgeArticleTypeConfigurations {
                try customKnowledgeArticleTypeConfigurationsContainer.encode(salesforcecustomknowledgearticletypeconfigurationlist0)
            }
        }
        if let includedStates = includedStates {
            var includedStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includedStates)
            for salesforceknowledgearticlestatelist0 in includedStates {
                try includedStatesContainer.encode(salesforceknowledgearticlestatelist0.rawValue)
            }
        }
        if let standardKnowledgeArticleTypeConfiguration = standardKnowledgeArticleTypeConfiguration {
            try encodeContainer.encode(standardKnowledgeArticleTypeConfiguration, forKey: .standardKnowledgeArticleTypeConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includedStatesContainer = try containerValues.decodeIfPresent([SalesforceKnowledgeArticleState?].self, forKey: .includedStates)
        var includedStatesDecoded0:[SalesforceKnowledgeArticleState]? = nil
        if let includedStatesContainer = includedStatesContainer {
            includedStatesDecoded0 = [SalesforceKnowledgeArticleState]()
            for string0 in includedStatesContainer {
                if let string0 = string0 {
                    includedStatesDecoded0?.append(string0)
                }
            }
        }
        includedStates = includedStatesDecoded0
        let standardKnowledgeArticleTypeConfigurationDecoded = try containerValues.decodeIfPresent(SalesforceStandardKnowledgeArticleTypeConfiguration.self, forKey: .standardKnowledgeArticleTypeConfiguration)
        standardKnowledgeArticleTypeConfiguration = standardKnowledgeArticleTypeConfigurationDecoded
        let customKnowledgeArticleTypeConfigurationsContainer = try containerValues.decodeIfPresent([SalesforceCustomKnowledgeArticleTypeConfiguration?].self, forKey: .customKnowledgeArticleTypeConfigurations)
        var customKnowledgeArticleTypeConfigurationsDecoded0:[SalesforceCustomKnowledgeArticleTypeConfiguration]? = nil
        if let customKnowledgeArticleTypeConfigurationsContainer = customKnowledgeArticleTypeConfigurationsContainer {
            customKnowledgeArticleTypeConfigurationsDecoded0 = [SalesforceCustomKnowledgeArticleTypeConfiguration]()
            for structure0 in customKnowledgeArticleTypeConfigurationsContainer {
                if let structure0 = structure0 {
                    customKnowledgeArticleTypeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        customKnowledgeArticleTypeConfigurations = customKnowledgeArticleTypeConfigurationsDecoded0
    }
}

extension SalesforceKnowledgeArticleConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceKnowledgeArticleConfiguration(customKnowledgeArticleTypeConfigurations: \(String(describing: customKnowledgeArticleTypeConfigurations)), includedStates: \(String(describing: includedStates)), standardKnowledgeArticleTypeConfiguration: \(String(describing: standardKnowledgeArticleTypeConfiguration)))"}
}

/// <p>Specifies configuration information for the knowledge article
///             types that Amazon Kendra indexes. Amazon Kendra indexes standard knowledge
///             articles and the standard fields of knowledge articles, or the
///             custom fields of custom knowledge articles, but not both </p>
public struct SalesforceKnowledgeArticleConfiguration: Equatable {
    /// <p>Provides configuration information for custom Salesforce knowledge
    ///             articles.</p>
    public let customKnowledgeArticleTypeConfigurations: [SalesforceCustomKnowledgeArticleTypeConfiguration]?
    /// <p>Specifies the document states that should be included when
    ///             Amazon Kendra indexes knowledge articles. You must specify at least one
    ///             state.</p>
    public let includedStates: [SalesforceKnowledgeArticleState]?
    /// <p>Provides configuration information for standard Salesforce
    ///             knowledge articles.</p>
    public let standardKnowledgeArticleTypeConfiguration: SalesforceStandardKnowledgeArticleTypeConfiguration?

    public init (
        customKnowledgeArticleTypeConfigurations: [SalesforceCustomKnowledgeArticleTypeConfiguration]? = nil,
        includedStates: [SalesforceKnowledgeArticleState]? = nil,
        standardKnowledgeArticleTypeConfiguration: SalesforceStandardKnowledgeArticleTypeConfiguration? = nil
    )
    {
        self.customKnowledgeArticleTypeConfigurations = customKnowledgeArticleTypeConfigurations
        self.includedStates = includedStates
        self.standardKnowledgeArticleTypeConfiguration = standardKnowledgeArticleTypeConfiguration
    }
}

public enum SalesforceKnowledgeArticleState {
    case archived
    case draft
    case published
    case sdkUnknown(String)
}

extension SalesforceKnowledgeArticleState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SalesforceKnowledgeArticleState] {
        return [
            .archived,
            .draft,
            .published,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .archived: return "ARCHIVED"
        case .draft: return "DRAFT"
        case .published: return "PUBLISHED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SalesforceKnowledgeArticleState(rawValue: rawValue) ?? SalesforceKnowledgeArticleState.sdkUnknown(rawValue)
    }
}

extension SalesforceStandardKnowledgeArticleTypeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case fieldMappings = "FieldMappings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
    }
}

extension SalesforceStandardKnowledgeArticleTypeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceStandardKnowledgeArticleTypeConfiguration(documentDataFieldName: \(String(describing: documentDataFieldName)), documentTitleFieldName: \(String(describing: documentTitleFieldName)), fieldMappings: \(String(describing: fieldMappings)))"}
}

/// <p>Provides configuration information for standard Salesforce
///             knowledge articles.</p>
public struct SalesforceStandardKnowledgeArticleTypeConfiguration: Equatable {
    /// <p>The name of the field that contains the document data to
    ///             index.</p>
    public let documentDataFieldName: String?
    /// <p>The name of the field that contains the document title.</p>
    public let documentTitleFieldName: String?
    /// <p>One or more objects that map fields in the knowledge article to
    ///             Amazon Kendra index fields. The index field must exist before you can map
    ///             a Salesforce field to it.</p>
    public let fieldMappings: [DataSourceToIndexFieldMapping]?

    public init (
        documentDataFieldName: String? = nil,
        documentTitleFieldName: String? = nil,
        fieldMappings: [DataSourceToIndexFieldMapping]? = nil
    )
    {
        self.documentDataFieldName = documentDataFieldName
        self.documentTitleFieldName = documentTitleFieldName
        self.fieldMappings = fieldMappings
    }
}

extension SalesforceStandardObjectAttachmentConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentTitleFieldName = "DocumentTitleFieldName"
        case fieldMappings = "FieldMappings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
    }
}

extension SalesforceStandardObjectAttachmentConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceStandardObjectAttachmentConfiguration(documentTitleFieldName: \(String(describing: documentTitleFieldName)), fieldMappings: \(String(describing: fieldMappings)))"}
}

/// <p>Provides configuration information for processing attachments to
///             Salesforce standard objects. </p>
public struct SalesforceStandardObjectAttachmentConfiguration: Equatable {
    /// <p>The name of the field used for the document title.</p>
    public let documentTitleFieldName: String?
    /// <p>One or more objects that map fields in attachments to Amazon Kendra
    ///             index fields.</p>
    public let fieldMappings: [DataSourceToIndexFieldMapping]?

    public init (
        documentTitleFieldName: String? = nil,
        fieldMappings: [DataSourceToIndexFieldMapping]? = nil
    )
    {
        self.documentTitleFieldName = documentTitleFieldName
        self.fieldMappings = fieldMappings
    }
}

extension SalesforceStandardObjectConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case fieldMappings = "FieldMappings"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SalesforceStandardObjectName.self, forKey: .name)
        name = nameDecoded
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
    }
}

extension SalesforceStandardObjectConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceStandardObjectConfiguration(documentDataFieldName: \(String(describing: documentDataFieldName)), documentTitleFieldName: \(String(describing: documentTitleFieldName)), fieldMappings: \(String(describing: fieldMappings)), name: \(String(describing: name)))"}
}

/// <p>Specifies configuration information for indexing a single standard
///             object.</p>
public struct SalesforceStandardObjectConfiguration: Equatable {
    /// <p>The name of the field in the standard object table that contains
    ///             the document contents.</p>
    public let documentDataFieldName: String?
    /// <p>The name of the field in the standard object table that contains
    ///             the document title.</p>
    public let documentTitleFieldName: String?
    /// <p>One or more objects that map fields in the standard object to
    ///             Amazon Kendra index fields. The index field must exist before you can map
    ///             a Salesforce field to it.</p>
    public let fieldMappings: [DataSourceToIndexFieldMapping]?
    /// <p>The name of the standard object.</p>
    public let name: SalesforceStandardObjectName?

    public init (
        documentDataFieldName: String? = nil,
        documentTitleFieldName: String? = nil,
        fieldMappings: [DataSourceToIndexFieldMapping]? = nil,
        name: SalesforceStandardObjectName? = nil
    )
    {
        self.documentDataFieldName = documentDataFieldName
        self.documentTitleFieldName = documentTitleFieldName
        self.fieldMappings = fieldMappings
        self.name = name
    }
}

public enum SalesforceStandardObjectName {
    case account
    case campaign
    case `case`
    case contact
    case contract
    case document
    case group
    case idea
    case lead
    case opportunity
    case partner
    case pricebook
    case product
    case profile
    case solution
    case task
    case user
    case sdkUnknown(String)
}

extension SalesforceStandardObjectName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SalesforceStandardObjectName] {
        return [
            .account,
            .campaign,
            .case,
            .contact,
            .contract,
            .document,
            .group,
            .idea,
            .lead,
            .opportunity,
            .partner,
            .pricebook,
            .product,
            .profile,
            .solution,
            .task,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .account: return "ACCOUNT"
        case .campaign: return "CAMPAIGN"
        case .case: return "CASE"
        case .contact: return "CONTACT"
        case .contract: return "CONTRACT"
        case .document: return "DOCUMENT"
        case .group: return "GROUP"
        case .idea: return "IDEA"
        case .lead: return "LEAD"
        case .opportunity: return "OPPORTUNITY"
        case .partner: return "PARTNER"
        case .pricebook: return "PRICEBOOK"
        case .product: return "PRODUCT"
        case .profile: return "PROFILE"
        case .solution: return "SOLUTION"
        case .task: return "TASK"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SalesforceStandardObjectName(rawValue: rawValue) ?? SalesforceStandardObjectName.sdkUnknown(rawValue)
    }
}

extension ScoreAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scoreConfidence = "ScoreConfidence"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scoreConfidence = scoreConfidence {
            try encodeContainer.encode(scoreConfidence.rawValue, forKey: .scoreConfidence)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreConfidenceDecoded = try containerValues.decodeIfPresent(ScoreConfidence.self, forKey: .scoreConfidence)
        scoreConfidence = scoreConfidenceDecoded
    }
}

extension ScoreAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScoreAttributes(scoreConfidence: \(String(describing: scoreConfidence)))"}
}

/// <p>Provides a relative ranking that indicates how confident Amazon Kendra is
///          that the response matches the query.</p>
public struct ScoreAttributes: Equatable {
    /// <p>A relative ranking for how well the response matches the
    ///          query.</p>
    public let scoreConfidence: ScoreConfidence?

    public init (
        scoreConfidence: ScoreConfidence? = nil
    )
    {
        self.scoreConfidence = scoreConfidence
    }
}

/// Enumeration for query score confidence.
public enum ScoreConfidence {
    case high
    case low
    case medium
    case veryHigh
    case sdkUnknown(String)
}

extension ScoreConfidence : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScoreConfidence] {
        return [
            .high,
            .low,
            .medium,
            .veryHigh,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "HIGH"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case .veryHigh: return "VERY_HIGH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScoreConfidence(rawValue: rawValue) ?? ScoreConfidence.sdkUnknown(rawValue)
    }
}

extension Search: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayable = "Displayable"
        case facetable = "Facetable"
        case searchable = "Searchable"
        case sortable = "Sortable"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if displayable != false {
            try encodeContainer.encode(displayable, forKey: .displayable)
        }
        if facetable != false {
            try encodeContainer.encode(facetable, forKey: .facetable)
        }
        if searchable != false {
            try encodeContainer.encode(searchable, forKey: .searchable)
        }
        if sortable != false {
            try encodeContainer.encode(sortable, forKey: .sortable)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetableDecoded = try containerValues.decode(Bool.self, forKey: .facetable)
        facetable = facetableDecoded
        let searchableDecoded = try containerValues.decode(Bool.self, forKey: .searchable)
        searchable = searchableDecoded
        let displayableDecoded = try containerValues.decode(Bool.self, forKey: .displayable)
        displayable = displayableDecoded
        let sortableDecoded = try containerValues.decode(Bool.self, forKey: .sortable)
        sortable = sortableDecoded
    }
}

extension Search: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Search(displayable: \(String(describing: displayable)), facetable: \(String(describing: facetable)), searchable: \(String(describing: searchable)), sortable: \(String(describing: sortable)))"}
}

/// <p>Provides information about how a custom index field is used during
///             a search.</p>
public struct Search: Equatable {
    /// <p>Determines whether the field is returned in the query response.
    ///             The default is <code>true</code>.</p>
    public let displayable: Bool
    /// <p>Indicates that the field can be used to create search facets, a
    ///             count of results for each value in the field. The default is
    ///                 <code>false</code> .</p>
    public let facetable: Bool
    /// <p>Determines whether the field is used in the search. If the
    ///                 <code>Searchable</code> field is <code>true</code>, you can use
    ///             relevance tuning to manually tune how Amazon Kendra weights the field in
    ///             the search. The default is <code>true</code> for string fields and
    ///                 <code>false</code> for number and date fields.</p>
    public let searchable: Bool
    /// <p>Determines whether the field can be used to sort the results of a
    ///             query. If you specify sorting on a field that does not have
    ///                 <code>Sortable</code> set to <code>true</code>, Amazon Kendra returns an
    ///             exception. The default is <code>false</code>.</p>
    public let sortable: Bool

    public init (
        displayable: Bool = false,
        facetable: Bool = false,
        searchable: Bool = false,
        sortable: Bool = false
    )
    {
        self.displayable = displayable
        self.facetable = facetable
        self.searchable = searchable
        self.sortable = sortable
    }
}

extension ServerSideEncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension ServerSideEncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerSideEncryptionConfiguration(kmsKeyId: \(String(describing: kmsKeyId)))"}
}

/// <p>Provides the identifier of the AWS KMS customer master key (CMK)
///             used to encrypt data indexed by Amazon Kendra. Amazon Kendra doesn't support
///             asymmetric CMKs.</p>
public struct ServerSideEncryptionConfiguration: Equatable {
    /// <p>The identifier of the AWS KMS customer master key (CMK). Amazon Kendra
    ///             doesn't support asymmetric CMKs.</p>
    public let kmsKeyId: String?

    public init (
        kmsKeyId: String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
    }
}

public enum ServiceNowAuthenticationType {
    case httpBasic
    case oauth2
    case sdkUnknown(String)
}

extension ServiceNowAuthenticationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceNowAuthenticationType] {
        return [
            .httpBasic,
            .oauth2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .httpBasic: return "HTTP_BASIC"
        case .oauth2: return "OAUTH2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceNowAuthenticationType(rawValue: rawValue) ?? ServiceNowAuthenticationType.sdkUnknown(rawValue)
    }
}

public enum ServiceNowBuildVersionType {
    case london
    case others
    case sdkUnknown(String)
}

extension ServiceNowBuildVersionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceNowBuildVersionType] {
        return [
            .london,
            .others,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .london: return "LONDON"
        case .others: return "OTHERS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceNowBuildVersionType(rawValue: rawValue) ?? ServiceNowBuildVersionType.sdkUnknown(rawValue)
    }
}

extension ServiceNowConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case hostUrl = "HostUrl"
        case knowledgeArticleConfiguration = "KnowledgeArticleConfiguration"
        case secretArn = "SecretArn"
        case serviceCatalogConfiguration = "ServiceCatalogConfiguration"
        case serviceNowBuildVersion = "ServiceNowBuildVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let hostUrl = hostUrl {
            try encodeContainer.encode(hostUrl, forKey: .hostUrl)
        }
        if let knowledgeArticleConfiguration = knowledgeArticleConfiguration {
            try encodeContainer.encode(knowledgeArticleConfiguration, forKey: .knowledgeArticleConfiguration)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let serviceCatalogConfiguration = serviceCatalogConfiguration {
            try encodeContainer.encode(serviceCatalogConfiguration, forKey: .serviceCatalogConfiguration)
        }
        if let serviceNowBuildVersion = serviceNowBuildVersion {
            try encodeContainer.encode(serviceNowBuildVersion.rawValue, forKey: .serviceNowBuildVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostUrl)
        hostUrl = hostUrlDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let serviceNowBuildVersionDecoded = try containerValues.decodeIfPresent(ServiceNowBuildVersionType.self, forKey: .serviceNowBuildVersion)
        serviceNowBuildVersion = serviceNowBuildVersionDecoded
        let knowledgeArticleConfigurationDecoded = try containerValues.decodeIfPresent(ServiceNowKnowledgeArticleConfiguration.self, forKey: .knowledgeArticleConfiguration)
        knowledgeArticleConfiguration = knowledgeArticleConfigurationDecoded
        let serviceCatalogConfigurationDecoded = try containerValues.decodeIfPresent(ServiceNowServiceCatalogConfiguration.self, forKey: .serviceCatalogConfiguration)
        serviceCatalogConfiguration = serviceCatalogConfigurationDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(ServiceNowAuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension ServiceNowConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNowConfiguration(authenticationType: \(String(describing: authenticationType)), hostUrl: \(String(describing: hostUrl)), knowledgeArticleConfiguration: \(String(describing: knowledgeArticleConfiguration)), secretArn: \(String(describing: secretArn)), serviceCatalogConfiguration: \(String(describing: serviceCatalogConfiguration)), serviceNowBuildVersion: \(String(describing: serviceNowBuildVersion)))"}
}

/// <p>Provides configuration information required to connect to a
///             ServiceNow data source.</p>
public struct ServiceNowConfiguration: Equatable {
    /// <p>Determines the type of authentication used to connect to the
    ///             ServiceNow instance. If you choose <code>HTTP_BASIC</code>, Amazon Kendra is
    ///             authenticated using the user name and password provided in the AWS
    ///             Secrets Manager secret in the <code>SecretArn</code> field. When you
    ///             choose <code>OAUTH2</code>, Amazon Kendra is authenticated using the OAuth
    ///             token and secret provided in the Secrets Manager secret, and the
    ///             user name and password are used to determine which information Amazon Kendra
    ///             has access to.</p>
    ///         <p>When you use <code>OAUTH2</code> authentication, you must generate
    ///             a token and a client secret using the ServiceNow console. For more
    ///             information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html">Using a
    ///                 ServiceNow data source</a>.</p>
    public let authenticationType: ServiceNowAuthenticationType?
    /// <p>The ServiceNow instance that the data source connects to. The host
    ///             endpoint should look like the following:
    ///                 <code>{instance}.service-now.com.</code>
    ///          </p>
    public let hostUrl: String?
    /// <p>Provides configuration information for crawling knowledge articles
    ///             in the ServiceNow site.</p>
    public let knowledgeArticleConfiguration: ServiceNowKnowledgeArticleConfiguration?
    /// <p>The Amazon Resource Name (ARN) of the AWS Secret Manager secret
    ///             that contains the user name and password required to connect to the
    ///             ServiceNow instance.</p>
    public let secretArn: String?
    /// <p>Provides configuration information for crawling service catalogs
    ///             in the ServiceNow site.</p>
    public let serviceCatalogConfiguration: ServiceNowServiceCatalogConfiguration?
    /// <p>The identifier of the release that the ServiceNow host is running.
    ///             If the host is not running the <code>LONDON</code> release, use
    ///                 <code>OTHERS</code>.</p>
    public let serviceNowBuildVersion: ServiceNowBuildVersionType?

    public init (
        authenticationType: ServiceNowAuthenticationType? = nil,
        hostUrl: String? = nil,
        knowledgeArticleConfiguration: ServiceNowKnowledgeArticleConfiguration? = nil,
        secretArn: String? = nil,
        serviceCatalogConfiguration: ServiceNowServiceCatalogConfiguration? = nil,
        serviceNowBuildVersion: ServiceNowBuildVersionType? = nil
    )
    {
        self.authenticationType = authenticationType
        self.hostUrl = hostUrl
        self.knowledgeArticleConfiguration = knowledgeArticleConfiguration
        self.secretArn = secretArn
        self.serviceCatalogConfiguration = serviceCatalogConfiguration
        self.serviceNowBuildVersion = serviceNowBuildVersion
    }
}

extension ServiceNowKnowledgeArticleConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlAttachments = "CrawlAttachments"
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case excludeAttachmentFilePatterns = "ExcludeAttachmentFilePatterns"
        case fieldMappings = "FieldMappings"
        case filterQuery = "FilterQuery"
        case includeAttachmentFilePatterns = "IncludeAttachmentFilePatterns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if crawlAttachments != false {
            try encodeContainer.encode(crawlAttachments, forKey: .crawlAttachments)
        }
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let excludeAttachmentFilePatterns = excludeAttachmentFilePatterns {
            var excludeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in excludeAttachmentFilePatterns {
                try excludeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let filterQuery = filterQuery {
            try encodeContainer.encode(filterQuery, forKey: .filterQuery)
        }
        if let includeAttachmentFilePatterns = includeAttachmentFilePatterns {
            var includeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in includeAttachmentFilePatterns {
                try includeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlAttachmentsDecoded = try containerValues.decode(Bool.self, forKey: .crawlAttachments)
        crawlAttachments = crawlAttachmentsDecoded
        let includeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .includeAttachmentFilePatterns)
        var includeAttachmentFilePatternsDecoded0:[String]? = nil
        if let includeAttachmentFilePatternsContainer = includeAttachmentFilePatternsContainer {
            includeAttachmentFilePatternsDecoded0 = [String]()
            for string0 in includeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    includeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        includeAttachmentFilePatterns = includeAttachmentFilePatternsDecoded0
        let excludeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludeAttachmentFilePatterns)
        var excludeAttachmentFilePatternsDecoded0:[String]? = nil
        if let excludeAttachmentFilePatternsContainer = excludeAttachmentFilePatternsContainer {
            excludeAttachmentFilePatternsDecoded0 = [String]()
            for string0 in excludeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    excludeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        excludeAttachmentFilePatterns = excludeAttachmentFilePatternsDecoded0
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let filterQueryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterQuery)
        filterQuery = filterQueryDecoded
    }
}

extension ServiceNowKnowledgeArticleConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNowKnowledgeArticleConfiguration(crawlAttachments: \(String(describing: crawlAttachments)), documentDataFieldName: \(String(describing: documentDataFieldName)), documentTitleFieldName: \(String(describing: documentTitleFieldName)), excludeAttachmentFilePatterns: \(String(describing: excludeAttachmentFilePatterns)), fieldMappings: \(String(describing: fieldMappings)), filterQuery: \(String(describing: filterQuery)), includeAttachmentFilePatterns: \(String(describing: includeAttachmentFilePatterns)))"}
}

/// <p>Provides configuration information for crawling knowledge articles
///             in the ServiceNow site.</p>
public struct ServiceNowKnowledgeArticleConfiguration: Equatable {
    /// <p>Indicates whether Amazon Kendra should index attachments to knowledge
    ///             articles.</p>
    public let crawlAttachments: Bool
    /// <p>The name of the ServiceNow field that is mapped to the index
    ///             document contents field in the Amazon Kendra index.</p>
    public let documentDataFieldName: String?
    /// <p>The name of the ServiceNow field that is mapped to the index
    ///             document title field.</p>
    public let documentTitleFieldName: String?
    /// <p>List of regular expressions applied to knowledge articles. Items
    ///             that don't match the inclusion pattern are not indexed. The regex is
    ///             applied to the field specified in the
    ///                 <code>PatternTargetField</code>
    ///          </p>
    public let excludeAttachmentFilePatterns: [String]?
    /// <p>Mapping between ServiceNow fields and Amazon Kendra index fields. You
    ///             must create the index field before you map the field.</p>
    public let fieldMappings: [DataSourceToIndexFieldMapping]?
    /// <p>A query that selects the knowledge articles to index. The query
    ///             can return articles from multiple knowledge bases, and the knowledge
    ///             bases can be public or private.</p>
    ///         <p>The query string must be one generated by the ServiceNow console.
    ///             For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/servicenow-query.html">Specifying
    ///                 documents to index with a query</a>. </p>
    public let filterQuery: String?
    /// <p>List of regular expressions applied to knowledge articles. Items
    ///             that don't match the inclusion pattern are not indexed. The regex is
    ///             applied to the field specified in the
    ///                 <code>PatternTargetField</code>.</p>
    public let includeAttachmentFilePatterns: [String]?

    public init (
        crawlAttachments: Bool = false,
        documentDataFieldName: String? = nil,
        documentTitleFieldName: String? = nil,
        excludeAttachmentFilePatterns: [String]? = nil,
        fieldMappings: [DataSourceToIndexFieldMapping]? = nil,
        filterQuery: String? = nil,
        includeAttachmentFilePatterns: [String]? = nil
    )
    {
        self.crawlAttachments = crawlAttachments
        self.documentDataFieldName = documentDataFieldName
        self.documentTitleFieldName = documentTitleFieldName
        self.excludeAttachmentFilePatterns = excludeAttachmentFilePatterns
        self.fieldMappings = fieldMappings
        self.filterQuery = filterQuery
        self.includeAttachmentFilePatterns = includeAttachmentFilePatterns
    }
}

extension ServiceNowServiceCatalogConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlAttachments = "CrawlAttachments"
        case documentDataFieldName = "DocumentDataFieldName"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case excludeAttachmentFilePatterns = "ExcludeAttachmentFilePatterns"
        case fieldMappings = "FieldMappings"
        case includeAttachmentFilePatterns = "IncludeAttachmentFilePatterns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if crawlAttachments != false {
            try encodeContainer.encode(crawlAttachments, forKey: .crawlAttachments)
        }
        if let documentDataFieldName = documentDataFieldName {
            try encodeContainer.encode(documentDataFieldName, forKey: .documentDataFieldName)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let excludeAttachmentFilePatterns = excludeAttachmentFilePatterns {
            var excludeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in excludeAttachmentFilePatterns {
                try excludeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let includeAttachmentFilePatterns = includeAttachmentFilePatterns {
            var includeAttachmentFilePatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeAttachmentFilePatterns)
            for datasourceinclusionsexclusionsstrings0 in includeAttachmentFilePatterns {
                try includeAttachmentFilePatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlAttachmentsDecoded = try containerValues.decode(Bool.self, forKey: .crawlAttachments)
        crawlAttachments = crawlAttachmentsDecoded
        let includeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .includeAttachmentFilePatterns)
        var includeAttachmentFilePatternsDecoded0:[String]? = nil
        if let includeAttachmentFilePatternsContainer = includeAttachmentFilePatternsContainer {
            includeAttachmentFilePatternsDecoded0 = [String]()
            for string0 in includeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    includeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        includeAttachmentFilePatterns = includeAttachmentFilePatternsDecoded0
        let excludeAttachmentFilePatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludeAttachmentFilePatterns)
        var excludeAttachmentFilePatternsDecoded0:[String]? = nil
        if let excludeAttachmentFilePatternsContainer = excludeAttachmentFilePatternsContainer {
            excludeAttachmentFilePatternsDecoded0 = [String]()
            for string0 in excludeAttachmentFilePatternsContainer {
                if let string0 = string0 {
                    excludeAttachmentFilePatternsDecoded0?.append(string0)
                }
            }
        }
        excludeAttachmentFilePatterns = excludeAttachmentFilePatternsDecoded0
        let documentDataFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentDataFieldName)
        documentDataFieldName = documentDataFieldNameDecoded
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
    }
}

extension ServiceNowServiceCatalogConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNowServiceCatalogConfiguration(crawlAttachments: \(String(describing: crawlAttachments)), documentDataFieldName: \(String(describing: documentDataFieldName)), documentTitleFieldName: \(String(describing: documentTitleFieldName)), excludeAttachmentFilePatterns: \(String(describing: excludeAttachmentFilePatterns)), fieldMappings: \(String(describing: fieldMappings)), includeAttachmentFilePatterns: \(String(describing: includeAttachmentFilePatterns)))"}
}

/// <p>Provides configuration information for crawling service catalog
///             items in the ServiceNow site</p>
public struct ServiceNowServiceCatalogConfiguration: Equatable {
    /// <p>Indicates whether Amazon Kendra should crawl attachments to the service
    ///             catalog items. </p>
    public let crawlAttachments: Bool
    /// <p>The name of the ServiceNow field that is mapped to the index
    ///             document contents field in the Amazon Kendra index.</p>
    public let documentDataFieldName: String?
    /// <p>The name of the ServiceNow field that is mapped to the index
    ///             document title field.</p>
    public let documentTitleFieldName: String?
    /// <p>A list of regular expression patterns. Documents that match the
    ///             patterns are excluded from the index. Documents that don't match the
    ///             patterns are included in the index. If a document matches both an
    ///             exclusion pattern and an inclusion pattern, the document is not
    ///             included in the index.</p>
    ///         <p>The regex is applied to the file name of the attachment.</p>
    public let excludeAttachmentFilePatterns: [String]?
    /// <p>Mapping between ServiceNow fields and Amazon Kendra index fields. You
    ///             must create the index field before you map the field.</p>
    public let fieldMappings: [DataSourceToIndexFieldMapping]?
    /// <p>A list of regular expression patterns. Documents that match the
    ///             patterns are included in the index. Documents that don't match the
    ///             patterns are excluded from the index. If a document matches both an
    ///             exclusion pattern and an inclusion pattern, the document is not
    ///             included in the index.</p>
    ///         <p>The regex is applied to the file name of the attachment.</p>
    public let includeAttachmentFilePatterns: [String]?

    public init (
        crawlAttachments: Bool = false,
        documentDataFieldName: String? = nil,
        documentTitleFieldName: String? = nil,
        excludeAttachmentFilePatterns: [String]? = nil,
        fieldMappings: [DataSourceToIndexFieldMapping]? = nil,
        includeAttachmentFilePatterns: [String]? = nil
    )
    {
        self.crawlAttachments = crawlAttachments
        self.documentDataFieldName = documentDataFieldName
        self.documentTitleFieldName = documentTitleFieldName
        self.excludeAttachmentFilePatterns = excludeAttachmentFilePatterns
        self.fieldMappings = fieldMappings
        self.includeAttachmentFilePatterns = includeAttachmentFilePatterns
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SharePointConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlAttachments = "CrawlAttachments"
        case disableLocalGroups = "DisableLocalGroups"
        case documentTitleFieldName = "DocumentTitleFieldName"
        case exclusionPatterns = "ExclusionPatterns"
        case fieldMappings = "FieldMappings"
        case inclusionPatterns = "InclusionPatterns"
        case secretArn = "SecretArn"
        case sharePointVersion = "SharePointVersion"
        case urls = "Urls"
        case useChangeLog = "UseChangeLog"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if crawlAttachments != false {
            try encodeContainer.encode(crawlAttachments, forKey: .crawlAttachments)
        }
        if disableLocalGroups != false {
            try encodeContainer.encode(disableLocalGroups, forKey: .disableLocalGroups)
        }
        if let documentTitleFieldName = documentTitleFieldName {
            try encodeContainer.encode(documentTitleFieldName, forKey: .documentTitleFieldName)
        }
        if let exclusionPatterns = exclusionPatterns {
            var exclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in exclusionPatterns {
                try exclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let fieldMappings = fieldMappings {
            var fieldMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldMappings)
            for datasourcetoindexfieldmappinglist0 in fieldMappings {
                try fieldMappingsContainer.encode(datasourcetoindexfieldmappinglist0)
            }
        }
        if let inclusionPatterns = inclusionPatterns {
            var inclusionPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPatterns)
            for datasourceinclusionsexclusionsstrings0 in inclusionPatterns {
                try inclusionPatternsContainer.encode(datasourceinclusionsexclusionsstrings0)
            }
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sharePointVersion = sharePointVersion {
            try encodeContainer.encode(sharePointVersion.rawValue, forKey: .sharePointVersion)
        }
        if let urls = urls {
            var urlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .urls)
            for sharepointurllist0 in urls {
                try urlsContainer.encode(sharepointurllist0)
            }
        }
        if useChangeLog != false {
            try encodeContainer.encode(useChangeLog, forKey: .useChangeLog)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharePointVersionDecoded = try containerValues.decodeIfPresent(SharePointVersion.self, forKey: .sharePointVersion)
        sharePointVersion = sharePointVersionDecoded
        let urlsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .urls)
        var urlsDecoded0:[String]? = nil
        if let urlsContainer = urlsContainer {
            urlsDecoded0 = [String]()
            for string0 in urlsContainer {
                if let string0 = string0 {
                    urlsDecoded0?.append(string0)
                }
            }
        }
        urls = urlsDecoded0
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let crawlAttachmentsDecoded = try containerValues.decode(Bool.self, forKey: .crawlAttachments)
        crawlAttachments = crawlAttachmentsDecoded
        let useChangeLogDecoded = try containerValues.decode(Bool.self, forKey: .useChangeLog)
        useChangeLog = useChangeLogDecoded
        let inclusionPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .inclusionPatterns)
        var inclusionPatternsDecoded0:[String]? = nil
        if let inclusionPatternsContainer = inclusionPatternsContainer {
            inclusionPatternsDecoded0 = [String]()
            for string0 in inclusionPatternsContainer {
                if let string0 = string0 {
                    inclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        inclusionPatterns = inclusionPatternsDecoded0
        let exclusionPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exclusionPatterns)
        var exclusionPatternsDecoded0:[String]? = nil
        if let exclusionPatternsContainer = exclusionPatternsContainer {
            exclusionPatternsDecoded0 = [String]()
            for string0 in exclusionPatternsContainer {
                if let string0 = string0 {
                    exclusionPatternsDecoded0?.append(string0)
                }
            }
        }
        exclusionPatterns = exclusionPatternsDecoded0
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(DataSourceVpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let fieldMappingsContainer = try containerValues.decodeIfPresent([DataSourceToIndexFieldMapping?].self, forKey: .fieldMappings)
        var fieldMappingsDecoded0:[DataSourceToIndexFieldMapping]? = nil
        if let fieldMappingsContainer = fieldMappingsContainer {
            fieldMappingsDecoded0 = [DataSourceToIndexFieldMapping]()
            for structure0 in fieldMappingsContainer {
                if let structure0 = structure0 {
                    fieldMappingsDecoded0?.append(structure0)
                }
            }
        }
        fieldMappings = fieldMappingsDecoded0
        let documentTitleFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentTitleFieldName)
        documentTitleFieldName = documentTitleFieldNameDecoded
        let disableLocalGroupsDecoded = try containerValues.decode(Bool.self, forKey: .disableLocalGroups)
        disableLocalGroups = disableLocalGroupsDecoded
    }
}

extension SharePointConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SharePointConfiguration(crawlAttachments: \(String(describing: crawlAttachments)), disableLocalGroups: \(String(describing: disableLocalGroups)), documentTitleFieldName: \(String(describing: documentTitleFieldName)), exclusionPatterns: \(String(describing: exclusionPatterns)), fieldMappings: \(String(describing: fieldMappings)), inclusionPatterns: \(String(describing: inclusionPatterns)), secretArn: \(String(describing: secretArn)), sharePointVersion: \(String(describing: sharePointVersion)), urls: \(String(describing: urls)), useChangeLog: \(String(describing: useChangeLog)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

/// <p>Provides configuration information for connecting to a Microsoft
///             SharePoint data source.</p>
public struct SharePointConfiguration: Equatable {
    /// <p>
    ///             <code>TRUE</code> to include attachments to documents stored in
    ///             your Microsoft SharePoint site in the index; otherwise,
    ///                 <code>FALSE</code>.</p>
    public let crawlAttachments: Bool
    /// <p>A Boolean value that specifies whether local
    ///          groups are disabled (<code>True</code>) or enabled (<code>False</code>).
    ///       </p>
    public let disableLocalGroups: Bool
    /// <p>The Microsoft SharePoint attribute field that contains the title
    ///             of the document.</p>
    public let documentTitleFieldName: String?
    /// <p>A list of regular expression patterns. Documents that match the
    ///             patterns are excluded from the index. Documents that don't match the
    ///             patterns are included in the index. If a document matches both an
    ///             exclusion pattern and an inclusion pattern, the document is not
    ///             included in the index.</p>
    ///         <p>The regex is applied to the display URL of the SharePoint
    ///             document.</p>
    public let exclusionPatterns: [String]?
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that
    ///             map Microsoft SharePoint attributes to custom fields in the Amazon Kendra
    ///             index. You must first create the index fields using the
    ///                 <code>UpdateIndex</code> operation before you map SharePoint
    ///             attributes. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping Data Source
    ///                 Fields</a>.</p>
    public let fieldMappings: [DataSourceToIndexFieldMapping]?
    /// <p>A list of regular expression patterns. Documents that match the
    ///             patterns are included in the index. Documents that don't match the
    ///             patterns are excluded from the index. If a document matches both an
    ///             inclusion pattern and an exclusion pattern, the document is not
    ///             included in the index.</p>
    ///         <p>The regex is applied to the display URL of the SharePoint
    ///             document.</p>
    public let inclusionPatterns: [String]?
    /// <p>The Amazon Resource Name (ARN) of credentials stored in AWS
    ///             Secrets Manager. The credentials should be a user/password pair. For
    ///             more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html">Using a
    ///                 Microsoft SharePoint Data Source</a>. For more information
    ///             about AWS Secrets Manager, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html"> What Is AWS
    ///                 Secrets Manager </a> in the <i>AWS Secrets
    ///                 Manager</i> user guide.</p>
    public let secretArn: String?
    /// <p>The version of Microsoft SharePoint that you are using as a data
    ///             source.</p>
    public let sharePointVersion: SharePointVersion?
    /// <p>The URLs of the Microsoft SharePoint site that contains the
    ///             documents that should be indexed.</p>
    public let urls: [String]?
    /// <p>Set to <code>TRUE</code> to use the Microsoft SharePoint change
    ///             log to determine the documents that need to be updated in the index.
    ///             Depending on the size of the SharePoint change log, it may take
    ///             longer for Amazon Kendra to use the change log than it takes it to
    ///             determine the changed documents using the Amazon Kendra document
    ///             crawler.</p>
    public let useChangeLog: Bool
    /// <p>Provides information for connecting to an Amazon VPC.</p>
    public let vpcConfiguration: DataSourceVpcConfiguration?

    public init (
        crawlAttachments: Bool = false,
        disableLocalGroups: Bool = false,
        documentTitleFieldName: String? = nil,
        exclusionPatterns: [String]? = nil,
        fieldMappings: [DataSourceToIndexFieldMapping]? = nil,
        inclusionPatterns: [String]? = nil,
        secretArn: String? = nil,
        sharePointVersion: SharePointVersion? = nil,
        urls: [String]? = nil,
        useChangeLog: Bool = false,
        vpcConfiguration: DataSourceVpcConfiguration? = nil
    )
    {
        self.crawlAttachments = crawlAttachments
        self.disableLocalGroups = disableLocalGroups
        self.documentTitleFieldName = documentTitleFieldName
        self.exclusionPatterns = exclusionPatterns
        self.fieldMappings = fieldMappings
        self.inclusionPatterns = inclusionPatterns
        self.secretArn = secretArn
        self.sharePointVersion = sharePointVersion
        self.urls = urls
        self.useChangeLog = useChangeLog
        self.vpcConfiguration = vpcConfiguration
    }
}

public enum SharePointVersion {
    case sharepointOnline
    case sdkUnknown(String)
}

extension SharePointVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SharePointVersion] {
        return [
            .sharepointOnline,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sharepointOnline: return "SHAREPOINT_ONLINE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SharePointVersion(rawValue: rawValue) ?? SharePointVersion.sdkUnknown(rawValue)
    }
}

public enum SortOrder {
    case asc
    case desc
    case sdkUnknown(String)
}

extension SortOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortOrder] {
        return [
            .asc,
            .desc,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .asc: return "ASC"
        case .desc: return "DESC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
    }
}

extension SortingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentAttributeKey = "DocumentAttributeKey"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentAttributeKey = documentAttributeKey {
            try encodeContainer.encode(documentAttributeKey, forKey: .documentAttributeKey)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentAttributeKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentAttributeKey)
        documentAttributeKey = documentAttributeKeyDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension SortingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SortingConfiguration(documentAttributeKey: \(String(describing: documentAttributeKey)), sortOrder: \(String(describing: sortOrder)))"}
}

/// <p>Specifies the document attribute to use to sort the response to a
///             Amazon Kendra query. You can specify a single attribute for sorting. The
///             attribute must have the <code>Sortable</code> flag set to
///                 <code>true</code>, otherwise Amazon Kendra returns an exception.</p>
///         <p>You can sort attributes of the following types.</p>
///         <ul>
///             <li>
///                 <p>Date value</p>
///             </li>
///             <li>
///                 <p>Long value</p>
///             </li>
///             <li>
///                 <p>String value</p>
///             </li>
///          </ul>
///         <p>You can't sort attributes of the following type.</p>
///         <ul>
///             <li>
///                 <p>String list value</p>
///             </li>
///          </ul>
public struct SortingConfiguration: Equatable {
    /// <p>The name of the document attribute used to sort the response. You
    ///             can use any field that has the <code>Sortable</code> flag set to
    ///             true.</p>
    ///         <p>You can also sort by any of the following built-in
    ///             attributes:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>_category</p>
    ///             </li>
    ///             <li>
    ///                 <p>_created_at</p>
    ///             </li>
    ///             <li>
    ///                 <p>_last_updated_at</p>
    ///             </li>
    ///             <li>
    ///                 <p>_version</p>
    ///             </li>
    ///             <li>
    ///                 <p>_view_count</p>
    ///             </li>
    ///          </ul>
    public let documentAttributeKey: String?
    /// <p>The order that the results should be returned in. In case of ties,
    ///             the relevance assigned to the result by Amazon Kendra is used as the
    ///             tie-breaker.</p>
    public let sortOrder: SortOrder?

    public init (
        documentAttributeKey: String? = nil,
        sortOrder: SortOrder? = nil
    )
    {
        self.documentAttributeKey = documentAttributeKey
        self.sortOrder = sortOrder
    }
}

extension SqlConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queryIdentifiersEnclosingOption = "QueryIdentifiersEnclosingOption"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryIdentifiersEnclosingOption = queryIdentifiersEnclosingOption {
            try encodeContainer.encode(queryIdentifiersEnclosingOption.rawValue, forKey: .queryIdentifiersEnclosingOption)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdentifiersEnclosingOptionDecoded = try containerValues.decodeIfPresent(QueryIdentifiersEnclosingOption.self, forKey: .queryIdentifiersEnclosingOption)
        queryIdentifiersEnclosingOption = queryIdentifiersEnclosingOptionDecoded
    }
}

extension SqlConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlConfiguration(queryIdentifiersEnclosingOption: \(String(describing: queryIdentifiersEnclosingOption)))"}
}

/// <p>Provides information that configures Amazon Kendra to use a SQL
///             database.</p>
public struct SqlConfiguration: Equatable {
    /// <p>Determines whether Amazon Kendra encloses SQL identifiers for tables and
    ///             column names in double quotes (") when making a database
    ///             query.</p>
    ///         <p>By default, Amazon Kendra passes SQL identifiers the way that they are
    ///             entered into the data source configuration. It does not change the
    ///             case of identifiers or enclose them in quotes.</p>
    ///         <p>PostgreSQL internally converts uppercase characters to lower case
    ///             characters in identifiers unless they are quoted. Choosing this
    ///             option encloses identifiers in quotes so that PostgreSQL does not
    ///             convert the character's case.</p>
    ///         <p>For MySQL databases, you must enable the <code>ansi_quotes</code>
    ///             option when you set this field to <code>DOUBLE_QUOTES</code>.</p>
    public let queryIdentifiersEnclosingOption: QueryIdentifiersEnclosingOption?

    public init (
        queryIdentifiersEnclosingOption: QueryIdentifiersEnclosingOption? = nil
    )
    {
        self.queryIdentifiersEnclosingOption = queryIdentifiersEnclosingOption
    }
}

public struct StartDataSourceSyncJobInputBodyMiddleware: Middleware {
    public let id: String = "StartDataSourceSyncJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDataSourceSyncJobInput>
    public typealias MOutput = OperationOutput<StartDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDataSourceSyncJobOutputError>
}

extension StartDataSourceSyncJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDataSourceSyncJobInput(id: \(String(describing: id)), indexId: \(String(describing: indexId)))"}
}

extension StartDataSourceSyncJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct StartDataSourceSyncJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartDataSourceSyncJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDataSourceSyncJobInput>
    public typealias MOutput = OperationOutput<StartDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDataSourceSyncJobOutputError>
}

public struct StartDataSourceSyncJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDataSourceSyncJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDataSourceSyncJobInput>
    public typealias MOutput = OperationOutput<StartDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDataSourceSyncJobOutputError>
}

public struct StartDataSourceSyncJobInput: Equatable {
    /// <p>The identifier of the data source to synchronize.</p>
    public let id: String?
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: String?

    public init (
        id: String? = nil,
        indexId: String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct StartDataSourceSyncJobInputBody: Equatable {
    public let id: String?
    public let indexId: String?
}

extension StartDataSourceSyncJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension StartDataSourceSyncJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDataSourceSyncJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDataSourceSyncJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDataSourceSyncJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDataSourceSyncJobOutputResponse(executionId: \(String(describing: executionId)))"}
}

extension StartDataSourceSyncJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDataSourceSyncJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.executionId = output.executionId
        } else {
            self.executionId = nil
        }
    }
}

public struct StartDataSourceSyncJobOutputResponse: Equatable {
    /// <p>Identifies a particular synchronization job.</p>
    public let executionId: String?

    public init (
        executionId: String? = nil
    )
    {
        self.executionId = executionId
    }
}

struct StartDataSourceSyncJobOutputResponseBody: Equatable {
    public let executionId: String?
}

extension StartDataSourceSyncJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionId = "ExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionId)
        executionId = executionIdDecoded
    }
}

public struct StopDataSourceSyncJobInputBodyMiddleware: Middleware {
    public let id: String = "StopDataSourceSyncJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDataSourceSyncJobInput>
    public typealias MOutput = OperationOutput<StopDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDataSourceSyncJobOutputError>
}

extension StopDataSourceSyncJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDataSourceSyncJobInput(id: \(String(describing: id)), indexId: \(String(describing: indexId)))"}
}

extension StopDataSourceSyncJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }
}

public struct StopDataSourceSyncJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopDataSourceSyncJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDataSourceSyncJobInput>
    public typealias MOutput = OperationOutput<StopDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDataSourceSyncJobOutputError>
}

public struct StopDataSourceSyncJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopDataSourceSyncJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDataSourceSyncJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDataSourceSyncJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDataSourceSyncJobInput>
    public typealias MOutput = OperationOutput<StopDataSourceSyncJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDataSourceSyncJobOutputError>
}

public struct StopDataSourceSyncJobInput: Equatable {
    /// <p>The identifier of the data source for which to stop the
    ///       synchronization jobs.</p>
    public let id: String?
    /// <p>The identifier of the index that contains the data source.</p>
    public let indexId: String?

    public init (
        id: String? = nil,
        indexId: String? = nil
    )
    {
        self.id = id
        self.indexId = indexId
    }
}

struct StopDataSourceSyncJobInputBody: Equatable {
    public let id: String?
    public let indexId: String?
}

extension StopDataSourceSyncJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case indexId = "IndexId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension StopDataSourceSyncJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDataSourceSyncJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDataSourceSyncJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDataSourceSyncJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDataSourceSyncJobOutputResponse()"}
}

extension StopDataSourceSyncJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopDataSourceSyncJobOutputResponse: Equatable {

    public init() {}
}

struct StopDataSourceSyncJobOutputResponseBody: Equatable {
}

extension StopDataSourceSyncJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SubmitFeedbackInputBodyMiddleware: Middleware {
    public let id: String = "SubmitFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubmitFeedbackOutputError>
}

extension SubmitFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubmitFeedbackInput(clickFeedbackItems: \(String(describing: clickFeedbackItems)), indexId: \(String(describing: indexId)), queryId: \(String(describing: queryId)), relevanceFeedbackItems: \(String(describing: relevanceFeedbackItems)))"}
}

extension SubmitFeedbackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clickFeedbackItems = "ClickFeedbackItems"
        case indexId = "IndexId"
        case queryId = "QueryId"
        case relevanceFeedbackItems = "RelevanceFeedbackItems"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clickFeedbackItems = clickFeedbackItems {
            var clickFeedbackItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clickFeedbackItems)
            for clickfeedbacklist0 in clickFeedbackItems {
                try clickFeedbackItemsContainer.encode(clickfeedbacklist0)
            }
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let queryId = queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
        if let relevanceFeedbackItems = relevanceFeedbackItems {
            var relevanceFeedbackItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relevanceFeedbackItems)
            for relevancefeedbacklist0 in relevanceFeedbackItems {
                try relevanceFeedbackItemsContainer.encode(relevancefeedbacklist0)
            }
        }
    }
}

public struct SubmitFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "SubmitFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubmitFeedbackOutputError>
}

public struct SubmitFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "SubmitFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubmitFeedbackOutputError>
}

public struct SubmitFeedbackInput: Equatable {
    /// <p>Tells Amazon Kendra that a particular search result link was chosen
    ///             by the user. </p>
    public let clickFeedbackItems: [ClickFeedback]?
    /// <p>The identifier of the index that was queried.</p>
    public let indexId: String?
    /// <p>The identifier of the specific query for which you are submitting
    ///             feedback. The query ID is returned in the response to the
    ///                 <code>Query</code> operation.</p>
    public let queryId: String?
    /// <p>Provides Amazon Kendra with relevant or not relevant feedback for
    ///             whether a particular item was relevant to the search.</p>
    public let relevanceFeedbackItems: [RelevanceFeedback]?

    public init (
        clickFeedbackItems: [ClickFeedback]? = nil,
        indexId: String? = nil,
        queryId: String? = nil,
        relevanceFeedbackItems: [RelevanceFeedback]? = nil
    )
    {
        self.clickFeedbackItems = clickFeedbackItems
        self.indexId = indexId
        self.queryId = queryId
        self.relevanceFeedbackItems = relevanceFeedbackItems
    }
}

struct SubmitFeedbackInputBody: Equatable {
    public let indexId: String?
    public let queryId: String?
    public let clickFeedbackItems: [ClickFeedback]?
    public let relevanceFeedbackItems: [RelevanceFeedback]?
}

extension SubmitFeedbackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clickFeedbackItems = "ClickFeedbackItems"
        case indexId = "IndexId"
        case queryId = "QueryId"
        case relevanceFeedbackItems = "RelevanceFeedbackItems"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let queryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let clickFeedbackItemsContainer = try containerValues.decodeIfPresent([ClickFeedback?].self, forKey: .clickFeedbackItems)
        var clickFeedbackItemsDecoded0:[ClickFeedback]? = nil
        if let clickFeedbackItemsContainer = clickFeedbackItemsContainer {
            clickFeedbackItemsDecoded0 = [ClickFeedback]()
            for structure0 in clickFeedbackItemsContainer {
                if let structure0 = structure0 {
                    clickFeedbackItemsDecoded0?.append(structure0)
                }
            }
        }
        clickFeedbackItems = clickFeedbackItemsDecoded0
        let relevanceFeedbackItemsContainer = try containerValues.decodeIfPresent([RelevanceFeedback?].self, forKey: .relevanceFeedbackItems)
        var relevanceFeedbackItemsDecoded0:[RelevanceFeedback]? = nil
        if let relevanceFeedbackItemsContainer = relevanceFeedbackItemsContainer {
            relevanceFeedbackItemsDecoded0 = [RelevanceFeedback]()
            for structure0 in relevanceFeedbackItemsContainer {
                if let structure0 = structure0 {
                    relevanceFeedbackItemsDecoded0?.append(structure0)
                }
            }
        }
        relevanceFeedbackItems = relevanceFeedbackItemsDecoded0
    }
}

extension SubmitFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubmitFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubmitFeedbackOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubmitFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubmitFeedbackOutputResponse()"}
}

extension SubmitFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SubmitFeedbackOutputResponse: Equatable {

    public init() {}
}

struct SubmitFeedbackOutputResponseBody: Equatable {
}

extension SubmitFeedbackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Suggestion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(SuggestionValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension Suggestion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Suggestion(id: \(String(describing: id)), value: \(String(describing: value)))"}
}

/// <p>A single query suggestion.</p>
public struct Suggestion: Equatable {
    /// <p>The unique UUID (universally unique identifier) of a single
    ///             query suggestion.</p>
    public let id: String?
    /// <p>The value for the unique UUID (universally unique identifier)
    ///             of a single query suggestion.</p>
    ///         <p>The value is the text string of a suggestion.</p>
    public let value: SuggestionValue?

    public init (
        id: String? = nil,
        value: SuggestionValue? = nil
    )
    {
        self.id = id
        self.value = value
    }
}

extension SuggestionHighlight: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
    }
}

extension SuggestionHighlight: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuggestionHighlight(beginOffset: \(String(describing: beginOffset)), endOffset: \(String(describing: endOffset)))"}
}

/// <p>The text highlights for a single query suggestion.</p>
public struct SuggestionHighlight: Equatable {
    /// <p>The zero-based location in the response string where the highlight starts.</p>
    public let beginOffset: Int?
    /// <p>The zero-based location in the response string where the highlight ends.</p>
    public let endOffset: Int?

    public init (
        beginOffset: Int? = nil,
        endOffset: Int? = nil
    )
    {
        self.beginOffset = beginOffset
        self.endOffset = endOffset
    }
}

extension SuggestionTextWithHighlights: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case highlights = "Highlights"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let highlights = highlights {
            var highlightsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .highlights)
            for suggestionhighlightlist0 in highlights {
                try highlightsContainer.encode(suggestionhighlightlist0)
            }
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let highlightsContainer = try containerValues.decodeIfPresent([SuggestionHighlight?].self, forKey: .highlights)
        var highlightsDecoded0:[SuggestionHighlight]? = nil
        if let highlightsContainer = highlightsContainer {
            highlightsDecoded0 = [SuggestionHighlight]()
            for structure0 in highlightsContainer {
                if let structure0 = structure0 {
                    highlightsDecoded0?.append(structure0)
                }
            }
        }
        highlights = highlightsDecoded0
    }
}

extension SuggestionTextWithHighlights: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuggestionTextWithHighlights(highlights: \(String(describing: highlights)), text: \(String(describing: text)))"}
}

/// <p>Provides text and information about where to highlight the query suggestion text.</p>
public struct SuggestionTextWithHighlights: Equatable {
    /// <p>The beginning and end of the query suggestion text that should be highlighted.</p>
    public let highlights: [SuggestionHighlight]?
    /// <p>The query suggestion text to display to the user.</p>
    public let text: String?

    public init (
        highlights: [SuggestionHighlight]? = nil,
        text: String? = nil
    )
    {
        self.highlights = highlights
        self.text = text
    }
}

extension SuggestionValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(SuggestionTextWithHighlights.self, forKey: .text)
        text = textDecoded
    }
}

extension SuggestionValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuggestionValue(text: \(String(describing: text)))"}
}

/// <p>The <code>SuggestionTextWithHighlights</code> structure information.</p>
public struct SuggestionValue: Equatable {
    /// <p>The <code>SuggestionTextWithHighlights</code> structure that contains
    ///             the query suggestion text and highlights.</p>
    public let text: SuggestionTextWithHighlights?

    public init (
        text: SuggestionTextWithHighlights? = nil
    )
    {
        self.text = text
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A list of key/value pairs that identify an index, FAQ, or data source.
///       Tag keys and values can consist of Unicode letters, digits, white space,
///       and any of the following symbols: _ . : / = + - @.</p>
public struct Tag: Equatable {
    /// <p>The key for the tag. Keys are not case sensitive and must be unique
    ///       for the index, FAQ, or data source.</p>
    public let key: String?
    /// <p>The value associated with the tag. The value may be an empty string
    ///       but it can't be null.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the index, FAQ, or data source to
    ///       tag.</p>
    public let resourceARN: String?
    /// <p>A list of tag keys to add to the index, FAQ, or data source. If a tag
    ///       already exists, the existing value is replaced with the new value.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TextDocumentStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexedTextBytes = "IndexedTextBytes"
        case indexedTextDocumentsCount = "IndexedTextDocumentsCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if indexedTextBytes != 0 {
            try encodeContainer.encode(indexedTextBytes, forKey: .indexedTextBytes)
        }
        if indexedTextDocumentsCount != 0 {
            try encodeContainer.encode(indexedTextDocumentsCount, forKey: .indexedTextDocumentsCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexedTextDocumentsCountDecoded = try containerValues.decode(Int.self, forKey: .indexedTextDocumentsCount)
        indexedTextDocumentsCount = indexedTextDocumentsCountDecoded
        let indexedTextBytesDecoded = try containerValues.decode(Int.self, forKey: .indexedTextBytes)
        indexedTextBytes = indexedTextBytesDecoded
    }
}

extension TextDocumentStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextDocumentStatistics(indexedTextBytes: \(String(describing: indexedTextBytes)), indexedTextDocumentsCount: \(String(describing: indexedTextDocumentsCount)))"}
}

/// <p>Provides information about text documents indexed in an
///             index.</p>
public struct TextDocumentStatistics: Equatable {
    /// <p>The total size, in bytes, of the indexed documents.</p>
    public let indexedTextBytes: Int
    /// <p>The number of text documents indexed.</p>
    public let indexedTextDocumentsCount: Int

    public init (
        indexedTextBytes: Int = 0,
        indexedTextDocumentsCount: Int = 0
    )
    {
        self.indexedTextBytes = indexedTextBytes
        self.indexedTextDocumentsCount = indexedTextDocumentsCount
    }
}

extension TextWithHighlights: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case highlights = "Highlights"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let highlights = highlights {
            var highlightsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .highlights)
            for highlightlist0 in highlights {
                try highlightsContainer.encode(highlightlist0)
            }
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let highlightsContainer = try containerValues.decodeIfPresent([Highlight?].self, forKey: .highlights)
        var highlightsDecoded0:[Highlight]? = nil
        if let highlightsContainer = highlightsContainer {
            highlightsDecoded0 = [Highlight]()
            for structure0 in highlightsContainer {
                if let structure0 = structure0 {
                    highlightsDecoded0?.append(structure0)
                }
            }
        }
        highlights = highlightsDecoded0
    }
}

extension TextWithHighlights: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextWithHighlights(highlights: \(String(describing: highlights)), text: \(String(describing: text)))"}
}

/// <p>Provides text and information about where to highlight the
///             text.</p>
public struct TextWithHighlights: Equatable {
    /// <p>The beginning and end of the text that should be
    ///             highlighted.</p>
    public let highlights: [Highlight]?
    /// <p>The text to display to the user.</p>
    public let text: String?

    public init (
        highlights: [Highlight]? = nil,
        text: String? = nil
    )
    {
        self.highlights = highlights
        self.text = text
    }
}

public enum ThesaurusStatus {
    case active
    case activeButUpdateFailed
    case creating
    case deleting
    case failed
    case updating
    case sdkUnknown(String)
}

extension ThesaurusStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThesaurusStatus] {
        return [
            .active,
            .activeButUpdateFailed,
            .creating,
            .deleting,
            .failed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .activeButUpdateFailed: return "ACTIVE_BUT_UPDATE_FAILED"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThesaurusStatus(rawValue: rawValue) ?? ThesaurusStatus.sdkUnknown(rawValue)
    }
}

extension ThesaurusSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ThesaurusStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension ThesaurusSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThesaurusSummary(createdAt: \(String(describing: createdAt)), id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>An array of summary information for one or more thesauruses.</p>
public struct ThesaurusSummary: Equatable {
    /// <p>The Unix datetime that the thesaurus was created.</p>
    public let createdAt: Date?
    /// <p>The identifier of the thesaurus.</p>
    public let id: String?
    /// <p>The name of the thesaurus.</p>
    public let name: String?
    /// <p>The status of the thesaurus.</p>
    public let status: ThesaurusStatus?
    /// <p>The Unix datetime that the thesaurus was last updated.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        id: String? = nil,
        name: String? = nil,
        status: ThesaurusStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension TimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeRange(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

/// <p>Provides a range of time.</p>
public struct TimeRange: Equatable {
    /// <p>The UNIX datetime of the end of the time range.</p>
    public let endTime: Date?
    /// <p>The UNIX datetime of the beginning of the time range.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the index, FAQ, or data source to
    ///       remove the tag from.</p>
    public let resourceARN: String?
    /// <p>A list of tag keys to remove from the index, FAQ, or data source. If a
    ///       tag key does not exist on the resource, it is ignored.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourceOutputError>
}

extension UpdateDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSourceInput(configuration: \(String(describing: configuration)), description: \(String(describing: description)), id: \(String(describing: id)), indexId: \(String(describing: indexId)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), schedule: \(String(describing: schedule)))"}
}

extension UpdateDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case schedule = "Schedule"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
    }
}

public struct UpdateDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourceOutputError>
}

public struct UpdateDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourceOutputError>
}

public struct UpdateDataSourceInput: Equatable {
    /// <p>Configuration information for a Amazon Kendra data source.</p>
    public let configuration: DataSourceConfiguration?
    /// <p>The new description for the data source.</p>
    public let description: String?
    /// <p>The unique identifier of the data source to update.</p>
    public let id: String?
    /// <p>The identifier of the index that contains the data source to
    ///       update.</p>
    public let indexId: String?
    /// <p>The name of the data source to update. The name of the data source
    ///       can't be updated. To rename a data source you must delete the data source
    ///       and re-create it.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the new role to use when the data
    ///       source is accessing resources on your behalf.</p>
    public let roleArn: String?
    /// <p>The new update schedule for the data source.</p>
    public let schedule: String?

    public init (
        configuration: DataSourceConfiguration? = nil,
        description: String? = nil,
        id: String? = nil,
        indexId: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        schedule: String? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.schedule = schedule
    }
}

struct UpdateDataSourceInputBody: Equatable {
    public let id: String?
    public let name: String?
    public let indexId: String?
    public let configuration: DataSourceConfiguration?
    public let description: String?
    public let schedule: String?
    public let roleArn: String?
}

extension UpdateDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case schedule = "Schedule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DataSourceConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSourceOutputResponse()"}
}

extension UpdateDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDataSourceOutputResponse: Equatable {

    public init() {}
}

struct UpdateDataSourceOutputResponseBody: Equatable {
}

extension UpdateDataSourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateIndexInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIndexInput>
    public typealias MOutput = OperationOutput<UpdateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIndexOutputError>
}

extension UpdateIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIndexInput(capacityUnits: \(String(describing: capacityUnits)), description: \(String(describing: description)), documentMetadataConfigurationUpdates: \(String(describing: documentMetadataConfigurationUpdates)), id: \(String(describing: id)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), userContextPolicy: \(String(describing: userContextPolicy)), userTokenConfigurations: \(String(describing: userTokenConfigurations)))"}
}

extension UpdateIndexInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capacityUnits = "CapacityUnits"
        case description = "Description"
        case documentMetadataConfigurationUpdates = "DocumentMetadataConfigurationUpdates"
        case id = "Id"
        case name = "Name"
        case roleArn = "RoleArn"
        case userContextPolicy = "UserContextPolicy"
        case userTokenConfigurations = "UserTokenConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityUnits = capacityUnits {
            try encodeContainer.encode(capacityUnits, forKey: .capacityUnits)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentMetadataConfigurationUpdates = documentMetadataConfigurationUpdates {
            var documentMetadataConfigurationUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentMetadataConfigurationUpdates)
            for documentmetadataconfigurationlist0 in documentMetadataConfigurationUpdates {
                try documentMetadataConfigurationUpdatesContainer.encode(documentmetadataconfigurationlist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let userContextPolicy = userContextPolicy {
            try encodeContainer.encode(userContextPolicy.rawValue, forKey: .userContextPolicy)
        }
        if let userTokenConfigurations = userTokenConfigurations {
            var userTokenConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userTokenConfigurations)
            for usertokenconfigurationlist0 in userTokenConfigurations {
                try userTokenConfigurationsContainer.encode(usertokenconfigurationlist0)
            }
        }
    }
}

public struct UpdateIndexInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIndexInput>
    public typealias MOutput = OperationOutput<UpdateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIndexOutputError>
}

public struct UpdateIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIndexInput>
    public typealias MOutput = OperationOutput<UpdateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIndexOutputError>
}

public struct UpdateIndexInput: Equatable {
    /// <p>Sets the number of additional storage and query capacity units that
    ///       should be used by the index. You can change the capacity of the index up
    ///       to 5 times per day.</p>
    ///          <p>If you are using extra storage units, you can't reduce the storage
    ///       capacity below that required to meet the storage needs for your
    ///       index.</p>
    public let capacityUnits: CapacityUnitsConfiguration?
    /// <p>A new description for the index.</p>
    public let description: String?
    /// <p>The document metadata to update. </p>
    public let documentMetadataConfigurationUpdates: [DocumentMetadataConfiguration]?
    /// <p>The identifier of the index to update.</p>
    public let id: String?
    /// <p>The name of the index to update.</p>
    public let name: String?
    /// <p>A new IAM role that gives Amazon Kendra permission to access your
    ///       Amazon CloudWatch logs.</p>
    public let roleArn: String?
    /// <p>The user user token context policy.</p>
    public let userContextPolicy: UserContextPolicy?
    /// <p>The user token configuration.</p>
    public let userTokenConfigurations: [UserTokenConfiguration]?

    public init (
        capacityUnits: CapacityUnitsConfiguration? = nil,
        description: String? = nil,
        documentMetadataConfigurationUpdates: [DocumentMetadataConfiguration]? = nil,
        id: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        userContextPolicy: UserContextPolicy? = nil,
        userTokenConfigurations: [UserTokenConfiguration]? = nil
    )
    {
        self.capacityUnits = capacityUnits
        self.description = description
        self.documentMetadataConfigurationUpdates = documentMetadataConfigurationUpdates
        self.id = id
        self.name = name
        self.roleArn = roleArn
        self.userContextPolicy = userContextPolicy
        self.userTokenConfigurations = userTokenConfigurations
    }
}

struct UpdateIndexInputBody: Equatable {
    public let id: String?
    public let name: String?
    public let roleArn: String?
    public let description: String?
    public let documentMetadataConfigurationUpdates: [DocumentMetadataConfiguration]?
    public let capacityUnits: CapacityUnitsConfiguration?
    public let userTokenConfigurations: [UserTokenConfiguration]?
    public let userContextPolicy: UserContextPolicy?
}

extension UpdateIndexInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capacityUnits = "CapacityUnits"
        case description = "Description"
        case documentMetadataConfigurationUpdates = "DocumentMetadataConfigurationUpdates"
        case id = "Id"
        case name = "Name"
        case roleArn = "RoleArn"
        case userContextPolicy = "UserContextPolicy"
        case userTokenConfigurations = "UserTokenConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let documentMetadataConfigurationUpdatesContainer = try containerValues.decodeIfPresent([DocumentMetadataConfiguration?].self, forKey: .documentMetadataConfigurationUpdates)
        var documentMetadataConfigurationUpdatesDecoded0:[DocumentMetadataConfiguration]? = nil
        if let documentMetadataConfigurationUpdatesContainer = documentMetadataConfigurationUpdatesContainer {
            documentMetadataConfigurationUpdatesDecoded0 = [DocumentMetadataConfiguration]()
            for structure0 in documentMetadataConfigurationUpdatesContainer {
                if let structure0 = structure0 {
                    documentMetadataConfigurationUpdatesDecoded0?.append(structure0)
                }
            }
        }
        documentMetadataConfigurationUpdates = documentMetadataConfigurationUpdatesDecoded0
        let capacityUnitsDecoded = try containerValues.decodeIfPresent(CapacityUnitsConfiguration.self, forKey: .capacityUnits)
        capacityUnits = capacityUnitsDecoded
        let userTokenConfigurationsContainer = try containerValues.decodeIfPresent([UserTokenConfiguration?].self, forKey: .userTokenConfigurations)
        var userTokenConfigurationsDecoded0:[UserTokenConfiguration]? = nil
        if let userTokenConfigurationsContainer = userTokenConfigurationsContainer {
            userTokenConfigurationsDecoded0 = [UserTokenConfiguration]()
            for structure0 in userTokenConfigurationsContainer {
                if let structure0 = structure0 {
                    userTokenConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        userTokenConfigurations = userTokenConfigurationsDecoded0
        let userContextPolicyDecoded = try containerValues.decodeIfPresent(UserContextPolicy.self, forKey: .userContextPolicy)
        userContextPolicy = userContextPolicyDecoded
    }
}

extension UpdateIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIndexOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIndexOutputResponse()"}
}

extension UpdateIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateIndexOutputResponse: Equatable {

    public init() {}
}

struct UpdateIndexOutputResponseBody: Equatable {
}

extension UpdateIndexOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateQuerySuggestionsBlockListInputBodyMiddleware: Middleware {
    public let id: String = "UpdateQuerySuggestionsBlockListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuerySuggestionsBlockListOutputError>
}

extension UpdateQuerySuggestionsBlockListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQuerySuggestionsBlockListInput(description: \(String(describing: description)), id: \(String(describing: id)), indexId: \(String(describing: indexId)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), sourceS3Path: \(String(describing: sourceS3Path)))"}
}

extension UpdateQuerySuggestionsBlockListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sourceS3Path = sourceS3Path {
            try encodeContainer.encode(sourceS3Path, forKey: .sourceS3Path)
        }
    }
}

public struct UpdateQuerySuggestionsBlockListInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateQuerySuggestionsBlockListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuerySuggestionsBlockListOutputError>
}

public struct UpdateQuerySuggestionsBlockListInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateQuerySuggestionsBlockListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuerySuggestionsBlockListInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuerySuggestionsBlockListInput>
    public typealias MOutput = OperationOutput<UpdateQuerySuggestionsBlockListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuerySuggestionsBlockListOutputError>
}

public struct UpdateQuerySuggestionsBlockListInput: Equatable {
    /// <p>The description for a block list.</p>
    public let description: String?
    /// <p>The unique identifier of a block list.</p>
    public let id: String?
    /// <p>The identifier of the index for a block list.</p>
    public let indexId: String?
    /// <p>The name of a block list.</p>
    public let name: String?
    /// <p>The IAM (Identity and Access Management) role used to access the
    ///             block list text file in S3.</p>
    public let roleArn: String?
    /// <p>The S3 path where your block list text file sits in S3.</p>
    ///         <p>If you update your block list and provide the same path to the
    ///             block list text file in S3, then Amazon Kendra reloads the file to refresh
    ///             the block list. Amazon Kendra does not automatically refresh your block list.
    ///             You need to call the <code>UpdateQuerySuggestionsBlockList</code> API
    ///             to refresh you block list.</p>
    ///         <p>If you update your block list, then Amazon Kendra asynchronously refreshes
    ///             all query suggestions with the latest content in the S3 file. This
    ///             means changes might not take effect immediately.</p>
    public let sourceS3Path: S3Path?

    public init (
        description: String? = nil,
        id: String? = nil,
        indexId: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        sourceS3Path: S3Path? = nil
    )
    {
        self.description = description
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
    }
}

struct UpdateQuerySuggestionsBlockListInputBody: Equatable {
    public let indexId: String?
    public let id: String?
    public let name: String?
    public let description: String?
    public let sourceS3Path: S3Path?
    public let roleArn: String?
}

extension UpdateQuerySuggestionsBlockListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateQuerySuggestionsBlockListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQuerySuggestionsBlockListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQuerySuggestionsBlockListOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQuerySuggestionsBlockListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQuerySuggestionsBlockListOutputResponse()"}
}

extension UpdateQuerySuggestionsBlockListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQuerySuggestionsBlockListOutputResponse: Equatable {

    public init() {}
}

struct UpdateQuerySuggestionsBlockListOutputResponseBody: Equatable {
}

extension UpdateQuerySuggestionsBlockListOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateQuerySuggestionsConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateQuerySuggestionsConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuerySuggestionsConfigInput>
    public typealias MOutput = OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuerySuggestionsConfigOutputError>
}

extension UpdateQuerySuggestionsConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQuerySuggestionsConfigInput(includeQueriesWithoutUserInformation: \(String(describing: includeQueriesWithoutUserInformation)), indexId: \(String(describing: indexId)), minimumNumberOfQueryingUsers: \(String(describing: minimumNumberOfQueryingUsers)), minimumQueryCount: \(String(describing: minimumQueryCount)), mode: \(String(describing: mode)), queryLogLookBackWindowInDays: \(String(describing: queryLogLookBackWindowInDays)))"}
}

extension UpdateQuerySuggestionsConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeQueriesWithoutUserInformation = "IncludeQueriesWithoutUserInformation"
        case indexId = "IndexId"
        case minimumNumberOfQueryingUsers = "MinimumNumberOfQueryingUsers"
        case minimumQueryCount = "MinimumQueryCount"
        case mode = "Mode"
        case queryLogLookBackWindowInDays = "QueryLogLookBackWindowInDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeQueriesWithoutUserInformation = includeQueriesWithoutUserInformation {
            try encodeContainer.encode(includeQueriesWithoutUserInformation, forKey: .includeQueriesWithoutUserInformation)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let minimumNumberOfQueryingUsers = minimumNumberOfQueryingUsers {
            try encodeContainer.encode(minimumNumberOfQueryingUsers, forKey: .minimumNumberOfQueryingUsers)
        }
        if let minimumQueryCount = minimumQueryCount {
            try encodeContainer.encode(minimumQueryCount, forKey: .minimumQueryCount)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let queryLogLookBackWindowInDays = queryLogLookBackWindowInDays {
            try encodeContainer.encode(queryLogLookBackWindowInDays, forKey: .queryLogLookBackWindowInDays)
        }
    }
}

public struct UpdateQuerySuggestionsConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateQuerySuggestionsConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuerySuggestionsConfigInput>
    public typealias MOutput = OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuerySuggestionsConfigOutputError>
}

public struct UpdateQuerySuggestionsConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateQuerySuggestionsConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuerySuggestionsConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuerySuggestionsConfigInput>
    public typealias MOutput = OperationOutput<UpdateQuerySuggestionsConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuerySuggestionsConfigOutputError>
}

public struct UpdateQuerySuggestionsConfigInput: Equatable {
    /// <p>
    ///             <code>TRUE</code> to include queries without user information (i.e. all queries,
    ///             irrespective of the user), otherwise <code>FALSE</code> to only include queries
    ///             with user information.</p>
    ///         <p>If you pass user information to Amazon Kendra along with the queries, you can set this
    ///             flag to <code>FALSE</code> and instruct Amazon Kendra to only consider queries with user
    ///             information.</p>
    ///         <p>If you set to <code>FALSE</code>, Amazon Kendra only considers queries searched at least
    ///             <code>MinimumQueryCount</code> times across <code>MinimumNumberOfQueryingUsers</code>
    ///             unique users for suggestions.</p>
    ///         <p>If you set to <code>TRUE</code>, Amazon Kendra ignores all user information and learns
    ///             from all queries.</p>
    public let includeQueriesWithoutUserInformation: Bool?
    /// <p>The identifier of the index you want to update query suggestions settings for.</p>
    public let indexId: String?
    /// <p>The minimum number of unique users who must search a query in order for the query
    ///             to be eligible to suggest to your users.</p>
    ///         <p>Increasing this number might decrease the number of suggestions. However, this
    ///             ensures a query is searched by many users and is truly popular to suggest to users.</p>
    ///         <p>How you tune this setting depends on your specific needs.</p>
    public let minimumNumberOfQueryingUsers: Int?
    /// <p>The the minimum number of times a query must be searched in order to be
    ///             eligible to suggest to your users.</p>
    ///         <p>Decreasing this number increases the number of suggestions. However, this
    ///             affects the quality of suggestions as it sets a low bar for a query to be
    ///             considered popular to suggest to users.</p>
    ///         <p>How you tune this setting depends on your specific needs.</p>
    public let minimumQueryCount: Int?
    /// <p>Set the mode to <code>ENABLED</code> or <code>LEARN_ONLY</code>.</p>
    ///         <p>By default, Amazon Kendra enables query suggestions.
    ///             <code>LEARN_ONLY</code> mode allows you to turn off query suggestions.
    ///             You can to update this at any time.</p>
    ///         <p>In <code>LEARN_ONLY</code> mode, Amazon Kendra continues to learn from new
    ///             queries to keep suggestions up to date for when you are ready to
    ///             switch to ENABLED mode again.</p>
    public let mode: Mode?
    /// <p>How recent your queries are in your query log time window.</p>
    ///         <p>The time window is the number of days from current day to past days.</p>
    ///         <p>By default, Amazon Kendra sets this to 180.</p>
    public let queryLogLookBackWindowInDays: Int?

    public init (
        includeQueriesWithoutUserInformation: Bool? = nil,
        indexId: String? = nil,
        minimumNumberOfQueryingUsers: Int? = nil,
        minimumQueryCount: Int? = nil,
        mode: Mode? = nil,
        queryLogLookBackWindowInDays: Int? = nil
    )
    {
        self.includeQueriesWithoutUserInformation = includeQueriesWithoutUserInformation
        self.indexId = indexId
        self.minimumNumberOfQueryingUsers = minimumNumberOfQueryingUsers
        self.minimumQueryCount = minimumQueryCount
        self.mode = mode
        self.queryLogLookBackWindowInDays = queryLogLookBackWindowInDays
    }
}

struct UpdateQuerySuggestionsConfigInputBody: Equatable {
    public let indexId: String?
    public let mode: Mode?
    public let queryLogLookBackWindowInDays: Int?
    public let includeQueriesWithoutUserInformation: Bool?
    public let minimumNumberOfQueryingUsers: Int?
    public let minimumQueryCount: Int?
}

extension UpdateQuerySuggestionsConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includeQueriesWithoutUserInformation = "IncludeQueriesWithoutUserInformation"
        case indexId = "IndexId"
        case minimumNumberOfQueryingUsers = "MinimumNumberOfQueryingUsers"
        case minimumQueryCount = "MinimumQueryCount"
        case mode = "Mode"
        case queryLogLookBackWindowInDays = "QueryLogLookBackWindowInDays"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let modeDecoded = try containerValues.decodeIfPresent(Mode.self, forKey: .mode)
        mode = modeDecoded
        let queryLogLookBackWindowInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queryLogLookBackWindowInDays)
        queryLogLookBackWindowInDays = queryLogLookBackWindowInDaysDecoded
        let includeQueriesWithoutUserInformationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeQueriesWithoutUserInformation)
        includeQueriesWithoutUserInformation = includeQueriesWithoutUserInformationDecoded
        let minimumNumberOfQueryingUsersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumNumberOfQueryingUsers)
        minimumNumberOfQueryingUsers = minimumNumberOfQueryingUsersDecoded
        let minimumQueryCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumQueryCount)
        minimumQueryCount = minimumQueryCountDecoded
    }
}

extension UpdateQuerySuggestionsConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQuerySuggestionsConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQuerySuggestionsConfigOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQuerySuggestionsConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQuerySuggestionsConfigOutputResponse()"}
}

extension UpdateQuerySuggestionsConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQuerySuggestionsConfigOutputResponse: Equatable {

    public init() {}
}

struct UpdateQuerySuggestionsConfigOutputResponseBody: Equatable {
}

extension UpdateQuerySuggestionsConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateThesaurusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateThesaurusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThesaurusInput>
    public typealias MOutput = OperationOutput<UpdateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThesaurusOutputError>
}

extension UpdateThesaurusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThesaurusInput(description: \(String(describing: description)), id: \(String(describing: id)), indexId: \(String(describing: indexId)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), sourceS3Path: \(String(describing: sourceS3Path)))"}
}

extension UpdateThesaurusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indexId = indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sourceS3Path = sourceS3Path {
            try encodeContainer.encode(sourceS3Path, forKey: .sourceS3Path)
        }
    }
}

public struct UpdateThesaurusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateThesaurusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThesaurusInput>
    public typealias MOutput = OperationOutput<UpdateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThesaurusOutputError>
}

public struct UpdateThesaurusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateThesaurusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThesaurusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThesaurusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThesaurusInput>
    public typealias MOutput = OperationOutput<UpdateThesaurusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThesaurusOutputError>
}

public struct UpdateThesaurusInput: Equatable {
    /// <p>The updated description of the thesaurus.</p>
    public let description: String?
    /// <p>The identifier of the thesaurus to update.</p>
    public let id: String?
    /// <p>The identifier of the index associated with the thesaurus to update.</p>
    public let indexId: String?
    /// <p>The updated name of the thesaurus.</p>
    public let name: String?
    /// <p>The updated role ARN of the thesaurus.</p>
    public let roleArn: String?
    /// <p>Information required to find a specific file in an Amazon S3
    ///             bucket.</p>
    public let sourceS3Path: S3Path?

    public init (
        description: String? = nil,
        id: String? = nil,
        indexId: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        sourceS3Path: S3Path? = nil
    )
    {
        self.description = description
        self.id = id
        self.indexId = indexId
        self.name = name
        self.roleArn = roleArn
        self.sourceS3Path = sourceS3Path
    }
}

struct UpdateThesaurusInputBody: Equatable {
    public let id: String?
    public let name: String?
    public let indexId: String?
    public let description: String?
    public let roleArn: String?
    public let sourceS3Path: S3Path?
}

extension UpdateThesaurusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case indexId = "IndexId"
        case name = "Name"
        case roleArn = "RoleArn"
        case sourceS3Path = "SourceS3Path"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let sourceS3PathDecoded = try containerValues.decodeIfPresent(S3Path.self, forKey: .sourceS3Path)
        sourceS3Path = sourceS3PathDecoded
    }
}

extension UpdateThesaurusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThesaurusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThesaurusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThesaurusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThesaurusOutputResponse()"}
}

extension UpdateThesaurusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateThesaurusOutputResponse: Equatable {

    public init() {}
}

struct UpdateThesaurusOutputResponseBody: Equatable {
}

extension UpdateThesaurusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UserContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case token = "Token"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension UserContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserContext(token: \(String(describing: token)))"}
}

/// <p>Provides information about the user context for a Amazon Kendra index.</p>
public struct UserContext: Equatable {
    /// <p>The user context token. It must be a JWT or a JSON token.</p>
    public let token: String?

    public init (
        token: String? = nil
    )
    {
        self.token = token
    }
}

public enum UserContextPolicy {
    case attributeFilter
    case userToken
    case sdkUnknown(String)
}

extension UserContextPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserContextPolicy] {
        return [
            .attributeFilter,
            .userToken,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .attributeFilter: return "ATTRIBUTE_FILTER"
        case .userToken: return "USER_TOKEN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserContextPolicy(rawValue: rawValue) ?? UserContextPolicy.sdkUnknown(rawValue)
    }
}

extension UserTokenConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jsonTokenTypeConfiguration = "JsonTokenTypeConfiguration"
        case jwtTokenTypeConfiguration = "JwtTokenTypeConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonTokenTypeConfiguration = jsonTokenTypeConfiguration {
            try encodeContainer.encode(jsonTokenTypeConfiguration, forKey: .jsonTokenTypeConfiguration)
        }
        if let jwtTokenTypeConfiguration = jwtTokenTypeConfiguration {
            try encodeContainer.encode(jwtTokenTypeConfiguration, forKey: .jwtTokenTypeConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jwtTokenTypeConfigurationDecoded = try containerValues.decodeIfPresent(JwtTokenTypeConfiguration.self, forKey: .jwtTokenTypeConfiguration)
        jwtTokenTypeConfiguration = jwtTokenTypeConfigurationDecoded
        let jsonTokenTypeConfigurationDecoded = try containerValues.decodeIfPresent(JsonTokenTypeConfiguration.self, forKey: .jsonTokenTypeConfiguration)
        jsonTokenTypeConfiguration = jsonTokenTypeConfigurationDecoded
    }
}

extension UserTokenConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserTokenConfiguration(jsonTokenTypeConfiguration: \(String(describing: jsonTokenTypeConfiguration)), jwtTokenTypeConfiguration: \(String(describing: jwtTokenTypeConfiguration)))"}
}

/// <p>Provides configuration information for a token configuration.</p>
public struct UserTokenConfiguration: Equatable {
    /// <p>Information about the JSON token type configuration.</p>
    public let jsonTokenTypeConfiguration: JsonTokenTypeConfiguration?
    /// <p>Information about the JWT token type configuration.</p>
    public let jwtTokenTypeConfiguration: JwtTokenTypeConfiguration?

    public init (
        jsonTokenTypeConfiguration: JsonTokenTypeConfiguration? = nil,
        jwtTokenTypeConfiguration: JwtTokenTypeConfiguration? = nil
    )
    {
        self.jsonTokenTypeConfiguration = jsonTokenTypeConfiguration
        self.jwtTokenTypeConfiguration = jwtTokenTypeConfiguration
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
