// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountLimitExceededException(message: \(String(describing: message)))"}
}

extension AccountLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An AWS service limit was exceeded for the calling AWS account.</p>
public struct AccountLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccountLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension AccountLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ArtifactNamespace {
    case buildId
    case `none`
    case sdkUnknown(String)
}

extension ArtifactNamespace : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ArtifactNamespace] {
        return [
            .buildId,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .buildId: return "BUILD_ID"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ArtifactNamespace(rawValue: rawValue) ?? ArtifactNamespace.sdkUnknown(rawValue)
    }
}

public enum ArtifactPackaging {
    case `none`
    case zip
    case sdkUnknown(String)
}

extension ArtifactPackaging : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ArtifactPackaging] {
        return [
            .none,
            .zip,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .zip: return "ZIP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ArtifactPackaging(rawValue: rawValue) ?? ArtifactPackaging.sdkUnknown(rawValue)
    }
}

public enum ArtifactsType {
    case codepipeline
    case noArtifacts
    case s3
    case sdkUnknown(String)
}

extension ArtifactsType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ArtifactsType] {
        return [
            .codepipeline,
            .noArtifacts,
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .codepipeline: return "CODEPIPELINE"
        case .noArtifacts: return "NO_ARTIFACTS"
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ArtifactsType(rawValue: rawValue) ?? ArtifactsType.sdkUnknown(rawValue)
    }
}

public enum AuthType {
    case basicAuth
    case oauth
    case personalAccessToken
    case sdkUnknown(String)
}

extension AuthType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthType] {
        return [
            .basicAuth,
            .oauth,
            .personalAccessToken,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .basicAuth: return "BASIC_AUTH"
        case .oauth: return "OAUTH"
        case .personalAccessToken: return "PERSONAL_ACCESS_TOKEN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthType(rawValue: rawValue) ?? AuthType.sdkUnknown(rawValue)
    }
}

public struct BatchDeleteBuildsInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteBuildsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteBuildsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteBuildsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteBuildsInput>
    public typealias MOutput = OperationOutput<BatchDeleteBuildsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteBuildsOutputError>
}

extension BatchDeleteBuildsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteBuildsInput(ids: \(String(describing: ids)))"}
}

extension BatchDeleteBuildsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ids
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for buildids0 in ids {
                try idsContainer.encode(buildids0)
            }
        }
    }
}

public struct BatchDeleteBuildsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteBuildsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteBuildsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteBuildsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteBuildsInput>
    public typealias MOutput = OperationOutput<BatchDeleteBuildsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteBuildsOutputError>
}

public struct BatchDeleteBuildsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteBuildsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteBuildsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteBuildsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteBuildsInput>
    public typealias MOutput = OperationOutput<BatchDeleteBuildsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteBuildsOutputError>
}

public struct BatchDeleteBuildsInput: Equatable {
    /// <p>The IDs of the builds to delete.</p>
    public let ids: [String]?

    public init (
        ids: [String]? = nil
    )
    {
        self.ids = ids
    }
}

struct BatchDeleteBuildsInputBody: Equatable {
    public let ids: [String]?
}

extension BatchDeleteBuildsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ids
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchDeleteBuildsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteBuildsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteBuildsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteBuildsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteBuildsOutputResponse(buildsDeleted: \(String(describing: buildsDeleted)), buildsNotDeleted: \(String(describing: buildsNotDeleted)))"}
}

extension BatchDeleteBuildsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteBuildsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.buildsDeleted = output.buildsDeleted
            self.buildsNotDeleted = output.buildsNotDeleted
        } else {
            self.buildsDeleted = nil
            self.buildsNotDeleted = nil
        }
    }
}

public struct BatchDeleteBuildsOutputResponse: Equatable {
    /// <p>The IDs of the builds that were successfully deleted.</p>
    public let buildsDeleted: [String]?
    /// <p>Information about any builds that could not be successfully deleted.</p>
    public let buildsNotDeleted: [BuildNotDeleted]?

    public init (
        buildsDeleted: [String]? = nil,
        buildsNotDeleted: [BuildNotDeleted]? = nil
    )
    {
        self.buildsDeleted = buildsDeleted
        self.buildsNotDeleted = buildsNotDeleted
    }
}

struct BatchDeleteBuildsOutputResponseBody: Equatable {
    public let buildsDeleted: [String]?
    public let buildsNotDeleted: [BuildNotDeleted]?
}

extension BatchDeleteBuildsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case buildsDeleted
        case buildsNotDeleted
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildsDeletedContainer = try containerValues.decodeIfPresent([String?].self, forKey: .buildsDeleted)
        var buildsDeletedDecoded0:[String]? = nil
        if let buildsDeletedContainer = buildsDeletedContainer {
            buildsDeletedDecoded0 = [String]()
            for string0 in buildsDeletedContainer {
                if let string0 = string0 {
                    buildsDeletedDecoded0?.append(string0)
                }
            }
        }
        buildsDeleted = buildsDeletedDecoded0
        let buildsNotDeletedContainer = try containerValues.decodeIfPresent([BuildNotDeleted?].self, forKey: .buildsNotDeleted)
        var buildsNotDeletedDecoded0:[BuildNotDeleted]? = nil
        if let buildsNotDeletedContainer = buildsNotDeletedContainer {
            buildsNotDeletedDecoded0 = [BuildNotDeleted]()
            for structure0 in buildsNotDeletedContainer {
                if let structure0 = structure0 {
                    buildsNotDeletedDecoded0?.append(structure0)
                }
            }
        }
        buildsNotDeleted = buildsNotDeletedDecoded0
    }
}

public struct BatchGetBuildBatchesInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetBuildBatchesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetBuildBatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetBuildBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetBuildBatchesInput>
    public typealias MOutput = OperationOutput<BatchGetBuildBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetBuildBatchesOutputError>
}

extension BatchGetBuildBatchesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetBuildBatchesInput(ids: \(String(describing: ids)))"}
}

extension BatchGetBuildBatchesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ids
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for buildbatchids0 in ids {
                try idsContainer.encode(buildbatchids0)
            }
        }
    }
}

public struct BatchGetBuildBatchesInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetBuildBatchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetBuildBatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetBuildBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetBuildBatchesInput>
    public typealias MOutput = OperationOutput<BatchGetBuildBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetBuildBatchesOutputError>
}

public struct BatchGetBuildBatchesInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetBuildBatchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetBuildBatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetBuildBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetBuildBatchesInput>
    public typealias MOutput = OperationOutput<BatchGetBuildBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetBuildBatchesOutputError>
}

public struct BatchGetBuildBatchesInput: Equatable {
    /// <p>An array that contains the batch build identifiers to retrieve.</p>
    public let ids: [String]?

    public init (
        ids: [String]? = nil
    )
    {
        self.ids = ids
    }
}

struct BatchGetBuildBatchesInputBody: Equatable {
    public let ids: [String]?
}

extension BatchGetBuildBatchesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ids
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchGetBuildBatchesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetBuildBatchesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetBuildBatchesOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetBuildBatchesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetBuildBatchesOutputResponse(buildBatches: \(String(describing: buildBatches)), buildBatchesNotFound: \(String(describing: buildBatchesNotFound)))"}
}

extension BatchGetBuildBatchesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetBuildBatchesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.buildBatches = output.buildBatches
            self.buildBatchesNotFound = output.buildBatchesNotFound
        } else {
            self.buildBatches = nil
            self.buildBatchesNotFound = nil
        }
    }
}

public struct BatchGetBuildBatchesOutputResponse: Equatable {
    /// <p>An array of <code>BuildBatch</code> objects that represent the retrieved batch
    ///             builds.</p>
    public let buildBatches: [BuildBatch]?
    /// <p>An array that contains the identifiers of any batch builds that are not found.</p>
    public let buildBatchesNotFound: [String]?

    public init (
        buildBatches: [BuildBatch]? = nil,
        buildBatchesNotFound: [String]? = nil
    )
    {
        self.buildBatches = buildBatches
        self.buildBatchesNotFound = buildBatchesNotFound
    }
}

struct BatchGetBuildBatchesOutputResponseBody: Equatable {
    public let buildBatches: [BuildBatch]?
    public let buildBatchesNotFound: [String]?
}

extension BatchGetBuildBatchesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case buildBatches
        case buildBatchesNotFound
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildBatchesContainer = try containerValues.decodeIfPresent([BuildBatch?].self, forKey: .buildBatches)
        var buildBatchesDecoded0:[BuildBatch]? = nil
        if let buildBatchesContainer = buildBatchesContainer {
            buildBatchesDecoded0 = [BuildBatch]()
            for structure0 in buildBatchesContainer {
                if let structure0 = structure0 {
                    buildBatchesDecoded0?.append(structure0)
                }
            }
        }
        buildBatches = buildBatchesDecoded0
        let buildBatchesNotFoundContainer = try containerValues.decodeIfPresent([String?].self, forKey: .buildBatchesNotFound)
        var buildBatchesNotFoundDecoded0:[String]? = nil
        if let buildBatchesNotFoundContainer = buildBatchesNotFoundContainer {
            buildBatchesNotFoundDecoded0 = [String]()
            for string0 in buildBatchesNotFoundContainer {
                if let string0 = string0 {
                    buildBatchesNotFoundDecoded0?.append(string0)
                }
            }
        }
        buildBatchesNotFound = buildBatchesNotFoundDecoded0
    }
}

public struct BatchGetBuildsInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetBuildsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetBuildsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetBuildsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetBuildsInput>
    public typealias MOutput = OperationOutput<BatchGetBuildsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetBuildsOutputError>
}

extension BatchGetBuildsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetBuildsInput(ids: \(String(describing: ids)))"}
}

extension BatchGetBuildsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ids
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for buildids0 in ids {
                try idsContainer.encode(buildids0)
            }
        }
    }
}

public struct BatchGetBuildsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetBuildsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetBuildsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetBuildsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetBuildsInput>
    public typealias MOutput = OperationOutput<BatchGetBuildsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetBuildsOutputError>
}

public struct BatchGetBuildsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetBuildsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetBuildsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetBuildsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetBuildsInput>
    public typealias MOutput = OperationOutput<BatchGetBuildsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetBuildsOutputError>
}

public struct BatchGetBuildsInput: Equatable {
    /// <p>The IDs of the builds.</p>
    public let ids: [String]?

    public init (
        ids: [String]? = nil
    )
    {
        self.ids = ids
    }
}

struct BatchGetBuildsInputBody: Equatable {
    public let ids: [String]?
}

extension BatchGetBuildsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ids
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchGetBuildsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetBuildsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetBuildsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetBuildsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetBuildsOutputResponse(builds: \(String(describing: builds)), buildsNotFound: \(String(describing: buildsNotFound)))"}
}

extension BatchGetBuildsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetBuildsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.builds = output.builds
            self.buildsNotFound = output.buildsNotFound
        } else {
            self.builds = nil
            self.buildsNotFound = nil
        }
    }
}

public struct BatchGetBuildsOutputResponse: Equatable {
    /// <p>Information about the requested builds.</p>
    public let builds: [Build]?
    /// <p>The IDs of builds for which information could not be found.</p>
    public let buildsNotFound: [String]?

    public init (
        builds: [Build]? = nil,
        buildsNotFound: [String]? = nil
    )
    {
        self.builds = builds
        self.buildsNotFound = buildsNotFound
    }
}

struct BatchGetBuildsOutputResponseBody: Equatable {
    public let builds: [Build]?
    public let buildsNotFound: [String]?
}

extension BatchGetBuildsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case builds
        case buildsNotFound
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildsContainer = try containerValues.decodeIfPresent([Build?].self, forKey: .builds)
        var buildsDecoded0:[Build]? = nil
        if let buildsContainer = buildsContainer {
            buildsDecoded0 = [Build]()
            for structure0 in buildsContainer {
                if let structure0 = structure0 {
                    buildsDecoded0?.append(structure0)
                }
            }
        }
        builds = buildsDecoded0
        let buildsNotFoundContainer = try containerValues.decodeIfPresent([String?].self, forKey: .buildsNotFound)
        var buildsNotFoundDecoded0:[String]? = nil
        if let buildsNotFoundContainer = buildsNotFoundContainer {
            buildsNotFoundDecoded0 = [String]()
            for string0 in buildsNotFoundContainer {
                if let string0 = string0 {
                    buildsNotFoundDecoded0?.append(string0)
                }
            }
        }
        buildsNotFound = buildsNotFoundDecoded0
    }
}

public struct BatchGetProjectsInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetProjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetProjectsInput>
    public typealias MOutput = OperationOutput<BatchGetProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetProjectsOutputError>
}

extension BatchGetProjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetProjectsInput(names: \(String(describing: names)))"}
}

extension BatchGetProjectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case names
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for projectnames0 in names {
                try namesContainer.encode(projectnames0)
            }
        }
    }
}

public struct BatchGetProjectsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetProjectsInput>
    public typealias MOutput = OperationOutput<BatchGetProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetProjectsOutputError>
}

public struct BatchGetProjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetProjectsInput>
    public typealias MOutput = OperationOutput<BatchGetProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetProjectsOutputError>
}

public struct BatchGetProjectsInput: Equatable {
    /// <p>The names or ARNs of the build projects. To get information about a project shared
    ///             with your AWS account, its ARN must be specified. You cannot specify a shared project
    ///             using its name.</p>
    public let names: [String]?

    public init (
        names: [String]? = nil
    )
    {
        self.names = names
    }
}

struct BatchGetProjectsInputBody: Equatable {
    public let names: [String]?
}

extension BatchGetProjectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case names
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
    }
}

extension BatchGetProjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetProjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetProjectsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetProjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetProjectsOutputResponse(projects: \(String(describing: projects)), projectsNotFound: \(String(describing: projectsNotFound)))"}
}

extension BatchGetProjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetProjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.projects = output.projects
            self.projectsNotFound = output.projectsNotFound
        } else {
            self.projects = nil
            self.projectsNotFound = nil
        }
    }
}

public struct BatchGetProjectsOutputResponse: Equatable {
    /// <p>Information about the requested build projects.</p>
    public let projects: [Project]?
    /// <p>The names of build projects for which information could not be found.</p>
    public let projectsNotFound: [String]?

    public init (
        projects: [Project]? = nil,
        projectsNotFound: [String]? = nil
    )
    {
        self.projects = projects
        self.projectsNotFound = projectsNotFound
    }
}

struct BatchGetProjectsOutputResponseBody: Equatable {
    public let projects: [Project]?
    public let projectsNotFound: [String]?
}

extension BatchGetProjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projects
        case projectsNotFound
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([Project?].self, forKey: .projects)
        var projectsDecoded0:[Project]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [Project]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let projectsNotFoundContainer = try containerValues.decodeIfPresent([String?].self, forKey: .projectsNotFound)
        var projectsNotFoundDecoded0:[String]? = nil
        if let projectsNotFoundContainer = projectsNotFoundContainer {
            projectsNotFoundDecoded0 = [String]()
            for string0 in projectsNotFoundContainer {
                if let string0 = string0 {
                    projectsNotFoundDecoded0?.append(string0)
                }
            }
        }
        projectsNotFound = projectsNotFoundDecoded0
    }
}

public struct BatchGetReportGroupsInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetReportGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetReportGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetReportGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetReportGroupsInput>
    public typealias MOutput = OperationOutput<BatchGetReportGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetReportGroupsOutputError>
}

extension BatchGetReportGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetReportGroupsInput(reportGroupArns: \(String(describing: reportGroupArns)))"}
}

extension BatchGetReportGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reportGroupArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportGroupArns = reportGroupArns {
            var reportGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportGroupArns)
            for reportgrouparns0 in reportGroupArns {
                try reportGroupArnsContainer.encode(reportgrouparns0)
            }
        }
    }
}

public struct BatchGetReportGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetReportGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetReportGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetReportGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetReportGroupsInput>
    public typealias MOutput = OperationOutput<BatchGetReportGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetReportGroupsOutputError>
}

public struct BatchGetReportGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetReportGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetReportGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetReportGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetReportGroupsInput>
    public typealias MOutput = OperationOutput<BatchGetReportGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetReportGroupsOutputError>
}

public struct BatchGetReportGroupsInput: Equatable {
    /// <p>
    ///       An array of report group ARNs that identify the report groups to return.
    ///     </p>
    public let reportGroupArns: [String]?

    public init (
        reportGroupArns: [String]? = nil
    )
    {
        self.reportGroupArns = reportGroupArns
    }
}

struct BatchGetReportGroupsInputBody: Equatable {
    public let reportGroupArns: [String]?
}

extension BatchGetReportGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportGroupArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .reportGroupArns)
        var reportGroupArnsDecoded0:[String]? = nil
        if let reportGroupArnsContainer = reportGroupArnsContainer {
            reportGroupArnsDecoded0 = [String]()
            for string0 in reportGroupArnsContainer {
                if let string0 = string0 {
                    reportGroupArnsDecoded0?.append(string0)
                }
            }
        }
        reportGroupArns = reportGroupArnsDecoded0
    }
}

extension BatchGetReportGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetReportGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetReportGroupsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetReportGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetReportGroupsOutputResponse(reportGroups: \(String(describing: reportGroups)), reportGroupsNotFound: \(String(describing: reportGroupsNotFound)))"}
}

extension BatchGetReportGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetReportGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reportGroups = output.reportGroups
            self.reportGroupsNotFound = output.reportGroupsNotFound
        } else {
            self.reportGroups = nil
            self.reportGroupsNotFound = nil
        }
    }
}

public struct BatchGetReportGroupsOutputResponse: Equatable {
    /// <p>
    ///       The array of report groups returned by <code>BatchGetReportGroups</code>.
    ///     </p>
    public let reportGroups: [ReportGroup]?
    /// <p>
    ///       An array of ARNs passed to <code>BatchGetReportGroups</code> that are not associated with a <code>ReportGroup</code>.
    ///     </p>
    public let reportGroupsNotFound: [String]?

    public init (
        reportGroups: [ReportGroup]? = nil,
        reportGroupsNotFound: [String]? = nil
    )
    {
        self.reportGroups = reportGroups
        self.reportGroupsNotFound = reportGroupsNotFound
    }
}

struct BatchGetReportGroupsOutputResponseBody: Equatable {
    public let reportGroups: [ReportGroup]?
    public let reportGroupsNotFound: [String]?
}

extension BatchGetReportGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportGroups
        case reportGroupsNotFound
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupsContainer = try containerValues.decodeIfPresent([ReportGroup?].self, forKey: .reportGroups)
        var reportGroupsDecoded0:[ReportGroup]? = nil
        if let reportGroupsContainer = reportGroupsContainer {
            reportGroupsDecoded0 = [ReportGroup]()
            for structure0 in reportGroupsContainer {
                if let structure0 = structure0 {
                    reportGroupsDecoded0?.append(structure0)
                }
            }
        }
        reportGroups = reportGroupsDecoded0
        let reportGroupsNotFoundContainer = try containerValues.decodeIfPresent([String?].self, forKey: .reportGroupsNotFound)
        var reportGroupsNotFoundDecoded0:[String]? = nil
        if let reportGroupsNotFoundContainer = reportGroupsNotFoundContainer {
            reportGroupsNotFoundDecoded0 = [String]()
            for string0 in reportGroupsNotFoundContainer {
                if let string0 = string0 {
                    reportGroupsNotFoundDecoded0?.append(string0)
                }
            }
        }
        reportGroupsNotFound = reportGroupsNotFoundDecoded0
    }
}

public struct BatchGetReportsInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetReportsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetReportsInput>
    public typealias MOutput = OperationOutput<BatchGetReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetReportsOutputError>
}

extension BatchGetReportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetReportsInput(reportArns: \(String(describing: reportArns)))"}
}

extension BatchGetReportsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reportArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportArns = reportArns {
            var reportArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportArns)
            for reportarns0 in reportArns {
                try reportArnsContainer.encode(reportarns0)
            }
        }
    }
}

public struct BatchGetReportsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetReportsInput>
    public typealias MOutput = OperationOutput<BatchGetReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetReportsOutputError>
}

public struct BatchGetReportsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetReportsInput>
    public typealias MOutput = OperationOutput<BatchGetReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetReportsOutputError>
}

public struct BatchGetReportsInput: Equatable {
    /// <p>
    ///       An array of ARNs that identify the <code>Report</code> objects to return.
    ///     </p>
    public let reportArns: [String]?

    public init (
        reportArns: [String]? = nil
    )
    {
        self.reportArns = reportArns
    }
}

struct BatchGetReportsInputBody: Equatable {
    public let reportArns: [String]?
}

extension BatchGetReportsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .reportArns)
        var reportArnsDecoded0:[String]? = nil
        if let reportArnsContainer = reportArnsContainer {
            reportArnsDecoded0 = [String]()
            for string0 in reportArnsContainer {
                if let string0 = string0 {
                    reportArnsDecoded0?.append(string0)
                }
            }
        }
        reportArns = reportArnsDecoded0
    }
}

extension BatchGetReportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetReportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetReportsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetReportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetReportsOutputResponse(reports: \(String(describing: reports)), reportsNotFound: \(String(describing: reportsNotFound)))"}
}

extension BatchGetReportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetReportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reports = output.reports
            self.reportsNotFound = output.reportsNotFound
        } else {
            self.reports = nil
            self.reportsNotFound = nil
        }
    }
}

public struct BatchGetReportsOutputResponse: Equatable {
    /// <p>
    ///       The array of <code>Report</code> objects returned by <code>BatchGetReports</code>.
    ///     </p>
    public let reports: [Report]?
    /// <p>
    ///       An array of ARNs passed to <code>BatchGetReportGroups</code> that are not associated with a <code>Report</code>.
    ///     </p>
    public let reportsNotFound: [String]?

    public init (
        reports: [Report]? = nil,
        reportsNotFound: [String]? = nil
    )
    {
        self.reports = reports
        self.reportsNotFound = reportsNotFound
    }
}

struct BatchGetReportsOutputResponseBody: Equatable {
    public let reports: [Report]?
    public let reportsNotFound: [String]?
}

extension BatchGetReportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reports
        case reportsNotFound
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportsContainer = try containerValues.decodeIfPresent([Report?].self, forKey: .reports)
        var reportsDecoded0:[Report]? = nil
        if let reportsContainer = reportsContainer {
            reportsDecoded0 = [Report]()
            for structure0 in reportsContainer {
                if let structure0 = structure0 {
                    reportsDecoded0?.append(structure0)
                }
            }
        }
        reports = reportsDecoded0
        let reportsNotFoundContainer = try containerValues.decodeIfPresent([String?].self, forKey: .reportsNotFound)
        var reportsNotFoundDecoded0:[String]? = nil
        if let reportsNotFoundContainer = reportsNotFoundContainer {
            reportsNotFoundDecoded0 = [String]()
            for string0 in reportsNotFoundContainer {
                if let string0 = string0 {
                    reportsNotFoundDecoded0?.append(string0)
                }
            }
        }
        reportsNotFound = reportsNotFoundDecoded0
    }
}

extension BatchRestrictions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case computeTypesAllowed
        case maximumBuildsAllowed
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeTypesAllowed = computeTypesAllowed {
            var computeTypesAllowedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computeTypesAllowed)
            for computetypesallowed0 in computeTypesAllowed {
                try computeTypesAllowedContainer.encode(computetypesallowed0)
            }
        }
        if let maximumBuildsAllowed = maximumBuildsAllowed {
            try encodeContainer.encode(maximumBuildsAllowed, forKey: .maximumBuildsAllowed)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumBuildsAllowedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumBuildsAllowed)
        maximumBuildsAllowed = maximumBuildsAllowedDecoded
        let computeTypesAllowedContainer = try containerValues.decodeIfPresent([String?].self, forKey: .computeTypesAllowed)
        var computeTypesAllowedDecoded0:[String]? = nil
        if let computeTypesAllowedContainer = computeTypesAllowedContainer {
            computeTypesAllowedDecoded0 = [String]()
            for string0 in computeTypesAllowedContainer {
                if let string0 = string0 {
                    computeTypesAllowedDecoded0?.append(string0)
                }
            }
        }
        computeTypesAllowed = computeTypesAllowedDecoded0
    }
}

extension BatchRestrictions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchRestrictions(computeTypesAllowed: \(String(describing: computeTypesAllowed)), maximumBuildsAllowed: \(String(describing: maximumBuildsAllowed)))"}
}

/// <p>Specifies restrictions for the batch build.</p>
public struct BatchRestrictions: Equatable {
    /// <p>An array of strings that specify the compute types that are allowed for the batch
    ///             build. See <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html">Build environment
    ///                 compute types</a> in the <i>AWS CodeBuild User Guide</i> for these values.
    ///         </p>
    public let computeTypesAllowed: [String]?
    /// <p>Specifies the maximum number of builds allowed.</p>
    public let maximumBuildsAllowed: Int?

    public init (
        computeTypesAllowed: [String]? = nil,
        maximumBuildsAllowed: Int? = nil
    )
    {
        self.computeTypesAllowed = computeTypesAllowed
        self.maximumBuildsAllowed = maximumBuildsAllowed
    }
}

/// <p>Specifies the access for objects that are uploaded to an Amazon S3 bucket that is owned by
///             another account.</p>
///         <p>By default, only the account that uploads the objects to the bucket has access to
///             these objects. This property allows you to give the bucket owner access to these
///             objects.</p>
///          <dl>
///             <dt>NONE</dt>
///             <dd>
///                 <p>The bucket owner does not have access to the objects. This is the
///                         default.</p>
///             </dd>
///             <dt>READ_ONLY</dt>
///             <dd>
///               <p>The bucket owner has read only access to the objects. The uploading account
///                         retains ownership of the objects.</p>
///             </dd>
///             <dt>FULL</dt>
///             <dd>
///               <p>The bucket owner has full access to the objects. Object ownership is determined
///                         by the following criteria:</p>
///                     <ul>
///                   <li>
///                             <p>If the bucket is configured with the <b>Bucket
///                                     owner preferred</b> setting, the bucket owner owns the
///                                 objects. The uploading account will have object access as specified
///                                 by the bucket's policy.</p>
///                         </li>
///                   <li>
///                             <p>Otherwise, the uploading account retains ownership of the
///                                 objects.</p>
///                         </li>
///                </ul>
///                     <p>For more information about Amazon S3 object ownership, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html">Controlling ownership of uploaded objects using S3
///                             Object Ownership</a> in the <i>Amazon Simple Storage Service User
///                         Guide</i>.</p>
///             </dd>
///          </dl>
public enum BucketOwnerAccess {
    case full
    case `none`
    case readOnly
    case sdkUnknown(String)
}

extension BucketOwnerAccess : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BucketOwnerAccess] {
        return [
            .full,
            .none,
            .readOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .full: return "FULL"
        case .none: return "NONE"
        case .readOnly: return "READ_ONLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BucketOwnerAccess(rawValue: rawValue) ?? BucketOwnerAccess.sdkUnknown(rawValue)
    }
}

extension Build: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case artifacts
        case buildBatchArn
        case buildComplete
        case buildNumber
        case buildStatus
        case cache
        case currentPhase
        case debugSession
        case encryptionKey
        case endTime
        case environment
        case exportedEnvironmentVariables
        case fileSystemLocations
        case id
        case initiator
        case logs
        case networkInterface
        case phases
        case projectName
        case queuedTimeoutInMinutes
        case reportArns
        case resolvedSourceVersion
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case startTime
        case timeoutInMinutes
        case vpcConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let artifacts = artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let buildBatchArn = buildBatchArn {
            try encodeContainer.encode(buildBatchArn, forKey: .buildBatchArn)
        }
        if buildComplete != false {
            try encodeContainer.encode(buildComplete, forKey: .buildComplete)
        }
        if let buildNumber = buildNumber {
            try encodeContainer.encode(buildNumber, forKey: .buildNumber)
        }
        if let buildStatus = buildStatus {
            try encodeContainer.encode(buildStatus.rawValue, forKey: .buildStatus)
        }
        if let cache = cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if let currentPhase = currentPhase {
            try encodeContainer.encode(currentPhase, forKey: .currentPhase)
        }
        if let debugSession = debugSession {
            try encodeContainer.encode(debugSession, forKey: .debugSession)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let exportedEnvironmentVariables = exportedEnvironmentVariables {
            var exportedEnvironmentVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportedEnvironmentVariables)
            for exportedenvironmentvariables0 in exportedEnvironmentVariables {
                try exportedEnvironmentVariablesContainer.encode(exportedenvironmentvariables0)
            }
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocations0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocations0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let initiator = initiator {
            try encodeContainer.encode(initiator, forKey: .initiator)
        }
        if let logs = logs {
            try encodeContainer.encode(logs, forKey: .logs)
        }
        if let networkInterface = networkInterface {
            try encodeContainer.encode(networkInterface, forKey: .networkInterface)
        }
        if let phases = phases {
            var phasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phases)
            for buildphases0 in phases {
                try phasesContainer.encode(buildphases0)
            }
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let queuedTimeoutInMinutes = queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let reportArns = reportArns {
            var reportArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportArns)
            for buildreportarns0 in reportArns {
                try reportArnsContainer.encode(buildreportarns0)
            }
        }
        if let resolvedSourceVersion = resolvedSourceVersion {
            try encodeContainer.encode(resolvedSourceVersion, forKey: .resolvedSourceVersion)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for buildartifactslist0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(buildartifactslist0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsecondarysourceversions0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsecondarysourceversions0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsources0 in secondarySources {
                try secondarySourcesContainer.encode(projectsources0)
            }
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let timeoutInMinutes = timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let currentPhaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentPhase)
        currentPhase = currentPhaseDecoded
        let buildStatusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .buildStatus)
        buildStatus = buildStatusDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let resolvedSourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolvedSourceVersion)
        resolvedSourceVersion = resolvedSourceVersionDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let phasesContainer = try containerValues.decodeIfPresent([BuildPhase?].self, forKey: .phases)
        var phasesDecoded0:[BuildPhase]? = nil
        if let phasesContainer = phasesContainer {
            phasesDecoded0 = [BuildPhase]()
            for structure0 in phasesContainer {
                if let structure0 = structure0 {
                    phasesDecoded0?.append(structure0)
                }
            }
        }
        phases = phasesDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(ProjectSource.self, forKey: .source)
        source = sourceDecoded
        let secondarySourcesContainer = try containerValues.decodeIfPresent([ProjectSource?].self, forKey: .secondarySources)
        var secondarySourcesDecoded0:[ProjectSource]? = nil
        if let secondarySourcesContainer = secondarySourcesContainer {
            secondarySourcesDecoded0 = [ProjectSource]()
            for structure0 in secondarySourcesContainer {
                if let structure0 = structure0 {
                    secondarySourcesDecoded0?.append(structure0)
                }
            }
        }
        secondarySources = secondarySourcesDecoded0
        let secondarySourceVersionsContainer = try containerValues.decodeIfPresent([ProjectSourceVersion?].self, forKey: .secondarySourceVersions)
        var secondarySourceVersionsDecoded0:[ProjectSourceVersion]? = nil
        if let secondarySourceVersionsContainer = secondarySourceVersionsContainer {
            secondarySourceVersionsDecoded0 = [ProjectSourceVersion]()
            for structure0 in secondarySourceVersionsContainer {
                if let structure0 = structure0 {
                    secondarySourceVersionsDecoded0?.append(structure0)
                }
            }
        }
        secondarySourceVersions = secondarySourceVersionsDecoded0
        let artifactsDecoded = try containerValues.decodeIfPresent(BuildArtifacts.self, forKey: .artifacts)
        artifacts = artifactsDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([BuildArtifacts?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[BuildArtifacts]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [BuildArtifacts]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
        let cacheDecoded = try containerValues.decodeIfPresent(ProjectCache.self, forKey: .cache)
        cache = cacheDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(ProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let logsDecoded = try containerValues.decodeIfPresent(LogsLocation.self, forKey: .logs)
        logs = logsDecoded
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
        let queuedTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queuedTimeoutInMinutes)
        queuedTimeoutInMinutes = queuedTimeoutInMinutesDecoded
        let buildCompleteDecoded = try containerValues.decode(Bool.self, forKey: .buildComplete)
        buildComplete = buildCompleteDecoded
        let initiatorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initiator)
        initiator = initiatorDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let exportedEnvironmentVariablesContainer = try containerValues.decodeIfPresent([ExportedEnvironmentVariable?].self, forKey: .exportedEnvironmentVariables)
        var exportedEnvironmentVariablesDecoded0:[ExportedEnvironmentVariable]? = nil
        if let exportedEnvironmentVariablesContainer = exportedEnvironmentVariablesContainer {
            exportedEnvironmentVariablesDecoded0 = [ExportedEnvironmentVariable]()
            for structure0 in exportedEnvironmentVariablesContainer {
                if let structure0 = structure0 {
                    exportedEnvironmentVariablesDecoded0?.append(structure0)
                }
            }
        }
        exportedEnvironmentVariables = exportedEnvironmentVariablesDecoded0
        let reportArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .reportArns)
        var reportArnsDecoded0:[String]? = nil
        if let reportArnsContainer = reportArnsContainer {
            reportArnsDecoded0 = [String]()
            for string0 in reportArnsContainer {
                if let string0 = string0 {
                    reportArnsDecoded0?.append(string0)
                }
            }
        }
        reportArns = reportArnsDecoded0
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([ProjectFileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[ProjectFileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [ProjectFileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
        let debugSessionDecoded = try containerValues.decodeIfPresent(DebugSession.self, forKey: .debugSession)
        debugSession = debugSessionDecoded
        let buildBatchArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildBatchArn)
        buildBatchArn = buildBatchArnDecoded
    }
}

extension Build: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Build(arn: \(String(describing: arn)), artifacts: \(String(describing: artifacts)), buildBatchArn: \(String(describing: buildBatchArn)), buildComplete: \(String(describing: buildComplete)), buildNumber: \(String(describing: buildNumber)), buildStatus: \(String(describing: buildStatus)), cache: \(String(describing: cache)), currentPhase: \(String(describing: currentPhase)), debugSession: \(String(describing: debugSession)), encryptionKey: \(String(describing: encryptionKey)), endTime: \(String(describing: endTime)), environment: \(String(describing: environment)), exportedEnvironmentVariables: \(String(describing: exportedEnvironmentVariables)), fileSystemLocations: \(String(describing: fileSystemLocations)), id: \(String(describing: id)), initiator: \(String(describing: initiator)), logs: \(String(describing: logs)), networkInterface: \(String(describing: networkInterface)), phases: \(String(describing: phases)), projectName: \(String(describing: projectName)), queuedTimeoutInMinutes: \(String(describing: queuedTimeoutInMinutes)), reportArns: \(String(describing: reportArns)), resolvedSourceVersion: \(String(describing: resolvedSourceVersion)), secondaryArtifacts: \(String(describing: secondaryArtifacts)), secondarySourceVersions: \(String(describing: secondarySourceVersions)), secondarySources: \(String(describing: secondarySources)), serviceRole: \(String(describing: serviceRole)), source: \(String(describing: source)), sourceVersion: \(String(describing: sourceVersion)), startTime: \(String(describing: startTime)), timeoutInMinutes: \(String(describing: timeoutInMinutes)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Information about a build.</p>
public struct Build: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the build.</p>
    public let arn: String?
    /// <p>Information about the output artifacts for the build.</p>
    public let artifacts: BuildArtifacts?
    /// <p>The ARN of the batch build that this build is a member of, if applicable.</p>
    public let buildBatchArn: String?
    /// <p>Whether the build is complete. True if complete; otherwise, false.</p>
    public let buildComplete: Bool
    /// <p>The number of the build. For each project, the <code>buildNumber</code> of its first
    ///             build is <code>1</code>. The <code>buildNumber</code> of each subsequent build is
    ///             incremented by <code>1</code>. If a build is deleted, the <code>buildNumber</code> of
    ///             other builds does not change.</p>
    public let buildNumber: Int?
    /// <p>The current status of the build. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>FAILED</code>: The build failed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FAULT</code>: The build faulted.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>IN_PROGRESS</code>: The build is still in progress.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>STOPPED</code>: The build stopped.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SUCCEEDED</code>: The build succeeded.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TIMED_OUT</code>: The build timed out.</p>
    ///             </li>
    ///          </ul>
    public let buildStatus: StatusType?
    /// <p>Information about the cache for the build.</p>
    public let cache: ProjectCache?
    /// <p>The current build phase.</p>
    public let currentPhase: String?
    /// <p>Contains information about the debug session for this build.</p>
    public let debugSession: DebugSession?
    /// <p>The AWS Key Management Service (AWS KMS) customer master key (CMK) to be used for encrypting the build output
    ///             artifacts.</p>
    ///         <note>
    ///             <p> You can use a cross-account KMS key to encrypt the build output artifacts if your
    ///                 service role has permission to that key. </p>
    ///         </note>
    ///         <p>You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using
    ///             the format <code>alias/<alias-name></code>).</p>
    public let encryptionKey: String?
    /// <p>When the build process ended, expressed in Unix time format.</p>
    public let endTime: Date?
    /// <p>Information about the build environment for this build.</p>
    public let environment: ProjectEnvironment?
    /// <p>A list of exported environment variables for this build.</p>
    ///         <p>Exported environment variables are used in conjunction with AWS CodePipeline to export
    ///   environment variables from the current build stage to subsequent stages in the pipeline.
    ///   For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-variables.html">Working with variables</a> in the <i>AWS CodePipeline User Guide</i>.</p>
    public let exportedEnvironmentVariables: [ExportedEnvironmentVariable]?
    /// <p>
    ///       An array of <code>ProjectFileSystemLocation</code> objects for a CodeBuild build project. A <code>ProjectFileSystemLocation</code> object
    ///       specifies the <code>identifier</code>, <code>location</code>, <code>mountOptions</code>,
    ///       <code>mountPoint</code>, and <code>type</code> of a file system created using Amazon Elastic File System.
    ///   </p>
    public let fileSystemLocations: [ProjectFileSystemLocation]?
    /// <p>The unique ID for the build.</p>
    public let id: String?
    /// <p>The entity that started the build. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If AWS CodePipeline started the build, the pipeline's name (for example,
    ///                         <code>codepipeline/my-demo-pipeline</code>).</p>
    ///             </li>
    ///             <li>
    ///                 <p>If an AWS Identity and Access Management (IAM) user started the build, the user's name (for example,
    ///                         <code>MyUserName</code>).</p>
    ///             </li>
    ///             <li>
    ///                 <p>If the Jenkins plugin for AWS CodeBuild started the build, the string
    ///                         <code>CodeBuild-Jenkins-Plugin</code>.</p>
    ///             </li>
    ///          </ul>
    public let initiator: String?
    /// <p>Information about the build's logs in Amazon CloudWatch Logs.</p>
    public let logs: LogsLocation?
    /// <p>Describes a network interface.</p>
    public let networkInterface: NetworkInterface?
    /// <p>Information about all previous build phases that are complete and information about
    ///             any current build phase that is not yet complete.</p>
    public let phases: [BuildPhase]?
    /// <p>The name of the AWS CodeBuild project.</p>
    public let projectName: String?
    /// <p> The number of minutes a build is allowed to be queued before it times out. </p>
    public let queuedTimeoutInMinutes: Int?
    /// <p> An array of the ARNs associated with this build's reports. </p>
    public let reportArns: [String]?
    /// <p> An identifier for the version of this build's source code. </p>
    ///         <ul>
    ///             <li>
    ///                 <p> For AWS CodeCommit, GitHub, GitHub Enterprise, and BitBucket, the commit ID. </p>
    ///             </li>
    ///             <li>
    ///                 <p> For AWS CodePipeline, the source revision provided by AWS CodePipeline. </p>
    ///             </li>
    ///             <li>
    ///                 <p> For Amazon S3, this does not apply. </p>
    ///             </li>
    ///          </ul>
    public let resolvedSourceVersion: String?
    /// <p> An array of <code>ProjectArtifacts</code> objects. </p>
    public let secondaryArtifacts: [BuildArtifacts]?
    /// <p> An array of <code>ProjectSourceVersion</code> objects. Each
    ///                 <code>ProjectSourceVersion</code> must be one of: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>For AWS CodeCommit: the commit ID, branch, or Git tag to use.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For GitHub: the commit ID, pull request ID, branch name, or tag name that
    ///                     corresponds to the version of the source code you want to build. If a pull
    ///                     request ID is specified, it must use the format <code>pr/pull-request-ID</code>
    ///                     (for example, <code>pr/25</code>). If a branch name is specified, the branch's
    ///                     HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is
    ///                     used.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For Bitbucket: the commit ID, branch name, or tag name that corresponds to the
    ///                     version of the source code you want to build. If a branch name is specified, the
    ///                     branch's HEAD commit ID is used. If not specified, the default branch's HEAD
    ///                     commit ID is used.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For Amazon S3: the version ID of the object that represents the build input ZIP
    ///                     file to use.</p>
    ///             </li>
    ///          </ul>
    public let secondarySourceVersions: [ProjectSourceVersion]?
    /// <p> An array of <code>ProjectSource</code> objects. </p>
    public let secondarySources: [ProjectSource]?
    /// <p>The name of a service role used for this build.</p>
    public let serviceRole: String?
    /// <p>Information about the source code to be built.</p>
    public let source: ProjectSource?
    /// <p>Any version identifier for the version of the source code to be built. If
    ///                 <code>sourceVersion</code> is specified at the project level, then this
    ///                 <code>sourceVersion</code> (at the build level) takes precedence. </p>
    ///         <p> For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html">Source Version Sample
    ///                 with CodeBuild</a> in the <i>AWS CodeBuild User Guide</i>. </p>
    public let sourceVersion: String?
    /// <p>When the build process started, expressed in Unix time format.</p>
    public let startTime: Date?
    /// <p>How long, in minutes, for AWS CodeBuild to wait before timing out this build if it does not
    ///             get marked as completed.</p>
    public let timeoutInMinutes: Int?
    /// <p>If your AWS CodeBuild project accesses resources in an Amazon VPC, you provide this parameter
    ///             that identifies the VPC ID and the list of security group IDs and subnet IDs. The
    ///             security groups and subnets must belong to the same VPC. You must provide at least one
    ///             security group and one subnet ID.</p>
    public let vpcConfig: VpcConfig?

    public init (
        arn: String? = nil,
        artifacts: BuildArtifacts? = nil,
        buildBatchArn: String? = nil,
        buildComplete: Bool = false,
        buildNumber: Int? = nil,
        buildStatus: StatusType? = nil,
        cache: ProjectCache? = nil,
        currentPhase: String? = nil,
        debugSession: DebugSession? = nil,
        encryptionKey: String? = nil,
        endTime: Date? = nil,
        environment: ProjectEnvironment? = nil,
        exportedEnvironmentVariables: [ExportedEnvironmentVariable]? = nil,
        fileSystemLocations: [ProjectFileSystemLocation]? = nil,
        id: String? = nil,
        initiator: String? = nil,
        logs: LogsLocation? = nil,
        networkInterface: NetworkInterface? = nil,
        phases: [BuildPhase]? = nil,
        projectName: String? = nil,
        queuedTimeoutInMinutes: Int? = nil,
        reportArns: [String]? = nil,
        resolvedSourceVersion: String? = nil,
        secondaryArtifacts: [BuildArtifacts]? = nil,
        secondarySourceVersions: [ProjectSourceVersion]? = nil,
        secondarySources: [ProjectSource]? = nil,
        serviceRole: String? = nil,
        source: ProjectSource? = nil,
        sourceVersion: String? = nil,
        startTime: Date? = nil,
        timeoutInMinutes: Int? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.arn = arn
        self.artifacts = artifacts
        self.buildBatchArn = buildBatchArn
        self.buildComplete = buildComplete
        self.buildNumber = buildNumber
        self.buildStatus = buildStatus
        self.cache = cache
        self.currentPhase = currentPhase
        self.debugSession = debugSession
        self.encryptionKey = encryptionKey
        self.endTime = endTime
        self.environment = environment
        self.exportedEnvironmentVariables = exportedEnvironmentVariables
        self.fileSystemLocations = fileSystemLocations
        self.id = id
        self.initiator = initiator
        self.logs = logs
        self.networkInterface = networkInterface
        self.phases = phases
        self.projectName = projectName
        self.queuedTimeoutInMinutes = queuedTimeoutInMinutes
        self.reportArns = reportArns
        self.resolvedSourceVersion = resolvedSourceVersion
        self.secondaryArtifacts = secondaryArtifacts
        self.secondarySourceVersions = secondarySourceVersions
        self.secondarySources = secondarySources
        self.serviceRole = serviceRole
        self.source = source
        self.sourceVersion = sourceVersion
        self.startTime = startTime
        self.timeoutInMinutes = timeoutInMinutes
        self.vpcConfig = vpcConfig
    }
}

extension BuildArtifacts: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactIdentifier
        case bucketOwnerAccess
        case encryptionDisabled
        case location
        case md5sum
        case overrideArtifactName
        case sha256sum
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactIdentifier = artifactIdentifier {
            try encodeContainer.encode(artifactIdentifier, forKey: .artifactIdentifier)
        }
        if let bucketOwnerAccess = bucketOwnerAccess {
            try encodeContainer.encode(bucketOwnerAccess.rawValue, forKey: .bucketOwnerAccess)
        }
        if let encryptionDisabled = encryptionDisabled {
            try encodeContainer.encode(encryptionDisabled, forKey: .encryptionDisabled)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let md5sum = md5sum {
            try encodeContainer.encode(md5sum, forKey: .md5sum)
        }
        if let overrideArtifactName = overrideArtifactName {
            try encodeContainer.encode(overrideArtifactName, forKey: .overrideArtifactName)
        }
        if let sha256sum = sha256sum {
            try encodeContainer.encode(sha256sum, forKey: .sha256sum)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let sha256sumDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sha256sum)
        sha256sum = sha256sumDecoded
        let md5sumDecoded = try containerValues.decodeIfPresent(String.self, forKey: .md5sum)
        md5sum = md5sumDecoded
        let overrideArtifactNameDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .overrideArtifactName)
        overrideArtifactName = overrideArtifactNameDecoded
        let encryptionDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encryptionDisabled)
        encryptionDisabled = encryptionDisabledDecoded
        let artifactIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactIdentifier)
        artifactIdentifier = artifactIdentifierDecoded
        let bucketOwnerAccessDecoded = try containerValues.decodeIfPresent(BucketOwnerAccess.self, forKey: .bucketOwnerAccess)
        bucketOwnerAccess = bucketOwnerAccessDecoded
    }
}

extension BuildArtifacts: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildArtifacts(artifactIdentifier: \(String(describing: artifactIdentifier)), bucketOwnerAccess: \(String(describing: bucketOwnerAccess)), encryptionDisabled: \(String(describing: encryptionDisabled)), location: \(String(describing: location)), md5sum: \(String(describing: md5sum)), overrideArtifactName: \(String(describing: overrideArtifactName)), sha256sum: \(String(describing: sha256sum)))"}
}

/// <p>Information about build output artifacts.</p>
public struct BuildArtifacts: Equatable {
    /// <p> An identifier for this artifact definition. </p>
    public let artifactIdentifier: String?
    /// <p>Specifies the access for objects that are uploaded to an Amazon S3 bucket that is owned by
    ///             another account.</p>
    ///         <p>By default, only the account that uploads the objects to the bucket has access to
    ///             these objects. This property allows you to give the bucket owner access to these
    ///             objects.</p>
    ///          <dl>
    ///             <dt>NONE</dt>
    ///             <dd>
    ///                 <p>The bucket owner does not have access to the objects. This is the
    ///                         default.</p>
    ///             </dd>
    ///             <dt>READ_ONLY</dt>
    ///             <dd>
    ///               <p>The bucket owner has read only access to the objects. The uploading account
    ///                         retains ownership of the objects.</p>
    ///             </dd>
    ///             <dt>FULL</dt>
    ///             <dd>
    ///               <p>The bucket owner has full access to the objects. Object ownership is determined
    ///                         by the following criteria:</p>
    ///                     <ul>
    ///                   <li>
    ///                             <p>If the bucket is configured with the <b>Bucket
    ///                                     owner preferred</b> setting, the bucket owner owns the
    ///                                 objects. The uploading account will have object access as specified
    ///                                 by the bucket's policy.</p>
    ///                         </li>
    ///                   <li>
    ///                             <p>Otherwise, the uploading account retains ownership of the
    ///                                 objects.</p>
    ///                         </li>
    ///                </ul>
    ///                     <p>For more information about Amazon S3 object ownership, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html">Controlling ownership of uploaded objects using S3
    ///                             Object Ownership</a> in the <i>Amazon Simple Storage Service User
    ///                         Guide</i>.</p>
    ///             </dd>
    ///          </dl>
    public let bucketOwnerAccess: BucketOwnerAccess?
    /// <p> Information that tells you if encryption for build artifacts is disabled. </p>
    public let encryptionDisabled: Bool?
    /// <p>Information about the location of the build artifacts.</p>
    public let location: String?
    /// <p>The MD5 hash of the build artifact.</p>
    ///         <p>You can use this hash along with a checksum tool to confirm file integrity and
    ///             authenticity.</p>
    ///         <note>
    ///             <p>This value is available only if the build project's <code>packaging</code> value
    ///                 is set to <code>ZIP</code>.</p>
    ///         </note>
    public let md5sum: String?
    /// <p> If this flag is set, a name specified in the buildspec file overrides the artifact
    ///             name. The name specified in a buildspec file is calculated at build time and uses the
    ///             Shell Command Language. For example, you can append a date and time to your artifact
    ///             name so that it is always unique. </p>
    public let overrideArtifactName: Bool?
    /// <p>The SHA-256 hash of the build artifact.</p>
    ///         <p>You can use this hash along with a checksum tool to confirm file integrity and
    ///             authenticity.</p>
    ///         <note>
    ///             <p>This value is available only if the build project's <code>packaging</code> value
    ///                 is set to <code>ZIP</code>.</p>
    ///         </note>
    public let sha256sum: String?

    public init (
        artifactIdentifier: String? = nil,
        bucketOwnerAccess: BucketOwnerAccess? = nil,
        encryptionDisabled: Bool? = nil,
        location: String? = nil,
        md5sum: String? = nil,
        overrideArtifactName: Bool? = nil,
        sha256sum: String? = nil
    )
    {
        self.artifactIdentifier = artifactIdentifier
        self.bucketOwnerAccess = bucketOwnerAccess
        self.encryptionDisabled = encryptionDisabled
        self.location = location
        self.md5sum = md5sum
        self.overrideArtifactName = overrideArtifactName
        self.sha256sum = sha256sum
    }
}

extension BuildBatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case artifacts
        case buildBatchConfig
        case buildBatchNumber
        case buildBatchStatus
        case buildGroups
        case buildTimeoutInMinutes
        case cache
        case complete
        case currentPhase
        case debugSessionEnabled
        case encryptionKey
        case endTime
        case environment
        case fileSystemLocations
        case id
        case initiator
        case logConfig
        case phases
        case projectName
        case queuedTimeoutInMinutes
        case resolvedSourceVersion
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case startTime
        case vpcConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let artifacts = artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let buildBatchConfig = buildBatchConfig {
            try encodeContainer.encode(buildBatchConfig, forKey: .buildBatchConfig)
        }
        if let buildBatchNumber = buildBatchNumber {
            try encodeContainer.encode(buildBatchNumber, forKey: .buildBatchNumber)
        }
        if let buildBatchStatus = buildBatchStatus {
            try encodeContainer.encode(buildBatchStatus.rawValue, forKey: .buildBatchStatus)
        }
        if let buildGroups = buildGroups {
            var buildGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buildGroups)
            for buildgroups0 in buildGroups {
                try buildGroupsContainer.encode(buildgroups0)
            }
        }
        if let buildTimeoutInMinutes = buildTimeoutInMinutes {
            try encodeContainer.encode(buildTimeoutInMinutes, forKey: .buildTimeoutInMinutes)
        }
        if let cache = cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if complete != false {
            try encodeContainer.encode(complete, forKey: .complete)
        }
        if let currentPhase = currentPhase {
            try encodeContainer.encode(currentPhase, forKey: .currentPhase)
        }
        if let debugSessionEnabled = debugSessionEnabled {
            try encodeContainer.encode(debugSessionEnabled, forKey: .debugSessionEnabled)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocations0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocations0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let initiator = initiator {
            try encodeContainer.encode(initiator, forKey: .initiator)
        }
        if let logConfig = logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let phases = phases {
            var phasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phases)
            for buildbatchphases0 in phases {
                try phasesContainer.encode(buildbatchphases0)
            }
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let queuedTimeoutInMinutes = queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let resolvedSourceVersion = resolvedSourceVersion {
            try encodeContainer.encode(resolvedSourceVersion, forKey: .resolvedSourceVersion)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for buildartifactslist0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(buildartifactslist0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsecondarysourceversions0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsecondarysourceversions0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsources0 in secondarySources {
                try secondarySourcesContainer.encode(projectsources0)
            }
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let currentPhaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentPhase)
        currentPhase = currentPhaseDecoded
        let buildBatchStatusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .buildBatchStatus)
        buildBatchStatus = buildBatchStatusDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let resolvedSourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolvedSourceVersion)
        resolvedSourceVersion = resolvedSourceVersionDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let phasesContainer = try containerValues.decodeIfPresent([BuildBatchPhase?].self, forKey: .phases)
        var phasesDecoded0:[BuildBatchPhase]? = nil
        if let phasesContainer = phasesContainer {
            phasesDecoded0 = [BuildBatchPhase]()
            for structure0 in phasesContainer {
                if let structure0 = structure0 {
                    phasesDecoded0?.append(structure0)
                }
            }
        }
        phases = phasesDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(ProjectSource.self, forKey: .source)
        source = sourceDecoded
        let secondarySourcesContainer = try containerValues.decodeIfPresent([ProjectSource?].self, forKey: .secondarySources)
        var secondarySourcesDecoded0:[ProjectSource]? = nil
        if let secondarySourcesContainer = secondarySourcesContainer {
            secondarySourcesDecoded0 = [ProjectSource]()
            for structure0 in secondarySourcesContainer {
                if let structure0 = structure0 {
                    secondarySourcesDecoded0?.append(structure0)
                }
            }
        }
        secondarySources = secondarySourcesDecoded0
        let secondarySourceVersionsContainer = try containerValues.decodeIfPresent([ProjectSourceVersion?].self, forKey: .secondarySourceVersions)
        var secondarySourceVersionsDecoded0:[ProjectSourceVersion]? = nil
        if let secondarySourceVersionsContainer = secondarySourceVersionsContainer {
            secondarySourceVersionsDecoded0 = [ProjectSourceVersion]()
            for structure0 in secondarySourceVersionsContainer {
                if let structure0 = structure0 {
                    secondarySourceVersionsDecoded0?.append(structure0)
                }
            }
        }
        secondarySourceVersions = secondarySourceVersionsDecoded0
        let artifactsDecoded = try containerValues.decodeIfPresent(BuildArtifacts.self, forKey: .artifacts)
        artifacts = artifactsDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([BuildArtifacts?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[BuildArtifacts]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [BuildArtifacts]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
        let cacheDecoded = try containerValues.decodeIfPresent(ProjectCache.self, forKey: .cache)
        cache = cacheDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(ProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(LogsConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let buildTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .buildTimeoutInMinutes)
        buildTimeoutInMinutes = buildTimeoutInMinutesDecoded
        let queuedTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queuedTimeoutInMinutes)
        queuedTimeoutInMinutes = queuedTimeoutInMinutesDecoded
        let completeDecoded = try containerValues.decode(Bool.self, forKey: .complete)
        complete = completeDecoded
        let initiatorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initiator)
        initiator = initiatorDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let buildBatchNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .buildBatchNumber)
        buildBatchNumber = buildBatchNumberDecoded
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([ProjectFileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[ProjectFileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [ProjectFileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
        let buildBatchConfigDecoded = try containerValues.decodeIfPresent(ProjectBuildBatchConfig.self, forKey: .buildBatchConfig)
        buildBatchConfig = buildBatchConfigDecoded
        let buildGroupsContainer = try containerValues.decodeIfPresent([BuildGroup?].self, forKey: .buildGroups)
        var buildGroupsDecoded0:[BuildGroup]? = nil
        if let buildGroupsContainer = buildGroupsContainer {
            buildGroupsDecoded0 = [BuildGroup]()
            for structure0 in buildGroupsContainer {
                if let structure0 = structure0 {
                    buildGroupsDecoded0?.append(structure0)
                }
            }
        }
        buildGroups = buildGroupsDecoded0
        let debugSessionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .debugSessionEnabled)
        debugSessionEnabled = debugSessionEnabledDecoded
    }
}

extension BuildBatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildBatch(arn: \(String(describing: arn)), artifacts: \(String(describing: artifacts)), buildBatchConfig: \(String(describing: buildBatchConfig)), buildBatchNumber: \(String(describing: buildBatchNumber)), buildBatchStatus: \(String(describing: buildBatchStatus)), buildGroups: \(String(describing: buildGroups)), buildTimeoutInMinutes: \(String(describing: buildTimeoutInMinutes)), cache: \(String(describing: cache)), complete: \(String(describing: complete)), currentPhase: \(String(describing: currentPhase)), debugSessionEnabled: \(String(describing: debugSessionEnabled)), encryptionKey: \(String(describing: encryptionKey)), endTime: \(String(describing: endTime)), environment: \(String(describing: environment)), fileSystemLocations: \(String(describing: fileSystemLocations)), id: \(String(describing: id)), initiator: \(String(describing: initiator)), logConfig: \(String(describing: logConfig)), phases: \(String(describing: phases)), projectName: \(String(describing: projectName)), queuedTimeoutInMinutes: \(String(describing: queuedTimeoutInMinutes)), resolvedSourceVersion: \(String(describing: resolvedSourceVersion)), secondaryArtifacts: \(String(describing: secondaryArtifacts)), secondarySourceVersions: \(String(describing: secondarySourceVersions)), secondarySources: \(String(describing: secondarySources)), serviceRole: \(String(describing: serviceRole)), source: \(String(describing: source)), sourceVersion: \(String(describing: sourceVersion)), startTime: \(String(describing: startTime)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Contains information about a batch build.</p>
public struct BuildBatch: Equatable {
    /// <p>The ARN of the batch build.</p>
    public let arn: String?
    /// <p>A <code>BuildArtifacts</code> object the defines the build artifacts for this batch build.</p>
    public let artifacts: BuildArtifacts?
    /// <p>Contains configuration information about a batch build project.</p>
    public let buildBatchConfig: ProjectBuildBatchConfig?
    /// <p>The number of the batch build. For each project, the <code>buildBatchNumber</code> of its
    ///             first batch build is <code>1</code>. The <code>buildBatchNumber</code> of each subsequent
    ///             batch build is incremented by <code>1</code>. If a batch build is deleted, the
    ///                 <code>buildBatchNumber</code> of other batch builds does not change.</p>
    public let buildBatchNumber: Int?
    /// <p>The status of the batch build.</p>
    public let buildBatchStatus: StatusType?
    /// <p>An array of <code>BuildGroup</code> objects that define the build groups for the
    ///             batch build.</p>
    public let buildGroups: [BuildGroup]?
    /// <p>Specifies the maximum amount of time, in minutes, that the build in a batch must be
    ///             completed in.</p>
    public let buildTimeoutInMinutes: Int?
    /// <p>Information about the cache for the build project.</p>
    public let cache: ProjectCache?
    /// <p>Indicates if the batch build is complete.</p>
    public let complete: Bool
    /// <p>The current phase of the batch build.</p>
    public let currentPhase: String?
    /// <p>Specifies if session debugging is enabled for this batch build. For more information, see
    ///   <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/session-manager.html">Viewing a running build in Session Manager</a>. Batch session debugging is not supported for matrix batch builds.</p>
    public let debugSessionEnabled: Bool?
    /// <p>The AWS Key Management Service (AWS KMS) customer master key (CMK) to be used for encrypting the batch build output
    ///             artifacts.</p>
    ///         <note>
    ///             <p>You can use a cross-account KMS key to encrypt the build output artifacts if your
    ///                 service role has permission to that key. </p>
    ///         </note>
    ///         <p>You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using
    ///             the format <code>alias/<alias-name></code>).</p>
    public let encryptionKey: String?
    /// <p>The date and time that the batch build ended.</p>
    public let endTime: Date?
    /// <p>Information about the build environment of the build project.</p>
    public let environment: ProjectEnvironment?
    /// <p>An array of <code>ProjectFileSystemLocation</code> objects for the batch build
    ///             project. A <code>ProjectFileSystemLocation</code> object specifies the
    ///                 <code>identifier</code>, <code>location</code>, <code>mountOptions</code>,
    ///                 <code>mountPoint</code>, and <code>type</code> of a file system created using Amazon
    ///             Elastic File System. </p>
    public let fileSystemLocations: [ProjectFileSystemLocation]?
    /// <p>The identifier of the batch build.</p>
    public let id: String?
    /// <p>The entity that started the batch build. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If AWS CodePipeline started the build, the pipeline's name (for example,
    ///                         <code>codepipeline/my-demo-pipeline</code>).</p>
    ///             </li>
    ///             <li>
    ///                 <p>If an AWS Identity and Access Management (IAM) user started the build, the user's name.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If the Jenkins plugin for AWS CodeBuild started the build, the string
    ///                         <code>CodeBuild-Jenkins-Plugin</code>.</p>
    ///             </li>
    ///          </ul>
    public let initiator: String?
    /// <p> Information about logs for a build project. These can be logs in Amazon CloudWatch Logs, built in a
    ///             specified S3 bucket, or both. </p>
    public let logConfig: LogsConfig?
    /// <p>An array of <code>BuildBatchPhase</code> objects the specify the phases of the
    ///             batch build.</p>
    public let phases: [BuildBatchPhase]?
    /// <p>The name of the batch build project.</p>
    public let projectName: String?
    /// <p>Specifies the amount of time, in minutes, that the batch build is allowed to be queued
    ///             before it times out.</p>
    public let queuedTimeoutInMinutes: Int?
    /// <p>The identifier of the resolved version of this batch build's source code.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For AWS CodeCommit, GitHub, GitHub Enterprise, and BitBucket, the commit ID.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For AWS CodePipeline, the source revision provided by AWS CodePipeline.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For Amazon S3, this does not apply.</p>
    ///             </li>
    ///          </ul>
    public let resolvedSourceVersion: String?
    /// <p>An array of <code>BuildArtifacts</code> objects the define the build artifacts
    ///             for this batch build.</p>
    public let secondaryArtifacts: [BuildArtifacts]?
    /// <p>An array of <code>ProjectSourceVersion</code> objects. Each
    ///                 <code>ProjectSourceVersion</code> must be one of: </p>
    ///          <ul>
    ///             <li>
    ///                <p>For AWS CodeCommit: the commit ID, branch, or Git tag to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>For GitHub: the commit ID, pull request ID, branch name, or tag name that
    ///           corresponds to the version of the source code you want to build. If a pull
    ///           request ID is specified, it must use the format <code>pr/pull-request-ID</code>
    ///           (for example, <code>pr/25</code>). If a branch name is specified, the branch's
    ///           HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is
    ///           used.</p>
    ///             </li>
    ///             <li>
    ///                <p>For Bitbucket: the commit ID, branch name, or tag name that corresponds to the
    ///           version of the source code you want to build. If a branch name is specified, the
    ///           branch's HEAD commit ID is used. If not specified, the default branch's HEAD
    ///           commit ID is used.</p>
    ///             </li>
    ///             <li>
    ///                <p>For Amazon S3: the version ID of the object that represents the build input ZIP
    ///           file to use.</p>
    ///             </li>
    ///          </ul>
    public let secondarySourceVersions: [ProjectSourceVersion]?
    /// <p>An array of <code>ProjectSource</code> objects that define the sources for the batch
    ///             build.</p>
    public let secondarySources: [ProjectSource]?
    /// <p>The name of a service role used for builds in the batch.</p>
    public let serviceRole: String?
    /// <p>Information about the build input source code for the build project.</p>
    public let source: ProjectSource?
    /// <p>The identifier of the version of the source code to be built.</p>
    public let sourceVersion: String?
    /// <p>The date and time that the batch build started.</p>
    public let startTime: Date?
    /// <p>Information about the VPC configuration that AWS CodeBuild accesses.</p>
    public let vpcConfig: VpcConfig?

    public init (
        arn: String? = nil,
        artifacts: BuildArtifacts? = nil,
        buildBatchConfig: ProjectBuildBatchConfig? = nil,
        buildBatchNumber: Int? = nil,
        buildBatchStatus: StatusType? = nil,
        buildGroups: [BuildGroup]? = nil,
        buildTimeoutInMinutes: Int? = nil,
        cache: ProjectCache? = nil,
        complete: Bool = false,
        currentPhase: String? = nil,
        debugSessionEnabled: Bool? = nil,
        encryptionKey: String? = nil,
        endTime: Date? = nil,
        environment: ProjectEnvironment? = nil,
        fileSystemLocations: [ProjectFileSystemLocation]? = nil,
        id: String? = nil,
        initiator: String? = nil,
        logConfig: LogsConfig? = nil,
        phases: [BuildBatchPhase]? = nil,
        projectName: String? = nil,
        queuedTimeoutInMinutes: Int? = nil,
        resolvedSourceVersion: String? = nil,
        secondaryArtifacts: [BuildArtifacts]? = nil,
        secondarySourceVersions: [ProjectSourceVersion]? = nil,
        secondarySources: [ProjectSource]? = nil,
        serviceRole: String? = nil,
        source: ProjectSource? = nil,
        sourceVersion: String? = nil,
        startTime: Date? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.arn = arn
        self.artifacts = artifacts
        self.buildBatchConfig = buildBatchConfig
        self.buildBatchNumber = buildBatchNumber
        self.buildBatchStatus = buildBatchStatus
        self.buildGroups = buildGroups
        self.buildTimeoutInMinutes = buildTimeoutInMinutes
        self.cache = cache
        self.complete = complete
        self.currentPhase = currentPhase
        self.debugSessionEnabled = debugSessionEnabled
        self.encryptionKey = encryptionKey
        self.endTime = endTime
        self.environment = environment
        self.fileSystemLocations = fileSystemLocations
        self.id = id
        self.initiator = initiator
        self.logConfig = logConfig
        self.phases = phases
        self.projectName = projectName
        self.queuedTimeoutInMinutes = queuedTimeoutInMinutes
        self.resolvedSourceVersion = resolvedSourceVersion
        self.secondaryArtifacts = secondaryArtifacts
        self.secondarySourceVersions = secondarySourceVersions
        self.secondarySources = secondarySources
        self.serviceRole = serviceRole
        self.source = source
        self.sourceVersion = sourceVersion
        self.startTime = startTime
        self.vpcConfig = vpcConfig
    }
}

extension BuildBatchFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension BuildBatchFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildBatchFilter(status: \(String(describing: status)))"}
}

/// <p>Specifies filters when retrieving batch builds.</p>
public struct BuildBatchFilter: Equatable {
    /// <p>The status of the batch builds to retrieve. Only batch builds that have this status will
    ///             be retrieved.</p>
    public let status: StatusType?

    public init (
        status: StatusType? = nil
    )
    {
        self.status = status
    }
}

extension BuildBatchPhase: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contexts
        case durationInSeconds
        case endTime
        case phaseStatus
        case phaseType
        case startTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contexts = contexts {
            var contextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contexts)
            for phasecontexts0 in contexts {
                try contextsContainer.encode(phasecontexts0)
            }
        }
        if let durationInSeconds = durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let phaseStatus = phaseStatus {
            try encodeContainer.encode(phaseStatus.rawValue, forKey: .phaseStatus)
        }
        if let phaseType = phaseType {
            try encodeContainer.encode(phaseType.rawValue, forKey: .phaseType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phaseTypeDecoded = try containerValues.decodeIfPresent(BuildBatchPhaseType.self, forKey: .phaseType)
        phaseType = phaseTypeDecoded
        let phaseStatusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .phaseStatus)
        phaseStatus = phaseStatusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let contextsContainer = try containerValues.decodeIfPresent([PhaseContext?].self, forKey: .contexts)
        var contextsDecoded0:[PhaseContext]? = nil
        if let contextsContainer = contextsContainer {
            contextsDecoded0 = [PhaseContext]()
            for structure0 in contextsContainer {
                if let structure0 = structure0 {
                    contextsDecoded0?.append(structure0)
                }
            }
        }
        contexts = contextsDecoded0
    }
}

extension BuildBatchPhase: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildBatchPhase(contexts: \(String(describing: contexts)), durationInSeconds: \(String(describing: durationInSeconds)), endTime: \(String(describing: endTime)), phaseStatus: \(String(describing: phaseStatus)), phaseType: \(String(describing: phaseType)), startTime: \(String(describing: startTime)))"}
}

/// <p>Contains information about a stage for a batch build.</p>
public struct BuildBatchPhase: Equatable {
    /// <p>Additional information about the batch build phase. Especially to help troubleshoot a
    ///             failed batch build.</p>
    public let contexts: [PhaseContext]?
    /// <p>How long, in seconds, between the starting and ending times of the batch build's
    ///         phase.</p>
    public let durationInSeconds: Int?
    /// <p>When the batch build phase ended, expressed in Unix time format.</p>
    public let endTime: Date?
    /// <p>The current status of the batch build phase. Valid values include:</p>
    ///         <dl>
    ///             <dt>FAILED</dt>
    ///             <dd>
    ///                     <p>The build phase failed.</p>
    ///                 </dd>
    ///             <dt>FAULT</dt>
    ///             <dd>
    ///                     <p>The build phase faulted.</p>
    ///                 </dd>
    ///             <dt>IN_PROGRESS</dt>
    ///             <dd>
    ///                     <p>The build phase is still in progress.</p>
    ///                 </dd>
    ///             <dt>QUEUED</dt>
    ///             <dd>
    ///                     <p>The build has been submitted and is queued behind other submitted
    ///                         builds.</p>
    ///                 </dd>
    ///             <dt>STOPPED</dt>
    ///             <dd>
    ///                     <p>The build phase stopped.</p>
    ///                 </dd>
    ///             <dt>SUCCEEDED</dt>
    ///             <dd>
    ///                     <p>The build phase succeeded.</p>
    ///                 </dd>
    ///             <dt>TIMED_OUT</dt>
    ///             <dd>
    ///                     <p>The build phase timed out.</p>
    ///                 </dd>
    ///          </dl>
    public let phaseStatus: StatusType?
    /// <p>The name of the batch build phase. Valid values include:</p>
    ///         <dl>
    ///             <dt>COMBINE_ARTIFACTS</dt>
    ///             <dd>
    ///                     <p>Build output artifacts are being combined and uploaded to the output
    ///                         location.</p>
    ///                 </dd>
    ///             <dt>DOWNLOAD_BATCHSPEC</dt>
    ///             <dd>
    ///                     <p>The batch build specification is being downloaded.</p>
    ///                 </dd>
    ///             <dt>FAILED</dt>
    ///             <dd>
    ///                     <p>One or more of the builds failed.</p>
    ///                 </dd>
    ///             <dt>IN_PROGRESS</dt>
    ///             <dd>
    ///                     <p>The batch build is in progress.</p>
    ///                 </dd>
    ///             <dt>STOPPED</dt>
    ///             <dd>
    ///                     <p>The batch build was stopped.</p>
    ///                 </dd>
    ///             <dt>SUBMITTED</dt>
    ///             <dd>
    ///                     <p>The btach build has been submitted.</p>
    ///                 </dd>
    ///             <dt>SUCCEEDED</dt>
    ///             <dd>
    ///                     <p>The batch build succeeded.</p>
    ///                 </dd>
    ///          </dl>
    public let phaseType: BuildBatchPhaseType?
    /// <p>When the batch build phase started, expressed in Unix time format.</p>
    public let startTime: Date?

    public init (
        contexts: [PhaseContext]? = nil,
        durationInSeconds: Int? = nil,
        endTime: Date? = nil,
        phaseStatus: StatusType? = nil,
        phaseType: BuildBatchPhaseType? = nil,
        startTime: Date? = nil
    )
    {
        self.contexts = contexts
        self.durationInSeconds = durationInSeconds
        self.endTime = endTime
        self.phaseStatus = phaseStatus
        self.phaseType = phaseType
        self.startTime = startTime
    }
}

public enum BuildBatchPhaseType {
    case combineArtifacts
    case downloadBatchspec
    case failed
    case inProgress
    case stopped
    case submitted
    case succeeded
    case sdkUnknown(String)
}

extension BuildBatchPhaseType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BuildBatchPhaseType] {
        return [
            .combineArtifacts,
            .downloadBatchspec,
            .failed,
            .inProgress,
            .stopped,
            .submitted,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .combineArtifacts: return "COMBINE_ARTIFACTS"
        case .downloadBatchspec: return "DOWNLOAD_BATCHSPEC"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .stopped: return "STOPPED"
        case .submitted: return "SUBMITTED"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BuildBatchPhaseType(rawValue: rawValue) ?? BuildBatchPhaseType.sdkUnknown(rawValue)
    }
}

extension BuildGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentBuildSummary
        case dependsOn
        case identifier
        case ignoreFailure
        case priorBuildSummaryList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentBuildSummary = currentBuildSummary {
            try encodeContainer.encode(currentBuildSummary, forKey: .currentBuildSummary)
        }
        if let dependsOn = dependsOn {
            var dependsOnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dependsOn)
            for identifiers0 in dependsOn {
                try dependsOnContainer.encode(identifiers0)
            }
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if ignoreFailure != false {
            try encodeContainer.encode(ignoreFailure, forKey: .ignoreFailure)
        }
        if let priorBuildSummaryList = priorBuildSummaryList {
            var priorBuildSummaryListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .priorBuildSummaryList)
            for buildsummaries0 in priorBuildSummaryList {
                try priorBuildSummaryListContainer.encode(buildsummaries0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let dependsOnContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dependsOn)
        var dependsOnDecoded0:[String]? = nil
        if let dependsOnContainer = dependsOnContainer {
            dependsOnDecoded0 = [String]()
            for string0 in dependsOnContainer {
                if let string0 = string0 {
                    dependsOnDecoded0?.append(string0)
                }
            }
        }
        dependsOn = dependsOnDecoded0
        let ignoreFailureDecoded = try containerValues.decode(Bool.self, forKey: .ignoreFailure)
        ignoreFailure = ignoreFailureDecoded
        let currentBuildSummaryDecoded = try containerValues.decodeIfPresent(BuildSummary.self, forKey: .currentBuildSummary)
        currentBuildSummary = currentBuildSummaryDecoded
        let priorBuildSummaryListContainer = try containerValues.decodeIfPresent([BuildSummary?].self, forKey: .priorBuildSummaryList)
        var priorBuildSummaryListDecoded0:[BuildSummary]? = nil
        if let priorBuildSummaryListContainer = priorBuildSummaryListContainer {
            priorBuildSummaryListDecoded0 = [BuildSummary]()
            for structure0 in priorBuildSummaryListContainer {
                if let structure0 = structure0 {
                    priorBuildSummaryListDecoded0?.append(structure0)
                }
            }
        }
        priorBuildSummaryList = priorBuildSummaryListDecoded0
    }
}

extension BuildGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildGroup(currentBuildSummary: \(String(describing: currentBuildSummary)), dependsOn: \(String(describing: dependsOn)), identifier: \(String(describing: identifier)), ignoreFailure: \(String(describing: ignoreFailure)), priorBuildSummaryList: \(String(describing: priorBuildSummaryList)))"}
}

/// <p>Contains information about a batch build build group. Build groups are used to combine
///             builds that can run in parallel, while still being able to set dependencies on other
///             build groups.</p>
public struct BuildGroup: Equatable {
    /// <p>A <code>BuildSummary</code> object that contains a summary of the current build
    ///             group.</p>
    public let currentBuildSummary: BuildSummary?
    /// <p>An array of strings that contain the identifiers of the build groups that this build
    ///             group depends on.</p>
    public let dependsOn: [String]?
    /// <p>Contains the identifier of the build group.</p>
    public let identifier: String?
    /// <p>Specifies if failures in this build group can be ignored.</p>
    public let ignoreFailure: Bool
    /// <p>An array of <code>BuildSummary</code> objects that contain summaries of previous
    ///             build groups.</p>
    public let priorBuildSummaryList: [BuildSummary]?

    public init (
        currentBuildSummary: BuildSummary? = nil,
        dependsOn: [String]? = nil,
        identifier: String? = nil,
        ignoreFailure: Bool = false,
        priorBuildSummaryList: [BuildSummary]? = nil
    )
    {
        self.currentBuildSummary = currentBuildSummary
        self.dependsOn = dependsOn
        self.identifier = identifier
        self.ignoreFailure = ignoreFailure
        self.priorBuildSummaryList = priorBuildSummaryList
    }
}

extension BuildNotDeleted: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case statusCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension BuildNotDeleted: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildNotDeleted(id: \(String(describing: id)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>Information about a build that could not be successfully deleted.</p>
public struct BuildNotDeleted: Equatable {
    /// <p>The ID of the build that could not be successfully deleted.</p>
    public let id: String?
    /// <p>Additional information about the build that could not be successfully deleted.</p>
    public let statusCode: String?

    public init (
        id: String? = nil,
        statusCode: String? = nil
    )
    {
        self.id = id
        self.statusCode = statusCode
    }
}

extension BuildPhase: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contexts
        case durationInSeconds
        case endTime
        case phaseStatus
        case phaseType
        case startTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contexts = contexts {
            var contextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contexts)
            for phasecontexts0 in contexts {
                try contextsContainer.encode(phasecontexts0)
            }
        }
        if let durationInSeconds = durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let phaseStatus = phaseStatus {
            try encodeContainer.encode(phaseStatus.rawValue, forKey: .phaseStatus)
        }
        if let phaseType = phaseType {
            try encodeContainer.encode(phaseType.rawValue, forKey: .phaseType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phaseTypeDecoded = try containerValues.decodeIfPresent(BuildPhaseType.self, forKey: .phaseType)
        phaseType = phaseTypeDecoded
        let phaseStatusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .phaseStatus)
        phaseStatus = phaseStatusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let contextsContainer = try containerValues.decodeIfPresent([PhaseContext?].self, forKey: .contexts)
        var contextsDecoded0:[PhaseContext]? = nil
        if let contextsContainer = contextsContainer {
            contextsDecoded0 = [PhaseContext]()
            for structure0 in contextsContainer {
                if let structure0 = structure0 {
                    contextsDecoded0?.append(structure0)
                }
            }
        }
        contexts = contextsDecoded0
    }
}

extension BuildPhase: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildPhase(contexts: \(String(describing: contexts)), durationInSeconds: \(String(describing: durationInSeconds)), endTime: \(String(describing: endTime)), phaseStatus: \(String(describing: phaseStatus)), phaseType: \(String(describing: phaseType)), startTime: \(String(describing: startTime)))"}
}

/// <p>Information about a stage for a build.</p>
public struct BuildPhase: Equatable {
    /// <p>Additional information about a build phase, especially to help troubleshoot a failed
    ///             build.</p>
    public let contexts: [PhaseContext]?
    /// <p>How long, in seconds, between the starting and ending times of the build's
    ///             phase.</p>
    public let durationInSeconds: Int?
    /// <p>When the build phase ended, expressed in Unix time format.</p>
    public let endTime: Date?
    /// <p>The current status of the build phase. Valid values include:</p>
    ///         <dl>
    ///             <dt>FAILED</dt>
    ///             <dd>
    ///                     <p>The build phase failed.</p>
    ///                 </dd>
    ///             <dt>FAULT</dt>
    ///             <dd>
    ///                     <p>The build phase faulted.</p>
    ///                 </dd>
    ///             <dt>IN_PROGRESS</dt>
    ///             <dd>
    ///                     <p>The build phase is still in progress.</p>
    ///                 </dd>
    ///             <dt>QUEUED</dt>
    ///             <dd>
    ///                     <p>The build has been submitted and is queued behind other submitted
    ///                         builds.</p>
    ///                 </dd>
    ///             <dt>STOPPED</dt>
    ///             <dd>
    ///                     <p>The build phase stopped.</p>
    ///                 </dd>
    ///             <dt>SUCCEEDED</dt>
    ///             <dd>
    ///                     <p>The build phase succeeded.</p>
    ///                 </dd>
    ///             <dt>TIMED_OUT</dt>
    ///             <dd>
    ///                     <p>The build phase timed out.</p>
    ///                 </dd>
    ///          </dl>
    public let phaseStatus: StatusType?
    /// <p>The name of the build phase. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>BUILD</code>: Core build activities typically occur in this build
    ///                     phase.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>COMPLETED</code>: The build has been completed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DOWNLOAD_SOURCE</code>: Source code is being downloaded in this build
    ///                     phase.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FINALIZING</code>: The build process is completing in this build
    ///                     phase.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>INSTALL</code>: Installation activities typically occur in this build
    ///                     phase.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>POST_BUILD</code>: Post-build activities typically occur in this build
    ///                     phase.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>PRE_BUILD</code>: Pre-build activities typically occur in this build
    ///                     phase.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>PROVISIONING</code>: The build environment is being set up.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>QUEUED</code>: The build has been submitted and is queued behind other
    ///                     submitted builds.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SUBMITTED</code>: The build has been submitted.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>UPLOAD_ARTIFACTS</code>: Build output artifacts are being uploaded to
    ///                     the output location.</p>
    ///             </li>
    ///          </ul>
    public let phaseType: BuildPhaseType?
    /// <p>When the build phase started, expressed in Unix time format.</p>
    public let startTime: Date?

    public init (
        contexts: [PhaseContext]? = nil,
        durationInSeconds: Int? = nil,
        endTime: Date? = nil,
        phaseStatus: StatusType? = nil,
        phaseType: BuildPhaseType? = nil,
        startTime: Date? = nil
    )
    {
        self.contexts = contexts
        self.durationInSeconds = durationInSeconds
        self.endTime = endTime
        self.phaseStatus = phaseStatus
        self.phaseType = phaseType
        self.startTime = startTime
    }
}

public enum BuildPhaseType {
    case build
    case completed
    case downloadSource
    case finalizing
    case install
    case postBuild
    case preBuild
    case provisioning
    case queued
    case submitted
    case uploadArtifacts
    case sdkUnknown(String)
}

extension BuildPhaseType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BuildPhaseType] {
        return [
            .build,
            .completed,
            .downloadSource,
            .finalizing,
            .install,
            .postBuild,
            .preBuild,
            .provisioning,
            .queued,
            .submitted,
            .uploadArtifacts,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .build: return "BUILD"
        case .completed: return "COMPLETED"
        case .downloadSource: return "DOWNLOAD_SOURCE"
        case .finalizing: return "FINALIZING"
        case .install: return "INSTALL"
        case .postBuild: return "POST_BUILD"
        case .preBuild: return "PRE_BUILD"
        case .provisioning: return "PROVISIONING"
        case .queued: return "QUEUED"
        case .submitted: return "SUBMITTED"
        case .uploadArtifacts: return "UPLOAD_ARTIFACTS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BuildPhaseType(rawValue: rawValue) ?? BuildPhaseType.sdkUnknown(rawValue)
    }
}

extension BuildStatusConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case context
        case targetUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let context = context {
            try encodeContainer.encode(context, forKey: .context)
        }
        if let targetUrl = targetUrl {
            try encodeContainer.encode(targetUrl, forKey: .targetUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
        let targetUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetUrl)
        targetUrl = targetUrlDecoded
    }
}

extension BuildStatusConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildStatusConfig(context: \(String(describing: context)), targetUrl: \(String(describing: targetUrl)))"}
}

/// <p>Contains information that defines how the AWS CodeBuild build project reports the build status
///             to the source provider. </p>
public struct BuildStatusConfig: Equatable {
    /// <p>Specifies the context of the build status CodeBuild sends to the source provider. The
    ///             usage of this parameter depends on the source provider.</p>
    ///         <dl>
    ///             <dt>Bitbucket</dt>
    ///             <dd>
    ///                     <p>This parameter is used for the <code>name</code> parameter in the
    ///                         Bitbucket commit status. For more information, see <a href="https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Bworkspace%7D/%7Brepo_slug%7D/commit/%7Bnode%7D/statuses/build">build</a> in the Bitbucket API documentation.</p>
    ///                 </dd>
    ///             <dt>GitHub/GitHub Enterprise Server</dt>
    ///             <dd>
    ///                     <p>This parameter is used for the <code>context</code> parameter in the
    ///                         GitHub commit status. For more information, see <a href="https://developer.github.com/v3/repos/statuses/#create-a-commit-status">Create a commit status</a> in the GitHub developer guide.</p>
    ///                 </dd>
    ///          </dl>
    public let context: String?
    /// <p>Specifies the target url of the build status CodeBuild sends to the source provider. The
    ///             usage of this parameter depends on the source provider.</p>
    ///         <dl>
    ///             <dt>Bitbucket</dt>
    ///             <dd>
    ///                     <p>This parameter is used for the <code>url</code> parameter in the Bitbucket
    ///                         commit status. For more information, see <a href="https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Bworkspace%7D/%7Brepo_slug%7D/commit/%7Bnode%7D/statuses/build">build</a> in the Bitbucket API documentation.</p>
    ///                 </dd>
    ///             <dt>GitHub/GitHub Enterprise Server</dt>
    ///             <dd>
    ///                     <p>This parameter is used for the <code>target_url</code> parameter in the
    ///                         GitHub commit status. For more information, see <a href="https://developer.github.com/v3/repos/statuses/#create-a-commit-status">Create a commit status</a> in the GitHub developer guide.</p>
    ///                 </dd>
    ///          </dl>
    public let targetUrl: String?

    public init (
        context: String? = nil,
        targetUrl: String? = nil
    )
    {
        self.context = context
        self.targetUrl = targetUrl
    }
}

extension BuildSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case buildStatus
        case primaryArtifact
        case requestedOn
        case secondaryArtifacts
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let buildStatus = buildStatus {
            try encodeContainer.encode(buildStatus.rawValue, forKey: .buildStatus)
        }
        if let primaryArtifact = primaryArtifact {
            try encodeContainer.encode(primaryArtifact, forKey: .primaryArtifact)
        }
        if let requestedOn = requestedOn {
            try encodeContainer.encode(requestedOn.timeIntervalSince1970, forKey: .requestedOn)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for resolvedsecondaryartifacts0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(resolvedsecondaryartifacts0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let requestedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .requestedOn)
        requestedOn = requestedOnDecoded
        let buildStatusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .buildStatus)
        buildStatus = buildStatusDecoded
        let primaryArtifactDecoded = try containerValues.decodeIfPresent(ResolvedArtifact.self, forKey: .primaryArtifact)
        primaryArtifact = primaryArtifactDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([ResolvedArtifact?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[ResolvedArtifact]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [ResolvedArtifact]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
    }
}

extension BuildSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildSummary(arn: \(String(describing: arn)), buildStatus: \(String(describing: buildStatus)), primaryArtifact: \(String(describing: primaryArtifact)), requestedOn: \(String(describing: requestedOn)), secondaryArtifacts: \(String(describing: secondaryArtifacts)))"}
}

/// <p>Contains summary information about a batch build group.</p>
public struct BuildSummary: Equatable {
    /// <p>The batch build ARN.</p>
    public let arn: String?
    /// <p>The status of the build group.</p>
    ///         <dl>
    ///             <dt>FAILED</dt>
    ///             <dd>
    ///                     <p>The build group failed.</p>
    ///                 </dd>
    ///             <dt>FAULT</dt>
    ///             <dd>
    ///                     <p>The build group faulted.</p>
    ///                 </dd>
    ///             <dt>IN_PROGRESS</dt>
    ///             <dd>
    ///                     <p>The build group is still in progress.</p>
    ///                 </dd>
    ///             <dt>STOPPED</dt>
    ///             <dd>
    ///                     <p>The build group stopped.</p>
    ///                 </dd>
    ///             <dt>SUCCEEDED</dt>
    ///             <dd>
    ///                     <p>The build group succeeded.</p>
    ///                 </dd>
    ///             <dt>TIMED_OUT</dt>
    ///             <dd>
    ///                     <p>The build group timed out.</p>
    ///                 </dd>
    ///          </dl>
    public let buildStatus: StatusType?
    /// <p>A <code>ResolvedArtifact</code> object that represents the primary build artifacts for the
    ///             build group.</p>
    public let primaryArtifact: ResolvedArtifact?
    /// <p>When the build was started, expressed in Unix time format.</p>
    public let requestedOn: Date?
    /// <p>An array of <code>ResolvedArtifact</code> objects that represents the secondary build
    ///             artifacts for the build group.</p>
    public let secondaryArtifacts: [ResolvedArtifact]?

    public init (
        arn: String? = nil,
        buildStatus: StatusType? = nil,
        primaryArtifact: ResolvedArtifact? = nil,
        requestedOn: Date? = nil,
        secondaryArtifacts: [ResolvedArtifact]? = nil
    )
    {
        self.arn = arn
        self.buildStatus = buildStatus
        self.primaryArtifact = primaryArtifact
        self.requestedOn = requestedOn
        self.secondaryArtifacts = secondaryArtifacts
    }
}

public enum CacheMode {
    case localCustomCache
    case localDockerLayerCache
    case localSourceCache
    case sdkUnknown(String)
}

extension CacheMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CacheMode] {
        return [
            .localCustomCache,
            .localDockerLayerCache,
            .localSourceCache,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .localCustomCache: return "LOCAL_CUSTOM_CACHE"
        case .localDockerLayerCache: return "LOCAL_DOCKER_LAYER_CACHE"
        case .localSourceCache: return "LOCAL_SOURCE_CACHE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CacheMode(rawValue: rawValue) ?? CacheMode.sdkUnknown(rawValue)
    }
}

public enum CacheType {
    case local
    case noCache
    case s3
    case sdkUnknown(String)
}

extension CacheType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CacheType] {
        return [
            .local,
            .noCache,
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .local: return "LOCAL"
        case .noCache: return "NO_CACHE"
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CacheType(rawValue: rawValue) ?? CacheType.sdkUnknown(rawValue)
    }
}

extension CloudWatchLogsConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupName
        case status
        case streamName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LogsConfigStatusType.self, forKey: .status)
        status = statusDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension CloudWatchLogsConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLogsConfig(groupName: \(String(describing: groupName)), status: \(String(describing: status)), streamName: \(String(describing: streamName)))"}
}

/// <p> Information about Amazon CloudWatch Logs for a build project. </p>
public struct CloudWatchLogsConfig: Equatable {
    /// <p> The group name of the logs in Amazon CloudWatch Logs. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html">Working
    ///                 with Log Groups and Log Streams</a>. </p>
    public let groupName: String?
    /// <p>The current status of the logs in Amazon CloudWatch Logs for a build project. Valid values are:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ENABLED</code>: Amazon CloudWatch Logs are enabled for this build project.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DISABLED</code>: Amazon CloudWatch Logs are not enabled for this build project.</p>
    ///             </li>
    ///          </ul>
    public let status: LogsConfigStatusType?
    /// <p> The prefix of the stream name of the Amazon CloudWatch Logs. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html">Working
    ///                 with Log Groups and Log Streams</a>. </p>
    public let streamName: String?

    public init (
        groupName: String? = nil,
        status: LogsConfigStatusType? = nil,
        streamName: String? = nil
    )
    {
        self.groupName = groupName
        self.status = status
        self.streamName = streamName
    }
}

extension CodeCoverage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchCoveragePercentage
        case branchesCovered
        case branchesMissed
        case expired
        case filePath
        case id
        case lineCoveragePercentage
        case linesCovered
        case linesMissed
        case reportARN
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchCoveragePercentage = branchCoveragePercentage {
            try encodeContainer.encode(branchCoveragePercentage, forKey: .branchCoveragePercentage)
        }
        if let branchesCovered = branchesCovered {
            try encodeContainer.encode(branchesCovered, forKey: .branchesCovered)
        }
        if let branchesMissed = branchesMissed {
            try encodeContainer.encode(branchesMissed, forKey: .branchesMissed)
        }
        if let expired = expired {
            try encodeContainer.encode(expired.timeIntervalSince1970, forKey: .expired)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lineCoveragePercentage = lineCoveragePercentage {
            try encodeContainer.encode(lineCoveragePercentage, forKey: .lineCoveragePercentage)
        }
        if let linesCovered = linesCovered {
            try encodeContainer.encode(linesCovered, forKey: .linesCovered)
        }
        if let linesMissed = linesMissed {
            try encodeContainer.encode(linesMissed, forKey: .linesMissed)
        }
        if let reportARN = reportARN {
            try encodeContainer.encode(reportARN, forKey: .reportARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let reportARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportARN)
        reportARN = reportARNDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let lineCoveragePercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .lineCoveragePercentage)
        lineCoveragePercentage = lineCoveragePercentageDecoded
        let linesCoveredDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .linesCovered)
        linesCovered = linesCoveredDecoded
        let linesMissedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .linesMissed)
        linesMissed = linesMissedDecoded
        let branchCoveragePercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .branchCoveragePercentage)
        branchCoveragePercentage = branchCoveragePercentageDecoded
        let branchesCoveredDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .branchesCovered)
        branchesCovered = branchesCoveredDecoded
        let branchesMissedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .branchesMissed)
        branchesMissed = branchesMissedDecoded
        let expiredDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expired)
        expired = expiredDecoded
    }
}

extension CodeCoverage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeCoverage(branchCoveragePercentage: \(String(describing: branchCoveragePercentage)), branchesCovered: \(String(describing: branchesCovered)), branchesMissed: \(String(describing: branchesMissed)), expired: \(String(describing: expired)), filePath: \(String(describing: filePath)), id: \(String(describing: id)), lineCoveragePercentage: \(String(describing: lineCoveragePercentage)), linesCovered: \(String(describing: linesCovered)), linesMissed: \(String(describing: linesMissed)), reportARN: \(String(describing: reportARN)))"}
}

/// <p>Contains code coverage report information.</p>
///         <p>Line coverage measures how many statements your tests cover. A statement is a single
///       instruction, not including comments, conditionals, etc.</p>
///         <p>Branch coverage determines if your tests cover every possible branch of a control
///     structure, such as an <code>if</code> or <code>case</code> statement.</p>
public struct CodeCoverage: Equatable {
    /// <p>The percentage of branches that are covered by your tests.</p>
    public let branchCoveragePercentage: Double?
    /// <p>The number of conditional branches that are covered by your tests.</p>
    public let branchesCovered: Int?
    /// <p>The number of conditional branches that are not covered by your tests.</p>
    public let branchesMissed: Int?
    /// <p>The date and time that the tests were run.</p>
    public let expired: Date?
    /// <p>The path of the test report file.</p>
    public let filePath: String?
    /// <p>The identifier of the code coverage report.</p>
    public let id: String?
    /// <p>The percentage of lines that are covered by your tests.</p>
    public let lineCoveragePercentage: Double?
    /// <p>The number of lines that are covered by your tests.</p>
    public let linesCovered: Int?
    /// <p>The number of lines that are not covered by your tests.</p>
    public let linesMissed: Int?
    /// <p>The ARN of the report.</p>
    public let reportARN: String?

    public init (
        branchCoveragePercentage: Double? = nil,
        branchesCovered: Int? = nil,
        branchesMissed: Int? = nil,
        expired: Date? = nil,
        filePath: String? = nil,
        id: String? = nil,
        lineCoveragePercentage: Double? = nil,
        linesCovered: Int? = nil,
        linesMissed: Int? = nil,
        reportARN: String? = nil
    )
    {
        self.branchCoveragePercentage = branchCoveragePercentage
        self.branchesCovered = branchesCovered
        self.branchesMissed = branchesMissed
        self.expired = expired
        self.filePath = filePath
        self.id = id
        self.lineCoveragePercentage = lineCoveragePercentage
        self.linesCovered = linesCovered
        self.linesMissed = linesMissed
        self.reportARN = reportARN
    }
}

extension CodeCoverageReportSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchCoveragePercentage
        case branchesCovered
        case branchesMissed
        case lineCoveragePercentage
        case linesCovered
        case linesMissed
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchCoveragePercentage = branchCoveragePercentage {
            try encodeContainer.encode(branchCoveragePercentage, forKey: .branchCoveragePercentage)
        }
        if let branchesCovered = branchesCovered {
            try encodeContainer.encode(branchesCovered, forKey: .branchesCovered)
        }
        if let branchesMissed = branchesMissed {
            try encodeContainer.encode(branchesMissed, forKey: .branchesMissed)
        }
        if let lineCoveragePercentage = lineCoveragePercentage {
            try encodeContainer.encode(lineCoveragePercentage, forKey: .lineCoveragePercentage)
        }
        if let linesCovered = linesCovered {
            try encodeContainer.encode(linesCovered, forKey: .linesCovered)
        }
        if let linesMissed = linesMissed {
            try encodeContainer.encode(linesMissed, forKey: .linesMissed)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineCoveragePercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .lineCoveragePercentage)
        lineCoveragePercentage = lineCoveragePercentageDecoded
        let linesCoveredDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .linesCovered)
        linesCovered = linesCoveredDecoded
        let linesMissedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .linesMissed)
        linesMissed = linesMissedDecoded
        let branchCoveragePercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .branchCoveragePercentage)
        branchCoveragePercentage = branchCoveragePercentageDecoded
        let branchesCoveredDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .branchesCovered)
        branchesCovered = branchesCoveredDecoded
        let branchesMissedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .branchesMissed)
        branchesMissed = branchesMissedDecoded
    }
}

extension CodeCoverageReportSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeCoverageReportSummary(branchCoveragePercentage: \(String(describing: branchCoveragePercentage)), branchesCovered: \(String(describing: branchesCovered)), branchesMissed: \(String(describing: branchesMissed)), lineCoveragePercentage: \(String(describing: lineCoveragePercentage)), linesCovered: \(String(describing: linesCovered)), linesMissed: \(String(describing: linesMissed)))"}
}

/// <p>Contains a summary of a code coverage report.</p>
///         <p>Line coverage measures how many statements your tests cover. A statement is a single
///       instruction, not including comments, conditionals, etc.</p>
///         <p>Branch coverage determines if your tests cover every possible branch of a control
///     structure, such as an <code>if</code> or <code>case</code> statement.</p>
public struct CodeCoverageReportSummary: Equatable {
    /// <p>The percentage of branches that are covered by your tests.</p>
    public let branchCoveragePercentage: Double?
    /// <p>The number of conditional branches that are covered by your tests.</p>
    public let branchesCovered: Int?
    /// <p>The number of conditional branches that are not covered by your tests.</p>
    public let branchesMissed: Int?
    /// <p>The percentage of lines that are covered by your tests.</p>
    public let lineCoveragePercentage: Double?
    /// <p>The number of lines that are covered by your tests.</p>
    public let linesCovered: Int?
    /// <p>The number of lines that are not covered by your tests.</p>
    public let linesMissed: Int?

    public init (
        branchCoveragePercentage: Double? = nil,
        branchesCovered: Int? = nil,
        branchesMissed: Int? = nil,
        lineCoveragePercentage: Double? = nil,
        linesCovered: Int? = nil,
        linesMissed: Int? = nil
    )
    {
        self.branchCoveragePercentage = branchCoveragePercentage
        self.branchesCovered = branchesCovered
        self.branchesMissed = branchesMissed
        self.lineCoveragePercentage = lineCoveragePercentage
        self.linesCovered = linesCovered
        self.linesMissed = linesMissed
    }
}

public enum ComputeType {
    case buildGeneral12xlarge
    case buildGeneral1Large
    case buildGeneral1Medium
    case buildGeneral1Small
    case sdkUnknown(String)
}

extension ComputeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComputeType] {
        return [
            .buildGeneral12xlarge,
            .buildGeneral1Large,
            .buildGeneral1Medium,
            .buildGeneral1Small,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .buildGeneral12xlarge: return "BUILD_GENERAL1_2XLARGE"
        case .buildGeneral1Large: return "BUILD_GENERAL1_LARGE"
        case .buildGeneral1Medium: return "BUILD_GENERAL1_MEDIUM"
        case .buildGeneral1Small: return "BUILD_GENERAL1_SMALL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComputeType(rawValue: rawValue) ?? ComputeType.sdkUnknown(rawValue)
    }
}

public struct CreateProjectInputBodyMiddleware: Middleware {
    public let id: String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectInput(artifacts: \(String(describing: artifacts)), badgeEnabled: \(String(describing: badgeEnabled)), buildBatchConfig: \(String(describing: buildBatchConfig)), cache: \(String(describing: cache)), concurrentBuildLimit: \(String(describing: concurrentBuildLimit)), description: \(String(describing: description)), encryptionKey: \(String(describing: encryptionKey)), environment: \(String(describing: environment)), fileSystemLocations: \(String(describing: fileSystemLocations)), logsConfig: \(String(describing: logsConfig)), name: \(String(describing: name)), queuedTimeoutInMinutes: \(String(describing: queuedTimeoutInMinutes)), secondaryArtifacts: \(String(describing: secondaryArtifacts)), secondarySourceVersions: \(String(describing: secondarySourceVersions)), secondarySources: \(String(describing: secondarySources)), serviceRole: \(String(describing: serviceRole)), source: \(String(describing: source)), sourceVersion: \(String(describing: sourceVersion)), tags: \(String(describing: tags)), timeoutInMinutes: \(String(describing: timeoutInMinutes)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension CreateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifacts
        case badgeEnabled
        case buildBatchConfig
        case cache
        case concurrentBuildLimit
        case description
        case encryptionKey
        case environment
        case fileSystemLocations
        case logsConfig
        case name
        case queuedTimeoutInMinutes
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case tags
        case timeoutInMinutes
        case vpcConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifacts = artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let badgeEnabled = badgeEnabled {
            try encodeContainer.encode(badgeEnabled, forKey: .badgeEnabled)
        }
        if let buildBatchConfig = buildBatchConfig {
            try encodeContainer.encode(buildBatchConfig, forKey: .buildBatchConfig)
        }
        if let cache = cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if let concurrentBuildLimit = concurrentBuildLimit {
            try encodeContainer.encode(concurrentBuildLimit, forKey: .concurrentBuildLimit)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocations0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocations0)
            }
        }
        if let logsConfig = logsConfig {
            try encodeContainer.encode(logsConfig, forKey: .logsConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queuedTimeoutInMinutes = queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for projectartifactslist0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(projectartifactslist0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsecondarysourceversions0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsecondarysourceversions0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsources0 in secondarySources {
                try secondarySourcesContainer.encode(projectsources0)
            }
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let timeoutInMinutes = timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInput: Equatable {
    /// <p>Information about the build output artifacts for the build project.</p>
    public let artifacts: ProjectArtifacts?
    /// <p>Set this to true to generate a publicly accessible URL for your project's build
    ///         badge.</p>
    public let badgeEnabled: Bool?
    /// <p>A <a>ProjectBuildBatchConfig</a>
    ///  object that defines the batch build options
    ///             for the project.</p>
    public let buildBatchConfig: ProjectBuildBatchConfig?
    /// <p>Stores recently used information so that it can be quickly accessed at a later
    ///         time.</p>
    public let cache: ProjectCache?
    /// <p>The maximum number of concurrent builds that are allowed for this project.</p>
    ///          <p>New builds are only started if the current number of builds is less than or equal to this limit.
    ///   If the current build count meets this limit, new builds are throttled and are not run.</p>
    public let concurrentBuildLimit: Int?
    /// <p>A description that makes the build project easy to identify.</p>
    public let description: String?
    /// <p>The AWS Key Management Service (AWS KMS) customer master key (CMK) to be used for encrypting the build output
    ///       artifacts.</p>
    ///          <note>
    ///             <p>You can use a cross-account KMS key to encrypt the build output artifacts if your
    ///         service role has permission to that key. </p>
    ///          </note>
    ///          <p>You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using
    ///         the format <code>alias/<alias-name></code>).
    ///     </p>
    public let encryptionKey: String?
    /// <p>Information about the build environment for the build project.</p>
    public let environment: ProjectEnvironment?
    /// <p>
    ///       An array of <code>ProjectFileSystemLocation</code> objects for a CodeBuild build project. A <code>ProjectFileSystemLocation</code> object
    ///       specifies the <code>identifier</code>, <code>location</code>, <code>mountOptions</code>,
    ///       <code>mountPoint</code>, and <code>type</code> of a file system created using Amazon Elastic File System.
    ///   </p>
    public let fileSystemLocations: [ProjectFileSystemLocation]?
    /// <p>Information about logs for the build project. These can be logs in Amazon CloudWatch Logs, logs
    ///       uploaded to a specified S3 bucket, or both. </p>
    public let logsConfig: LogsConfig?
    /// <p>The name of the build project.</p>
    public let name: String?
    /// <p>The number of minutes a build is allowed to be queued before it times out. </p>
    public let queuedTimeoutInMinutes: Int?
    /// <p>An array of <code>ProjectArtifacts</code> objects. </p>
    public let secondaryArtifacts: [ProjectArtifacts]?
    /// <p>An array of <code>ProjectSourceVersion</code> objects. If
    ///       <code>secondarySourceVersions</code> is specified at the build level, then they take
    ///       precedence over these <code>secondarySourceVersions</code> (at the project level).
    ///     </p>
    public let secondarySourceVersions: [ProjectSourceVersion]?
    /// <p>An array of <code>ProjectSource</code> objects. </p>
    public let secondarySources: [ProjectSource]?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that enables AWS CodeBuild to interact with dependent AWS services
    ///       on behalf of the AWS account.</p>
    public let serviceRole: String?
    /// <p>Information about the build input source code for the build project.</p>
    public let source: ProjectSource?
    /// <p>A version of the build input to be built for this project. If not specified, the latest
    ///             version is used. If specified, it must be one of: </p>
    ///          <ul>
    ///             <li>
    ///                <p>For AWS CodeCommit: the commit ID, branch, or Git tag to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>For GitHub: the commit ID, pull request ID, branch name, or tag name that
    ///           corresponds to the version of the source code you want to build. If a pull
    ///           request ID is specified, it must use the format <code>pr/pull-request-ID</code>
    ///           (for example <code>pr/25</code>). If a branch name is specified, the branch's
    ///           HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is
    ///           used.</p>
    ///             </li>
    ///             <li>
    ///                <p>For Bitbucket: the commit ID, branch name, or tag name that corresponds to the
    ///           version of the source code you want to build. If a branch name is specified, the
    ///           branch's HEAD commit ID is used. If not specified, the default branch's HEAD
    ///           commit ID is used.</p>
    ///             </li>
    ///             <li>
    ///                <p>For Amazon S3: the version ID of the object that represents the build input ZIP
    ///           file to use.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If <code>sourceVersion</code> is specified at the build level, then that version takes
    ///             precedence over this <code>sourceVersion</code> (at the project level). </p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html">Source Version Sample
    ///                 with CodeBuild</a> in the <i>AWS CodeBuild User Guide</i>.
    ///     </p>
    public let sourceVersion: String?
    /// <p>A list of tag key and value pairs associated with this build project.</p>
    ///          <p>These tags are available for use by AWS services that support AWS CodeBuild build project
    ///       tags.</p>
    public let tags: [Tag]?
    /// <p>How long, in minutes, from 5 to 480 (8 hours), for AWS CodeBuild to wait before it times out
    ///       any build that has not been marked as completed. The default is 60 minutes.</p>
    public let timeoutInMinutes: Int?
    /// <p>VpcConfig enables AWS CodeBuild to access resources in an Amazon VPC.</p>
    public let vpcConfig: VpcConfig?

    public init (
        artifacts: ProjectArtifacts? = nil,
        badgeEnabled: Bool? = nil,
        buildBatchConfig: ProjectBuildBatchConfig? = nil,
        cache: ProjectCache? = nil,
        concurrentBuildLimit: Int? = nil,
        description: String? = nil,
        encryptionKey: String? = nil,
        environment: ProjectEnvironment? = nil,
        fileSystemLocations: [ProjectFileSystemLocation]? = nil,
        logsConfig: LogsConfig? = nil,
        name: String? = nil,
        queuedTimeoutInMinutes: Int? = nil,
        secondaryArtifacts: [ProjectArtifacts]? = nil,
        secondarySourceVersions: [ProjectSourceVersion]? = nil,
        secondarySources: [ProjectSource]? = nil,
        serviceRole: String? = nil,
        source: ProjectSource? = nil,
        sourceVersion: String? = nil,
        tags: [Tag]? = nil,
        timeoutInMinutes: Int? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.artifacts = artifacts
        self.badgeEnabled = badgeEnabled
        self.buildBatchConfig = buildBatchConfig
        self.cache = cache
        self.concurrentBuildLimit = concurrentBuildLimit
        self.description = description
        self.encryptionKey = encryptionKey
        self.environment = environment
        self.fileSystemLocations = fileSystemLocations
        self.logsConfig = logsConfig
        self.name = name
        self.queuedTimeoutInMinutes = queuedTimeoutInMinutes
        self.secondaryArtifacts = secondaryArtifacts
        self.secondarySourceVersions = secondarySourceVersions
        self.secondarySources = secondarySources
        self.serviceRole = serviceRole
        self.source = source
        self.sourceVersion = sourceVersion
        self.tags = tags
        self.timeoutInMinutes = timeoutInMinutes
        self.vpcConfig = vpcConfig
    }
}

struct CreateProjectInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let source: ProjectSource?
    public let secondarySources: [ProjectSource]?
    public let sourceVersion: String?
    public let secondarySourceVersions: [ProjectSourceVersion]?
    public let artifacts: ProjectArtifacts?
    public let secondaryArtifacts: [ProjectArtifacts]?
    public let cache: ProjectCache?
    public let environment: ProjectEnvironment?
    public let serviceRole: String?
    public let timeoutInMinutes: Int?
    public let queuedTimeoutInMinutes: Int?
    public let encryptionKey: String?
    public let tags: [Tag]?
    public let vpcConfig: VpcConfig?
    public let badgeEnabled: Bool?
    public let logsConfig: LogsConfig?
    public let fileSystemLocations: [ProjectFileSystemLocation]?
    public let buildBatchConfig: ProjectBuildBatchConfig?
    public let concurrentBuildLimit: Int?
}

extension CreateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case artifacts
        case badgeEnabled
        case buildBatchConfig
        case cache
        case concurrentBuildLimit
        case description
        case encryptionKey
        case environment
        case fileSystemLocations
        case logsConfig
        case name
        case queuedTimeoutInMinutes
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case tags
        case timeoutInMinutes
        case vpcConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(ProjectSource.self, forKey: .source)
        source = sourceDecoded
        let secondarySourcesContainer = try containerValues.decodeIfPresent([ProjectSource?].self, forKey: .secondarySources)
        var secondarySourcesDecoded0:[ProjectSource]? = nil
        if let secondarySourcesContainer = secondarySourcesContainer {
            secondarySourcesDecoded0 = [ProjectSource]()
            for structure0 in secondarySourcesContainer {
                if let structure0 = structure0 {
                    secondarySourcesDecoded0?.append(structure0)
                }
            }
        }
        secondarySources = secondarySourcesDecoded0
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let secondarySourceVersionsContainer = try containerValues.decodeIfPresent([ProjectSourceVersion?].self, forKey: .secondarySourceVersions)
        var secondarySourceVersionsDecoded0:[ProjectSourceVersion]? = nil
        if let secondarySourceVersionsContainer = secondarySourceVersionsContainer {
            secondarySourceVersionsDecoded0 = [ProjectSourceVersion]()
            for structure0 in secondarySourceVersionsContainer {
                if let structure0 = structure0 {
                    secondarySourceVersionsDecoded0?.append(structure0)
                }
            }
        }
        secondarySourceVersions = secondarySourceVersionsDecoded0
        let artifactsDecoded = try containerValues.decodeIfPresent(ProjectArtifacts.self, forKey: .artifacts)
        artifacts = artifactsDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([ProjectArtifacts?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[ProjectArtifacts]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [ProjectArtifacts]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
        let cacheDecoded = try containerValues.decodeIfPresent(ProjectCache.self, forKey: .cache)
        cache = cacheDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(ProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
        let queuedTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queuedTimeoutInMinutes)
        queuedTimeoutInMinutes = queuedTimeoutInMinutesDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let badgeEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .badgeEnabled)
        badgeEnabled = badgeEnabledDecoded
        let logsConfigDecoded = try containerValues.decodeIfPresent(LogsConfig.self, forKey: .logsConfig)
        logsConfig = logsConfigDecoded
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([ProjectFileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[ProjectFileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [ProjectFileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
        let buildBatchConfigDecoded = try containerValues.decodeIfPresent(ProjectBuildBatchConfig.self, forKey: .buildBatchConfig)
        buildBatchConfig = buildBatchConfigDecoded
        let concurrentBuildLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .concurrentBuildLimit)
        concurrentBuildLimit = concurrentBuildLimitDecoded
    }
}

extension CreateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountLimitExceededException" : self = .accountLimitExceededException(try AccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Equatable {
    case accountLimitExceededException(AccountLimitExceededException)
    case invalidInputException(InvalidInputException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectOutputResponse(project: \(String(describing: project)))"}
}

extension CreateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct CreateProjectOutputResponse: Equatable {
    /// <p>Information about the build project that was created.</p>
    public let project: Project?

    public init (
        project: Project? = nil
    )
    {
        self.project = project
    }
}

struct CreateProjectOutputResponseBody: Equatable {
    public let project: Project?
}

extension CreateProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case project
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(Project.self, forKey: .project)
        project = projectDecoded
    }
}

public struct CreateReportGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateReportGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReportGroupInput>
    public typealias MOutput = OperationOutput<CreateReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReportGroupOutputError>
}

extension CreateReportGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReportGroupInput(exportConfig: \(String(describing: exportConfig)), name: \(String(describing: name)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateReportGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportConfig
        case name
        case tags
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportConfig = exportConfig {
            try encodeContainer.encode(exportConfig, forKey: .exportConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateReportGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateReportGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReportGroupInput>
    public typealias MOutput = OperationOutput<CreateReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReportGroupOutputError>
}

public struct CreateReportGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateReportGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReportGroupInput>
    public typealias MOutput = OperationOutput<CreateReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReportGroupOutputError>
}

public struct CreateReportGroupInput: Equatable {
    /// <p>
    ///       A <code>ReportExportConfig</code> object that contains information about where the report group test results are exported.
    ///     </p>
    public let exportConfig: ReportExportConfig?
    /// <p>
    ///       The name of the report group.
    ///     </p>
    public let name: String?
    /// <p>
    ///       A list of tag key and value pairs associated with this report group.
    ///     </p>
    ///          <p>These tags are available for use by AWS services that support AWS CodeBuild report group
    ///       tags.</p>
    public let tags: [Tag]?
    /// <p>
    ///       The type of report group.
    ///     </p>
    public let type: ReportType?

    public init (
        exportConfig: ReportExportConfig? = nil,
        name: String? = nil,
        tags: [Tag]? = nil,
        type: ReportType? = nil
    )
    {
        self.exportConfig = exportConfig
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateReportGroupInputBody: Equatable {
    public let name: String?
    public let type: ReportType?
    public let exportConfig: ReportExportConfig?
    public let tags: [Tag]?
}

extension CreateReportGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportConfig
        case name
        case tags
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ReportType.self, forKey: .type)
        type = typeDecoded
        let exportConfigDecoded = try containerValues.decodeIfPresent(ReportExportConfig.self, forKey: .exportConfig)
        exportConfig = exportConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReportGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReportGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountLimitExceededException" : self = .accountLimitExceededException(try AccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReportGroupOutputError: Equatable {
    case accountLimitExceededException(AccountLimitExceededException)
    case invalidInputException(InvalidInputException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReportGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReportGroupOutputResponse(reportGroup: \(String(describing: reportGroup)))"}
}

extension CreateReportGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateReportGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reportGroup = output.reportGroup
        } else {
            self.reportGroup = nil
        }
    }
}

public struct CreateReportGroupOutputResponse: Equatable {
    /// <p>
    ///       Information about the report group that was created.
    ///     </p>
    public let reportGroup: ReportGroup?

    public init (
        reportGroup: ReportGroup? = nil
    )
    {
        self.reportGroup = reportGroup
    }
}

struct CreateReportGroupOutputResponseBody: Equatable {
    public let reportGroup: ReportGroup?
}

extension CreateReportGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportGroup
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupDecoded = try containerValues.decodeIfPresent(ReportGroup.self, forKey: .reportGroup)
        reportGroup = reportGroupDecoded
    }
}

public struct CreateWebhookInputBodyMiddleware: Middleware {
    public let id: String = "CreateWebhookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebhookInput>
    public typealias MOutput = OperationOutput<CreateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebhookOutputError>
}

extension CreateWebhookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebhookInput(branchFilter: \(String(describing: branchFilter)), buildType: \(String(describing: buildType)), filterGroups: \(String(describing: filterGroups)), projectName: \(String(describing: projectName)))"}
}

extension CreateWebhookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchFilter
        case buildType
        case filterGroups
        case projectName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchFilter = branchFilter {
            try encodeContainer.encode(branchFilter, forKey: .branchFilter)
        }
        if let buildType = buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let filterGroups = filterGroups {
            var filterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterGroups)
            for filtergroups0 in filterGroups {
                var filtergroups0Container = filterGroupsContainer.nestedUnkeyedContainer()
                for filtergroup1 in filtergroups0 {
                    try filtergroups0Container.encode(filtergroup1)
                }
            }
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

public struct CreateWebhookInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWebhookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebhookInput>
    public typealias MOutput = OperationOutput<CreateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebhookOutputError>
}

public struct CreateWebhookInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWebhookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebhookInput>
    public typealias MOutput = OperationOutput<CreateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebhookOutputError>
}

public struct CreateWebhookInput: Equatable {
    /// <p>A regular expression used to determine which repository branches are built when a
    ///       webhook is triggered. If the name of a branch matches the regular expression, then it is
    ///       built. If <code>branchFilter</code> is empty, then all branches are built.</p>
    ///          <note>
    ///             <p>It is recommended that you use <code>filterGroups</code> instead of
    ///         <code>branchFilter</code>. </p>
    ///          </note>
    public let branchFilter: String?
    /// <p>Specifies the type of build this webhook will trigger.</p>
    public let buildType: WebhookBuildType?
    /// <p>An array of arrays of <code>WebhookFilter</code> objects used to determine which
    ///       webhooks are triggered. At least one <code>WebhookFilter</code> in the array must
    ///       specify <code>EVENT</code> as its <code>type</code>. </p>
    ///          <p>For a build to be triggered, at least one filter group in the
    ///       <code>filterGroups</code> array must pass. For a filter group to pass, each of its
    ///       filters must pass. </p>
    public let filterGroups: [[WebhookFilter]]?
    /// <p>The name of the AWS CodeBuild project.</p>
    public let projectName: String?

    public init (
        branchFilter: String? = nil,
        buildType: WebhookBuildType? = nil,
        filterGroups: [[WebhookFilter]]? = nil,
        projectName: String? = nil
    )
    {
        self.branchFilter = branchFilter
        self.buildType = buildType
        self.filterGroups = filterGroups
        self.projectName = projectName
    }
}

struct CreateWebhookInputBody: Equatable {
    public let projectName: String?
    public let branchFilter: String?
    public let filterGroups: [[WebhookFilter]]?
    public let buildType: WebhookBuildType?
}

extension CreateWebhookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branchFilter
        case buildType
        case filterGroups
        case projectName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let branchFilterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchFilter)
        branchFilter = branchFilterDecoded
        let filterGroupsContainer = try containerValues.decodeIfPresent([[WebhookFilter?]?].self, forKey: .filterGroups)
        var filterGroupsDecoded0:[[WebhookFilter]]? = nil
        if let filterGroupsContainer = filterGroupsContainer {
            filterGroupsDecoded0 = [[WebhookFilter]]()
            for list0 in filterGroupsContainer {
                var list0Decoded0: [WebhookFilter]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [WebhookFilter]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    filterGroupsDecoded0?.append(list0Decoded0)
                }
            }
        }
        filterGroups = filterGroupsDecoded0
        let buildTypeDecoded = try containerValues.decodeIfPresent(WebhookBuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
    }
}

extension CreateWebhookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWebhookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OAuthProviderException" : self = .oAuthProviderException(try OAuthProviderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWebhookOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case oAuthProviderException(OAuthProviderException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWebhookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebhookOutputResponse(webhook: \(String(describing: webhook)))"}
}

extension CreateWebhookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWebhookOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

public struct CreateWebhookOutputResponse: Equatable {
    /// <p>Information about a webhook that connects repository events to a build project in
    ///       AWS CodeBuild.</p>
    public let webhook: Webhook?

    public init (
        webhook: Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct CreateWebhookOutputResponseBody: Equatable {
    public let webhook: Webhook?
}

extension CreateWebhookOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webhook
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

public enum CredentialProviderType {
    case secretsManager
    case sdkUnknown(String)
}

extension CredentialProviderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CredentialProviderType] {
        return [
            .secretsManager,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .secretsManager: return "SECRETS_MANAGER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CredentialProviderType(rawValue: rawValue) ?? CredentialProviderType.sdkUnknown(rawValue)
    }
}

extension DebugSession: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sessionEnabled
        case sessionTarget
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionEnabled = sessionEnabled {
            try encodeContainer.encode(sessionEnabled, forKey: .sessionEnabled)
        }
        if let sessionTarget = sessionTarget {
            try encodeContainer.encode(sessionTarget, forKey: .sessionTarget)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sessionEnabled)
        sessionEnabled = sessionEnabledDecoded
        let sessionTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionTarget)
        sessionTarget = sessionTargetDecoded
    }
}

extension DebugSession: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DebugSession(sessionEnabled: \(String(describing: sessionEnabled)), sessionTarget: \(String(describing: sessionTarget)))"}
}

/// <p>Contains information about the debug session for a build. For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/session-manager.html">Viewing a
///                 running build in Session Manager</a>.</p>
public struct DebugSession: Equatable {
    /// <p>Specifies if session debugging is enabled for this build.</p>
    public let sessionEnabled: Bool?
    /// <p>Contains the identifier of the Session Manager session used for the build. To work with
    ///             the paused build, you open this session to examine, control, and resume the
    ///             build.</p>
    public let sessionTarget: String?

    public init (
        sessionEnabled: Bool? = nil,
        sessionTarget: String? = nil
    )
    {
        self.sessionEnabled = sessionEnabled
        self.sessionTarget = sessionTarget
    }
}

public struct DeleteBuildBatchInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBuildBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBuildBatchInput>
    public typealias MOutput = OperationOutput<DeleteBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBuildBatchOutputError>
}

extension DeleteBuildBatchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBuildBatchInput(id: \(String(describing: id)))"}
}

extension DeleteBuildBatchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteBuildBatchInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBuildBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBuildBatchInput>
    public typealias MOutput = OperationOutput<DeleteBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBuildBatchOutputError>
}

public struct DeleteBuildBatchInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBuildBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBuildBatchInput>
    public typealias MOutput = OperationOutput<DeleteBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBuildBatchOutputError>
}

public struct DeleteBuildBatchInput: Equatable {
    /// <p>The identifier of the batch build to delete.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteBuildBatchInputBody: Equatable {
    public let id: String?
}

extension DeleteBuildBatchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteBuildBatchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBuildBatchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBuildBatchOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBuildBatchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBuildBatchOutputResponse(buildsDeleted: \(String(describing: buildsDeleted)), buildsNotDeleted: \(String(describing: buildsNotDeleted)), statusCode: \(String(describing: statusCode)))"}
}

extension DeleteBuildBatchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBuildBatchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.buildsDeleted = output.buildsDeleted
            self.buildsNotDeleted = output.buildsNotDeleted
            self.statusCode = output.statusCode
        } else {
            self.buildsDeleted = nil
            self.buildsNotDeleted = nil
            self.statusCode = nil
        }
    }
}

public struct DeleteBuildBatchOutputResponse: Equatable {
    /// <p>An array of strings that contain the identifiers of the builds that were deleted.</p>
    public let buildsDeleted: [String]?
    /// <p>An array of <code>BuildNotDeleted</code> objects that specify the builds that could not be
    ///             deleted.</p>
    public let buildsNotDeleted: [BuildNotDeleted]?
    /// <p>The status code.</p>
    public let statusCode: String?

    public init (
        buildsDeleted: [String]? = nil,
        buildsNotDeleted: [BuildNotDeleted]? = nil,
        statusCode: String? = nil
    )
    {
        self.buildsDeleted = buildsDeleted
        self.buildsNotDeleted = buildsNotDeleted
        self.statusCode = statusCode
    }
}

struct DeleteBuildBatchOutputResponseBody: Equatable {
    public let statusCode: String?
    public let buildsDeleted: [String]?
    public let buildsNotDeleted: [BuildNotDeleted]?
}

extension DeleteBuildBatchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case buildsDeleted
        case buildsNotDeleted
        case statusCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let buildsDeletedContainer = try containerValues.decodeIfPresent([String?].self, forKey: .buildsDeleted)
        var buildsDeletedDecoded0:[String]? = nil
        if let buildsDeletedContainer = buildsDeletedContainer {
            buildsDeletedDecoded0 = [String]()
            for string0 in buildsDeletedContainer {
                if let string0 = string0 {
                    buildsDeletedDecoded0?.append(string0)
                }
            }
        }
        buildsDeleted = buildsDeletedDecoded0
        let buildsNotDeletedContainer = try containerValues.decodeIfPresent([BuildNotDeleted?].self, forKey: .buildsNotDeleted)
        var buildsNotDeletedDecoded0:[BuildNotDeleted]? = nil
        if let buildsNotDeletedContainer = buildsNotDeletedContainer {
            buildsNotDeletedDecoded0 = [BuildNotDeleted]()
            for structure0 in buildsNotDeletedContainer {
                if let structure0 = structure0 {
                    buildsNotDeletedDecoded0?.append(structure0)
                }
            }
        }
        buildsNotDeleted = buildsNotDeletedDecoded0
    }
}

public struct DeleteProjectInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

extension DeleteProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectInput(name: \(String(describing: name)))"}
}

extension DeleteProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInput: Equatable {
    /// <p>The name of the build project.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteProjectInputBody: Equatable {
    public let name: String?
}

extension DeleteProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectOutputResponse()"}
}

extension DeleteProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProjectOutputResponse: Equatable {

    public init() {}
}

struct DeleteProjectOutputResponseBody: Equatable {
}

extension DeleteProjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteReportGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReportGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReportGroupInput>
    public typealias MOutput = OperationOutput<DeleteReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReportGroupOutputError>
}

extension DeleteReportGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReportGroupInput(arn: \(String(describing: arn)), deleteReports: \(String(describing: deleteReports)))"}
}

extension DeleteReportGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case deleteReports
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if deleteReports != false {
            try encodeContainer.encode(deleteReports, forKey: .deleteReports)
        }
    }
}

public struct DeleteReportGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReportGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReportGroupInput>
    public typealias MOutput = OperationOutput<DeleteReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReportGroupOutputError>
}

public struct DeleteReportGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReportGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReportGroupInput>
    public typealias MOutput = OperationOutput<DeleteReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReportGroupOutputError>
}

public struct DeleteReportGroupInput: Equatable {
    /// <p>The ARN of the report group to delete. </p>
    public let arn: String?
    /// <p>If <code>true</code>, deletes any reports that belong to a report group before deleting
    ///             the report group. </p>
    ///          <p>If <code>false</code>, you must delete any reports in the report group. Use <a href="https://docs.aws.amazon.com/codebuild/latest/APIReference/API_ListReportsForReportGroup.html">ListReportsForReportGroup</a> to get the reports in a report group. Use <a href="https://docs.aws.amazon.com/codebuild/latest/APIReference/API_DeleteReport.html">DeleteReport</a> to delete the reports. If you call
    ///       <code>DeleteReportGroup</code> for a report group that contains one or more reports,
    ///             an exception is thrown. </p>
    public let deleteReports: Bool

    public init (
        arn: String? = nil,
        deleteReports: Bool = false
    )
    {
        self.arn = arn
        self.deleteReports = deleteReports
    }
}

struct DeleteReportGroupInputBody: Equatable {
    public let arn: String?
    public let deleteReports: Bool
}

extension DeleteReportGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case deleteReports
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let deleteReportsDecoded = try containerValues.decode(Bool.self, forKey: .deleteReports)
        deleteReports = deleteReportsDecoded
    }
}

extension DeleteReportGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReportGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReportGroupOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReportGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReportGroupOutputResponse()"}
}

extension DeleteReportGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReportGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteReportGroupOutputResponseBody: Equatable {
}

extension DeleteReportGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteReportInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReportInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReportInput>
    public typealias MOutput = OperationOutput<DeleteReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReportOutputError>
}

extension DeleteReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReportInput(arn: \(String(describing: arn)))"}
}

extension DeleteReportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteReportInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReportInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReportInput>
    public typealias MOutput = OperationOutput<DeleteReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReportOutputError>
}

public struct DeleteReportInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReportInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReportInput>
    public typealias MOutput = OperationOutput<DeleteReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReportOutputError>
}

public struct DeleteReportInput: Equatable {
    /// <p>
    ///       The ARN of the report to delete.
    ///     </p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteReportInputBody: Equatable {
    public let arn: String?
}

extension DeleteReportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReportOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReportOutputResponse()"}
}

extension DeleteReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReportOutputResponse: Equatable {

    public init() {}
}

struct DeleteReportOutputResponseBody: Equatable {
}

extension DeleteReportOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

extension DeleteResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DeleteResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeleteResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInput: Equatable {
    /// <p> The ARN of the resource that is associated with the resource policy. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Equatable {
    public let resourceArn: String?
}

extension DeleteResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyOutputResponse()"}
}

extension DeleteResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourcePolicyOutputResponseBody: Equatable {
}

extension DeleteResourcePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSourceCredentialsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSourceCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSourceCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSourceCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSourceCredentialsInput>
    public typealias MOutput = OperationOutput<DeleteSourceCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSourceCredentialsOutputError>
}

extension DeleteSourceCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSourceCredentialsInput(arn: \(String(describing: arn)))"}
}

extension DeleteSourceCredentialsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteSourceCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSourceCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSourceCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSourceCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSourceCredentialsInput>
    public typealias MOutput = OperationOutput<DeleteSourceCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSourceCredentialsOutputError>
}

public struct DeleteSourceCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSourceCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSourceCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSourceCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSourceCredentialsInput>
    public typealias MOutput = OperationOutput<DeleteSourceCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSourceCredentialsOutputError>
}

public struct DeleteSourceCredentialsInput: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the token.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteSourceCredentialsInputBody: Equatable {
    public let arn: String?
}

extension DeleteSourceCredentialsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteSourceCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSourceCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSourceCredentialsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSourceCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSourceCredentialsOutputResponse(arn: \(String(describing: arn)))"}
}

extension DeleteSourceCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSourceCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeleteSourceCredentialsOutputResponse: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the token. </p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteSourceCredentialsOutputResponseBody: Equatable {
    public let arn: String?
}

extension DeleteSourceCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct DeleteWebhookInputBodyMiddleware: Middleware {
    public let id: String = "DeleteWebhookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebhookInput>
    public typealias MOutput = OperationOutput<DeleteWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebhookOutputError>
}

extension DeleteWebhookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWebhookInput(projectName: \(String(describing: projectName)))"}
}

extension DeleteWebhookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

public struct DeleteWebhookInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWebhookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebhookInput>
    public typealias MOutput = OperationOutput<DeleteWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebhookOutputError>
}

public struct DeleteWebhookInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWebhookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebhookInput>
    public typealias MOutput = OperationOutput<DeleteWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebhookOutputError>
}

public struct DeleteWebhookInput: Equatable {
    /// <p>The name of the AWS CodeBuild project.</p>
    public let projectName: String?

    public init (
        projectName: String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct DeleteWebhookInputBody: Equatable {
    public let projectName: String?
}

extension DeleteWebhookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
    }
}

extension DeleteWebhookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWebhookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OAuthProviderException" : self = .oAuthProviderException(try OAuthProviderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWebhookOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case oAuthProviderException(OAuthProviderException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWebhookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWebhookOutputResponse()"}
}

extension DeleteWebhookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWebhookOutputResponse: Equatable {

    public init() {}
}

struct DeleteWebhookOutputResponseBody: Equatable {
}

extension DeleteWebhookOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeCodeCoveragesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCodeCoveragesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCodeCoveragesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCodeCoveragesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCodeCoveragesInput>
    public typealias MOutput = OperationOutput<DescribeCodeCoveragesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCodeCoveragesOutputError>
}

extension DescribeCodeCoveragesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCodeCoveragesInput(maxLineCoveragePercentage: \(String(describing: maxLineCoveragePercentage)), maxResults: \(String(describing: maxResults)), minLineCoveragePercentage: \(String(describing: minLineCoveragePercentage)), nextToken: \(String(describing: nextToken)), reportArn: \(String(describing: reportArn)), sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

extension DescribeCodeCoveragesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxLineCoveragePercentage
        case maxResults
        case minLineCoveragePercentage
        case nextToken
        case reportArn
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxLineCoveragePercentage = maxLineCoveragePercentage {
            try encodeContainer.encode(maxLineCoveragePercentage, forKey: .maxLineCoveragePercentage)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let minLineCoveragePercentage = minLineCoveragePercentage {
            try encodeContainer.encode(minLineCoveragePercentage, forKey: .minLineCoveragePercentage)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let reportArn = reportArn {
            try encodeContainer.encode(reportArn, forKey: .reportArn)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct DescribeCodeCoveragesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCodeCoveragesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCodeCoveragesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCodeCoveragesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCodeCoveragesInput>
    public typealias MOutput = OperationOutput<DescribeCodeCoveragesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCodeCoveragesOutputError>
}

public struct DescribeCodeCoveragesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCodeCoveragesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCodeCoveragesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCodeCoveragesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCodeCoveragesInput>
    public typealias MOutput = OperationOutput<DescribeCodeCoveragesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCodeCoveragesOutputError>
}

public struct DescribeCodeCoveragesInput: Equatable {
    /// <p>The maximum line coverage percentage to report.</p>
    public let maxLineCoveragePercentage: Double?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The minimum line coverage percentage to report.</p>
    public let minLineCoveragePercentage: Double?
    /// <p>The <code>nextToken</code> value returned from a previous call to
    ///                 <code>DescribeCodeCoverages</code>. This specifies the next item to return. To
    ///             return the beginning of the list, exclude this parameter.</p>
    public let nextToken: String?
    /// <p>
    ///       The ARN of the report for which test cases are returned.
    ///     </p>
    public let reportArn: String?
    /// <p>Specifies how the results are sorted. Possible values are:</p>
    ///         <dl>
    ///             <dt>FILE_PATH</dt>
    ///             <dd>
    ///                     <p>The results are sorted by file path.</p>
    ///                 </dd>
    ///             <dt>LINE_COVERAGE_PERCENTAGE</dt>
    ///             <dd>
    ///                     <p>The results are sorted by the percentage of lines that are covered.</p>
    ///                 </dd>
    ///          </dl>
    public let sortBy: ReportCodeCoverageSortByType?
    /// <p>Specifies if the results are sorted in ascending or descending order.</p>
    public let sortOrder: SortOrderType?

    public init (
        maxLineCoveragePercentage: Double? = nil,
        maxResults: Int? = nil,
        minLineCoveragePercentage: Double? = nil,
        nextToken: String? = nil,
        reportArn: String? = nil,
        sortBy: ReportCodeCoverageSortByType? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.maxLineCoveragePercentage = maxLineCoveragePercentage
        self.maxResults = maxResults
        self.minLineCoveragePercentage = minLineCoveragePercentage
        self.nextToken = nextToken
        self.reportArn = reportArn
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct DescribeCodeCoveragesInputBody: Equatable {
    public let reportArn: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let sortOrder: SortOrderType?
    public let sortBy: ReportCodeCoverageSortByType?
    public let minLineCoveragePercentage: Double?
    public let maxLineCoveragePercentage: Double?
}

extension DescribeCodeCoveragesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxLineCoveragePercentage
        case maxResults
        case minLineCoveragePercentage
        case nextToken
        case reportArn
        case sortBy
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportArn)
        reportArn = reportArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(ReportCodeCoverageSortByType.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let minLineCoveragePercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .minLineCoveragePercentage)
        minLineCoveragePercentage = minLineCoveragePercentageDecoded
        let maxLineCoveragePercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxLineCoveragePercentage)
        maxLineCoveragePercentage = maxLineCoveragePercentageDecoded
    }
}

extension DescribeCodeCoveragesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCodeCoveragesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCodeCoveragesOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCodeCoveragesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCodeCoveragesOutputResponse(codeCoverages: \(String(describing: codeCoverages)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeCodeCoveragesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCodeCoveragesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeCoverages = output.codeCoverages
            self.nextToken = output.nextToken
        } else {
            self.codeCoverages = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeCodeCoveragesOutputResponse: Equatable {
    /// <p>An array of <code>CodeCoverage</code> objects that contain the results.</p>
    public let codeCoverages: [CodeCoverage]?
    /// <p>If there are more items to return, this contains a token that is passed to a subsequent
    ///             call to <code>DescribeCodeCoverages</code> to retrieve the next set of items.</p>
    public let nextToken: String?

    public init (
        codeCoverages: [CodeCoverage]? = nil,
        nextToken: String? = nil
    )
    {
        self.codeCoverages = codeCoverages
        self.nextToken = nextToken
    }
}

struct DescribeCodeCoveragesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let codeCoverages: [CodeCoverage]?
}

extension DescribeCodeCoveragesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeCoverages
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let codeCoveragesContainer = try containerValues.decodeIfPresent([CodeCoverage?].self, forKey: .codeCoverages)
        var codeCoveragesDecoded0:[CodeCoverage]? = nil
        if let codeCoveragesContainer = codeCoveragesContainer {
            codeCoveragesDecoded0 = [CodeCoverage]()
            for structure0 in codeCoveragesContainer {
                if let structure0 = structure0 {
                    codeCoveragesDecoded0?.append(structure0)
                }
            }
        }
        codeCoverages = codeCoveragesDecoded0
    }
}

public struct DescribeTestCasesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTestCasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTestCasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTestCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTestCasesInput>
    public typealias MOutput = OperationOutput<DescribeTestCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTestCasesOutputError>
}

extension DescribeTestCasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTestCasesInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), reportArn: \(String(describing: reportArn)))"}
}

extension DescribeTestCasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case reportArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let reportArn = reportArn {
            try encodeContainer.encode(reportArn, forKey: .reportArn)
        }
    }
}

public struct DescribeTestCasesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTestCasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTestCasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTestCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTestCasesInput>
    public typealias MOutput = OperationOutput<DescribeTestCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTestCasesOutputError>
}

public struct DescribeTestCasesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTestCasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTestCasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTestCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTestCasesInput>
    public typealias MOutput = OperationOutput<DescribeTestCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTestCasesOutputError>
}

public struct DescribeTestCasesInput: Equatable {
    /// <p>
    ///       A <code>TestCaseFilter</code> object used to filter the returned reports.
    ///     </p>
    public let filter: TestCaseFilter?
    /// <p>
    ///       The maximum number of paginated test cases returned per response. Use <code>nextToken</code> to iterate pages in
    ///       the list of returned <code>TestCase</code> objects. The default value is 100.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///       During a previous call, the maximum number of items that can be returned is the value specified in
    ///       <code>maxResults</code>. If there more items in the list, then a unique string called a <i>nextToken</i>
    ///       is returned. To get the next batch of items in the list, call this operation again, adding the next token
    ///       to the call. To get all of the items in the list, keep calling this operation with each
    ///       subsequent next token that is returned, until no more next tokens are returned.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       The ARN of the report for which test cases are returned.
    ///     </p>
    public let reportArn: String?

    public init (
        filter: TestCaseFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        reportArn: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reportArn = reportArn
    }
}

struct DescribeTestCasesInputBody: Equatable {
    public let reportArn: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let filter: TestCaseFilter?
}

extension DescribeTestCasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case reportArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportArn)
        reportArn = reportArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(TestCaseFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension DescribeTestCasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTestCasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTestCasesOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTestCasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTestCasesOutputResponse(nextToken: \(String(describing: nextToken)), testCases: \(String(describing: testCases)))"}
}

extension DescribeTestCasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTestCasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.testCases = output.testCases
        } else {
            self.nextToken = nil
            self.testCases = nil
        }
    }
}

public struct DescribeTestCasesOutputResponse: Equatable {
    /// <p>
    ///       During a previous call, the maximum number of items that can be returned is the value specified in
    ///       <code>maxResults</code>. If there more items in the list, then a unique string called a <i>nextToken</i>
    ///       is returned. To get the next batch of items in the list, call this operation again, adding the next token
    ///       to the call. To get all of the items in the list, keep calling this operation with each
    ///       subsequent next token that is returned, until no more next tokens are returned.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       The returned list of test cases.
    ///     </p>
    public let testCases: [TestCase]?

    public init (
        nextToken: String? = nil,
        testCases: [TestCase]? = nil
    )
    {
        self.nextToken = nextToken
        self.testCases = testCases
    }
}

struct DescribeTestCasesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let testCases: [TestCase]?
}

extension DescribeTestCasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case testCases
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let testCasesContainer = try containerValues.decodeIfPresent([TestCase?].self, forKey: .testCases)
        var testCasesDecoded0:[TestCase]? = nil
        if let testCasesContainer = testCasesContainer {
            testCasesDecoded0 = [TestCase]()
            for structure0 in testCasesContainer {
                if let structure0 = structure0 {
                    testCasesDecoded0?.append(structure0)
                }
            }
        }
        testCases = testCasesDecoded0
    }
}

extension EnvironmentImage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case versions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for imageversions0 in versions {
                try versionsContainer.encode(imageversions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let versionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .versions)
        var versionsDecoded0:[String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension EnvironmentImage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentImage(description: \(String(describing: description)), name: \(String(describing: name)), versions: \(String(describing: versions)))"}
}

/// <p>Information about a Docker image that is managed by AWS CodeBuild.</p>
public struct EnvironmentImage: Equatable {
    /// <p>The description of the Docker image.</p>
    public let description: String?
    /// <p>The name of the Docker image.</p>
    public let name: String?
    /// <p>A list of environment image versions.</p>
    public let versions: [String]?

    public init (
        description: String? = nil,
        name: String? = nil,
        versions: [String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.versions = versions
    }
}

extension EnvironmentLanguage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case images
        case language
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let images = images {
            var imagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .images)
            for environmentimages0 in images {
                try imagesContainer.encode(environmentimages0)
            }
        }
        if let language = language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageDecoded = try containerValues.decodeIfPresent(LanguageType.self, forKey: .language)
        language = languageDecoded
        let imagesContainer = try containerValues.decodeIfPresent([EnvironmentImage?].self, forKey: .images)
        var imagesDecoded0:[EnvironmentImage]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [EnvironmentImage]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
    }
}

extension EnvironmentLanguage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentLanguage(images: \(String(describing: images)), language: \(String(describing: language)))"}
}

/// <p>A set of Docker images that are related by programming language and are managed by
///             AWS CodeBuild.</p>
public struct EnvironmentLanguage: Equatable {
    /// <p>The list of Docker images that are related by the specified programming
    ///             language.</p>
    public let images: [EnvironmentImage]?
    /// <p>The programming language for the Docker images.</p>
    public let language: LanguageType?

    public init (
        images: [EnvironmentImage]? = nil,
        language: LanguageType? = nil
    )
    {
        self.images = images
        self.language = language
    }
}

extension EnvironmentPlatform: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languages
        case platform
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languages = languages {
            var languagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .languages)
            for environmentlanguages0 in languages {
                try languagesContainer.encode(environmentlanguages0)
            }
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformDecoded = try containerValues.decodeIfPresent(PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let languagesContainer = try containerValues.decodeIfPresent([EnvironmentLanguage?].self, forKey: .languages)
        var languagesDecoded0:[EnvironmentLanguage]? = nil
        if let languagesContainer = languagesContainer {
            languagesDecoded0 = [EnvironmentLanguage]()
            for structure0 in languagesContainer {
                if let structure0 = structure0 {
                    languagesDecoded0?.append(structure0)
                }
            }
        }
        languages = languagesDecoded0
    }
}

extension EnvironmentPlatform: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentPlatform(languages: \(String(describing: languages)), platform: \(String(describing: platform)))"}
}

/// <p>A set of Docker images that are related by platform and are managed by AWS CodeBuild.</p>
public struct EnvironmentPlatform: Equatable {
    /// <p>The list of programming languages that are available for the specified
    ///             platform.</p>
    public let languages: [EnvironmentLanguage]?
    /// <p>The platform's name.</p>
    public let platform: PlatformType?

    public init (
        languages: [EnvironmentLanguage]? = nil,
        platform: PlatformType? = nil
    )
    {
        self.languages = languages
        self.platform = platform
    }
}

public enum EnvironmentType {
    case armContainer
    case linuxContainer
    case linuxGpuContainer
    case windowsContainer
    case windowsServer2019Container
    case sdkUnknown(String)
}

extension EnvironmentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentType] {
        return [
            .armContainer,
            .linuxContainer,
            .linuxGpuContainer,
            .windowsContainer,
            .windowsServer2019Container,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .armContainer: return "ARM_CONTAINER"
        case .linuxContainer: return "LINUX_CONTAINER"
        case .linuxGpuContainer: return "LINUX_GPU_CONTAINER"
        case .windowsContainer: return "WINDOWS_CONTAINER"
        case .windowsServer2019Container: return "WINDOWS_SERVER_2019_CONTAINER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentType(rawValue: rawValue) ?? EnvironmentType.sdkUnknown(rawValue)
    }
}

extension EnvironmentVariable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case type
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EnvironmentVariableType.self, forKey: .type)
        type = typeDecoded
    }
}

extension EnvironmentVariable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentVariable(name: \(String(describing: name)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Information about an environment variable for a build project or a build.</p>
public struct EnvironmentVariable: Equatable {
    /// <p>The name or key of the environment variable.</p>
    public let name: String?
    /// <p>The type of environment variable. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>PARAMETER_STORE</code>: An environment variable stored in Amazon EC2 Systems Manager
    ///                     Parameter Store. To learn how to specify a parameter store environment variable,
    ///                     see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.env.parameter-store">env/parameter-store</a> in the
    ///                     <i>AWS CodeBuild User Guide</i>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>PLAINTEXT</code>: An environment variable in plain text format. This is
    ///                     the default value.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SECRETS_MANAGER</code>: An environment variable stored in AWS Secrets
    ///                     Manager. To learn how to specify a secrets manager environment variable, see
    ///                         <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.env.secrets-manager">env/secrets-manager</a> in the
    ///                     <i>AWS CodeBuild User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let type: EnvironmentVariableType?
    /// <p>The value of the environment variable.</p>
    ///         <important>
    ///             <p>We strongly discourage the use of <code>PLAINTEXT</code> environment variables to
    ///                 store sensitive values, especially AWS secret key IDs and secret access keys.
    ///                     <code>PLAINTEXT</code> environment variables can be displayed in plain text
    ///                 using the AWS CodeBuild console and the AWS Command Line Interface (AWS CLI). For sensitive values, we recommend you use an
    ///                 environment variable of type <code>PARAMETER_STORE</code> or
    ///                     <code>SECRETS_MANAGER</code>. </p>
    ///         </important>
    public let value: String?

    public init (
        name: String? = nil,
        type: EnvironmentVariableType? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.type = type
        self.value = value
    }
}

public enum EnvironmentVariableType {
    case parameterStore
    case plaintext
    case secretsManager
    case sdkUnknown(String)
}

extension EnvironmentVariableType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentVariableType] {
        return [
            .parameterStore,
            .plaintext,
            .secretsManager,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .parameterStore: return "PARAMETER_STORE"
        case .plaintext: return "PLAINTEXT"
        case .secretsManager: return "SECRETS_MANAGER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentVariableType(rawValue: rawValue) ?? EnvironmentVariableType.sdkUnknown(rawValue)
    }
}

extension ExportedEnvironmentVariable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ExportedEnvironmentVariable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportedEnvironmentVariable(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Contains information about an exported environment variable. </p>
///         <p>Exported environment variables are used in conjunction with AWS CodePipeline to export
///   environment variables from the current build stage to subsequent stages in the pipeline.
///   For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-variables.html">Working with variables</a> in the <i>AWS CodePipeline User Guide</i>.</p>
///         <note>
///             <p> During a build, the value of a variable is available starting with the
///                   <code>install</code> phase. It can be updated between the start of the
///                   <code>install</code> phase and the end of the <code>post_build</code> phase.
///               After the <code>post_build</code> phase ends, the value of exported variables cannot
///               change.</p>
///          </note>
public struct ExportedEnvironmentVariable: Equatable {
    /// <p>The name of the exported environment variable.</p>
    public let name: String?
    /// <p>The value assigned to the exported environment variable.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum FileSystemType {
    case efs
    case sdkUnknown(String)
}

extension FileSystemType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileSystemType] {
        return [
            .efs,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .efs: return "EFS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileSystemType(rawValue: rawValue) ?? FileSystemType.sdkUnknown(rawValue)
    }
}

public struct GetReportGroupTrendInputBodyMiddleware: Middleware {
    public let id: String = "GetReportGroupTrendInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReportGroupTrendInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReportGroupTrendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReportGroupTrendInput>
    public typealias MOutput = OperationOutput<GetReportGroupTrendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReportGroupTrendOutputError>
}

extension GetReportGroupTrendInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReportGroupTrendInput(numOfReports: \(String(describing: numOfReports)), reportGroupArn: \(String(describing: reportGroupArn)), trendField: \(String(describing: trendField)))"}
}

extension GetReportGroupTrendInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numOfReports
        case reportGroupArn
        case trendField
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numOfReports = numOfReports {
            try encodeContainer.encode(numOfReports, forKey: .numOfReports)
        }
        if let reportGroupArn = reportGroupArn {
            try encodeContainer.encode(reportGroupArn, forKey: .reportGroupArn)
        }
        if let trendField = trendField {
            try encodeContainer.encode(trendField.rawValue, forKey: .trendField)
        }
    }
}

public struct GetReportGroupTrendInputHeadersMiddleware: Middleware {
    public let id: String = "GetReportGroupTrendInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReportGroupTrendInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReportGroupTrendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReportGroupTrendInput>
    public typealias MOutput = OperationOutput<GetReportGroupTrendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReportGroupTrendOutputError>
}

public struct GetReportGroupTrendInputQueryItemMiddleware: Middleware {
    public let id: String = "GetReportGroupTrendInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReportGroupTrendInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReportGroupTrendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReportGroupTrendInput>
    public typealias MOutput = OperationOutput<GetReportGroupTrendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReportGroupTrendOutputError>
}

public struct GetReportGroupTrendInput: Equatable {
    /// <p>The number of reports to analyze. This operation always retrieves the most recent
    ///             reports.</p>
    ///         <p>If this parameter is omitted, the most recent 100 reports are analyzed.</p>
    public let numOfReports: Int?
    /// <p>The ARN of the report group that contains the reports to analyze.</p>
    public let reportGroupArn: String?
    /// <p>The test report value to accumulate. This must be one of the following values:</p>
    ///          <dl>
    ///             <dt>Test reports:</dt>
    ///             <dd>
    ///                     <dl>
    ///                   <dt>DURATION</dt>
    ///                   <dd>
    ///                                 <p>Accumulate the test run times for the specified
    ///                                     reports.</p>
    ///                             </dd>
    ///                   <dt>PASS_RATE</dt>
    ///                   <dd>
    ///                                 <p>Accumulate the percentage of tests that passed for the
    ///                                     specified test reports.</p>
    ///                             </dd>
    ///                   <dt>TOTAL</dt>
    ///                   <dd>
    ///                                 <p>Accumulate the total number of tests for the specified test
    ///                                     reports.</p>
    ///                             </dd>
    ///                </dl>
    ///                 </dd>
    ///          </dl>
    ///          <dl>
    ///             <dt>Code coverage reports:</dt>
    ///             <dd>
    ///                     <dl>
    ///                   <dt>BRANCH_COVERAGE</dt>
    ///                   <dd>
    ///                                 <p>Accumulate the branch coverage percentages for the specified
    ///                                     test reports.</p>
    ///                             </dd>
    ///                   <dt>BRANCHES_COVERED</dt>
    ///                   <dd>
    ///                                 <p>Accumulate the branches covered values for the specified test
    ///                                     reports.</p>
    ///                             </dd>
    ///                   <dt>BRANCHES_MISSED</dt>
    ///                   <dd>
    ///                                 <p>Accumulate the branches missed values for the specified test
    ///                                     reports.</p>
    ///                             </dd>
    ///                   <dt>LINE_COVERAGE</dt>
    ///                   <dd>
    ///                                 <p>Accumulate the line coverage percentages for the specified
    ///                                     test reports.</p>
    ///                             </dd>
    ///                   <dt>LINES_COVERED</dt>
    ///                   <dd>
    ///                                 <p>Accumulate the lines covered values for the specified test
    ///                                     reports.</p>
    ///                             </dd>
    ///                   <dt>LINES_MISSED</dt>
    ///                   <dd>
    ///                                 <p>Accumulate the lines not covered values for the specified test
    ///                                     reports.</p>
    ///                             </dd>
    ///                </dl>
    ///                 </dd>
    ///          </dl>
    public let trendField: ReportGroupTrendFieldType?

    public init (
        numOfReports: Int? = nil,
        reportGroupArn: String? = nil,
        trendField: ReportGroupTrendFieldType? = nil
    )
    {
        self.numOfReports = numOfReports
        self.reportGroupArn = reportGroupArn
        self.trendField = trendField
    }
}

struct GetReportGroupTrendInputBody: Equatable {
    public let reportGroupArn: String?
    public let numOfReports: Int?
    public let trendField: ReportGroupTrendFieldType?
}

extension GetReportGroupTrendInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case numOfReports
        case reportGroupArn
        case trendField
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportGroupArn)
        reportGroupArn = reportGroupArnDecoded
        let numOfReportsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numOfReports)
        numOfReports = numOfReportsDecoded
        let trendFieldDecoded = try containerValues.decodeIfPresent(ReportGroupTrendFieldType.self, forKey: .trendField)
        trendField = trendFieldDecoded
    }
}

extension GetReportGroupTrendOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReportGroupTrendOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReportGroupTrendOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReportGroupTrendOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReportGroupTrendOutputResponse(rawData: \(String(describing: rawData)), stats: \(String(describing: stats)))"}
}

extension GetReportGroupTrendOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetReportGroupTrendOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rawData = output.rawData
            self.stats = output.stats
        } else {
            self.rawData = nil
            self.stats = nil
        }
    }
}

public struct GetReportGroupTrendOutputResponse: Equatable {
    /// <p>An array that contains the raw data for each report.</p>
    public let rawData: [ReportWithRawData]?
    /// <p>Contains the accumulated trend data.</p>
    public let stats: ReportGroupTrendStats?

    public init (
        rawData: [ReportWithRawData]? = nil,
        stats: ReportGroupTrendStats? = nil
    )
    {
        self.rawData = rawData
        self.stats = stats
    }
}

struct GetReportGroupTrendOutputResponseBody: Equatable {
    public let stats: ReportGroupTrendStats?
    public let rawData: [ReportWithRawData]?
}

extension GetReportGroupTrendOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rawData
        case stats
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statsDecoded = try containerValues.decodeIfPresent(ReportGroupTrendStats.self, forKey: .stats)
        stats = statsDecoded
        let rawDataContainer = try containerValues.decodeIfPresent([ReportWithRawData?].self, forKey: .rawData)
        var rawDataDecoded0:[ReportWithRawData]? = nil
        if let rawDataContainer = rawDataContainer {
            rawDataDecoded0 = [ReportWithRawData]()
            for structure0 in rawDataContainer {
                if let structure0 = structure0 {
                    rawDataDecoded0?.append(structure0)
                }
            }
        }
        rawData = rawDataDecoded0
    }
}

public struct GetResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePolicyOutputError>
}

extension GetResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension GetResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct GetResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInput: Equatable {
    /// <p> The ARN of the resource that is associated with the resource policy. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourcePolicyInputBody: Equatable {
    public let resourceArn: String?
}

extension GetResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Equatable {
    /// <p> The resource policy for the resource identified by the input ARN parameter. </p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetResourcePolicyOutputResponseBody: Equatable {
    public let policy: String?
}

extension GetResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GitSubmodulesConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fetchSubmodules
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fetchSubmodules = fetchSubmodules {
            try encodeContainer.encode(fetchSubmodules, forKey: .fetchSubmodules)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fetchSubmodulesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .fetchSubmodules)
        fetchSubmodules = fetchSubmodulesDecoded
    }
}

extension GitSubmodulesConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GitSubmodulesConfig(fetchSubmodules: \(String(describing: fetchSubmodules)))"}
}

/// <p> Information about the Git submodules configuration for an AWS CodeBuild build project.
///         </p>
public struct GitSubmodulesConfig: Equatable {
    /// <p> Set to true to fetch Git submodules for your AWS CodeBuild build project. </p>
    public let fetchSubmodules: Bool?

    public init (
        fetchSubmodules: Bool? = nil
    )
    {
        self.fetchSubmodules = fetchSubmodules
    }
}

public enum ImagePullCredentialsType {
    case codebuild
    case serviceRole
    case sdkUnknown(String)
}

extension ImagePullCredentialsType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImagePullCredentialsType] {
        return [
            .codebuild,
            .serviceRole,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .codebuild: return "CODEBUILD"
        case .serviceRole: return "SERVICE_ROLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImagePullCredentialsType(rawValue: rawValue) ?? ImagePullCredentialsType.sdkUnknown(rawValue)
    }
}

public struct ImportSourceCredentialsInputBodyMiddleware: Middleware {
    public let id: String = "ImportSourceCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportSourceCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportSourceCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportSourceCredentialsInput>
    public typealias MOutput = OperationOutput<ImportSourceCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportSourceCredentialsOutputError>
}

extension ImportSourceCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportSourceCredentialsInput(authType: \(String(describing: authType)), serverType: \(String(describing: serverType)), shouldOverwrite: \(String(describing: shouldOverwrite)), token: \(String(describing: token)), username: \(String(describing: username)))"}
}

extension ImportSourceCredentialsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authType
        case serverType
        case shouldOverwrite
        case token
        case username
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let serverType = serverType {
            try encodeContainer.encode(serverType.rawValue, forKey: .serverType)
        }
        if let shouldOverwrite = shouldOverwrite {
            try encodeContainer.encode(shouldOverwrite, forKey: .shouldOverwrite)
        }
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct ImportSourceCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "ImportSourceCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportSourceCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportSourceCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportSourceCredentialsInput>
    public typealias MOutput = OperationOutput<ImportSourceCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportSourceCredentialsOutputError>
}

public struct ImportSourceCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportSourceCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportSourceCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportSourceCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportSourceCredentialsInput>
    public typealias MOutput = OperationOutput<ImportSourceCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportSourceCredentialsOutputError>
}

public struct ImportSourceCredentialsInput: Equatable {
    /// <p> The type of authentication used to connect to a GitHub, GitHub Enterprise, or
    ///             Bitbucket repository. An OAUTH connection is not supported by the API and must be
    ///             created using the AWS CodeBuild console. </p>
    public let authType: AuthType?
    /// <p> The source provider used for this project. </p>
    public let serverType: ServerType?
    /// <p> Set to <code>false</code> to prevent overwriting the repository source credentials.
    ///             Set to <code>true</code> to overwrite the repository source credentials. The default
    ///             value is <code>true</code>. </p>
    public let shouldOverwrite: Bool?
    /// <p> For GitHub or GitHub Enterprise, this is the personal access token. For Bitbucket,
    ///             this is the app password. </p>
    public let token: String?
    /// <p> The Bitbucket username when the <code>authType</code> is BASIC_AUTH. This parameter
    ///             is not valid for other types of source providers or connections. </p>
    public let username: String?

    public init (
        authType: AuthType? = nil,
        serverType: ServerType? = nil,
        shouldOverwrite: Bool? = nil,
        token: String? = nil,
        username: String? = nil
    )
    {
        self.authType = authType
        self.serverType = serverType
        self.shouldOverwrite = shouldOverwrite
        self.token = token
        self.username = username
    }
}

struct ImportSourceCredentialsInputBody: Equatable {
    public let username: String?
    public let token: String?
    public let serverType: ServerType?
    public let authType: AuthType?
    public let shouldOverwrite: Bool?
}

extension ImportSourceCredentialsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authType
        case serverType
        case shouldOverwrite
        case token
        case username
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
        let serverTypeDecoded = try containerValues.decodeIfPresent(ServerType.self, forKey: .serverType)
        serverType = serverTypeDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let shouldOverwriteDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .shouldOverwrite)
        shouldOverwrite = shouldOverwriteDecoded
    }
}

extension ImportSourceCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportSourceCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountLimitExceededException" : self = .accountLimitExceededException(try AccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportSourceCredentialsOutputError: Equatable {
    case accountLimitExceededException(AccountLimitExceededException)
    case invalidInputException(InvalidInputException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportSourceCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportSourceCredentialsOutputResponse(arn: \(String(describing: arn)))"}
}

extension ImportSourceCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportSourceCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct ImportSourceCredentialsOutputResponse: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the token. </p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct ImportSourceCredentialsOutputResponseBody: Equatable {
    public let arn: String?
}

extension ImportSourceCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input value that was provided is not valid.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct InvalidateProjectCacheInputBodyMiddleware: Middleware {
    public let id: String = "InvalidateProjectCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvalidateProjectCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<InvalidateProjectCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvalidateProjectCacheInput>
    public typealias MOutput = OperationOutput<InvalidateProjectCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvalidateProjectCacheOutputError>
}

extension InvalidateProjectCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidateProjectCacheInput(projectName: \(String(describing: projectName)))"}
}

extension InvalidateProjectCacheInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

public struct InvalidateProjectCacheInputHeadersMiddleware: Middleware {
    public let id: String = "InvalidateProjectCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvalidateProjectCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<InvalidateProjectCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvalidateProjectCacheInput>
    public typealias MOutput = OperationOutput<InvalidateProjectCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvalidateProjectCacheOutputError>
}

public struct InvalidateProjectCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "InvalidateProjectCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvalidateProjectCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<InvalidateProjectCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvalidateProjectCacheInput>
    public typealias MOutput = OperationOutput<InvalidateProjectCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvalidateProjectCacheOutputError>
}

public struct InvalidateProjectCacheInput: Equatable {
    /// <p>The name of the AWS CodeBuild build project that the cache is reset for.</p>
    public let projectName: String?

    public init (
        projectName: String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct InvalidateProjectCacheInputBody: Equatable {
    public let projectName: String?
}

extension InvalidateProjectCacheInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
    }
}

extension InvalidateProjectCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InvalidateProjectCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InvalidateProjectCacheOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InvalidateProjectCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidateProjectCacheOutputResponse()"}
}

extension InvalidateProjectCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct InvalidateProjectCacheOutputResponse: Equatable {

    public init() {}
}

struct InvalidateProjectCacheOutputResponseBody: Equatable {
}

extension InvalidateProjectCacheOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum LanguageType {
    case android
    case base
    case docker
    case dotnet
    case golang
    case java
    case nodeJs
    case php
    case python
    case ruby
    case sdkUnknown(String)
}

extension LanguageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LanguageType] {
        return [
            .android,
            .base,
            .docker,
            .dotnet,
            .golang,
            .java,
            .nodeJs,
            .php,
            .python,
            .ruby,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .android: return "ANDROID"
        case .base: return "BASE"
        case .docker: return "DOCKER"
        case .dotnet: return "DOTNET"
        case .golang: return "GOLANG"
        case .java: return "JAVA"
        case .nodeJs: return "NODE_JS"
        case .php: return "PHP"
        case .python: return "PYTHON"
        case .ruby: return "RUBY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LanguageType(rawValue: rawValue) ?? LanguageType.sdkUnknown(rawValue)
    }
}

public struct ListBuildBatchesForProjectInputBodyMiddleware: Middleware {
    public let id: String = "ListBuildBatchesForProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildBatchesForProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildBatchesForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildBatchesForProjectInput>
    public typealias MOutput = OperationOutput<ListBuildBatchesForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildBatchesForProjectOutputError>
}

extension ListBuildBatchesForProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuildBatchesForProjectInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), projectName: \(String(describing: projectName)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListBuildBatchesForProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case projectName
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListBuildBatchesForProjectInputHeadersMiddleware: Middleware {
    public let id: String = "ListBuildBatchesForProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildBatchesForProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildBatchesForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildBatchesForProjectInput>
    public typealias MOutput = OperationOutput<ListBuildBatchesForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildBatchesForProjectOutputError>
}

public struct ListBuildBatchesForProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBuildBatchesForProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildBatchesForProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildBatchesForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildBatchesForProjectInput>
    public typealias MOutput = OperationOutput<ListBuildBatchesForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildBatchesForProjectOutputError>
}

public struct ListBuildBatchesForProjectInput: Equatable {
    /// <p>A <code>BuildBatchFilter</code> object that specifies the filters for the search.</p>
    public let filter: BuildBatchFilter?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous call to
    ///                 <code>ListBuildBatchesForProject</code>. This specifies the next item to return. To return the
    ///             beginning of the list, exclude this parameter.</p>
    public let nextToken: String?
    /// <p>The name of the project.</p>
    public let projectName: String?
    /// <p>Specifies the sort order of the returned items. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ASCENDING</code>: List the batch build identifiers in ascending order by
    ///                     identifier.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DESCENDING</code>: List the batch build identifiers in descending order
    ///                     by identifier.</p>
    ///             </li>
    ///          </ul>
    public let sortOrder: SortOrderType?

    public init (
        filter: BuildBatchFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        projectName: String? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.sortOrder = sortOrder
    }
}

struct ListBuildBatchesForProjectInputBody: Equatable {
    public let projectName: String?
    public let filter: BuildBatchFilter?
    public let maxResults: Int?
    public let sortOrder: SortOrderType?
    public let nextToken: String?
}

extension ListBuildBatchesForProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case projectName
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let filterDecoded = try containerValues.decodeIfPresent(BuildBatchFilter.self, forKey: .filter)
        filter = filterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuildBatchesForProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBuildBatchesForProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBuildBatchesForProjectOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBuildBatchesForProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuildBatchesForProjectOutputResponse(ids: \(String(describing: ids)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBuildBatchesForProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBuildBatchesForProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ids = output.ids
            self.nextToken = output.nextToken
        } else {
            self.ids = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuildBatchesForProjectOutputResponse: Equatable {
    /// <p>An array of strings that contains the batch build identifiers.</p>
    public let ids: [String]?
    /// <p>If there are more items to return, this contains a token that is passed to a
    ///             subsequent call to <code>ListBuildBatchesForProject</code> to retrieve the next set of
    ///             items.</p>
    public let nextToken: String?

    public init (
        ids: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.ids = ids
        self.nextToken = nextToken
    }
}

struct ListBuildBatchesForProjectOutputResponseBody: Equatable {
    public let ids: [String]?
    public let nextToken: String?
}

extension ListBuildBatchesForProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ids
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListBuildBatchesInputBodyMiddleware: Middleware {
    public let id: String = "ListBuildBatchesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildBatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildBatchesInput>
    public typealias MOutput = OperationOutput<ListBuildBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildBatchesOutputError>
}

extension ListBuildBatchesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuildBatchesInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListBuildBatchesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListBuildBatchesInputHeadersMiddleware: Middleware {
    public let id: String = "ListBuildBatchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildBatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildBatchesInput>
    public typealias MOutput = OperationOutput<ListBuildBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildBatchesOutputError>
}

public struct ListBuildBatchesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBuildBatchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildBatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildBatchesInput>
    public typealias MOutput = OperationOutput<ListBuildBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildBatchesOutputError>
}

public struct ListBuildBatchesInput: Equatable {
    /// <p>A <code>BuildBatchFilter</code> object that specifies the filters for the search.</p>
    public let filter: BuildBatchFilter?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous call to
    ///                 <code>ListBuildBatches</code>. This specifies the next item to return. To return the
    ///             beginning of the list, exclude this parameter.</p>
    public let nextToken: String?
    /// <p>Specifies the sort order of the returned items. Valid values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ASCENDING</code>: List the batch build identifiers in ascending order by identifier.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DESCENDING</code>: List the batch build identifiers in descending order by identifier.</p>
    ///             </li>
    ///          </ul>
    public let sortOrder: SortOrderType?

    public init (
        filter: BuildBatchFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListBuildBatchesInputBody: Equatable {
    public let filter: BuildBatchFilter?
    public let maxResults: Int?
    public let sortOrder: SortOrderType?
    public let nextToken: String?
}

extension ListBuildBatchesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(BuildBatchFilter.self, forKey: .filter)
        filter = filterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuildBatchesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBuildBatchesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBuildBatchesOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBuildBatchesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuildBatchesOutputResponse(ids: \(String(describing: ids)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBuildBatchesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBuildBatchesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ids = output.ids
            self.nextToken = output.nextToken
        } else {
            self.ids = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuildBatchesOutputResponse: Equatable {
    /// <p>An array of strings that contains the batch build identifiers.</p>
    public let ids: [String]?
    /// <p>If there are more items to return, this contains a token that is passed to a subsequent
    ///             call to <code>ListBuildBatches</code> to retrieve the next set of items.</p>
    public let nextToken: String?

    public init (
        ids: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.ids = ids
        self.nextToken = nextToken
    }
}

struct ListBuildBatchesOutputResponseBody: Equatable {
    public let ids: [String]?
    public let nextToken: String?
}

extension ListBuildBatchesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ids
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListBuildsForProjectInputBodyMiddleware: Middleware {
    public let id: String = "ListBuildsForProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildsForProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildsForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildsForProjectInput>
    public typealias MOutput = OperationOutput<ListBuildsForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildsForProjectOutputError>
}

extension ListBuildsForProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuildsForProjectInput(nextToken: \(String(describing: nextToken)), projectName: \(String(describing: projectName)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListBuildsForProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case projectName
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListBuildsForProjectInputHeadersMiddleware: Middleware {
    public let id: String = "ListBuildsForProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildsForProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildsForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildsForProjectInput>
    public typealias MOutput = OperationOutput<ListBuildsForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildsForProjectOutputError>
}

public struct ListBuildsForProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBuildsForProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildsForProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildsForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildsForProjectInput>
    public typealias MOutput = OperationOutput<ListBuildsForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildsForProjectOutputError>
}

public struct ListBuildsForProjectInput: Equatable {
    /// <p>During a previous call, if there are more than 100 items in the list, only the first
    ///             100 items are returned, along with a unique string called a
    ///                 <i>nextToken</i>. To get the next batch of items in the list, call
    ///             this operation again, adding the next token to the call. To get all of the items in the
    ///             list, keep calling this operation with each subsequent next token that is returned,
    ///             until no more next tokens are returned.</p>
    public let nextToken: String?
    /// <p>The name of the AWS CodeBuild project.</p>
    public let projectName: String?
    /// <p>The order to list results in. The results are sorted by build number, not the build
    ///             identifier.</p>
    ///         <p>Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ASCENDING</code>: List the build IDs in ascending order by build
    ///                     ID.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DESCENDING</code>: List the build IDs in descending order by build
    ///                     ID.</p>
    ///             </li>
    ///          </ul>
    ///         <p>If the project has more than 100 builds, setting the sort order will result in an
    ///             error. </p>
    public let sortOrder: SortOrderType?

    public init (
        nextToken: String? = nil,
        projectName: String? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.nextToken = nextToken
        self.projectName = projectName
        self.sortOrder = sortOrder
    }
}

struct ListBuildsForProjectInputBody: Equatable {
    public let projectName: String?
    public let sortOrder: SortOrderType?
    public let nextToken: String?
}

extension ListBuildsForProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case projectName
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuildsForProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBuildsForProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBuildsForProjectOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBuildsForProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuildsForProjectOutputResponse(ids: \(String(describing: ids)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBuildsForProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBuildsForProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ids = output.ids
            self.nextToken = output.nextToken
        } else {
            self.ids = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuildsForProjectOutputResponse: Equatable {
    /// <p>A list of build IDs for the specified build project, with each build ID representing a
    ///             single build.</p>
    public let ids: [String]?
    /// <p>If there are more than 100 items in the list, only the first 100 items are returned,
    ///             along with a unique string called a <i>nextToken</i>. To get the next
    ///             batch of items in the list, call this operation again, adding the next token to the
    ///             call.</p>
    public let nextToken: String?

    public init (
        ids: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.ids = ids
        self.nextToken = nextToken
    }
}

struct ListBuildsForProjectOutputResponseBody: Equatable {
    public let ids: [String]?
    public let nextToken: String?
}

extension ListBuildsForProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ids
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListBuildsInputBodyMiddleware: Middleware {
    public let id: String = "ListBuildsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildsInput>
    public typealias MOutput = OperationOutput<ListBuildsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildsOutputError>
}

extension ListBuildsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuildsInput(nextToken: \(String(describing: nextToken)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListBuildsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListBuildsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBuildsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildsInput>
    public typealias MOutput = OperationOutput<ListBuildsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildsOutputError>
}

public struct ListBuildsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBuildsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuildsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuildsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuildsInput>
    public typealias MOutput = OperationOutput<ListBuildsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuildsOutputError>
}

public struct ListBuildsInput: Equatable {
    /// <p>During a previous call, if there are more than 100 items in the list, only the first
    ///             100 items are returned, along with a unique string called a
    ///                 <i>nextToken</i>. To get the next batch of items in the list, call
    ///             this operation again, adding the next token to the call. To get all of the items in the
    ///             list, keep calling this operation with each subsequent next token that is returned,
    ///             until no more next tokens are returned.</p>
    public let nextToken: String?
    /// <p>The order to list build IDs. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ASCENDING</code>: List the build IDs in ascending order by build
    ///                     ID.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DESCENDING</code>: List the build IDs in descending order by build
    ///                     ID.</p>
    ///             </li>
    ///          </ul>
    public let sortOrder: SortOrderType?

    public init (
        nextToken: String? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListBuildsInputBody: Equatable {
    public let sortOrder: SortOrderType?
    public let nextToken: String?
}

extension ListBuildsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuildsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBuildsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBuildsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBuildsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuildsOutputResponse(ids: \(String(describing: ids)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBuildsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBuildsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ids = output.ids
            self.nextToken = output.nextToken
        } else {
            self.ids = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuildsOutputResponse: Equatable {
    /// <p>A list of build IDs, with each build ID representing a single build.</p>
    public let ids: [String]?
    /// <p>If there are more than 100 items in the list, only the first 100 items are returned,
    ///             along with a unique string called a <i>nextToken</i>. To get the next
    ///             batch of items in the list, call this operation again, adding the next token to the
    ///             call.</p>
    public let nextToken: String?

    public init (
        ids: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.ids = ids
        self.nextToken = nextToken
    }
}

struct ListBuildsOutputResponseBody: Equatable {
    public let ids: [String]?
    public let nextToken: String?
}

extension ListBuildsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ids
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCuratedEnvironmentImagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCuratedEnvironmentImagesInput()"}
}

extension ListCuratedEnvironmentImagesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCuratedEnvironmentImagesInputHeadersMiddleware: Middleware {
    public let id: String = "ListCuratedEnvironmentImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCuratedEnvironmentImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCuratedEnvironmentImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCuratedEnvironmentImagesInput>
    public typealias MOutput = OperationOutput<ListCuratedEnvironmentImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCuratedEnvironmentImagesOutputError>
}

public struct ListCuratedEnvironmentImagesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCuratedEnvironmentImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCuratedEnvironmentImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCuratedEnvironmentImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCuratedEnvironmentImagesInput>
    public typealias MOutput = OperationOutput<ListCuratedEnvironmentImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCuratedEnvironmentImagesOutputError>
}

public struct ListCuratedEnvironmentImagesInput: Equatable {

    public init() {}
}

struct ListCuratedEnvironmentImagesInputBody: Equatable {
}

extension ListCuratedEnvironmentImagesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCuratedEnvironmentImagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCuratedEnvironmentImagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCuratedEnvironmentImagesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCuratedEnvironmentImagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCuratedEnvironmentImagesOutputResponse(platforms: \(String(describing: platforms)))"}
}

extension ListCuratedEnvironmentImagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCuratedEnvironmentImagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.platforms = output.platforms
        } else {
            self.platforms = nil
        }
    }
}

public struct ListCuratedEnvironmentImagesOutputResponse: Equatable {
    /// <p>Information about supported platforms for Docker images that are managed by
    ///             AWS CodeBuild.</p>
    public let platforms: [EnvironmentPlatform]?

    public init (
        platforms: [EnvironmentPlatform]? = nil
    )
    {
        self.platforms = platforms
    }
}

struct ListCuratedEnvironmentImagesOutputResponseBody: Equatable {
    public let platforms: [EnvironmentPlatform]?
}

extension ListCuratedEnvironmentImagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case platforms
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformsContainer = try containerValues.decodeIfPresent([EnvironmentPlatform?].self, forKey: .platforms)
        var platformsDecoded0:[EnvironmentPlatform]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [EnvironmentPlatform]()
            for structure0 in platformsContainer {
                if let structure0 = structure0 {
                    platformsDecoded0?.append(structure0)
                }
            }
        }
        platforms = platformsDecoded0
    }
}

public struct ListProjectsInputBodyMiddleware: Middleware {
    public let id: String = "ListProjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

extension ListProjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsInput(nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListProjectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListProjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInput: Equatable {
    /// <p>During a previous call, if there are more than 100 items in the list, only the first
    ///             100 items are returned, along with a unique string called a
    ///                 <i>nextToken</i>. To get the next batch of items in the list, call
    ///             this operation again, adding the next token to the call. To get all of the items in the
    ///             list, keep calling this operation with each subsequent next token that is returned,
    ///             until no more next tokens are returned.</p>
    public let nextToken: String?
    /// <p>The criterion to be used to list build project names. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATED_TIME</code>: List based on when each build project was
    ///                     created.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>LAST_MODIFIED_TIME</code>: List based on when information about each
    ///                     build project was last changed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NAME</code>: List based on each build project's name.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Use <code>sortOrder</code> to specify in what order to list the build project names
    ///             based on the preceding criteria.</p>
    public let sortBy: ProjectSortByType?
    /// <p>The order in which to list build projects. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ASCENDING</code>: List in ascending order.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DESCENDING</code>: List in descending order.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Use <code>sortBy</code> to specify the criterion to be used to list build project
    ///             names.</p>
    public let sortOrder: SortOrderType?

    public init (
        nextToken: String? = nil,
        sortBy: ProjectSortByType? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListProjectsInputBody: Equatable {
    public let sortBy: ProjectSortByType?
    public let sortOrder: SortOrderType?
    public let nextToken: String?
}

extension ListProjectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case sortBy
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(ProjectSortByType.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsOutputResponse(nextToken: \(String(describing: nextToken)), projects: \(String(describing: projects)))"}
}

extension ListProjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Equatable {
    /// <p>If there are more than 100 items in the list, only the first 100 items are returned,
    ///             along with a unique string called a <i>nextToken</i>. To get the next
    ///             batch of items in the list, call this operation again, adding the next token to the
    ///             call.</p>
    public let nextToken: String?
    /// <p>The list of build project names, with each build project name representing a single
    ///             build project.</p>
    public let projects: [String]?

    public init (
        nextToken: String? = nil,
        projects: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let projects: [String]?
}

extension ListProjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let projectsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .projects)
        var projectsDecoded0:[String]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [String]()
            for string0 in projectsContainer {
                if let string0 = string0 {
                    projectsDecoded0?.append(string0)
                }
            }
        }
        projects = projectsDecoded0
    }
}

public struct ListReportGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListReportGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReportGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReportGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReportGroupsInput>
    public typealias MOutput = OperationOutput<ListReportGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReportGroupsOutputError>
}

extension ListReportGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReportGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListReportGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListReportGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListReportGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReportGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReportGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReportGroupsInput>
    public typealias MOutput = OperationOutput<ListReportGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReportGroupsOutputError>
}

public struct ListReportGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReportGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReportGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReportGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReportGroupsInput>
    public typealias MOutput = OperationOutput<ListReportGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReportGroupsOutputError>
}

public struct ListReportGroupsInput: Equatable {
    /// <p>
    ///       The maximum number of paginated report groups returned per response. Use <code>nextToken</code> to iterate pages in
    ///       the list of returned <code>ReportGroup</code> objects. The default value is 100.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///       During a previous call, the maximum number of items that can be returned is the value specified in
    ///       <code>maxResults</code>. If there more items in the list, then a unique string called a <i>nextToken</i>
    ///       is returned. To get the next batch of items in the list, call this operation again, adding the next token
    ///       to the call. To get all of the items in the list, keep calling this operation with each
    ///       subsequent next token that is returned, until no more next tokens are returned.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       The criterion to be used to list build report groups. Valid values include:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATED_TIME</code>: List based on when each report group was
    ///           created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAST_MODIFIED_TIME</code>: List based on when each report group  was last changed.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NAME</code>: List based on each report group's name.</p>
    ///             </li>
    ///          </ul>
    public let sortBy: ReportGroupSortByType?
    /// <p>
    ///       Used to specify the order to sort the list of returned report groups. Valid values are
    ///       <code>ASCENDING</code> and <code>DESCENDING</code>.
    ///     </p>
    public let sortOrder: SortOrderType?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: ReportGroupSortByType? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListReportGroupsInputBody: Equatable {
    public let sortOrder: SortOrderType?
    public let sortBy: ReportGroupSortByType?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListReportGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(ReportGroupSortByType.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReportGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReportGroupsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReportGroupsOutputResponse(nextToken: \(String(describing: nextToken)), reportGroups: \(String(describing: reportGroups)))"}
}

extension ListReportGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReportGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.reportGroups = output.reportGroups
        } else {
            self.nextToken = nil
            self.reportGroups = nil
        }
    }
}

public struct ListReportGroupsOutputResponse: Equatable {
    /// <p>
    ///       During a previous call, the maximum number of items that can be returned is the value specified in
    ///       <code>maxResults</code>. If there more items in the list, then a unique string called a <i>nextToken</i>
    ///       is returned. To get the next batch of items in the list, call this operation again, adding the next token
    ///       to the call. To get all of the items in the list, keep calling this operation with each
    ///       subsequent next token that is returned, until no more next tokens are returned.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       The list of ARNs for the report groups in the current AWS account.
    ///     </p>
    public let reportGroups: [String]?

    public init (
        nextToken: String? = nil,
        reportGroups: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportGroups = reportGroups
    }
}

struct ListReportGroupsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let reportGroups: [String]?
}

extension ListReportGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case reportGroups
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reportGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .reportGroups)
        var reportGroupsDecoded0:[String]? = nil
        if let reportGroupsContainer = reportGroupsContainer {
            reportGroupsDecoded0 = [String]()
            for string0 in reportGroupsContainer {
                if let string0 = string0 {
                    reportGroupsDecoded0?.append(string0)
                }
            }
        }
        reportGroups = reportGroupsDecoded0
    }
}

public struct ListReportsForReportGroupInputBodyMiddleware: Middleware {
    public let id: String = "ListReportsForReportGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReportsForReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReportsForReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReportsForReportGroupInput>
    public typealias MOutput = OperationOutput<ListReportsForReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReportsForReportGroupOutputError>
}

extension ListReportsForReportGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReportsForReportGroupInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), reportGroupArn: \(String(describing: reportGroupArn)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListReportsForReportGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case reportGroupArn
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let reportGroupArn = reportGroupArn {
            try encodeContainer.encode(reportGroupArn, forKey: .reportGroupArn)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListReportsForReportGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ListReportsForReportGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReportsForReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReportsForReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReportsForReportGroupInput>
    public typealias MOutput = OperationOutput<ListReportsForReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReportsForReportGroupOutputError>
}

public struct ListReportsForReportGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReportsForReportGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReportsForReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReportsForReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReportsForReportGroupInput>
    public typealias MOutput = OperationOutput<ListReportsForReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReportsForReportGroupOutputError>
}

public struct ListReportsForReportGroupInput: Equatable {
    /// <p>
    ///       A <code>ReportFilter</code> object used to filter the returned reports.
    ///     </p>
    public let filter: ReportFilter?
    /// <p>
    ///       The maximum number of paginated reports in this report group returned per response. Use <code>nextToken</code> to iterate pages in
    ///       the list of returned <code>Report</code> objects. The default value is 100.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///       During a previous call, the maximum number of items that can be returned is the value specified in
    ///       <code>maxResults</code>. If there more items in the list, then a unique string called a <i>nextToken</i>
    ///       is returned. To get the next batch of items in the list, call this operation again, adding the next token
    ///       to the call. To get all of the items in the list, keep calling this operation with each
    ///       subsequent next token that is returned, until no more next tokens are returned.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       The ARN of the report group for which you want to return report ARNs.
    ///     </p>
    public let reportGroupArn: String?
    /// <p>
    ///       Use to specify whether the results are returned in ascending or descending order.
    ///     </p>
    public let sortOrder: SortOrderType?

    public init (
        filter: ReportFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        reportGroupArn: String? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reportGroupArn = reportGroupArn
        self.sortOrder = sortOrder
    }
}

struct ListReportsForReportGroupInputBody: Equatable {
    public let reportGroupArn: String?
    public let nextToken: String?
    public let sortOrder: SortOrderType?
    public let maxResults: Int?
    public let filter: ReportFilter?
}

extension ListReportsForReportGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case reportGroupArn
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportGroupArn)
        reportGroupArn = reportGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(ReportFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReportsForReportGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportsForReportGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReportsForReportGroupOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportsForReportGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReportsForReportGroupOutputResponse(nextToken: \(String(describing: nextToken)), reports: \(String(describing: reports)))"}
}

extension ListReportsForReportGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReportsForReportGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.reports = output.reports
        } else {
            self.nextToken = nil
            self.reports = nil
        }
    }
}

public struct ListReportsForReportGroupOutputResponse: Equatable {
    /// <p>
    ///       During a previous call, the maximum number of items that can be returned is the value specified in
    ///       <code>maxResults</code>. If there more items in the list, then a unique string called a <i>nextToken</i>
    ///       is returned. To get the next batch of items in the list, call this operation again, adding the next token
    ///       to the call. To get all of the items in the list, keep calling this operation with each
    ///       subsequent next token that is returned, until no more next tokens are returned.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       The list of report ARNs.
    ///     </p>
    public let reports: [String]?

    public init (
        nextToken: String? = nil,
        reports: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.reports = reports
    }
}

struct ListReportsForReportGroupOutputResponseBody: Equatable {
    public let nextToken: String?
    public let reports: [String]?
}

extension ListReportsForReportGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case reports
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reportsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .reports)
        var reportsDecoded0:[String]? = nil
        if let reportsContainer = reportsContainer {
            reportsDecoded0 = [String]()
            for string0 in reportsContainer {
                if let string0 = string0 {
                    reportsDecoded0?.append(string0)
                }
            }
        }
        reports = reportsDecoded0
    }
}

public struct ListReportsInputBodyMiddleware: Middleware {
    public let id: String = "ListReportsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReportsInput>
    public typealias MOutput = OperationOutput<ListReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReportsOutputError>
}

extension ListReportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReportsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListReportsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListReportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReportsInput>
    public typealias MOutput = OperationOutput<ListReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReportsOutputError>
}

public struct ListReportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReportsInput>
    public typealias MOutput = OperationOutput<ListReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReportsOutputError>
}

public struct ListReportsInput: Equatable {
    /// <p>
    ///       A <code>ReportFilter</code> object used to filter the returned reports.
    ///     </p>
    public let filter: ReportFilter?
    /// <p>
    ///       The maximum number of paginated reports returned per response. Use <code>nextToken</code> to iterate pages in
    ///       the list of returned <code>Report</code> objects. The default value is 100.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///       During a previous call, the maximum number of items that can be returned is the value specified in
    ///       <code>maxResults</code>. If there more items in the list, then a unique string called a <i>nextToken</i>
    ///       is returned. To get the next batch of items in the list, call this operation again, adding the next token
    ///       to the call. To get all of the items in the list, keep calling this operation with each
    ///       subsequent next token that is returned, until no more next tokens are returned.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       Specifies the sort order for the list of returned reports. Valid values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ASCENDING</code>: return reports in chronological order based on their creation date.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DESCENDING</code>: return reports in the reverse chronological order based on their creation date.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let sortOrder: SortOrderType?

    public init (
        filter: ReportFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListReportsInputBody: Equatable {
    public let sortOrder: SortOrderType?
    public let nextToken: String?
    public let maxResults: Int?
    public let filter: ReportFilter?
}

extension ListReportsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(ReportFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReportsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReportsOutputResponse(nextToken: \(String(describing: nextToken)), reports: \(String(describing: reports)))"}
}

extension ListReportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.reports = output.reports
        } else {
            self.nextToken = nil
            self.reports = nil
        }
    }
}

public struct ListReportsOutputResponse: Equatable {
    /// <p>
    ///       During a previous call, the maximum number of items that can be returned is the value specified in
    ///       <code>maxResults</code>. If there more items in the list, then a unique string called a <i>nextToken</i>
    ///       is returned. To get the next batch of items in the list, call this operation again, adding the next token
    ///       to the call. To get all of the items in the list, keep calling this operation with each
    ///       subsequent next token that is returned, until no more next tokens are returned.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       The list of returned ARNs for the reports in the current AWS account.
    ///     </p>
    public let reports: [String]?

    public init (
        nextToken: String? = nil,
        reports: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.reports = reports
    }
}

struct ListReportsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let reports: [String]?
}

extension ListReportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case reports
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reportsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .reports)
        var reportsDecoded0:[String]? = nil
        if let reportsContainer = reportsContainer {
            reportsDecoded0 = [String]()
            for string0 in reportsContainer {
                if let string0 = string0 {
                    reportsDecoded0?.append(string0)
                }
            }
        }
        reports = reportsDecoded0
    }
}

public struct ListSharedProjectsInputBodyMiddleware: Middleware {
    public let id: String = "ListSharedProjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSharedProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSharedProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSharedProjectsInput>
    public typealias MOutput = OperationOutput<ListSharedProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSharedProjectsOutputError>
}

extension ListSharedProjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSharedProjectsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListSharedProjectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListSharedProjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSharedProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSharedProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSharedProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSharedProjectsInput>
    public typealias MOutput = OperationOutput<ListSharedProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSharedProjectsOutputError>
}

public struct ListSharedProjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSharedProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSharedProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSharedProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSharedProjectsInput>
    public typealias MOutput = OperationOutput<ListSharedProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSharedProjectsOutputError>
}

public struct ListSharedProjectsInput: Equatable {
    /// <p> The maximum number of paginated shared build projects returned per response. Use
    ///                 <code>nextToken</code> to iterate pages in the list of returned <code>Project</code>
    ///             objects. The default value is 100. </p>
    public let maxResults: Int?
    /// <p> During a previous call, the maximum number of items that can be returned is the value
    ///             specified in <code>maxResults</code>. If there more items in the list, then a unique
    ///             string called a <i>nextToken</i> is returned. To get the next batch of
    ///             items in the list, call this operation again, adding the next token to the call. To get
    ///             all of the items in the list, keep calling this operation with each subsequent next
    ///             token that is returned, until no more next tokens are returned. </p>
    public let nextToken: String?
    /// <p> The criterion to be used to list build projects shared with the current AWS account
    ///             or user. Valid values include: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>ARN</code>: List based on the ARN. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>MODIFIED_TIME</code>: List based on when information about the shared
    ///                     project was last changed. </p>
    ///             </li>
    ///          </ul>
    public let sortBy: SharedResourceSortByType?
    /// <p>The order in which to list shared build projects. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ASCENDING</code>: List in ascending order.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DESCENDING</code>: List in descending order.</p>
    ///             </li>
    ///          </ul>
    public let sortOrder: SortOrderType?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: SharedResourceSortByType? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListSharedProjectsInputBody: Equatable {
    public let sortBy: SharedResourceSortByType?
    public let sortOrder: SortOrderType?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListSharedProjectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(SharedResourceSortByType.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSharedProjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSharedProjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSharedProjectsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSharedProjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSharedProjectsOutputResponse(nextToken: \(String(describing: nextToken)), projects: \(String(describing: projects)))"}
}

extension ListSharedProjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSharedProjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListSharedProjectsOutputResponse: Equatable {
    /// <p> During a previous call, the maximum number of items that can be returned is the value
    ///             specified in <code>maxResults</code>. If there more items in the list, then a unique
    ///             string called a <i>nextToken</i> is returned. To get the next batch of
    ///             items in the list, call this operation again, adding the next token to the call. To get
    ///             all of the items in the list, keep calling this operation with each subsequent next
    ///             token that is returned, until no more next tokens are returned. </p>
    public let nextToken: String?
    /// <p> The list of ARNs for the build projects shared with the current AWS account or user.
    ///         </p>
    public let projects: [String]?

    public init (
        nextToken: String? = nil,
        projects: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListSharedProjectsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let projects: [String]?
}

extension ListSharedProjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let projectsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .projects)
        var projectsDecoded0:[String]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [String]()
            for string0 in projectsContainer {
                if let string0 = string0 {
                    projectsDecoded0?.append(string0)
                }
            }
        }
        projects = projectsDecoded0
    }
}

public struct ListSharedReportGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListSharedReportGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSharedReportGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSharedReportGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSharedReportGroupsInput>
    public typealias MOutput = OperationOutput<ListSharedReportGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSharedReportGroupsOutputError>
}

extension ListSharedReportGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSharedReportGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListSharedReportGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListSharedReportGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSharedReportGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSharedReportGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSharedReportGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSharedReportGroupsInput>
    public typealias MOutput = OperationOutput<ListSharedReportGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSharedReportGroupsOutputError>
}

public struct ListSharedReportGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSharedReportGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSharedReportGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSharedReportGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSharedReportGroupsInput>
    public typealias MOutput = OperationOutput<ListSharedReportGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSharedReportGroupsOutputError>
}

public struct ListSharedReportGroupsInput: Equatable {
    /// <p> The maximum number of paginated shared report groups per response. Use
    ///                 <code>nextToken</code> to iterate pages in the list of returned
    ///                 <code>ReportGroup</code> objects. The default value is 100. </p>
    public let maxResults: Int?
    /// <p> During a previous call, the maximum number of items that can be returned is the value
    ///             specified in <code>maxResults</code>. If there more items in the list, then a unique
    ///             string called a <i>nextToken</i> is returned. To get the next batch of
    ///             items in the list, call this operation again, adding the next token to the call. To get
    ///             all of the items in the list, keep calling this operation with each subsequent next
    ///             token that is returned, until no more next tokens are returned. </p>
    public let nextToken: String?
    /// <p> The criterion to be used to list report groups shared with the current AWS account or
    ///             user. Valid values include: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>ARN</code>: List based on the ARN. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>MODIFIED_TIME</code>: List based on when information about the shared
    ///                     report group was last changed. </p>
    ///             </li>
    ///          </ul>
    public let sortBy: SharedResourceSortByType?
    /// <p>The order in which to list shared report groups. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ASCENDING</code>: List in ascending order.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DESCENDING</code>: List in descending order.</p>
    ///             </li>
    ///          </ul>
    public let sortOrder: SortOrderType?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: SharedResourceSortByType? = nil,
        sortOrder: SortOrderType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListSharedReportGroupsInputBody: Equatable {
    public let sortOrder: SortOrderType?
    public let sortBy: SharedResourceSortByType?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListSharedReportGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(SharedResourceSortByType.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSharedReportGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSharedReportGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSharedReportGroupsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSharedReportGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSharedReportGroupsOutputResponse(nextToken: \(String(describing: nextToken)), reportGroups: \(String(describing: reportGroups)))"}
}

extension ListSharedReportGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSharedReportGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.reportGroups = output.reportGroups
        } else {
            self.nextToken = nil
            self.reportGroups = nil
        }
    }
}

public struct ListSharedReportGroupsOutputResponse: Equatable {
    /// <p> During a previous call, the maximum number of items that can be returned is the value
    ///             specified in <code>maxResults</code>. If there more items in the list, then a unique
    ///             string called a <i>nextToken</i> is returned. To get the next batch of
    ///             items in the list, call this operation again, adding the next token to the call. To get
    ///             all of the items in the list, keep calling this operation with each subsequent next
    ///             token that is returned, until no more next tokens are returned. </p>
    public let nextToken: String?
    /// <p> The list of ARNs for the report groups shared with the current AWS account or user.
    ///         </p>
    public let reportGroups: [String]?

    public init (
        nextToken: String? = nil,
        reportGroups: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportGroups = reportGroups
    }
}

struct ListSharedReportGroupsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let reportGroups: [String]?
}

extension ListSharedReportGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case reportGroups
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reportGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .reportGroups)
        var reportGroupsDecoded0:[String]? = nil
        if let reportGroupsContainer = reportGroupsContainer {
            reportGroupsDecoded0 = [String]()
            for string0 in reportGroupsContainer {
                if let string0 = string0 {
                    reportGroupsDecoded0?.append(string0)
                }
            }
        }
        reportGroups = reportGroupsDecoded0
    }
}

extension ListSourceCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSourceCredentialsInput()"}
}

extension ListSourceCredentialsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSourceCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSourceCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSourceCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSourceCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSourceCredentialsInput>
    public typealias MOutput = OperationOutput<ListSourceCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSourceCredentialsOutputError>
}

public struct ListSourceCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSourceCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSourceCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSourceCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSourceCredentialsInput>
    public typealias MOutput = OperationOutput<ListSourceCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSourceCredentialsOutputError>
}

public struct ListSourceCredentialsInput: Equatable {

    public init() {}
}

struct ListSourceCredentialsInputBody: Equatable {
}

extension ListSourceCredentialsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSourceCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSourceCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSourceCredentialsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSourceCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSourceCredentialsOutputResponse(sourceCredentialsInfos: \(String(describing: sourceCredentialsInfos)))"}
}

extension ListSourceCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSourceCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sourceCredentialsInfos = output.sourceCredentialsInfos
        } else {
            self.sourceCredentialsInfos = nil
        }
    }
}

public struct ListSourceCredentialsOutputResponse: Equatable {
    /// <p> A list of <code>SourceCredentialsInfo</code> objects. Each
    ///                 <code>SourceCredentialsInfo</code> object includes the authentication type, token
    ///             ARN, and type of source provider for one set of credentials. </p>
    public let sourceCredentialsInfos: [SourceCredentialsInfo]?

    public init (
        sourceCredentialsInfos: [SourceCredentialsInfo]? = nil
    )
    {
        self.sourceCredentialsInfos = sourceCredentialsInfos
    }
}

struct ListSourceCredentialsOutputResponseBody: Equatable {
    public let sourceCredentialsInfos: [SourceCredentialsInfo]?
}

extension ListSourceCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceCredentialsInfos
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceCredentialsInfosContainer = try containerValues.decodeIfPresent([SourceCredentialsInfo?].self, forKey: .sourceCredentialsInfos)
        var sourceCredentialsInfosDecoded0:[SourceCredentialsInfo]? = nil
        if let sourceCredentialsInfosContainer = sourceCredentialsInfosContainer {
            sourceCredentialsInfosDecoded0 = [SourceCredentialsInfo]()
            for structure0 in sourceCredentialsInfosContainer {
                if let structure0 = structure0 {
                    sourceCredentialsInfosDecoded0?.append(structure0)
                }
            }
        }
        sourceCredentialsInfos = sourceCredentialsInfosDecoded0
    }
}

extension LogsConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogs
        case s3Logs
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(CloudWatchLogsConfig.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
        let s3LogsDecoded = try containerValues.decodeIfPresent(S3LogsConfig.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension LogsConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogsConfig(cloudWatchLogs: \(String(describing: cloudWatchLogs)), s3Logs: \(String(describing: s3Logs)))"}
}

/// <p> Information about logs for a build project. These can be logs in Amazon CloudWatch Logs, built in a
///             specified S3 bucket, or both. </p>
public struct LogsConfig: Equatable {
    /// <p> Information about Amazon CloudWatch Logs for a build project. Amazon CloudWatch Logs are enabled by default. </p>
    public let cloudWatchLogs: CloudWatchLogsConfig?
    /// <p> Information about logs built to an S3 bucket for a build project. S3 logs are not
    ///             enabled by default. </p>
    public let s3Logs: S3LogsConfig?

    public init (
        cloudWatchLogs: CloudWatchLogsConfig? = nil,
        s3Logs: S3LogsConfig? = nil
    )
    {
        self.cloudWatchLogs = cloudWatchLogs
        self.s3Logs = s3Logs
    }
}

public enum LogsConfigStatusType {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension LogsConfigStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogsConfigStatusType] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogsConfigStatusType(rawValue: rawValue) ?? LogsConfigStatusType.sdkUnknown(rawValue)
    }
}

extension LogsLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogs
        case cloudWatchLogsArn
        case deepLink
        case groupName
        case s3DeepLink
        case s3Logs
        case s3LogsArn
        case streamName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let cloudWatchLogsArn = cloudWatchLogsArn {
            try encodeContainer.encode(cloudWatchLogsArn, forKey: .cloudWatchLogsArn)
        }
        if let deepLink = deepLink {
            try encodeContainer.encode(deepLink, forKey: .deepLink)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let s3DeepLink = s3DeepLink {
            try encodeContainer.encode(s3DeepLink, forKey: .s3DeepLink)
        }
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
        if let s3LogsArn = s3LogsArn {
            try encodeContainer.encode(s3LogsArn, forKey: .s3LogsArn)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let deepLinkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deepLink)
        deepLink = deepLinkDecoded
        let s3DeepLinkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3DeepLink)
        s3DeepLink = s3DeepLinkDecoded
        let cloudWatchLogsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsArn)
        cloudWatchLogsArn = cloudWatchLogsArnDecoded
        let s3LogsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3LogsArn)
        s3LogsArn = s3LogsArnDecoded
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(CloudWatchLogsConfig.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
        let s3LogsDecoded = try containerValues.decodeIfPresent(S3LogsConfig.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension LogsLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogsLocation(cloudWatchLogs: \(String(describing: cloudWatchLogs)), cloudWatchLogsArn: \(String(describing: cloudWatchLogsArn)), deepLink: \(String(describing: deepLink)), groupName: \(String(describing: groupName)), s3DeepLink: \(String(describing: s3DeepLink)), s3Logs: \(String(describing: s3Logs)), s3LogsArn: \(String(describing: s3LogsArn)), streamName: \(String(describing: streamName)))"}
}

/// <p>Information about build logs in Amazon CloudWatch Logs.</p>
public struct LogsLocation: Equatable {
    /// <p> Information about Amazon CloudWatch Logs for a build project. </p>
    public let cloudWatchLogs: CloudWatchLogsConfig?
    /// <p> The ARN of Amazon CloudWatch Logs for a build project. Its format is
    ///                 <code>arn:${Partition}:logs:${Region}:${Account}:log-group:${LogGroupName}:log-stream:${LogStreamName}</code>.
    ///             For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatchlogs.html#amazoncloudwatchlogs-resources-for-iam-policies">Resources Defined by Amazon CloudWatch Logs</a>. </p>
    public let cloudWatchLogsArn: String?
    /// <p>The URL to an individual build log in Amazon CloudWatch Logs.</p>
    public let deepLink: String?
    /// <p>The name of the Amazon CloudWatch Logs group for the build logs.</p>
    public let groupName: String?
    /// <p> The URL to a build log in an S3 bucket. </p>
    public let s3DeepLink: String?
    /// <p> Information about S3 logs for a build project. </p>
    public let s3Logs: S3LogsConfig?
    /// <p> The ARN of S3 logs for a build project. Its format is
    ///                 <code>arn:${Partition}:s3:::${BucketName}/${ObjectName}</code>. For more
    ///             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazons3.html#amazons3-resources-for-iam-policies">Resources Defined by Amazon S3</a>. </p>
    public let s3LogsArn: String?
    /// <p>The name of the Amazon CloudWatch Logs stream for the build logs.</p>
    public let streamName: String?

    public init (
        cloudWatchLogs: CloudWatchLogsConfig? = nil,
        cloudWatchLogsArn: String? = nil,
        deepLink: String? = nil,
        groupName: String? = nil,
        s3DeepLink: String? = nil,
        s3Logs: S3LogsConfig? = nil,
        s3LogsArn: String? = nil,
        streamName: String? = nil
    )
    {
        self.cloudWatchLogs = cloudWatchLogs
        self.cloudWatchLogsArn = cloudWatchLogsArn
        self.deepLink = deepLink
        self.groupName = groupName
        self.s3DeepLink = s3DeepLink
        self.s3Logs = s3Logs
        self.s3LogsArn = s3LogsArn
        self.streamName = streamName
    }
}

extension NetworkInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case networkInterfaceId
        case subnetId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
    }
}

extension NetworkInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkInterface(networkInterfaceId: \(String(describing: networkInterfaceId)), subnetId: \(String(describing: subnetId)))"}
}

/// <p>Describes a network interface.</p>
public struct NetworkInterface: Equatable {
    /// <p>The ID of the network interface.</p>
    public let networkInterfaceId: String?
    /// <p>The ID of the subnet.</p>
    public let subnetId: String?

    public init (
        networkInterfaceId: String? = nil,
        subnetId: String? = nil
    )
    {
        self.networkInterfaceId = networkInterfaceId
        self.subnetId = subnetId
    }
}

extension OAuthProviderException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OAuthProviderException(message: \(String(describing: message)))"}
}

extension OAuthProviderException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OAuthProviderExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was a problem with the underlying OAuth provider.</p>
public struct OAuthProviderException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OAuthProviderExceptionBody: Equatable {
    public let message: String?
}

extension OAuthProviderExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PhaseContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
        case statusCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PhaseContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PhaseContext(message: \(String(describing: message)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>Additional information about a build phase that has an error. You can use this
///             information for troubleshooting.</p>
public struct PhaseContext: Equatable {
    /// <p>An explanation of the build phase's context. This might include a command ID and an
    ///             exit code.</p>
    public let message: String?
    /// <p>The status code for the context of the build phase.</p>
    public let statusCode: String?

    public init (
        message: String? = nil,
        statusCode: String? = nil
    )
    {
        self.message = message
        self.statusCode = statusCode
    }
}

public enum PlatformType {
    case amazonLinux
    case debian
    case ubuntu
    case windowsServer
    case sdkUnknown(String)
}

extension PlatformType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PlatformType] {
        return [
            .amazonLinux,
            .debian,
            .ubuntu,
            .windowsServer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amazonLinux: return "AMAZON_LINUX"
        case .debian: return "DEBIAN"
        case .ubuntu: return "UBUNTU"
        case .windowsServer: return "WINDOWS_SERVER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PlatformType(rawValue: rawValue) ?? PlatformType.sdkUnknown(rawValue)
    }
}

extension Project: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case artifacts
        case badge
        case buildBatchConfig
        case cache
        case concurrentBuildLimit
        case created
        case description
        case encryptionKey
        case environment
        case fileSystemLocations
        case lastModified
        case logsConfig
        case name
        case queuedTimeoutInMinutes
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case tags
        case timeoutInMinutes
        case vpcConfig
        case webhook
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let artifacts = artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let badge = badge {
            try encodeContainer.encode(badge, forKey: .badge)
        }
        if let buildBatchConfig = buildBatchConfig {
            try encodeContainer.encode(buildBatchConfig, forKey: .buildBatchConfig)
        }
        if let cache = cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if let concurrentBuildLimit = concurrentBuildLimit {
            try encodeContainer.encode(concurrentBuildLimit, forKey: .concurrentBuildLimit)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocations0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocations0)
            }
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let logsConfig = logsConfig {
            try encodeContainer.encode(logsConfig, forKey: .logsConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queuedTimeoutInMinutes = queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for projectartifactslist0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(projectartifactslist0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsecondarysourceversions0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsecondarysourceversions0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsources0 in secondarySources {
                try secondarySourcesContainer.encode(projectsources0)
            }
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let timeoutInMinutes = timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
        if let webhook = webhook {
            try encodeContainer.encode(webhook, forKey: .webhook)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(ProjectSource.self, forKey: .source)
        source = sourceDecoded
        let secondarySourcesContainer = try containerValues.decodeIfPresent([ProjectSource?].self, forKey: .secondarySources)
        var secondarySourcesDecoded0:[ProjectSource]? = nil
        if let secondarySourcesContainer = secondarySourcesContainer {
            secondarySourcesDecoded0 = [ProjectSource]()
            for structure0 in secondarySourcesContainer {
                if let structure0 = structure0 {
                    secondarySourcesDecoded0?.append(structure0)
                }
            }
        }
        secondarySources = secondarySourcesDecoded0
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let secondarySourceVersionsContainer = try containerValues.decodeIfPresent([ProjectSourceVersion?].self, forKey: .secondarySourceVersions)
        var secondarySourceVersionsDecoded0:[ProjectSourceVersion]? = nil
        if let secondarySourceVersionsContainer = secondarySourceVersionsContainer {
            secondarySourceVersionsDecoded0 = [ProjectSourceVersion]()
            for structure0 in secondarySourceVersionsContainer {
                if let structure0 = structure0 {
                    secondarySourceVersionsDecoded0?.append(structure0)
                }
            }
        }
        secondarySourceVersions = secondarySourceVersionsDecoded0
        let artifactsDecoded = try containerValues.decodeIfPresent(ProjectArtifacts.self, forKey: .artifacts)
        artifacts = artifactsDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([ProjectArtifacts?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[ProjectArtifacts]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [ProjectArtifacts]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
        let cacheDecoded = try containerValues.decodeIfPresent(ProjectCache.self, forKey: .cache)
        cache = cacheDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(ProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
        let queuedTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queuedTimeoutInMinutes)
        queuedTimeoutInMinutes = queuedTimeoutInMinutesDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let webhookDecoded = try containerValues.decodeIfPresent(Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let badgeDecoded = try containerValues.decodeIfPresent(ProjectBadge.self, forKey: .badge)
        badge = badgeDecoded
        let logsConfigDecoded = try containerValues.decodeIfPresent(LogsConfig.self, forKey: .logsConfig)
        logsConfig = logsConfigDecoded
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([ProjectFileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[ProjectFileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [ProjectFileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
        let buildBatchConfigDecoded = try containerValues.decodeIfPresent(ProjectBuildBatchConfig.self, forKey: .buildBatchConfig)
        buildBatchConfig = buildBatchConfigDecoded
        let concurrentBuildLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .concurrentBuildLimit)
        concurrentBuildLimit = concurrentBuildLimitDecoded
    }
}

extension Project: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Project(arn: \(String(describing: arn)), artifacts: \(String(describing: artifacts)), badge: \(String(describing: badge)), buildBatchConfig: \(String(describing: buildBatchConfig)), cache: \(String(describing: cache)), concurrentBuildLimit: \(String(describing: concurrentBuildLimit)), created: \(String(describing: created)), description: \(String(describing: description)), encryptionKey: \(String(describing: encryptionKey)), environment: \(String(describing: environment)), fileSystemLocations: \(String(describing: fileSystemLocations)), lastModified: \(String(describing: lastModified)), logsConfig: \(String(describing: logsConfig)), name: \(String(describing: name)), queuedTimeoutInMinutes: \(String(describing: queuedTimeoutInMinutes)), secondaryArtifacts: \(String(describing: secondaryArtifacts)), secondarySourceVersions: \(String(describing: secondarySourceVersions)), secondarySources: \(String(describing: secondarySources)), serviceRole: \(String(describing: serviceRole)), source: \(String(describing: source)), sourceVersion: \(String(describing: sourceVersion)), tags: \(String(describing: tags)), timeoutInMinutes: \(String(describing: timeoutInMinutes)), vpcConfig: \(String(describing: vpcConfig)), webhook: \(String(describing: webhook)))"}
}

/// <p>Information about a build project.</p>
public struct Project: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the build project.</p>
    public let arn: String?
    /// <p>Information about the build output artifacts for the build project.</p>
    public let artifacts: ProjectArtifacts?
    /// <p>Information about the build badge for the build project.</p>
    public let badge: ProjectBadge?
    /// <p>A <a>ProjectBuildBatchConfig</a>
    ///  object that defines the batch build
    ///             options for the project.</p>
    public let buildBatchConfig: ProjectBuildBatchConfig?
    /// <p>Information about the cache for the build project.</p>
    public let cache: ProjectCache?
    /// <p>The maximum number of concurrent builds that are allowed for this project.</p>
    ///          <p>New builds are only started if the current number of builds is less than or equal to this limit.
    ///   If the current build count meets this limit, new builds are throttled and are not run.</p>
    public let concurrentBuildLimit: Int?
    /// <p>When the build project was created, expressed in Unix time format.</p>
    public let created: Date?
    /// <p>A description that makes the build project easy to identify.</p>
    public let description: String?
    /// <p>The AWS Key Management Service (AWS KMS) customer master key (CMK) to be used for encrypting the build output
    ///       artifacts.</p>
    ///          <note>
    ///             <p>You can use a cross-account KMS key to encrypt the build output artifacts if your
    ///         service role has permission to that key. </p>
    ///          </note>
    ///          <p>You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using
    ///         the format <code>alias/<alias-name></code>).
    ///     </p>
    public let encryptionKey: String?
    /// <p>Information about the build environment for this build project.</p>
    public let environment: ProjectEnvironment?
    /// <p>
    ///       An array of <code>ProjectFileSystemLocation</code> objects for a CodeBuild build project. A <code>ProjectFileSystemLocation</code> object
    ///       specifies the <code>identifier</code>, <code>location</code>, <code>mountOptions</code>,
    ///       <code>mountPoint</code>, and <code>type</code> of a file system created using Amazon Elastic File System.
    ///   </p>
    public let fileSystemLocations: [ProjectFileSystemLocation]?
    /// <p>When the build project's settings were last modified, expressed in Unix time
    ///       format.</p>
    public let lastModified: Date?
    /// <p>Information about logs for the build project. A project can create logs in Amazon CloudWatch Logs, an
    ///       S3 bucket, or both. </p>
    public let logsConfig: LogsConfig?
    /// <p>The name of the build project.</p>
    public let name: String?
    /// <p>The number of minutes a build is allowed to be queued before it times out. </p>
    public let queuedTimeoutInMinutes: Int?
    /// <p>An array of <code>ProjectArtifacts</code> objects. </p>
    public let secondaryArtifacts: [ProjectArtifacts]?
    /// <p>An array of <code>ProjectSourceVersion</code> objects. If
    ///       <code>secondarySourceVersions</code> is specified at the build level, then they take
    ///       over these <code>secondarySourceVersions</code> (at the project level). </p>
    public let secondarySourceVersions: [ProjectSourceVersion]?
    /// <p>An array of <code>ProjectSource</code> objects. </p>
    public let secondarySources: [ProjectSource]?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that enables AWS CodeBuild to interact with dependent AWS services
    ///       on behalf of the AWS account.</p>
    public let serviceRole: String?
    /// <p>Information about the build input source code for this build project.</p>
    public let source: ProjectSource?
    /// <p>A version of the build input to be built for this project. If not specified, the
    ///       latest version is used. If specified, it must be one of:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For AWS CodeCommit: the commit ID, branch, or Git tag to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>For GitHub: the commit ID, pull request ID, branch name, or tag name that
    ///           corresponds to the version of the source code you want to build. If a pull
    ///           request ID is specified, it must use the format <code>pr/pull-request-ID</code>
    ///           (for example <code>pr/25</code>). If a branch name is specified, the branch's
    ///           HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is
    ///           used.</p>
    ///             </li>
    ///             <li>
    ///                <p>For Bitbucket: the commit ID, branch name, or tag name that corresponds to the
    ///           version of the source code you want to build. If a branch name is specified, the
    ///           branch's HEAD commit ID is used. If not specified, the default branch's HEAD
    ///           commit ID is used.</p>
    ///             </li>
    ///             <li>
    ///                <p>For Amazon S3: the version ID of the object that represents the build input ZIP
    ///           file to use.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If <code>sourceVersion</code> is specified at the build level, then that version
    ///       takes precedence over this <code>sourceVersion</code> (at the project level). </p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html">Source Version Sample
    ///       with CodeBuild</a> in the <i>AWS CodeBuild User Guide</i>.
    ///     </p>
    public let sourceVersion: String?
    /// <p>A list of tag key and value pairs associated with this build project.</p>
    ///          <p>These tags are available for use by AWS services that support AWS CodeBuild build project
    ///       tags.</p>
    public let tags: [Tag]?
    /// <p>How long, in minutes, from 5 to 480 (8 hours), for AWS CodeBuild to wait before timing out any
    ///       related build that did not get marked as completed. The default is 60 minutes.</p>
    public let timeoutInMinutes: Int?
    /// <p>Information about the VPC configuration that AWS CodeBuild accesses.</p>
    public let vpcConfig: VpcConfig?
    /// <p>Information about a webhook that connects repository events to a build project in
    ///       AWS CodeBuild.</p>
    public let webhook: Webhook?

    public init (
        arn: String? = nil,
        artifacts: ProjectArtifacts? = nil,
        badge: ProjectBadge? = nil,
        buildBatchConfig: ProjectBuildBatchConfig? = nil,
        cache: ProjectCache? = nil,
        concurrentBuildLimit: Int? = nil,
        created: Date? = nil,
        description: String? = nil,
        encryptionKey: String? = nil,
        environment: ProjectEnvironment? = nil,
        fileSystemLocations: [ProjectFileSystemLocation]? = nil,
        lastModified: Date? = nil,
        logsConfig: LogsConfig? = nil,
        name: String? = nil,
        queuedTimeoutInMinutes: Int? = nil,
        secondaryArtifacts: [ProjectArtifacts]? = nil,
        secondarySourceVersions: [ProjectSourceVersion]? = nil,
        secondarySources: [ProjectSource]? = nil,
        serviceRole: String? = nil,
        source: ProjectSource? = nil,
        sourceVersion: String? = nil,
        tags: [Tag]? = nil,
        timeoutInMinutes: Int? = nil,
        vpcConfig: VpcConfig? = nil,
        webhook: Webhook? = nil
    )
    {
        self.arn = arn
        self.artifacts = artifacts
        self.badge = badge
        self.buildBatchConfig = buildBatchConfig
        self.cache = cache
        self.concurrentBuildLimit = concurrentBuildLimit
        self.created = created
        self.description = description
        self.encryptionKey = encryptionKey
        self.environment = environment
        self.fileSystemLocations = fileSystemLocations
        self.lastModified = lastModified
        self.logsConfig = logsConfig
        self.name = name
        self.queuedTimeoutInMinutes = queuedTimeoutInMinutes
        self.secondaryArtifacts = secondaryArtifacts
        self.secondarySourceVersions = secondarySourceVersions
        self.secondarySources = secondarySources
        self.serviceRole = serviceRole
        self.source = source
        self.sourceVersion = sourceVersion
        self.tags = tags
        self.timeoutInMinutes = timeoutInMinutes
        self.vpcConfig = vpcConfig
        self.webhook = webhook
    }
}

extension ProjectArtifacts: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactIdentifier
        case bucketOwnerAccess
        case encryptionDisabled
        case location
        case name
        case namespaceType
        case overrideArtifactName
        case packaging
        case path
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactIdentifier = artifactIdentifier {
            try encodeContainer.encode(artifactIdentifier, forKey: .artifactIdentifier)
        }
        if let bucketOwnerAccess = bucketOwnerAccess {
            try encodeContainer.encode(bucketOwnerAccess.rawValue, forKey: .bucketOwnerAccess)
        }
        if let encryptionDisabled = encryptionDisabled {
            try encodeContainer.encode(encryptionDisabled, forKey: .encryptionDisabled)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceType = namespaceType {
            try encodeContainer.encode(namespaceType.rawValue, forKey: .namespaceType)
        }
        if let overrideArtifactName = overrideArtifactName {
            try encodeContainer.encode(overrideArtifactName, forKey: .overrideArtifactName)
        }
        if let packaging = packaging {
            try encodeContainer.encode(packaging.rawValue, forKey: .packaging)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ArtifactsType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let namespaceTypeDecoded = try containerValues.decodeIfPresent(ArtifactNamespace.self, forKey: .namespaceType)
        namespaceType = namespaceTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let packagingDecoded = try containerValues.decodeIfPresent(ArtifactPackaging.self, forKey: .packaging)
        packaging = packagingDecoded
        let overrideArtifactNameDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .overrideArtifactName)
        overrideArtifactName = overrideArtifactNameDecoded
        let encryptionDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encryptionDisabled)
        encryptionDisabled = encryptionDisabledDecoded
        let artifactIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactIdentifier)
        artifactIdentifier = artifactIdentifierDecoded
        let bucketOwnerAccessDecoded = try containerValues.decodeIfPresent(BucketOwnerAccess.self, forKey: .bucketOwnerAccess)
        bucketOwnerAccess = bucketOwnerAccessDecoded
    }
}

extension ProjectArtifacts: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectArtifacts(artifactIdentifier: \(String(describing: artifactIdentifier)), bucketOwnerAccess: \(String(describing: bucketOwnerAccess)), encryptionDisabled: \(String(describing: encryptionDisabled)), location: \(String(describing: location)), name: \(String(describing: name)), namespaceType: \(String(describing: namespaceType)), overrideArtifactName: \(String(describing: overrideArtifactName)), packaging: \(String(describing: packaging)), path: \(String(describing: path)), type: \(String(describing: type)))"}
}

/// <p>Information about the build output artifacts for the build project.</p>
public struct ProjectArtifacts: Equatable {
    /// <p> An identifier for this artifact definition. </p>
    public let artifactIdentifier: String?
    /// <p>Specifies the access for objects that are uploaded to an Amazon S3 bucket that is owned by
    ///             another account.</p>
    ///         <p>By default, only the account that uploads the objects to the bucket has access to
    ///             these objects. This property allows you to give the bucket owner access to these
    ///             objects.</p>
    ///          <dl>
    ///             <dt>NONE</dt>
    ///             <dd>
    ///                 <p>The bucket owner does not have access to the objects. This is the
    ///                         default.</p>
    ///             </dd>
    ///             <dt>READ_ONLY</dt>
    ///             <dd>
    ///               <p>The bucket owner has read only access to the objects. The uploading account
    ///                         retains ownership of the objects.</p>
    ///             </dd>
    ///             <dt>FULL</dt>
    ///             <dd>
    ///               <p>The bucket owner has full access to the objects. Object ownership is determined
    ///                         by the following criteria:</p>
    ///                     <ul>
    ///                   <li>
    ///                             <p>If the bucket is configured with the <b>Bucket
    ///                                     owner preferred</b> setting, the bucket owner owns the
    ///                                 objects. The uploading account will have object access as specified
    ///                                 by the bucket's policy.</p>
    ///                         </li>
    ///                   <li>
    ///                             <p>Otherwise, the uploading account retains ownership of the
    ///                                 objects.</p>
    ///                         </li>
    ///                </ul>
    ///                     <p>For more information about Amazon S3 object ownership, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html">Controlling ownership of uploaded objects using S3
    ///                             Object Ownership</a> in the <i>Amazon Simple Storage Service User
    ///                         Guide</i>.</p>
    ///             </dd>
    ///          </dl>
    public let bucketOwnerAccess: BucketOwnerAccess?
    /// <p> Set to true if you do not want your output artifacts encrypted. This option is valid
    ///             only if your artifacts type is Amazon S3. If this is set with another artifacts type, an
    ///             invalidInputException is thrown. </p>
    public let encryptionDisabled: Bool?
    /// <p>Information about the build output artifact location:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, AWS CodePipeline ignores this
    ///                     value if specified. This is because AWS CodePipeline manages its build output locations
    ///                     instead of AWS CodeBuild.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is
    ///                     ignored if specified, because no build output is produced.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output
    ///                     bucket.</p>
    ///             </li>
    ///          </ul>
    public let location: String?
    /// <p>Along with <code>path</code> and <code>namespaceType</code>, the pattern that AWS CodeBuild
    ///             uses to name and store the output artifact:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, AWS CodePipeline ignores this
    ///                     value if specified. This is because AWS CodePipeline manages its build output names instead
    ///                     of AWS CodeBuild.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is
    ///                     ignored if specified, because no build output is produced.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output
    ///                     artifact object. If you set the name to be a forward slash ("/"), the artifact
    ///                     is stored in the root of the output bucket.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For example:</p>
    ///         <ul>
    ///             <li>
    ///                 <p> If <code>path</code> is set to <code>MyArtifacts</code>,
    ///                         <code>namespaceType</code> is set to <code>BUILD_ID</code>, and
    ///                         <code>name</code> is set to <code>MyArtifact.zip</code>, then the output
    ///                     artifact is stored in <code>MyArtifacts/<build-ID>/MyArtifact.zip</code>. </p>
    ///             </li>
    ///             <li>
    ///                 <p> If <code>path</code> is empty, <code>namespaceType</code> is set to
    ///                         <code>NONE</code>, and <code>name</code> is set to "<code>/</code>", the
    ///                     output artifact is stored in the root of the output bucket. </p>
    ///             </li>
    ///             <li>
    ///                 <p> If <code>path</code> is set to <code>MyArtifacts</code>,
    ///                         <code>namespaceType</code> is set to <code>BUILD_ID</code>, and
    ///                         <code>name</code> is set to "<code>/</code>", the output artifact is stored
    ///                     in <code>MyArtifacts/<build-ID></code>. </p>
    ///             </li>
    ///          </ul>
    public let name: String?
    /// <p>Along with <code>path</code> and <code>name</code>, the pattern that AWS CodeBuild uses to
    ///             determine the name and location to store the output artifact:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, AWS CodePipeline ignores this
    ///                     value if specified. This is because AWS CodePipeline manages its build output names instead
    ///                     of AWS CodeBuild.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is
    ///                     ignored if specified, because no build output is produced.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>S3</code>, valid values include:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>
    ///                         <code>BUILD_ID</code>: Include the build ID in the location of the
    ///                             build output artifact.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <code>NONE</code>: Do not include the build ID. This is the default if
    ///                                 <code>namespaceType</code> is not specified.</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    ///         <p>For example, if <code>path</code> is set to <code>MyArtifacts</code>,
    ///                 <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is
    ///             set to <code>MyArtifact.zip</code>, the output artifact is stored in
    ///                 <code>MyArtifacts/<build-ID>/MyArtifact.zip</code>.</p>
    public let namespaceType: ArtifactNamespace?
    /// <p> If this flag is set, a name specified in the buildspec file overrides the artifact
    ///             name. The name specified in a buildspec file is calculated at build time and uses the
    ///             Shell Command Language. For example, you can append a date and time to your artifact
    ///             name so that it is always unique. </p>
    public let overrideArtifactName: Bool?
    /// <p>The type of build output artifact to create:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, AWS CodePipeline ignores this
    ///                     value if specified. This is because AWS CodePipeline manages its build output artifacts
    ///                     instead of AWS CodeBuild.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is
    ///                     ignored if specified, because no build output is produced.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>S3</code>, valid values include:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>
    ///                         <code>NONE</code>: AWS CodeBuild creates in the output bucket a folder that
    ///                             contains the build output. This is the default if <code>packaging</code>
    ///                             is not specified.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <code>ZIP</code>: AWS CodeBuild creates in the output bucket a ZIP file that
    ///                             contains the build output.</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let packaging: ArtifactPackaging?
    /// <p>Along with <code>namespaceType</code> and <code>name</code>, the pattern that AWS CodeBuild
    ///             uses to name and store the output artifact:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, AWS CodePipeline ignores this
    ///                     value if specified. This is because AWS CodePipeline manages its build output names instead
    ///                     of AWS CodeBuild.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is
    ///                     ignored if specified, because no build output is produced.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If <code>type</code> is set to <code>S3</code>, this is the path to the output
    ///                     artifact. If <code>path</code> is not specified, <code>path</code> is not
    ///                     used.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For example, if <code>path</code> is set to <code>MyArtifacts</code>,
    ///                 <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set
    ///             to <code>MyArtifact.zip</code>, the output artifact is stored in the output bucket at
    ///                 <code>MyArtifacts/MyArtifact.zip</code>.</p>
    public let path: String?
    /// <p>The type of build output artifact. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>CODEPIPELINE</code>: The build project has build output generated
    ///                     through AWS CodePipeline. </p>
    ///                 <note>
    ///                     <p>The <code>CODEPIPELINE</code> type is not supported for
    ///                             <code>secondaryArtifacts</code>.</p>
    ///                 </note>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NO_ARTIFACTS</code>: The build project does not produce any build
    ///                     output.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>S3</code>: The build project stores build output in Amazon S3.</p>
    ///             </li>
    ///          </ul>
    public let type: ArtifactsType?

    public init (
        artifactIdentifier: String? = nil,
        bucketOwnerAccess: BucketOwnerAccess? = nil,
        encryptionDisabled: Bool? = nil,
        location: String? = nil,
        name: String? = nil,
        namespaceType: ArtifactNamespace? = nil,
        overrideArtifactName: Bool? = nil,
        packaging: ArtifactPackaging? = nil,
        path: String? = nil,
        type: ArtifactsType? = nil
    )
    {
        self.artifactIdentifier = artifactIdentifier
        self.bucketOwnerAccess = bucketOwnerAccess
        self.encryptionDisabled = encryptionDisabled
        self.location = location
        self.name = name
        self.namespaceType = namespaceType
        self.overrideArtifactName = overrideArtifactName
        self.packaging = packaging
        self.path = path
        self.type = type
    }
}

extension ProjectBadge: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case badgeEnabled
        case badgeRequestUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if badgeEnabled != false {
            try encodeContainer.encode(badgeEnabled, forKey: .badgeEnabled)
        }
        if let badgeRequestUrl = badgeRequestUrl {
            try encodeContainer.encode(badgeRequestUrl, forKey: .badgeRequestUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let badgeEnabledDecoded = try containerValues.decode(Bool.self, forKey: .badgeEnabled)
        badgeEnabled = badgeEnabledDecoded
        let badgeRequestUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .badgeRequestUrl)
        badgeRequestUrl = badgeRequestUrlDecoded
    }
}

extension ProjectBadge: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectBadge(badgeEnabled: \(String(describing: badgeEnabled)), badgeRequestUrl: \(String(describing: badgeRequestUrl)))"}
}

/// <p>Information about the build badge for the build project.</p>
public struct ProjectBadge: Equatable {
    /// <p>Set this to true to generate a publicly accessible URL for your project's build
    ///             badge.</p>
    public let badgeEnabled: Bool
    /// <p>The publicly-accessible URL through which you can access the build badge for your
    ///             project. </p>
    public let badgeRequestUrl: String?

    public init (
        badgeEnabled: Bool = false,
        badgeRequestUrl: String? = nil
    )
    {
        self.badgeEnabled = badgeEnabled
        self.badgeRequestUrl = badgeRequestUrl
    }
}

extension ProjectBuildBatchConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case combineArtifacts
        case restrictions
        case serviceRole
        case timeoutInMins
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let combineArtifacts = combineArtifacts {
            try encodeContainer.encode(combineArtifacts, forKey: .combineArtifacts)
        }
        if let restrictions = restrictions {
            try encodeContainer.encode(restrictions, forKey: .restrictions)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let timeoutInMins = timeoutInMins {
            try encodeContainer.encode(timeoutInMins, forKey: .timeoutInMins)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let combineArtifactsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .combineArtifacts)
        combineArtifacts = combineArtifactsDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(BatchRestrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let timeoutInMinsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInMins)
        timeoutInMins = timeoutInMinsDecoded
    }
}

extension ProjectBuildBatchConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectBuildBatchConfig(combineArtifacts: \(String(describing: combineArtifacts)), restrictions: \(String(describing: restrictions)), serviceRole: \(String(describing: serviceRole)), timeoutInMins: \(String(describing: timeoutInMins)))"}
}

/// <p>Contains configuration information about a batch build project.</p>
public struct ProjectBuildBatchConfig: Equatable {
    /// <p>Specifies if the build artifacts for the batch build should be combined into a single
    ///             artifact location.</p>
    public let combineArtifacts: Bool?
    /// <p>A <code>BatchRestrictions</code> object that specifies the restrictions for the batch
    ///             build.</p>
    public let restrictions: BatchRestrictions?
    /// <p>Specifies the service role ARN for the batch build project.</p>
    public let serviceRole: String?
    /// <p>Specifies the maximum amount of time, in minutes, that the batch build must be completed in.</p>
    public let timeoutInMins: Int?

    public init (
        combineArtifacts: Bool? = nil,
        restrictions: BatchRestrictions? = nil,
        serviceRole: String? = nil,
        timeoutInMins: Int? = nil
    )
    {
        self.combineArtifacts = combineArtifacts
        self.restrictions = restrictions
        self.serviceRole = serviceRole
        self.timeoutInMins = timeoutInMins
    }
}

extension ProjectCache: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case location
        case modes
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let modes = modes {
            var modesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modes)
            for projectcachemodes0 in modes {
                try modesContainer.encode(projectcachemodes0.rawValue)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CacheType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let modesContainer = try containerValues.decodeIfPresent([CacheMode?].self, forKey: .modes)
        var modesDecoded0:[CacheMode]? = nil
        if let modesContainer = modesContainer {
            modesDecoded0 = [CacheMode]()
            for string0 in modesContainer {
                if let string0 = string0 {
                    modesDecoded0?.append(string0)
                }
            }
        }
        modes = modesDecoded0
    }
}

extension ProjectCache: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectCache(location: \(String(describing: location)), modes: \(String(describing: modes)), type: \(String(describing: type)))"}
}

/// <p>Information about the cache for the build project.</p>
public struct ProjectCache: Equatable {
    /// <p>Information about the cache location: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>NO_CACHE</code> or <code>LOCAL</code>: This value is ignored.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>S3</code>: This is the S3 bucket name/prefix.</p>
    ///             </li>
    ///          </ul>
    public let location: String?
    /// <p>An array of strings that specify the local cache modes. You can use one or more local
    ///             cache modes at the same time. This is only used for <code>LOCAL</code> cache
    ///             types.</p>
    ///         <p>Possible values are:</p>
    ///         <dl>
    ///             <dt>LOCAL_SOURCE_CACHE</dt>
    ///             <dd>
    ///                     <p>Caches Git metadata for primary and secondary sources. After the cache is
    ///                         created, subsequent builds pull only the change between commits. This mode
    ///                         is a good choice for projects with a clean working directory and a source
    ///                         that is a large Git repository. If you choose this option and your project
    ///                         does not use a Git repository (GitHub, GitHub Enterprise, or Bitbucket), the
    ///                         option is ignored. </p>
    ///                 </dd>
    ///             <dt>LOCAL_DOCKER_LAYER_CACHE</dt>
    ///             <dd>
    ///                     <p>Caches existing Docker layers. This mode is a good choice for projects
    ///                         that build or pull large Docker images. It can prevent the performance
    ///                         issues caused by pulling large Docker images down from the network. </p>
    ///                     <note>
    ///                         <ul>
    ///                      <li>
    ///                                 <p>You can use a Docker layer cache in the Linux environment
    ///                                     only. </p>
    ///                             </li>
    ///                      <li>
    ///                                 <p>The <code>privileged</code> flag must be set so that your
    ///                                     project has the required Docker permissions. </p>
    ///                             </li>
    ///                      <li>
    ///                                 <p>You should consider the security implications before you use a
    ///                                     Docker layer cache. </p>
    ///                             </li>
    ///                   </ul>
    ///                     </note>
    ///                 </dd>
    ///             <dt>LOCAL_CUSTOM_CACHE</dt>
    ///             <dd>
    ///                     <p>Caches directories you specify in the buildspec file. This mode is a good
    ///                         choice if your build scenario is not suited to one of the other three local
    ///                         cache modes. If you use a custom cache: </p>
    ///                     <ul>
    ///                   <li>
    ///                             <p>Only directories can be specified for caching. You cannot specify
    ///                                 individual files. </p>
    ///                         </li>
    ///                   <li>
    ///                             <p>Symlinks are used to reference cached directories. </p>
    ///                         </li>
    ///                   <li>
    ///                             <p>Cached directories are linked to your build before it downloads
    ///                                 its project sources. Cached items are overridden if a source item
    ///                                 has the same name. Directories are specified using cache paths in
    ///                                 the buildspec file. </p>
    ///                         </li>
    ///                </ul>
    ///                 </dd>
    ///          </dl>
    public let modes: [CacheMode]?
    /// <p>The type of cache used by the build project. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>NO_CACHE</code>: The build project does not use any cache.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>S3</code>: The build project reads and writes from and to S3.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>LOCAL</code>: The build project stores a cache locally on a build host
    ///                     that is only available to that build host.</p>
    ///             </li>
    ///          </ul>
    public let type: CacheType?

    public init (
        location: String? = nil,
        modes: [CacheMode]? = nil,
        type: CacheType? = nil
    )
    {
        self.location = location
        self.modes = modes
        self.type = type
    }
}

extension ProjectEnvironment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate
        case computeType
        case environmentVariables
        case image
        case imagePullCredentialsType
        case privilegedMode
        case registryCredential
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let computeType = computeType {
            try encodeContainer.encode(computeType.rawValue, forKey: .computeType)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentVariables)
            for environmentvariables0 in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariables0)
            }
        }
        if let image = image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let imagePullCredentialsType = imagePullCredentialsType {
            try encodeContainer.encode(imagePullCredentialsType.rawValue, forKey: .imagePullCredentialsType)
        }
        if let privilegedMode = privilegedMode {
            try encodeContainer.encode(privilegedMode, forKey: .privilegedMode)
        }
        if let registryCredential = registryCredential {
            try encodeContainer.encode(registryCredential, forKey: .registryCredential)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EnvironmentType.self, forKey: .type)
        type = typeDecoded
        let imageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .image)
        image = imageDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([EnvironmentVariable?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0:[EnvironmentVariable]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [EnvironmentVariable]()
            for structure0 in environmentVariablesContainer {
                if let structure0 = structure0 {
                    environmentVariablesDecoded0?.append(structure0)
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let privilegedModeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .privilegedMode)
        privilegedMode = privilegedModeDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let registryCredentialDecoded = try containerValues.decodeIfPresent(RegistryCredential.self, forKey: .registryCredential)
        registryCredential = registryCredentialDecoded
        let imagePullCredentialsTypeDecoded = try containerValues.decodeIfPresent(ImagePullCredentialsType.self, forKey: .imagePullCredentialsType)
        imagePullCredentialsType = imagePullCredentialsTypeDecoded
    }
}

extension ProjectEnvironment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectEnvironment(certificate: \(String(describing: certificate)), computeType: \(String(describing: computeType)), environmentVariables: \(String(describing: environmentVariables)), image: \(String(describing: image)), imagePullCredentialsType: \(String(describing: imagePullCredentialsType)), privilegedMode: \(String(describing: privilegedMode)), registryCredential: \(String(describing: registryCredential)), type: \(String(describing: type)))"}
}

/// <p>Information about the build environment of the build project.</p>
public struct ProjectEnvironment: Equatable {
    /// <p>The ARN of the Amazon S3 bucket, path prefix, and object key that contains the PEM-encoded
    ///             certificate for the build project. For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/create-project-cli.html#cli.environment.certificate">certificate</a> in the
    ///                 <i>AWS CodeBuild User Guide</i>.</p>
    public let certificate: String?
    /// <p>Information about the compute resources the build project uses. Available values
    ///             include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>BUILD_GENERAL1_SMALL</code>: Use up to 3 GB memory and 2 vCPUs for
    ///                     builds.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>BUILD_GENERAL1_MEDIUM</code>: Use up to 7 GB memory and 4 vCPUs for
    ///                     builds.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>BUILD_GENERAL1_LARGE</code>: Use up to 16 GB memory and 8 vCPUs for
    ///                     builds, depending on your environment type.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>BUILD_GENERAL1_2XLARGE</code>: Use up to 145 GB memory, 72 vCPUs, and
    ///                     824 GB of SSD storage for builds. This compute type supports Docker images up to
    ///                     100 GB uncompressed.</p>
    ///             </li>
    ///          </ul>
    ///         <p> If you use <code>BUILD_GENERAL1_LARGE</code>: </p>
    ///         <ul>
    ///             <li>
    ///                 <p> For environment type <code>LINUX_CONTAINER</code>, you can use up to 15 GB
    ///                     memory and 8 vCPUs for builds. </p>
    ///             </li>
    ///             <li>
    ///                 <p> For environment type <code>LINUX_GPU_CONTAINER</code>, you can use up to 255
    ///                     GB memory, 32 vCPUs, and 4 NVIDIA Tesla V100 GPUs for builds.</p>
    ///             </li>
    ///             <li>
    ///                 <p> For environment type <code>ARM_CONTAINER</code>, you can use up to 16 GB
    ///                     memory and 8 vCPUs on ARM-based processors for builds.</p>
    ///             </li>
    ///          </ul>
    ///         <p> For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html">Build Environment
    ///                 Compute Types</a> in the <i>AWS CodeBuild User Guide.</i>
    ///         </p>
    public let computeType: ComputeType?
    /// <p>A set of environment variables to make available to builds for this build
    ///             project.</p>
    public let environmentVariables: [EnvironmentVariable]?
    /// <p>The image tag or image digest that identifies the Docker image to use for this build
    ///             project. Use the following formats:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For an image tag: <code><registry>/<repository>:<tag></code>. For
    ///                     example, in the Docker repository that CodeBuild uses to manage its Docker
    ///                     images, this would be <code>aws/codebuild/standard:4.0</code>. </p>
    ///             </li>
    ///             <li>
    ///                 <p>For an image digest: <code><registry>/<repository>@<digest></code>.
    ///                     For example, to specify an image with the digest
    ///                     "sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf," use
    ///                         <code><registry>/<repository>@sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf</code>.</p>
    ///             </li>
    ///          </ul>
    public let image: String?
    /// <p> The type of credentials AWS CodeBuild uses to pull images in your build. There are two valid
    ///             values: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>CODEBUILD</code> specifies that AWS CodeBuild uses its own credentials.
    ///                     This requires that you modify your ECR repository policy to trust AWS
    ///                     CodeBuild's service principal. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>SERVICE_ROLE</code> specifies that AWS CodeBuild uses your build project's service
    ///                     role. </p>
    ///             </li>
    ///          </ul>
    ///         <p> When you use a cross-account or private registry image, you must use SERVICE_ROLE
    ///             credentials. When you use an AWS CodeBuild curated image, you must use CODEBUILD credentials.
    ///         </p>
    public let imagePullCredentialsType: ImagePullCredentialsType?
    /// <p>Enables running the Docker daemon inside a Docker container. Set to true only if the
    ///             build project is used to build Docker images. Otherwise, a build that attempts to
    ///             interact with the Docker daemon fails. The default setting is <code>false</code>.</p>
    ///         <p>You can initialize the Docker daemon during the install phase of your build by adding
    ///             one of the following sets of commands to the install phase of your buildspec
    ///             file:</p>
    ///         <p>If the operating system's base image is Ubuntu Linux:</p>
    ///         <p>
    ///             <code>- nohup /usr/local/bin/dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 --storage-driver=overlay&</code>
    ///         </p>
    ///         <p>
    ///             <code>- timeout 15 sh -c "until docker info; do echo .; sleep 1; done"</code>
    ///         </p>
    ///         <p>If the operating system's base image is Alpine Linux and the previous command does not
    ///             work, add the <code>-t</code> argument to <code>timeout</code>:</p>
    ///         <p>
    ///             <code>- nohup /usr/local/bin/dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 --storage-driver=overlay&</code>
    ///          </p>
    ///         <p>
    ///             <code>- timeout -t 15 sh -c "until docker info; do echo .; sleep 1; done"</code>
    ///         </p>
    public let privilegedMode: Bool?
    /// <p> The credentials for access to a private registry.</p>
    public let registryCredential: RegistryCredential?
    /// <p>The type of build environment to use for related builds.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The environment type <code>ARM_CONTAINER</code> is available only in regions
    ///                     US East (N. Virginia), US East (Ohio), US West (Oregon), EU (Ireland),
    ///                     Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and
    ///                     EU (Frankfurt).</p>
    ///             </li>
    ///             <li>
    ///                 <p>The environment type <code>LINUX_CONTAINER</code> with compute type
    ///                         <code>build.general1.2xlarge</code> is available only in regions
    ///                     US East (N. Virginia), US East (Ohio), US West (Oregon),
    ///                     Canada (Central), EU (Ireland), EU (London),
    ///                     EU (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul),
    ///                     Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and
    ///                     China (Ningxia).</p>
    ///             </li>
    ///             <li>
    ///                 <p>The environment type <code>LINUX_GPU_CONTAINER</code> is available only in
    ///                     regions US East (N. Virginia), US East (Ohio), US West (Oregon),
    ///                     Canada (Central), EU (Ireland), EU (London),
    ///                     EU (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul),
    ///                     Asia Pacific (Singapore), Asia Pacific (Sydney) , China (Beijing), and
    ///                     China (Ningxia).</p>
    ///             </li>
    ///          </ul>
    public let type: EnvironmentType?

    public init (
        certificate: String? = nil,
        computeType: ComputeType? = nil,
        environmentVariables: [EnvironmentVariable]? = nil,
        image: String? = nil,
        imagePullCredentialsType: ImagePullCredentialsType? = nil,
        privilegedMode: Bool? = nil,
        registryCredential: RegistryCredential? = nil,
        type: EnvironmentType? = nil
    )
    {
        self.certificate = certificate
        self.computeType = computeType
        self.environmentVariables = environmentVariables
        self.image = image
        self.imagePullCredentialsType = imagePullCredentialsType
        self.privilegedMode = privilegedMode
        self.registryCredential = registryCredential
        self.type = type
    }
}

extension ProjectFileSystemLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identifier
        case location
        case mountOptions
        case mountPoint
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let mountOptions = mountOptions {
            try encodeContainer.encode(mountOptions, forKey: .mountOptions)
        }
        if let mountPoint = mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FileSystemType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let mountOptionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mountOptions)
        mountOptions = mountOptionsDecoded
    }
}

extension ProjectFileSystemLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectFileSystemLocation(identifier: \(String(describing: identifier)), location: \(String(describing: location)), mountOptions: \(String(describing: mountOptions)), mountPoint: \(String(describing: mountPoint)), type: \(String(describing: type)))"}
}

/// <p> Information about a file system created by Amazon Elastic File System (EFS). For more
///             information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html">What Is
///                 Amazon Elastic File System?</a>
///         </p>
public struct ProjectFileSystemLocation: Equatable {
    /// <p>The name used to access a file system created by Amazon EFS. CodeBuild creates an
    ///             environment variable by appending the <code>identifier</code> in all capital letters to
    ///                 <code>CODEBUILD_</code>. For example, if you specify <code>my_efs</code> for
    ///                 <code>identifier</code>, a new environment variable is create named
    ///                 <code>CODEBUILD_MY_EFS</code>. </p>
    ///         <p> The <code>identifier</code> is used to mount your file system. </p>
    public let identifier: String?
    /// <p>A string that specifies the location of the file system created by Amazon EFS. Its
    ///             format is <code>efs-dns-name:/directory-path</code>. You can find the DNS name of file
    ///             system when you view it in the AWS EFS console. The directory path is a path to a
    ///             directory in the file system that CodeBuild mounts. For example, if the DNS name of a
    ///             file system is <code>fs-abcd1234.efs.us-west-2.amazonaws.com</code>, and its mount
    ///             directory is <code>my-efs-mount-directory</code>, then the <code>location</code> is
    ///                 <code>fs-abcd1234.efs.us-west-2.amazonaws.com:/my-efs-mount-directory</code>. </p>
    ///         <p>The directory path in the format <code>efs-dns-name:/directory-path</code> is
    ///             optional. If you do not specify a directory path, the location is only the DNS name and
    ///             CodeBuild mounts the entire file system. </p>
    public let location: String?
    /// <p> The mount options for a file system created by AWS EFS. The default mount options
    ///             used by CodeBuild are
    ///                 <code>nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2</code>. For
    ///             more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/mounting-fs-nfs-mount-settings.html">Recommended NFS Mount
    ///                 Options</a>. </p>
    public let mountOptions: String?
    /// <p>The location in the container where you mount the file system. </p>
    public let mountPoint: String?
    /// <p> The type of the file system. The one supported type is <code>EFS</code>. </p>
    public let type: FileSystemType?

    public init (
        identifier: String? = nil,
        location: String? = nil,
        mountOptions: String? = nil,
        mountPoint: String? = nil,
        type: FileSystemType? = nil
    )
    {
        self.identifier = identifier
        self.location = location
        self.mountOptions = mountOptions
        self.mountPoint = mountPoint
        self.type = type
    }
}

public enum ProjectSortByType {
    case createdTime
    case lastModifiedTime
    case name
    case sdkUnknown(String)
}

extension ProjectSortByType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProjectSortByType] {
        return [
            .createdTime,
            .lastModifiedTime,
            .name,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createdTime: return "CREATED_TIME"
        case .lastModifiedTime: return "LAST_MODIFIED_TIME"
        case .name: return "NAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProjectSortByType(rawValue: rawValue) ?? ProjectSortByType.sdkUnknown(rawValue)
    }
}

extension ProjectSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auth
        case buildStatusConfig
        case buildspec
        case gitCloneDepth
        case gitSubmodulesConfig
        case insecureSsl
        case location
        case reportBuildStatus
        case sourceIdentifier
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auth = auth {
            try encodeContainer.encode(auth, forKey: .auth)
        }
        if let buildStatusConfig = buildStatusConfig {
            try encodeContainer.encode(buildStatusConfig, forKey: .buildStatusConfig)
        }
        if let buildspec = buildspec {
            try encodeContainer.encode(buildspec, forKey: .buildspec)
        }
        if let gitCloneDepth = gitCloneDepth {
            try encodeContainer.encode(gitCloneDepth, forKey: .gitCloneDepth)
        }
        if let gitSubmodulesConfig = gitSubmodulesConfig {
            try encodeContainer.encode(gitSubmodulesConfig, forKey: .gitSubmodulesConfig)
        }
        if let insecureSsl = insecureSsl {
            try encodeContainer.encode(insecureSsl, forKey: .insecureSsl)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let reportBuildStatus = reportBuildStatus {
            try encodeContainer.encode(reportBuildStatus, forKey: .reportBuildStatus)
        }
        if let sourceIdentifier = sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let gitCloneDepthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .gitCloneDepth)
        gitCloneDepth = gitCloneDepthDecoded
        let gitSubmodulesConfigDecoded = try containerValues.decodeIfPresent(GitSubmodulesConfig.self, forKey: .gitSubmodulesConfig)
        gitSubmodulesConfig = gitSubmodulesConfigDecoded
        let buildspecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildspec)
        buildspec = buildspecDecoded
        let authDecoded = try containerValues.decodeIfPresent(SourceAuth.self, forKey: .auth)
        auth = authDecoded
        let reportBuildStatusDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .reportBuildStatus)
        reportBuildStatus = reportBuildStatusDecoded
        let buildStatusConfigDecoded = try containerValues.decodeIfPresent(BuildStatusConfig.self, forKey: .buildStatusConfig)
        buildStatusConfig = buildStatusConfigDecoded
        let insecureSslDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .insecureSsl)
        insecureSsl = insecureSslDecoded
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
    }
}

extension ProjectSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectSource(auth: \(String(describing: auth)), buildStatusConfig: \(String(describing: buildStatusConfig)), buildspec: \(String(describing: buildspec)), gitCloneDepth: \(String(describing: gitCloneDepth)), gitSubmodulesConfig: \(String(describing: gitSubmodulesConfig)), insecureSsl: \(String(describing: insecureSsl)), location: \(String(describing: location)), reportBuildStatus: \(String(describing: reportBuildStatus)), sourceIdentifier: \(String(describing: sourceIdentifier)), type: \(String(describing: type)))"}
}

/// <p>Information about the build input source code for the build project.</p>
public struct ProjectSource: Equatable {
    /// <p>Information about the authorization settings for AWS CodeBuild to access the source code to be
    ///             built.</p>
    ///         <p>This information is for the AWS CodeBuild console's use only. Your code should not get or set
    ///             this information directly.</p>
    public let auth: SourceAuth?
    /// <p>Contains information that defines how the build project reports the build status to
    ///             the source provider. This option is only used when the source provider is
    ///                 <code>GITHUB</code>, <code>GITHUB_ENTERPRISE</code>, or
    ///             <code>BITBUCKET</code>.</p>
    public let buildStatusConfig: BuildStatusConfig?
    /// <p>The buildspec file declaration to use for the builds in this build project.</p>
    ///         <p> If this value is set, it can be either an inline buildspec definition, the path to an
    ///             alternate buildspec file relative to the value of the built-in
    ///                 <code>CODEBUILD_SRC_DIR</code> environment variable, or the path to an S3 bucket.
    ///             The bucket must be in the same AWS Region as the build project. Specify the buildspec
    ///             file using its ARN (for example,
    ///                 <code>arn:aws:s3:::my-codebuild-sample2/buildspec.yml</code>). If this value is not
    ///             provided or is set to an empty string, the source code must contain a buildspec file in
    ///             its root directory. For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-name-storage">Buildspec File Name and Storage Location</a>. </p>
    public let buildspec: String?
    /// <p>Information about the Git clone depth for the build project.</p>
    public let gitCloneDepth: Int?
    /// <p> Information about the Git submodules configuration for the build project. </p>
    public let gitSubmodulesConfig: GitSubmodulesConfig?
    /// <p>Enable this flag to ignore SSL warnings while connecting to the project source
    ///           code.</p>
    public let insecureSsl: Bool?
    /// <p>Information about the location of the source code to be built. Valid values
    ///             include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For source code settings that are specified in the source action of a pipeline
    ///                     in AWS CodePipeline, <code>location</code> should not be specified. If it is specified,
    ///                     AWS CodePipeline ignores it. This is because AWS CodePipeline uses the settings in a pipeline's source
    ///                     action instead of this value.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository
    ///                     that contains the source code and the buildspec file (for example,
    ///                         <code>https://git-codecommit.<region-ID>.amazonaws.com/v1/repos/<repo-name></code>).</p>
    ///             </li>
    ///             <li>
    ///                 <p>For source code in an Amazon S3 input bucket, one of the following. </p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>The path to the ZIP file that contains the source code (for example,
    ///                                 <code><bucket-name>/<path>/<object-name>.zip</code>). </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The path to the folder that contains the source code (for example,
    ///                                 <code><bucket-name>/<path-to-source-code>/<folder>/</code>). </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>For source code in a GitHub repository, the HTTPS clone URL to the repository
    ///                     that contains the source and the buildspec file. You must connect your AWS
    ///                     account to your GitHub account. Use the AWS CodeBuild console to start creating a build
    ///                     project. When you use the console to connect (or reconnect) with GitHub, on the
    ///                     GitHub <b>Authorize application</b> page, for
    ///                         <b>Organization access</b>, choose <b>Request access</b> next to each repository you want to
    ///                     allow AWS CodeBuild to have access to, and then choose <b>Authorize
    ///                         application</b>. (After you have connected to your GitHub account,
    ///                     you do not need to finish creating the build project. You can leave the AWS CodeBuild
    ///                     console.) To instruct AWS CodeBuild to use this connection, in the <code>source</code>
    ///                     object, set the <code>auth</code> object's <code>type</code> value to
    ///                         <code>OAUTH</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For source code in a Bitbucket repository, the HTTPS clone URL to the
    ///                     repository that contains the source and the buildspec file. You must connect
    ///                     your AWS account to your Bitbucket account. Use the AWS CodeBuild console to start
    ///                     creating a build project. When you use the console to connect (or reconnect)
    ///                     with Bitbucket, on the Bitbucket <b>Confirm access to your
    ///                         account</b> page, choose <b>Grant
    ///                         access</b>. (After you have connected to your Bitbucket account, you
    ///                     do not need to finish creating the build project. You can leave the AWS CodeBuild
    ///                     console.) To instruct AWS CodeBuild to use this connection, in the <code>source</code>
    ///                     object, set the <code>auth</code> object's <code>type</code> value to
    ///                         <code>OAUTH</code>.</p>
    ///             </li>
    ///          </ul>
    public let location: String?
    /// <p> Set to true to report the status of a build's start and finish to your source
    ///             provider. This option is valid only when your source provider is GitHub, GitHub
    ///             Enterprise, or Bitbucket. If this is set and you use a different source provider, an
    ///             <code>invalidInputException</code> is thrown. </p>
    ///             <p>To be able to report the build status to the source provider, the user associated with the source provider must
    /// have write access to the repo. If the user does not have write access, the build status cannot be updated. For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/access-tokens.html">Source provider access</a> in the <i>AWS CodeBuild User Guide</i>.</p>
    ///         <note>
    ///             <p> The status of a build triggered by a webhook is always reported to your source
    ///                 provider. </p>
    ///         </note>
    public let reportBuildStatus: Bool?
    /// <p>An identifier for this project source. The identifier can only contain
    ///           alphanumeric characters and underscores, and must be less than 128 characters in length. </p>
    public let sourceIdentifier: String?
    /// <p>The type of repository that contains the source code to be built. Valid values
    ///             include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>BITBUCKET</code>: The source code is in a Bitbucket repository.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CODEPIPELINE</code>: The source code settings are specified in the
    ///                     source action of a pipeline in AWS CodePipeline.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>GITHUB</code>: The source code is in a GitHub or GitHub Enterprise Cloud
    ///                     repository.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>GITHUB_ENTERPRISE</code>: The source code is in a GitHub Enterprise
    ///                     Server repository.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NO_SOURCE</code>: The project does not have input source code.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>S3</code>: The source code is in an Amazon S3 bucket.</p>
    ///             </li>
    ///          </ul>
    public let type: SourceType?

    public init (
        auth: SourceAuth? = nil,
        buildStatusConfig: BuildStatusConfig? = nil,
        buildspec: String? = nil,
        gitCloneDepth: Int? = nil,
        gitSubmodulesConfig: GitSubmodulesConfig? = nil,
        insecureSsl: Bool? = nil,
        location: String? = nil,
        reportBuildStatus: Bool? = nil,
        sourceIdentifier: String? = nil,
        type: SourceType? = nil
    )
    {
        self.auth = auth
        self.buildStatusConfig = buildStatusConfig
        self.buildspec = buildspec
        self.gitCloneDepth = gitCloneDepth
        self.gitSubmodulesConfig = gitSubmodulesConfig
        self.insecureSsl = insecureSsl
        self.location = location
        self.reportBuildStatus = reportBuildStatus
        self.sourceIdentifier = sourceIdentifier
        self.type = type
    }
}

extension ProjectSourceVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceIdentifier
        case sourceVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceIdentifier = sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

extension ProjectSourceVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectSourceVersion(sourceIdentifier: \(String(describing: sourceIdentifier)), sourceVersion: \(String(describing: sourceVersion)))"}
}

/// <p> A source identifier and its corresponding version. </p>
public struct ProjectSourceVersion: Equatable {
    /// <p>An identifier for a source in the build project. The identifier can only contain
    ///             alphanumeric characters and underscores, and must be less than 128 characters in length. </p>
    public let sourceIdentifier: String?
    /// <p>The source version for the corresponding source identifier. If specified, must be one
    ///           of:</p>
    ///          <ul>
    ///             <li>
    ///               <p>For AWS CodeCommit: the commit ID, branch, or Git tag to use.</p>
    ///             </li>
    ///             <li>
    ///               <p>For GitHub: the commit ID, pull request ID, branch name, or tag name that
    ///                   corresponds to the version of the source code you want to build. If a pull
    ///                   request ID is specified, it must use the format <code>pr/pull-request-ID</code>
    ///                   (for example, <code>pr/25</code>). If a branch name is specified, the branch's
    ///                   HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is
    ///                   used.</p>
    ///             </li>
    ///             <li>
    ///               <p>For Bitbucket: the commit ID, branch name, or tag name that corresponds to the
    ///                   version of the source code you want to build. If a branch name is specified, the
    ///                   branch's HEAD commit ID is used. If not specified, the default branch's HEAD
    ///                   commit ID is used.</p>
    ///             </li>
    ///             <li>
    ///               <p>For Amazon S3: the version ID of the object that represents the build input ZIP
    ///                   file to use.</p>
    ///             </li>
    ///          </ul>
    ///          <p> For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html">Source Version Sample
    ///               with CodeBuild</a> in the <i>AWS CodeBuild User Guide</i>. </p>
    public let sourceVersion: String?

    public init (
        sourceIdentifier: String? = nil,
        sourceVersion: String? = nil
    )
    {
        self.sourceIdentifier = sourceIdentifier
        self.sourceVersion = sourceVersion
    }
}

public struct PutResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

extension PutResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyInput(policy: \(String(describing: policy)), resourceArn: \(String(describing: resourceArn)))"}
}

extension PutResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct PutResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInput: Equatable {
    /// <p> A JSON-formatted resource policy. For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/project-sharing.html#project-sharing-share">Sharing
    ///                 a Project</a> and <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/report-groups-sharing.html#report-groups-sharing-share">Sharing a Report Group</a> in the <i>AWS CodeBuild User Guide</i>.
    ///         </p>
    public let policy: String?
    /// <p> The ARN of the <code>Project</code> or <code>ReportGroup</code> resource you want to
    ///             associate with a resource policy. </p>
    public let resourceArn: String?

    public init (
        policy: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Equatable {
    public let policy: String?
    public let resourceArn: String?
}

extension PutResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension PutResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourcePolicyOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyOutputResponse(resourceArn: \(String(describing: resourceArn)))"}
}

extension PutResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceArn = output.resourceArn
        } else {
            self.resourceArn = nil
        }
    }
}

public struct PutResourcePolicyOutputResponse: Equatable {
    /// <p> The ARN of the <code>Project</code> or <code>ReportGroup</code> resource that is
    ///             associated with a resource policy. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyOutputResponseBody: Equatable {
    public let resourceArn: String?
}

extension PutResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension RegistryCredential: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case credential
        case credentialProvider
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credential = credential {
            try encodeContainer.encode(credential, forKey: .credential)
        }
        if let credentialProvider = credentialProvider {
            try encodeContainer.encode(credentialProvider.rawValue, forKey: .credentialProvider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credential)
        credential = credentialDecoded
        let credentialProviderDecoded = try containerValues.decodeIfPresent(CredentialProviderType.self, forKey: .credentialProvider)
        credentialProvider = credentialProviderDecoded
    }
}

extension RegistryCredential: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegistryCredential(credential: \(String(describing: credential)), credentialProvider: \(String(describing: credentialProvider)))"}
}

/// <p> Information about credentials that provide access to a private Docker registry. When
///             this is set: </p>
///         <ul>
///             <li>
///                 <p>
///                     <code>imagePullCredentialsType</code> must be set to <code>SERVICE_ROLE</code>.
///                 </p>
///             </li>
///             <li>
///                 <p> images cannot be curated or an Amazon ECR image.</p>
///             </li>
///          </ul>
///         <p> For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/sample-private-registry.html">Private Registry with
///                 AWS Secrets Manager Sample for AWS CodeBuild</a>. </p>
public struct RegistryCredential: Equatable {
    /// <p> The Amazon Resource Name (ARN) or name of credentials created using AWS Secrets Manager. </p>
    ///         <note>
    ///             <p> The <code>credential</code> can use the name of the credentials only if they
    ///                 exist in your current AWS Region. </p>
    ///         </note>
    public let credential: String?
    /// <p> The service that created the credentials to access a private Docker registry. The
    ///             valid value, SECRETS_MANAGER, is for AWS Secrets Manager. </p>
    public let credentialProvider: CredentialProviderType?

    public init (
        credential: String? = nil,
        credentialProvider: CredentialProviderType? = nil
    )
    {
        self.credential = credential
        self.credentialProvider = credentialProvider
    }
}

extension Report: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case codeCoverageSummary
        case created
        case executionId
        case expired
        case exportConfig
        case name
        case reportGroupArn
        case status
        case testSummary
        case truncated
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let codeCoverageSummary = codeCoverageSummary {
            try encodeContainer.encode(codeCoverageSummary, forKey: .codeCoverageSummary)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let expired = expired {
            try encodeContainer.encode(expired.timeIntervalSince1970, forKey: .expired)
        }
        if let exportConfig = exportConfig {
            try encodeContainer.encode(exportConfig, forKey: .exportConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reportGroupArn = reportGroupArn {
            try encodeContainer.encode(reportGroupArn, forKey: .reportGroupArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let testSummary = testSummary {
            try encodeContainer.encode(testSummary, forKey: .testSummary)
        }
        if let truncated = truncated {
            try encodeContainer.encode(truncated, forKey: .truncated)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ReportType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let reportGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportGroupArn)
        reportGroupArn = reportGroupArnDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ReportStatusType.self, forKey: .status)
        status = statusDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let expiredDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expired)
        expired = expiredDecoded
        let exportConfigDecoded = try containerValues.decodeIfPresent(ReportExportConfig.self, forKey: .exportConfig)
        exportConfig = exportConfigDecoded
        let truncatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
        let testSummaryDecoded = try containerValues.decodeIfPresent(TestReportSummary.self, forKey: .testSummary)
        testSummary = testSummaryDecoded
        let codeCoverageSummaryDecoded = try containerValues.decodeIfPresent(CodeCoverageReportSummary.self, forKey: .codeCoverageSummary)
        codeCoverageSummary = codeCoverageSummaryDecoded
    }
}

extension Report: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Report(arn: \(String(describing: arn)), codeCoverageSummary: \(String(describing: codeCoverageSummary)), created: \(String(describing: created)), executionId: \(String(describing: executionId)), expired: \(String(describing: expired)), exportConfig: \(String(describing: exportConfig)), name: \(String(describing: name)), reportGroupArn: \(String(describing: reportGroupArn)), status: \(String(describing: status)), testSummary: \(String(describing: testSummary)), truncated: \(String(describing: truncated)), type: \(String(describing: type)))"}
}

/// <p>Information about the results from running a series of test cases during the run of a
///             build project. The test cases are specified in the buildspec for the build project using
///             one or more paths to the test case files. You can specify any type of tests you want,
///             such as unit tests, integration tests, and functional tests. </p>
public struct Report: Equatable {
    /// <p> The ARN of the report run. </p>
    public let arn: String?
    /// <p>A <code>CodeCoverageReportSummary</code> object that contains a code coverage summary for
    ///             this report.</p>
    public let codeCoverageSummary: CodeCoverageReportSummary?
    /// <p> The date and time this report run occurred. </p>
    public let created: Date?
    /// <p> The ARN of the build run that generated this report. </p>
    public let executionId: String?
    /// <p> The date and time a report expires. A report expires 30 days after it is created. An
    ///       expired report is not available to view in CodeBuild. </p>
    public let expired: Date?
    /// <p> Information about where the raw data used to generate this report was exported.
    ///     </p>
    public let exportConfig: ReportExportConfig?
    /// <p> The name of the report that was run. </p>
    public let name: String?
    /// <p> The ARN of the report group associated with this report. </p>
    public let reportGroupArn: String?
    /// <p> The status of this report. </p>
    public let status: ReportStatusType?
    /// <p> A <code>TestReportSummary</code> object that contains information about this test
    ///       report. </p>
    public let testSummary: TestReportSummary?
    /// <p> A boolean that specifies if this report run is truncated. The list of test cases is
    ///       truncated after the maximum number of test cases is reached. </p>
    public let truncated: Bool?
    /// <p>The type of the report that was run.</p>
    ///          <dl>
    ///             <dt>CODE_COVERAGE</dt>
    ///             <dd>
    ///                <p>A code coverage report.</p>
    ///             </dd>
    ///             <dt>TEST</dt>
    ///             <dd>
    ///                <p>A test report.</p>
    ///             </dd>
    ///          </dl>
    public let type: ReportType?

    public init (
        arn: String? = nil,
        codeCoverageSummary: CodeCoverageReportSummary? = nil,
        created: Date? = nil,
        executionId: String? = nil,
        expired: Date? = nil,
        exportConfig: ReportExportConfig? = nil,
        name: String? = nil,
        reportGroupArn: String? = nil,
        status: ReportStatusType? = nil,
        testSummary: TestReportSummary? = nil,
        truncated: Bool? = nil,
        type: ReportType? = nil
    )
    {
        self.arn = arn
        self.codeCoverageSummary = codeCoverageSummary
        self.created = created
        self.executionId = executionId
        self.expired = expired
        self.exportConfig = exportConfig
        self.name = name
        self.reportGroupArn = reportGroupArn
        self.status = status
        self.testSummary = testSummary
        self.truncated = truncated
        self.type = type
    }
}

public enum ReportCodeCoverageSortByType {
    case filePath
    case lineCoveragePercentage
    case sdkUnknown(String)
}

extension ReportCodeCoverageSortByType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportCodeCoverageSortByType] {
        return [
            .filePath,
            .lineCoveragePercentage,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .filePath: return "FILE_PATH"
        case .lineCoveragePercentage: return "LINE_COVERAGE_PERCENTAGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportCodeCoverageSortByType(rawValue: rawValue) ?? ReportCodeCoverageSortByType.sdkUnknown(rawValue)
    }
}

extension ReportExportConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportConfigType
        case s3Destination
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportConfigType = exportConfigType {
            try encodeContainer.encode(exportConfigType.rawValue, forKey: .exportConfigType)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportConfigTypeDecoded = try containerValues.decodeIfPresent(ReportExportConfigType.self, forKey: .exportConfigType)
        exportConfigType = exportConfigTypeDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(S3ReportExportConfig.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension ReportExportConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportExportConfig(exportConfigType: \(String(describing: exportConfigType)), s3Destination: \(String(describing: s3Destination)))"}
}

/// <p> Information about the location where the run of a report is exported. </p>
public struct ReportExportConfig: Equatable {
    /// <p> The export configuration type. Valid values are: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>S3</code>: The report results are exported to an S3 bucket. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>NO_EXPORT</code>: The report results are not exported. </p>
    ///             </li>
    ///          </ul>
    public let exportConfigType: ReportExportConfigType?
    /// <p> A <code>S3ReportExportConfig</code> object that contains information about the S3
    ///             bucket where the run of a report is exported. </p>
    public let s3Destination: S3ReportExportConfig?

    public init (
        exportConfigType: ReportExportConfigType? = nil,
        s3Destination: S3ReportExportConfig? = nil
    )
    {
        self.exportConfigType = exportConfigType
        self.s3Destination = s3Destination
    }
}

public enum ReportExportConfigType {
    case noExport
    case s3
    case sdkUnknown(String)
}

extension ReportExportConfigType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportExportConfigType] {
        return [
            .noExport,
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .noExport: return "NO_EXPORT"
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportExportConfigType(rawValue: rawValue) ?? ReportExportConfigType.sdkUnknown(rawValue)
    }
}

extension ReportFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ReportStatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension ReportFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportFilter(status: \(String(describing: status)))"}
}

/// <p> A filter used to return reports with the status specified by the input
///                 <code>status</code> parameter. </p>
public struct ReportFilter: Equatable {
    /// <p> The status used to filter reports. You can filter using one status only. </p>
    public let status: ReportStatusType?

    public init (
        status: ReportStatusType? = nil
    )
    {
        self.status = status
    }
}

extension ReportGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case created
        case exportConfig
        case lastModified
        case name
        case status
        case tags
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let exportConfig = exportConfig {
            try encodeContainer.encode(exportConfig, forKey: .exportConfig)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ReportType.self, forKey: .type)
        type = typeDecoded
        let exportConfigDecoded = try containerValues.decodeIfPresent(ReportExportConfig.self, forKey: .exportConfig)
        exportConfig = exportConfigDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ReportGroupStatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension ReportGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportGroup(arn: \(String(describing: arn)), created: \(String(describing: created)), exportConfig: \(String(describing: exportConfig)), lastModified: \(String(describing: lastModified)), name: \(String(describing: name)), status: \(String(describing: status)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

/// <p>A series of reports. Each report contains information about the results from running a
///             series of test cases. You specify the test cases for a report group in the buildspec for
///             a build project using one or more paths to the test case files. </p>
public struct ReportGroup: Equatable {
    /// <p>The ARN of the <code>ReportGroup</code>.
    ///     </p>
    public let arn: String?
    /// <p>The date and time this <code>ReportGroup</code> was created. </p>
    public let created: Date?
    /// <p>Information about the destination where the raw data of this <code>ReportGroup</code>
    ///             is exported. </p>
    public let exportConfig: ReportExportConfig?
    /// <p>The date and time this <code>ReportGroup</code> was last modified. </p>
    public let lastModified: Date?
    /// <p>The name of the <code>ReportGroup</code>.
    ///     </p>
    public let name: String?
    /// <p>The status of the report group. This property is read-only.</p>
    ///          <p>This can be one of the following values:</p>
    ///          <dl>
    ///             <dt>ACTIVE</dt>
    ///             <dd>
    ///                <p>The report group is active.</p>
    ///             </dd>
    ///             <dt>DELETING</dt>
    ///             <dd>
    ///                <p>The report group is in the process of being deleted.</p>
    ///             </dd>
    ///          </dl>
    public let status: ReportGroupStatusType?
    /// <p>A list of tag key and value pairs associated with this report group. </p>
    ///         <p>These tags are available for use by AWS services that support AWS CodeBuild report group
    ///       tags.</p>
    public let tags: [Tag]?
    /// <p>The type of the <code>ReportGroup</code>. This can be one of the following
    ///             values:</p>
    ///          <dl>
    ///             <dt>CODE_COVERAGE</dt>
    ///             <dd>
    ///                <p>The report group contains code coverage reports.</p>
    ///             </dd>
    ///             <dt>TEST</dt>
    ///             <dd>
    ///                <p>The report group contains test reports.</p>
    ///             </dd>
    ///          </dl>
    public let type: ReportType?

    public init (
        arn: String? = nil,
        created: Date? = nil,
        exportConfig: ReportExportConfig? = nil,
        lastModified: Date? = nil,
        name: String? = nil,
        status: ReportGroupStatusType? = nil,
        tags: [Tag]? = nil,
        type: ReportType? = nil
    )
    {
        self.arn = arn
        self.created = created
        self.exportConfig = exportConfig
        self.lastModified = lastModified
        self.name = name
        self.status = status
        self.tags = tags
        self.type = type
    }
}

public enum ReportGroupSortByType {
    case createdTime
    case lastModifiedTime
    case name
    case sdkUnknown(String)
}

extension ReportGroupSortByType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportGroupSortByType] {
        return [
            .createdTime,
            .lastModifiedTime,
            .name,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createdTime: return "CREATED_TIME"
        case .lastModifiedTime: return "LAST_MODIFIED_TIME"
        case .name: return "NAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportGroupSortByType(rawValue: rawValue) ?? ReportGroupSortByType.sdkUnknown(rawValue)
    }
}

public enum ReportGroupStatusType {
    case active
    case deleting
    case sdkUnknown(String)
}

extension ReportGroupStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportGroupStatusType] {
        return [
            .active,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportGroupStatusType(rawValue: rawValue) ?? ReportGroupStatusType.sdkUnknown(rawValue)
    }
}

public enum ReportGroupTrendFieldType {
    case branchesCovered
    case branchesMissed
    case branchCoverage
    case duration
    case linesCovered
    case linesMissed
    case lineCoverage
    case passRate
    case total
    case sdkUnknown(String)
}

extension ReportGroupTrendFieldType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportGroupTrendFieldType] {
        return [
            .branchesCovered,
            .branchesMissed,
            .branchCoverage,
            .duration,
            .linesCovered,
            .linesMissed,
            .lineCoverage,
            .passRate,
            .total,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .branchesCovered: return "BRANCHES_COVERED"
        case .branchesMissed: return "BRANCHES_MISSED"
        case .branchCoverage: return "BRANCH_COVERAGE"
        case .duration: return "DURATION"
        case .linesCovered: return "LINES_COVERED"
        case .linesMissed: return "LINES_MISSED"
        case .lineCoverage: return "LINE_COVERAGE"
        case .passRate: return "PASS_RATE"
        case .total: return "TOTAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportGroupTrendFieldType(rawValue: rawValue) ?? ReportGroupTrendFieldType.sdkUnknown(rawValue)
    }
}

extension ReportGroupTrendStats: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case average
        case max
        case min
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let average = average {
            try encodeContainer.encode(average, forKey: .average)
        }
        if let max = max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = min {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let averageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .average)
        average = averageDecoded
        let maxDecoded = try containerValues.decodeIfPresent(String.self, forKey: .max)
        max = maxDecoded
        let minDecoded = try containerValues.decodeIfPresent(String.self, forKey: .min)
        min = minDecoded
    }
}

extension ReportGroupTrendStats: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportGroupTrendStats(average: \(String(describing: average)), max: \(String(describing: max)), min: \(String(describing: min)))"}
}

/// <p>Contains trend statistics for a set of reports. The actual values depend on the type of
///             trend being collected. For more information, see .</p>
public struct ReportGroupTrendStats: Equatable {
    /// <p>Contains the average of all values analyzed.</p>
    public let average: String?
    /// <p>Contains the maximum value analyzed.</p>
    public let max: String?
    /// <p>Contains the minimum value analyzed.</p>
    public let min: String?

    public init (
        average: String? = nil,
        max: String? = nil,
        min: String? = nil
    )
    {
        self.average = average
        self.max = max
        self.min = min
    }
}

public enum ReportPackagingType {
    case `none`
    case zip
    case sdkUnknown(String)
}

extension ReportPackagingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportPackagingType] {
        return [
            .none,
            .zip,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .zip: return "ZIP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportPackagingType(rawValue: rawValue) ?? ReportPackagingType.sdkUnknown(rawValue)
    }
}

public enum ReportStatusType {
    case deleting
    case failed
    case generating
    case incomplete
    case succeeded
    case sdkUnknown(String)
}

extension ReportStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportStatusType] {
        return [
            .deleting,
            .failed,
            .generating,
            .incomplete,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .generating: return "GENERATING"
        case .incomplete: return "INCOMPLETE"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportStatusType(rawValue: rawValue) ?? ReportStatusType.sdkUnknown(rawValue)
    }
}

public enum ReportType {
    case codeCoverage
    case test
    case sdkUnknown(String)
}

extension ReportType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportType] {
        return [
            .codeCoverage,
            .test,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .codeCoverage: return "CODE_COVERAGE"
        case .test: return "TEST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportType(rawValue: rawValue) ?? ReportType.sdkUnknown(rawValue)
    }
}

extension ReportWithRawData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data
        case reportArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let reportArn = reportArn {
            try encodeContainer.encode(reportArn, forKey: .reportArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportArn)
        reportArn = reportArnDecoded
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
    }
}

extension ReportWithRawData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportWithRawData(data: \(String(describing: data)), reportArn: \(String(describing: reportArn)))"}
}

/// <p>Contains the unmodified data for the report. For more information, see .</p>
public struct ReportWithRawData: Equatable {
    /// <p>The value of the requested data field from the report.</p>
    public let data: String?
    /// <p>The ARN of the report.</p>
    public let reportArn: String?

    public init (
        data: String? = nil,
        reportArn: String? = nil
    )
    {
        self.data = data
        self.reportArn = reportArn
    }
}

extension ResolvedArtifact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identifier
        case location
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ArtifactsType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension ResolvedArtifact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolvedArtifact(identifier: \(String(describing: identifier)), location: \(String(describing: location)), type: \(String(describing: type)))"}
}

/// <p>Represents a resolved build artifact. A resolve artifact is an artifact that is built and
///             deployed to the destination, such as Amazon S3.</p>
public struct ResolvedArtifact: Equatable {
    /// <p>The identifier of the artifact.</p>
    public let identifier: String?
    /// <p>The location of the artifact.</p>
    public let location: String?
    /// <p>Specifies the type of artifact.</p>
    public let type: ArtifactsType?

    public init (
        identifier: String? = nil,
        location: String? = nil,
        type: ArtifactsType? = nil
    )
    {
        self.identifier = identifier
        self.location = location
        self.type = type
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified AWS resource cannot be created, because an AWS resource with the same
///             settings already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified AWS resource cannot be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RetryBuildBatchInputBodyMiddleware: Middleware {
    public let id: String = "RetryBuildBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryBuildBatchInput>
    public typealias MOutput = OperationOutput<RetryBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryBuildBatchOutputError>
}

extension RetryBuildBatchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetryBuildBatchInput(id: \(String(describing: id)), idempotencyToken: \(String(describing: idempotencyToken)), retryType: \(String(describing: retryType)))"}
}

extension RetryBuildBatchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case idempotencyToken
        case retryType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let retryType = retryType {
            try encodeContainer.encode(retryType.rawValue, forKey: .retryType)
        }
    }
}

public struct RetryBuildBatchInputHeadersMiddleware: Middleware {
    public let id: String = "RetryBuildBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryBuildBatchInput>
    public typealias MOutput = OperationOutput<RetryBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryBuildBatchOutputError>
}

public struct RetryBuildBatchInputQueryItemMiddleware: Middleware {
    public let id: String = "RetryBuildBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryBuildBatchInput>
    public typealias MOutput = OperationOutput<RetryBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryBuildBatchOutputError>
}

public struct RetryBuildBatchInput: Equatable {
    /// <p>Specifies the identifier of the batch build to restart.</p>
    public let id: String?
    /// <p>A unique, case sensitive identifier you provide to ensure the idempotency of the
    ///                 <code>RetryBuildBatch</code> request. The token is included in the
    ///                 <code>RetryBuildBatch</code> request and is valid for five minutes. If you repeat
    ///             the <code>RetryBuildBatch</code> request with the same token, but change a parameter,
    ///             AWS CodeBuild returns a parameter mismatch error.</p>
    public let idempotencyToken: String?
    /// <p>Specifies the type of retry to perform.</p>
    public let retryType: RetryBuildBatchType?

    public init (
        id: String? = nil,
        idempotencyToken: String? = nil,
        retryType: RetryBuildBatchType? = nil
    )
    {
        self.id = id
        self.idempotencyToken = idempotencyToken
        self.retryType = retryType
    }
}

struct RetryBuildBatchInputBody: Equatable {
    public let id: String?
    public let idempotencyToken: String?
    public let retryType: RetryBuildBatchType?
}

extension RetryBuildBatchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case idempotencyToken
        case retryType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let retryTypeDecoded = try containerValues.decodeIfPresent(RetryBuildBatchType.self, forKey: .retryType)
        retryType = retryTypeDecoded
    }
}

extension RetryBuildBatchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetryBuildBatchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetryBuildBatchOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetryBuildBatchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetryBuildBatchOutputResponse(buildBatch: \(String(describing: buildBatch)))"}
}

extension RetryBuildBatchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RetryBuildBatchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.buildBatch = output.buildBatch
        } else {
            self.buildBatch = nil
        }
    }
}

public struct RetryBuildBatchOutputResponse: Equatable {
    /// <p>Contains information about a batch build.</p>
    public let buildBatch: BuildBatch?

    public init (
        buildBatch: BuildBatch? = nil
    )
    {
        self.buildBatch = buildBatch
    }
}

struct RetryBuildBatchOutputResponseBody: Equatable {
    public let buildBatch: BuildBatch?
}

extension RetryBuildBatchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case buildBatch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildBatchDecoded = try containerValues.decodeIfPresent(BuildBatch.self, forKey: .buildBatch)
        buildBatch = buildBatchDecoded
    }
}

public enum RetryBuildBatchType {
    case retryAllBuilds
    case retryFailedBuilds
    case sdkUnknown(String)
}

extension RetryBuildBatchType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RetryBuildBatchType] {
        return [
            .retryAllBuilds,
            .retryFailedBuilds,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .retryAllBuilds: return "RETRY_ALL_BUILDS"
        case .retryFailedBuilds: return "RETRY_FAILED_BUILDS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RetryBuildBatchType(rawValue: rawValue) ?? RetryBuildBatchType.sdkUnknown(rawValue)
    }
}

public struct RetryBuildInputBodyMiddleware: Middleware {
    public let id: String = "RetryBuildInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryBuildInput>
    public typealias MOutput = OperationOutput<RetryBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryBuildOutputError>
}

extension RetryBuildInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetryBuildInput(id: \(String(describing: id)), idempotencyToken: \(String(describing: idempotencyToken)))"}
}

extension RetryBuildInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case idempotencyToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
    }
}

public struct RetryBuildInputHeadersMiddleware: Middleware {
    public let id: String = "RetryBuildInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryBuildInput>
    public typealias MOutput = OperationOutput<RetryBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryBuildOutputError>
}

public struct RetryBuildInputQueryItemMiddleware: Middleware {
    public let id: String = "RetryBuildInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryBuildInput>
    public typealias MOutput = OperationOutput<RetryBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryBuildOutputError>
}

public struct RetryBuildInput: Equatable {
    /// <p>Specifies the identifier of the build to restart.</p>
    public let id: String?
    /// <p>A unique, case sensitive identifier you provide to ensure the idempotency of the
    ///       <code>RetryBuild</code> request. The token is included in the
    ///       <code>RetryBuild</code> request and is valid for five minutes. If you repeat
    ///       the <code>RetryBuild</code> request with the same token, but change a parameter,
    ///       AWS CodeBuild returns a parameter mismatch error.</p>
    public let idempotencyToken: String?

    public init (
        id: String? = nil,
        idempotencyToken: String? = nil
    )
    {
        self.id = id
        self.idempotencyToken = idempotencyToken
    }
}

struct RetryBuildInputBody: Equatable {
    public let id: String?
    public let idempotencyToken: String?
}

extension RetryBuildInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case idempotencyToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension RetryBuildOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetryBuildOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountLimitExceededException" : self = .accountLimitExceededException(try AccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetryBuildOutputError: Equatable {
    case accountLimitExceededException(AccountLimitExceededException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetryBuildOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetryBuildOutputResponse(build: \(String(describing: build)))"}
}

extension RetryBuildOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RetryBuildOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.build = output.build
        } else {
            self.build = nil
        }
    }
}

public struct RetryBuildOutputResponse: Equatable {
    /// <p>Information about a build.</p>
    public let build: Build?

    public init (
        build: Build? = nil
    )
    {
        self.build = build
    }
}

struct RetryBuildOutputResponseBody: Equatable {
    public let build: Build?
}

extension RetryBuildOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case build
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildDecoded = try containerValues.decodeIfPresent(Build.self, forKey: .build)
        build = buildDecoded
    }
}

extension S3LogsConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketOwnerAccess
        case encryptionDisabled
        case location
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketOwnerAccess = bucketOwnerAccess {
            try encodeContainer.encode(bucketOwnerAccess.rawValue, forKey: .bucketOwnerAccess)
        }
        if let encryptionDisabled = encryptionDisabled {
            try encodeContainer.encode(encryptionDisabled, forKey: .encryptionDisabled)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LogsConfigStatusType.self, forKey: .status)
        status = statusDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let encryptionDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encryptionDisabled)
        encryptionDisabled = encryptionDisabledDecoded
        let bucketOwnerAccessDecoded = try containerValues.decodeIfPresent(BucketOwnerAccess.self, forKey: .bucketOwnerAccess)
        bucketOwnerAccess = bucketOwnerAccessDecoded
    }
}

extension S3LogsConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3LogsConfig(bucketOwnerAccess: \(String(describing: bucketOwnerAccess)), encryptionDisabled: \(String(describing: encryptionDisabled)), location: \(String(describing: location)), status: \(String(describing: status)))"}
}

/// <p> Information about S3 logs for a build project. </p>
public struct S3LogsConfig: Equatable {
    /// <p>Specifies the access for objects that are uploaded to an Amazon S3 bucket that is owned by
    ///             another account.</p>
    ///         <p>By default, only the account that uploads the objects to the bucket has access to
    ///             these objects. This property allows you to give the bucket owner access to these
    ///             objects.</p>
    ///          <dl>
    ///             <dt>NONE</dt>
    ///             <dd>
    ///                 <p>The bucket owner does not have access to the objects. This is the
    ///                         default.</p>
    ///             </dd>
    ///             <dt>READ_ONLY</dt>
    ///             <dd>
    ///               <p>The bucket owner has read only access to the objects. The uploading account
    ///                         retains ownership of the objects.</p>
    ///             </dd>
    ///             <dt>FULL</dt>
    ///             <dd>
    ///               <p>The bucket owner has full access to the objects. Object ownership is determined
    ///                         by the following criteria:</p>
    ///                     <ul>
    ///                   <li>
    ///                             <p>If the bucket is configured with the <b>Bucket
    ///                                     owner preferred</b> setting, the bucket owner owns the
    ///                                 objects. The uploading account will have object access as specified
    ///                                 by the bucket's policy.</p>
    ///                         </li>
    ///                   <li>
    ///                             <p>Otherwise, the uploading account retains ownership of the
    ///                                 objects.</p>
    ///                         </li>
    ///                </ul>
    ///                     <p>For more information about Amazon S3 object ownership, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html">Controlling ownership of uploaded objects using S3
    ///                             Object Ownership</a> in the <i>Amazon Simple Storage Service User
    ///                         Guide</i>.</p>
    ///             </dd>
    ///          </dl>
    public let bucketOwnerAccess: BucketOwnerAccess?
    /// <p> Set to true if you do not want your S3 build log output encrypted. By default S3
    ///             build logs are encrypted. </p>
    public let encryptionDisabled: Bool?
    /// <p> The ARN of an S3 bucket and the path prefix for S3 logs. If your Amazon S3 bucket
    ///             name is <code>my-bucket</code>, and your path prefix is <code>build-log</code>, then
    ///             acceptable formats are <code>my-bucket/build-log</code> or
    ///                 <code>arn:aws:s3:::my-bucket/build-log</code>. </p>
    public let location: String?
    /// <p>The current status of the S3 build logs. Valid values are:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ENABLED</code>: S3 build logs are enabled for this build project.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DISABLED</code>: S3 build logs are not enabled for this build
    ///                     project.</p>
    ///             </li>
    ///          </ul>
    public let status: LogsConfigStatusType?

    public init (
        bucketOwnerAccess: BucketOwnerAccess? = nil,
        encryptionDisabled: Bool? = nil,
        location: String? = nil,
        status: LogsConfigStatusType? = nil
    )
    {
        self.bucketOwnerAccess = bucketOwnerAccess
        self.encryptionDisabled = encryptionDisabled
        self.location = location
        self.status = status
    }
}

extension S3ReportExportConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case bucketOwner
        case encryptionDisabled
        case encryptionKey
        case packaging
        case path
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let bucketOwner = bucketOwner {
            try encodeContainer.encode(bucketOwner, forKey: .bucketOwner)
        }
        if let encryptionDisabled = encryptionDisabled {
            try encodeContainer.encode(encryptionDisabled, forKey: .encryptionDisabled)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let packaging = packaging {
            try encodeContainer.encode(packaging.rawValue, forKey: .packaging)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let bucketOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketOwner)
        bucketOwner = bucketOwnerDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let packagingDecoded = try containerValues.decodeIfPresent(ReportPackagingType.self, forKey: .packaging)
        packaging = packagingDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let encryptionDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encryptionDisabled)
        encryptionDisabled = encryptionDisabledDecoded
    }
}

extension S3ReportExportConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ReportExportConfig(bucket: \(String(describing: bucket)), bucketOwner: \(String(describing: bucketOwner)), encryptionDisabled: \(String(describing: encryptionDisabled)), encryptionKey: \(String(describing: encryptionKey)), packaging: \(String(describing: packaging)), path: \(String(describing: path)))"}
}

/// <p> Information about the S3 bucket where the raw data of a report are exported. </p>
public struct S3ReportExportConfig: Equatable {
    /// <p> The name of the S3 bucket where the raw data of a report are exported. </p>
    public let bucket: String?
    /// <p>The AWS account identifier of the owner of the Amazon S3 bucket. This allows report data to be exported to an Amazon S3 bucket
    ///         that is owned by an account other than the account running the build.</p>
    public let bucketOwner: String?
    /// <p> A boolean value that specifies if the results of a report are encrypted. </p>
    public let encryptionDisabled: Bool?
    /// <p> The encryption key for the report's encrypted raw data. </p>
    public let encryptionKey: String?
    /// <p> The type of build output artifact to create. Valid values include: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>NONE</code>: AWS CodeBuild creates the raw data in the output bucket. This
    ///                     is the default if packaging is not specified. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ZIP</code>: AWS CodeBuild creates a ZIP file with the raw data in the
    ///                     output bucket. </p>
    ///             </li>
    ///          </ul>
    public let packaging: ReportPackagingType?
    /// <p> The path to the exported report's raw data results. </p>
    public let path: String?

    public init (
        bucket: String? = nil,
        bucketOwner: String? = nil,
        encryptionDisabled: Bool? = nil,
        encryptionKey: String? = nil,
        packaging: ReportPackagingType? = nil,
        path: String? = nil
    )
    {
        self.bucket = bucket
        self.bucketOwner = bucketOwner
        self.encryptionDisabled = encryptionDisabled
        self.encryptionKey = encryptionKey
        self.packaging = packaging
        self.path = path
    }
}

public enum ServerType {
    case bitbucket
    case github
    case githubEnterprise
    case sdkUnknown(String)
}

extension ServerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServerType] {
        return [
            .bitbucket,
            .github,
            .githubEnterprise,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bitbucket: return "BITBUCKET"
        case .github: return "GITHUB"
        case .githubEnterprise: return "GITHUB_ENTERPRISE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServerType(rawValue: rawValue) ?? ServerType.sdkUnknown(rawValue)
    }
}

public enum SharedResourceSortByType {
    case arn
    case modifiedTime
    case sdkUnknown(String)
}

extension SharedResourceSortByType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SharedResourceSortByType] {
        return [
            .arn,
            .modifiedTime,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .arn: return "ARN"
        case .modifiedTime: return "MODIFIED_TIME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SharedResourceSortByType(rawValue: rawValue) ?? SharedResourceSortByType.sdkUnknown(rawValue)
    }
}

public enum SortOrderType {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortOrderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortOrderType] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortOrderType(rawValue: rawValue) ?? SortOrderType.sdkUnknown(rawValue)
    }
}

extension SourceAuth: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resource
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SourceAuthType.self, forKey: .type)
        type = typeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension SourceAuth: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceAuth(resource: \(String(describing: resource)), type: \(String(describing: type)))"}
}

/// <p>Information about the authorization settings for AWS CodeBuild to access the source code to be
///             built.</p>
///         <p>This information is for the AWS CodeBuild console's use only. Your code should not get or set
///             this information directly.</p>
public struct SourceAuth: Equatable {
    /// <p>The resource value that applies to the specified authorization type.</p>
    public let resource: String?
    /// <note>
    ///             <p> This data type is deprecated and is no longer accurate or used. </p>
    ///         </note>
    ///         <p>The authorization type to use. The only valid value is <code>OAUTH</code>, which
    ///             represents the OAuth authorization type.</p>
    public let type: SourceAuthType?

    public init (
        resource: String? = nil,
        type: SourceAuthType? = nil
    )
    {
        self.resource = resource
        self.type = type
    }
}

public enum SourceAuthType {
    case oauth
    case sdkUnknown(String)
}

extension SourceAuthType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceAuthType] {
        return [
            .oauth,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .oauth: return "OAUTH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceAuthType(rawValue: rawValue) ?? SourceAuthType.sdkUnknown(rawValue)
    }
}

extension SourceCredentialsInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case authType
        case serverType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authType = authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let serverType = serverType {
            try encodeContainer.encode(serverType.rawValue, forKey: .serverType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let serverTypeDecoded = try containerValues.decodeIfPresent(ServerType.self, forKey: .serverType)
        serverType = serverTypeDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

extension SourceCredentialsInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceCredentialsInfo(arn: \(String(describing: arn)), authType: \(String(describing: authType)), serverType: \(String(describing: serverType)))"}
}

/// <p> Information about the credentials for a GitHub, GitHub Enterprise, or Bitbucket
///             repository. </p>
public struct SourceCredentialsInfo: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the token. </p>
    public let arn: String?
    /// <p> The type of authentication used by the credentials. Valid options are OAUTH,
    ///             BASIC_AUTH, or PERSONAL_ACCESS_TOKEN. </p>
    public let authType: AuthType?
    /// <p> The type of source provider. The valid options are GITHUB, GITHUB_ENTERPRISE, or
    ///             BITBUCKET. </p>
    public let serverType: ServerType?

    public init (
        arn: String? = nil,
        authType: AuthType? = nil,
        serverType: ServerType? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.serverType = serverType
    }
}

public enum SourceType {
    case bitbucket
    case codecommit
    case codepipeline
    case github
    case githubEnterprise
    case noSource
    case s3
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .bitbucket,
            .codecommit,
            .codepipeline,
            .github,
            .githubEnterprise,
            .noSource,
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bitbucket: return "BITBUCKET"
        case .codecommit: return "CODECOMMIT"
        case .codepipeline: return "CODEPIPELINE"
        case .github: return "GITHUB"
        case .githubEnterprise: return "GITHUB_ENTERPRISE"
        case .noSource: return "NO_SOURCE"
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

public struct StartBuildBatchInputBodyMiddleware: Middleware {
    public let id: String = "StartBuildBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBuildBatchInput>
    public typealias MOutput = OperationOutput<StartBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBuildBatchOutputError>
}

extension StartBuildBatchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartBuildBatchInput(artifactsOverride: \(String(describing: artifactsOverride)), buildBatchConfigOverride: \(String(describing: buildBatchConfigOverride)), buildTimeoutInMinutesOverride: \(String(describing: buildTimeoutInMinutesOverride)), buildspecOverride: \(String(describing: buildspecOverride)), cacheOverride: \(String(describing: cacheOverride)), certificateOverride: \(String(describing: certificateOverride)), computeTypeOverride: \(String(describing: computeTypeOverride)), debugSessionEnabled: \(String(describing: debugSessionEnabled)), encryptionKeyOverride: \(String(describing: encryptionKeyOverride)), environmentTypeOverride: \(String(describing: environmentTypeOverride)), environmentVariablesOverride: \(String(describing: environmentVariablesOverride)), gitCloneDepthOverride: \(String(describing: gitCloneDepthOverride)), gitSubmodulesConfigOverride: \(String(describing: gitSubmodulesConfigOverride)), idempotencyToken: \(String(describing: idempotencyToken)), imageOverride: \(String(describing: imageOverride)), imagePullCredentialsTypeOverride: \(String(describing: imagePullCredentialsTypeOverride)), insecureSslOverride: \(String(describing: insecureSslOverride)), logsConfigOverride: \(String(describing: logsConfigOverride)), privilegedModeOverride: \(String(describing: privilegedModeOverride)), projectName: \(String(describing: projectName)), queuedTimeoutInMinutesOverride: \(String(describing: queuedTimeoutInMinutesOverride)), registryCredentialOverride: \(String(describing: registryCredentialOverride)), reportBuildBatchStatusOverride: \(String(describing: reportBuildBatchStatusOverride)), secondaryArtifactsOverride: \(String(describing: secondaryArtifactsOverride)), secondarySourcesOverride: \(String(describing: secondarySourcesOverride)), secondarySourcesVersionOverride: \(String(describing: secondarySourcesVersionOverride)), serviceRoleOverride: \(String(describing: serviceRoleOverride)), sourceAuthOverride: \(String(describing: sourceAuthOverride)), sourceLocationOverride: \(String(describing: sourceLocationOverride)), sourceTypeOverride: \(String(describing: sourceTypeOverride)), sourceVersion: \(String(describing: sourceVersion)))"}
}

extension StartBuildBatchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactsOverride
        case buildBatchConfigOverride
        case buildTimeoutInMinutesOverride
        case buildspecOverride
        case cacheOverride
        case certificateOverride
        case computeTypeOverride
        case debugSessionEnabled
        case encryptionKeyOverride
        case environmentTypeOverride
        case environmentVariablesOverride
        case gitCloneDepthOverride
        case gitSubmodulesConfigOverride
        case idempotencyToken
        case imageOverride
        case imagePullCredentialsTypeOverride
        case insecureSslOverride
        case logsConfigOverride
        case privilegedModeOverride
        case projectName
        case queuedTimeoutInMinutesOverride
        case registryCredentialOverride
        case reportBuildBatchStatusOverride
        case secondaryArtifactsOverride
        case secondarySourcesOverride
        case secondarySourcesVersionOverride
        case serviceRoleOverride
        case sourceAuthOverride
        case sourceLocationOverride
        case sourceTypeOverride
        case sourceVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsOverride = artifactsOverride {
            try encodeContainer.encode(artifactsOverride, forKey: .artifactsOverride)
        }
        if let buildBatchConfigOverride = buildBatchConfigOverride {
            try encodeContainer.encode(buildBatchConfigOverride, forKey: .buildBatchConfigOverride)
        }
        if let buildTimeoutInMinutesOverride = buildTimeoutInMinutesOverride {
            try encodeContainer.encode(buildTimeoutInMinutesOverride, forKey: .buildTimeoutInMinutesOverride)
        }
        if let buildspecOverride = buildspecOverride {
            try encodeContainer.encode(buildspecOverride, forKey: .buildspecOverride)
        }
        if let cacheOverride = cacheOverride {
            try encodeContainer.encode(cacheOverride, forKey: .cacheOverride)
        }
        if let certificateOverride = certificateOverride {
            try encodeContainer.encode(certificateOverride, forKey: .certificateOverride)
        }
        if let computeTypeOverride = computeTypeOverride {
            try encodeContainer.encode(computeTypeOverride.rawValue, forKey: .computeTypeOverride)
        }
        if let debugSessionEnabled = debugSessionEnabled {
            try encodeContainer.encode(debugSessionEnabled, forKey: .debugSessionEnabled)
        }
        if let encryptionKeyOverride = encryptionKeyOverride {
            try encodeContainer.encode(encryptionKeyOverride, forKey: .encryptionKeyOverride)
        }
        if let environmentTypeOverride = environmentTypeOverride {
            try encodeContainer.encode(environmentTypeOverride.rawValue, forKey: .environmentTypeOverride)
        }
        if let environmentVariablesOverride = environmentVariablesOverride {
            var environmentVariablesOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentVariablesOverride)
            for environmentvariables0 in environmentVariablesOverride {
                try environmentVariablesOverrideContainer.encode(environmentvariables0)
            }
        }
        if let gitCloneDepthOverride = gitCloneDepthOverride {
            try encodeContainer.encode(gitCloneDepthOverride, forKey: .gitCloneDepthOverride)
        }
        if let gitSubmodulesConfigOverride = gitSubmodulesConfigOverride {
            try encodeContainer.encode(gitSubmodulesConfigOverride, forKey: .gitSubmodulesConfigOverride)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let imageOverride = imageOverride {
            try encodeContainer.encode(imageOverride, forKey: .imageOverride)
        }
        if let imagePullCredentialsTypeOverride = imagePullCredentialsTypeOverride {
            try encodeContainer.encode(imagePullCredentialsTypeOverride.rawValue, forKey: .imagePullCredentialsTypeOverride)
        }
        if let insecureSslOverride = insecureSslOverride {
            try encodeContainer.encode(insecureSslOverride, forKey: .insecureSslOverride)
        }
        if let logsConfigOverride = logsConfigOverride {
            try encodeContainer.encode(logsConfigOverride, forKey: .logsConfigOverride)
        }
        if let privilegedModeOverride = privilegedModeOverride {
            try encodeContainer.encode(privilegedModeOverride, forKey: .privilegedModeOverride)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let queuedTimeoutInMinutesOverride = queuedTimeoutInMinutesOverride {
            try encodeContainer.encode(queuedTimeoutInMinutesOverride, forKey: .queuedTimeoutInMinutesOverride)
        }
        if let registryCredentialOverride = registryCredentialOverride {
            try encodeContainer.encode(registryCredentialOverride, forKey: .registryCredentialOverride)
        }
        if let reportBuildBatchStatusOverride = reportBuildBatchStatusOverride {
            try encodeContainer.encode(reportBuildBatchStatusOverride, forKey: .reportBuildBatchStatusOverride)
        }
        if let secondaryArtifactsOverride = secondaryArtifactsOverride {
            var secondaryArtifactsOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifactsOverride)
            for projectartifactslist0 in secondaryArtifactsOverride {
                try secondaryArtifactsOverrideContainer.encode(projectartifactslist0)
            }
        }
        if let secondarySourcesOverride = secondarySourcesOverride {
            var secondarySourcesOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourcesOverride)
            for projectsources0 in secondarySourcesOverride {
                try secondarySourcesOverrideContainer.encode(projectsources0)
            }
        }
        if let secondarySourcesVersionOverride = secondarySourcesVersionOverride {
            var secondarySourcesVersionOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourcesVersionOverride)
            for projectsecondarysourceversions0 in secondarySourcesVersionOverride {
                try secondarySourcesVersionOverrideContainer.encode(projectsecondarysourceversions0)
            }
        }
        if let serviceRoleOverride = serviceRoleOverride {
            try encodeContainer.encode(serviceRoleOverride, forKey: .serviceRoleOverride)
        }
        if let sourceAuthOverride = sourceAuthOverride {
            try encodeContainer.encode(sourceAuthOverride, forKey: .sourceAuthOverride)
        }
        if let sourceLocationOverride = sourceLocationOverride {
            try encodeContainer.encode(sourceLocationOverride, forKey: .sourceLocationOverride)
        }
        if let sourceTypeOverride = sourceTypeOverride {
            try encodeContainer.encode(sourceTypeOverride.rawValue, forKey: .sourceTypeOverride)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
    }
}

public struct StartBuildBatchInputHeadersMiddleware: Middleware {
    public let id: String = "StartBuildBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBuildBatchInput>
    public typealias MOutput = OperationOutput<StartBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBuildBatchOutputError>
}

public struct StartBuildBatchInputQueryItemMiddleware: Middleware {
    public let id: String = "StartBuildBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBuildBatchInput>
    public typealias MOutput = OperationOutput<StartBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBuildBatchOutputError>
}

public struct StartBuildBatchInput: Equatable {
    /// <p>An array of <code>ProjectArtifacts</code> objects that contains information about the
    ///             build output artifact overrides for the build project.</p>
    public let artifactsOverride: ProjectArtifacts?
    /// <p>A <code>BuildBatchConfigOverride</code> object that contains batch build configuration
    ///             overrides.</p>
    public let buildBatchConfigOverride: ProjectBuildBatchConfig?
    /// <p>Overrides the build timeout specified in the batch build project.</p>
    public let buildTimeoutInMinutesOverride: Int?
    /// <p>A buildspec file declaration that overrides, for this build only, the latest one
    ///         already defined in the build project.</p>
    ///          <p>If this value is set, it can be either an inline buildspec definition, the path to an
    ///         alternate buildspec file relative to the value of the built-in
    ///         <code>CODEBUILD_SRC_DIR</code> environment variable, or the path to an S3 bucket.
    ///         The bucket must be in the same AWS Region as the build project. Specify the buildspec
    ///         file using its ARN (for example,
    ///         <code>arn:aws:s3:::my-codebuild-sample2/buildspec.yml</code>). If this value is not
    ///         provided or is set to an empty string, the source code must contain a buildspec file in
    ///         its root directory. For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-name-storage">Buildspec File Name and Storage Location</a>. </p>
    public let buildspecOverride: String?
    /// <p>A <code>ProjectCache</code> object that specifies cache overrides.</p>
    public let cacheOverride: ProjectCache?
    /// <p>The name of a certificate for this batch build that overrides the one specified in the batch build
    ///         project.</p>
    public let certificateOverride: String?
    /// <p>The name of a compute type for this batch build that overrides the one specified in the
    ///         batch build project.</p>
    public let computeTypeOverride: ComputeType?
    /// <p>Specifies if session debugging is enabled for this batch build. For more information, see
    ///   <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/session-manager.html">Viewing a running build in Session Manager</a>. Batch session debugging is not supported for matrix batch builds.</p>
    public let debugSessionEnabled: Bool?
    /// <p>The AWS Key Management Service (AWS KMS) customer master key (CMK) that overrides the one specified in the batch build
    ///         project. The CMK key encrypts the build output artifacts.</p>
    ///          <note>
    ///             <p>You can use a cross-account KMS key to encrypt the build output artifacts if your
    ///           service role has permission to that key. </p>
    ///          </note>
    ///          <p>You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using
    ///         the format <code>alias/<alias-name></code>).</p>
    public let encryptionKeyOverride: String?
    /// <p>A container type for this batch build that overrides the one specified in the batch build
    ///         project.</p>
    public let environmentTypeOverride: EnvironmentType?
    /// <p>An array of <code>EnvironmentVariable</code> objects that override, or add to, the
    ///             environment variables defined in the batch build project.</p>
    public let environmentVariablesOverride: [EnvironmentVariable]?
    /// <p>The user-defined depth of history, with a minimum value of 0, that overrides, for this
    ///         batch build only, any previous depth of history defined in the batch build project.</p>
    public let gitCloneDepthOverride: Int?
    /// <p>A <code>GitSubmodulesConfig</code> object that overrides the Git submodules configuration
    ///             for this batch build.</p>
    public let gitSubmodulesConfigOverride: GitSubmodulesConfig?
    /// <p>A unique, case sensitive identifier you provide to ensure the idempotency of the
    ///                 <code>StartBuildBatch</code> request. The token is included in the
    ///                 <code>StartBuildBatch</code> request and is valid for five minutes. If you repeat
    ///             the <code>StartBuildBatch</code> request with the same token, but change a parameter,
    ///             AWS CodeBuild returns a parameter mismatch error.</p>
    public let idempotencyToken: String?
    /// <p>The name of an image for this batch build that overrides the one specified in the batch
    ///             build project.</p>
    public let imageOverride: String?
    /// <p>The type of credentials AWS CodeBuild uses to pull images in your batch build. There are two valid
    ///         values: </p>
    ///         <dl>
    ///             <dt>CODEBUILD</dt>
    ///             <dd>
    ///                     <p>Specifies that AWS CodeBuild uses its own credentials. This requires that you
    ///                         modify your ECR repository policy to trust AWS CodeBuild's service principal.</p>
    ///                 </dd>
    ///             <dt>SERVICE_ROLE</dt>
    ///             <dd>
    ///                     <p>Specifies that AWS CodeBuild uses your build project's service role. </p>
    ///                 </dd>
    ///          </dl>
    ///          <p>When using a cross-account or private registry image, you must use
    ///                 <code>SERVICE_ROLE</code> credentials. When using an AWS CodeBuild curated image,
    ///             you must use <code>CODEBUILD</code> credentials. </p>
    public let imagePullCredentialsTypeOverride: ImagePullCredentialsType?
    /// <p>Enable this flag to override the insecure SSL setting that is specified in the batch build
    ///         project. The insecure SSL setting determines whether to ignore SSL warnings while
    ///         connecting to the project source code. This override applies only if the build's source
    ///         is GitHub Enterprise.</p>
    public let insecureSslOverride: Bool?
    /// <p>A <code>LogsConfig</code> object that override the log settings defined in the batch build
    ///             project.</p>
    public let logsConfigOverride: LogsConfig?
    /// <p>Enable this flag to override privileged mode in the batch build project.</p>
    public let privilegedModeOverride: Bool?
    /// <p>The name of the project.</p>
    public let projectName: String?
    /// <p>The number of minutes a batch build is allowed to be queued before it times out.</p>
    public let queuedTimeoutInMinutesOverride: Int?
    /// <p>A <code>RegistryCredential</code> object that overrides credentials for access to a
    ///             private registry.</p>
    public let registryCredentialOverride: RegistryCredential?
    /// <p>Set to <code>true</code> to report to your source provider the status of a batch build's
    ///             start and completion. If you use this option with a source provider other than GitHub,
    ///             GitHub Enterprise, or Bitbucket, an <code>invalidInputException</code> is thrown. </p>
    ///          <note>
    ///             <p>The status of a build triggered by a webhook is always reported to your source
    ///           provider. </p>
    ///          </note>
    public let reportBuildBatchStatusOverride: Bool?
    /// <p>An array of <code>ProjectArtifacts</code> objects that override the secondary artifacts
    ///             defined in the batch build project.</p>
    public let secondaryArtifactsOverride: [ProjectArtifacts]?
    /// <p>An array of <code>ProjectSource</code> objects that override the secondary sources
    ///         defined in the batch build project.</p>
    public let secondarySourcesOverride: [ProjectSource]?
    /// <p>An array of <code>ProjectSourceVersion</code> objects that override the secondary source
    ///             versions in the batch build project.</p>
    public let secondarySourcesVersionOverride: [ProjectSourceVersion]?
    /// <p>The name of a service role for this batch build that overrides the one specified in the
    ///         batch build project.</p>
    public let serviceRoleOverride: String?
    /// <p>A <code>SourceAuth</code> object that overrides the one defined in the batch build
    ///             project. This override applies only if the build project's source is BitBucket or
    ///             GitHub.</p>
    public let sourceAuthOverride: SourceAuth?
    /// <p>A location that overrides, for this batch build, the source location defined in
    ///         the batch build project.</p>
    public let sourceLocationOverride: String?
    /// <p>The source input type that overrides the source input defined in the batch
    ///         build project.</p>
    public let sourceTypeOverride: SourceType?
    /// <p>The version of the batch build input to be built, for this build only. If not specified,
    ///             the latest version is used. If specified, the contents depends on the source
    ///             provider:</p>
    ///         <dl>
    ///             <dt>AWS CodeCommit</dt>
    ///             <dd>
    ///                     <p>The commit ID, branch, or Git tag to use.</p>
    ///                 </dd>
    ///             <dt>GitHub</dt>
    ///             <dd>
    ///                     <p>The commit ID, pull request ID, branch name, or tag name that corresponds
    ///                         to the version of the source code you want to build. If a pull request ID is
    ///                         specified, it must use the format <code>pr/pull-request-ID</code> (for
    ///                         example <code>pr/25</code>). If a branch name is specified, the branch's
    ///                         HEAD commit ID is used. If not specified, the default branch's HEAD commit
    ///                         ID is used.</p>
    ///                 </dd>
    ///             <dt>Bitbucket</dt>
    ///             <dd>
    ///                     <p>The commit ID, branch name, or tag name that corresponds to the version of
    ///                         the source code you want to build. If a branch name is specified, the
    ///                         branch's HEAD commit ID is used. If not specified, the default branch's HEAD
    ///                         commit ID is used.</p>
    ///                 </dd>
    ///             <dt>Amazon S3</dt>
    ///             <dd>
    ///                     <p>The version ID of the object that represents the build input ZIP file to
    ///                         use.</p>
    ///                 </dd>
    ///          </dl>
    ///          <p>If <code>sourceVersion</code> is specified at the project level, then this
    ///                 <code>sourceVersion</code> (at the build level) takes precedence. </p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html">Source Version Sample
    ///                 with CodeBuild</a> in the <i>AWS CodeBuild User Guide</i>. </p>
    public let sourceVersion: String?

    public init (
        artifactsOverride: ProjectArtifacts? = nil,
        buildBatchConfigOverride: ProjectBuildBatchConfig? = nil,
        buildTimeoutInMinutesOverride: Int? = nil,
        buildspecOverride: String? = nil,
        cacheOverride: ProjectCache? = nil,
        certificateOverride: String? = nil,
        computeTypeOverride: ComputeType? = nil,
        debugSessionEnabled: Bool? = nil,
        encryptionKeyOverride: String? = nil,
        environmentTypeOverride: EnvironmentType? = nil,
        environmentVariablesOverride: [EnvironmentVariable]? = nil,
        gitCloneDepthOverride: Int? = nil,
        gitSubmodulesConfigOverride: GitSubmodulesConfig? = nil,
        idempotencyToken: String? = nil,
        imageOverride: String? = nil,
        imagePullCredentialsTypeOverride: ImagePullCredentialsType? = nil,
        insecureSslOverride: Bool? = nil,
        logsConfigOverride: LogsConfig? = nil,
        privilegedModeOverride: Bool? = nil,
        projectName: String? = nil,
        queuedTimeoutInMinutesOverride: Int? = nil,
        registryCredentialOverride: RegistryCredential? = nil,
        reportBuildBatchStatusOverride: Bool? = nil,
        secondaryArtifactsOverride: [ProjectArtifacts]? = nil,
        secondarySourcesOverride: [ProjectSource]? = nil,
        secondarySourcesVersionOverride: [ProjectSourceVersion]? = nil,
        serviceRoleOverride: String? = nil,
        sourceAuthOverride: SourceAuth? = nil,
        sourceLocationOverride: String? = nil,
        sourceTypeOverride: SourceType? = nil,
        sourceVersion: String? = nil
    )
    {
        self.artifactsOverride = artifactsOverride
        self.buildBatchConfigOverride = buildBatchConfigOverride
        self.buildTimeoutInMinutesOverride = buildTimeoutInMinutesOverride
        self.buildspecOverride = buildspecOverride
        self.cacheOverride = cacheOverride
        self.certificateOverride = certificateOverride
        self.computeTypeOverride = computeTypeOverride
        self.debugSessionEnabled = debugSessionEnabled
        self.encryptionKeyOverride = encryptionKeyOverride
        self.environmentTypeOverride = environmentTypeOverride
        self.environmentVariablesOverride = environmentVariablesOverride
        self.gitCloneDepthOverride = gitCloneDepthOverride
        self.gitSubmodulesConfigOverride = gitSubmodulesConfigOverride
        self.idempotencyToken = idempotencyToken
        self.imageOverride = imageOverride
        self.imagePullCredentialsTypeOverride = imagePullCredentialsTypeOverride
        self.insecureSslOverride = insecureSslOverride
        self.logsConfigOverride = logsConfigOverride
        self.privilegedModeOverride = privilegedModeOverride
        self.projectName = projectName
        self.queuedTimeoutInMinutesOverride = queuedTimeoutInMinutesOverride
        self.registryCredentialOverride = registryCredentialOverride
        self.reportBuildBatchStatusOverride = reportBuildBatchStatusOverride
        self.secondaryArtifactsOverride = secondaryArtifactsOverride
        self.secondarySourcesOverride = secondarySourcesOverride
        self.secondarySourcesVersionOverride = secondarySourcesVersionOverride
        self.serviceRoleOverride = serviceRoleOverride
        self.sourceAuthOverride = sourceAuthOverride
        self.sourceLocationOverride = sourceLocationOverride
        self.sourceTypeOverride = sourceTypeOverride
        self.sourceVersion = sourceVersion
    }
}

struct StartBuildBatchInputBody: Equatable {
    public let projectName: String?
    public let secondarySourcesOverride: [ProjectSource]?
    public let secondarySourcesVersionOverride: [ProjectSourceVersion]?
    public let sourceVersion: String?
    public let artifactsOverride: ProjectArtifacts?
    public let secondaryArtifactsOverride: [ProjectArtifacts]?
    public let environmentVariablesOverride: [EnvironmentVariable]?
    public let sourceTypeOverride: SourceType?
    public let sourceLocationOverride: String?
    public let sourceAuthOverride: SourceAuth?
    public let gitCloneDepthOverride: Int?
    public let gitSubmodulesConfigOverride: GitSubmodulesConfig?
    public let buildspecOverride: String?
    public let insecureSslOverride: Bool?
    public let reportBuildBatchStatusOverride: Bool?
    public let environmentTypeOverride: EnvironmentType?
    public let imageOverride: String?
    public let computeTypeOverride: ComputeType?
    public let certificateOverride: String?
    public let cacheOverride: ProjectCache?
    public let serviceRoleOverride: String?
    public let privilegedModeOverride: Bool?
    public let buildTimeoutInMinutesOverride: Int?
    public let queuedTimeoutInMinutesOverride: Int?
    public let encryptionKeyOverride: String?
    public let idempotencyToken: String?
    public let logsConfigOverride: LogsConfig?
    public let registryCredentialOverride: RegistryCredential?
    public let imagePullCredentialsTypeOverride: ImagePullCredentialsType?
    public let buildBatchConfigOverride: ProjectBuildBatchConfig?
    public let debugSessionEnabled: Bool?
}

extension StartBuildBatchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case artifactsOverride
        case buildBatchConfigOverride
        case buildTimeoutInMinutesOverride
        case buildspecOverride
        case cacheOverride
        case certificateOverride
        case computeTypeOverride
        case debugSessionEnabled
        case encryptionKeyOverride
        case environmentTypeOverride
        case environmentVariablesOverride
        case gitCloneDepthOverride
        case gitSubmodulesConfigOverride
        case idempotencyToken
        case imageOverride
        case imagePullCredentialsTypeOverride
        case insecureSslOverride
        case logsConfigOverride
        case privilegedModeOverride
        case projectName
        case queuedTimeoutInMinutesOverride
        case registryCredentialOverride
        case reportBuildBatchStatusOverride
        case secondaryArtifactsOverride
        case secondarySourcesOverride
        case secondarySourcesVersionOverride
        case serviceRoleOverride
        case sourceAuthOverride
        case sourceLocationOverride
        case sourceTypeOverride
        case sourceVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let secondarySourcesOverrideContainer = try containerValues.decodeIfPresent([ProjectSource?].self, forKey: .secondarySourcesOverride)
        var secondarySourcesOverrideDecoded0:[ProjectSource]? = nil
        if let secondarySourcesOverrideContainer = secondarySourcesOverrideContainer {
            secondarySourcesOverrideDecoded0 = [ProjectSource]()
            for structure0 in secondarySourcesOverrideContainer {
                if let structure0 = structure0 {
                    secondarySourcesOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondarySourcesOverride = secondarySourcesOverrideDecoded0
        let secondarySourcesVersionOverrideContainer = try containerValues.decodeIfPresent([ProjectSourceVersion?].self, forKey: .secondarySourcesVersionOverride)
        var secondarySourcesVersionOverrideDecoded0:[ProjectSourceVersion]? = nil
        if let secondarySourcesVersionOverrideContainer = secondarySourcesVersionOverrideContainer {
            secondarySourcesVersionOverrideDecoded0 = [ProjectSourceVersion]()
            for structure0 in secondarySourcesVersionOverrideContainer {
                if let structure0 = structure0 {
                    secondarySourcesVersionOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondarySourcesVersionOverride = secondarySourcesVersionOverrideDecoded0
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let artifactsOverrideDecoded = try containerValues.decodeIfPresent(ProjectArtifacts.self, forKey: .artifactsOverride)
        artifactsOverride = artifactsOverrideDecoded
        let secondaryArtifactsOverrideContainer = try containerValues.decodeIfPresent([ProjectArtifacts?].self, forKey: .secondaryArtifactsOverride)
        var secondaryArtifactsOverrideDecoded0:[ProjectArtifacts]? = nil
        if let secondaryArtifactsOverrideContainer = secondaryArtifactsOverrideContainer {
            secondaryArtifactsOverrideDecoded0 = [ProjectArtifacts]()
            for structure0 in secondaryArtifactsOverrideContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifactsOverride = secondaryArtifactsOverrideDecoded0
        let environmentVariablesOverrideContainer = try containerValues.decodeIfPresent([EnvironmentVariable?].self, forKey: .environmentVariablesOverride)
        var environmentVariablesOverrideDecoded0:[EnvironmentVariable]? = nil
        if let environmentVariablesOverrideContainer = environmentVariablesOverrideContainer {
            environmentVariablesOverrideDecoded0 = [EnvironmentVariable]()
            for structure0 in environmentVariablesOverrideContainer {
                if let structure0 = structure0 {
                    environmentVariablesOverrideDecoded0?.append(structure0)
                }
            }
        }
        environmentVariablesOverride = environmentVariablesOverrideDecoded0
        let sourceTypeOverrideDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceTypeOverride)
        sourceTypeOverride = sourceTypeOverrideDecoded
        let sourceLocationOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationOverride)
        sourceLocationOverride = sourceLocationOverrideDecoded
        let sourceAuthOverrideDecoded = try containerValues.decodeIfPresent(SourceAuth.self, forKey: .sourceAuthOverride)
        sourceAuthOverride = sourceAuthOverrideDecoded
        let gitCloneDepthOverrideDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .gitCloneDepthOverride)
        gitCloneDepthOverride = gitCloneDepthOverrideDecoded
        let gitSubmodulesConfigOverrideDecoded = try containerValues.decodeIfPresent(GitSubmodulesConfig.self, forKey: .gitSubmodulesConfigOverride)
        gitSubmodulesConfigOverride = gitSubmodulesConfigOverrideDecoded
        let buildspecOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildspecOverride)
        buildspecOverride = buildspecOverrideDecoded
        let insecureSslOverrideDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .insecureSslOverride)
        insecureSslOverride = insecureSslOverrideDecoded
        let reportBuildBatchStatusOverrideDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .reportBuildBatchStatusOverride)
        reportBuildBatchStatusOverride = reportBuildBatchStatusOverrideDecoded
        let environmentTypeOverrideDecoded = try containerValues.decodeIfPresent(EnvironmentType.self, forKey: .environmentTypeOverride)
        environmentTypeOverride = environmentTypeOverrideDecoded
        let imageOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageOverride)
        imageOverride = imageOverrideDecoded
        let computeTypeOverrideDecoded = try containerValues.decodeIfPresent(ComputeType.self, forKey: .computeTypeOverride)
        computeTypeOverride = computeTypeOverrideDecoded
        let certificateOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateOverride)
        certificateOverride = certificateOverrideDecoded
        let cacheOverrideDecoded = try containerValues.decodeIfPresent(ProjectCache.self, forKey: .cacheOverride)
        cacheOverride = cacheOverrideDecoded
        let serviceRoleOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleOverride)
        serviceRoleOverride = serviceRoleOverrideDecoded
        let privilegedModeOverrideDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .privilegedModeOverride)
        privilegedModeOverride = privilegedModeOverrideDecoded
        let buildTimeoutInMinutesOverrideDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .buildTimeoutInMinutesOverride)
        buildTimeoutInMinutesOverride = buildTimeoutInMinutesOverrideDecoded
        let queuedTimeoutInMinutesOverrideDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queuedTimeoutInMinutesOverride)
        queuedTimeoutInMinutesOverride = queuedTimeoutInMinutesOverrideDecoded
        let encryptionKeyOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyOverride)
        encryptionKeyOverride = encryptionKeyOverrideDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let logsConfigOverrideDecoded = try containerValues.decodeIfPresent(LogsConfig.self, forKey: .logsConfigOverride)
        logsConfigOverride = logsConfigOverrideDecoded
        let registryCredentialOverrideDecoded = try containerValues.decodeIfPresent(RegistryCredential.self, forKey: .registryCredentialOverride)
        registryCredentialOverride = registryCredentialOverrideDecoded
        let imagePullCredentialsTypeOverrideDecoded = try containerValues.decodeIfPresent(ImagePullCredentialsType.self, forKey: .imagePullCredentialsTypeOverride)
        imagePullCredentialsTypeOverride = imagePullCredentialsTypeOverrideDecoded
        let buildBatchConfigOverrideDecoded = try containerValues.decodeIfPresent(ProjectBuildBatchConfig.self, forKey: .buildBatchConfigOverride)
        buildBatchConfigOverride = buildBatchConfigOverrideDecoded
        let debugSessionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .debugSessionEnabled)
        debugSessionEnabled = debugSessionEnabledDecoded
    }
}

extension StartBuildBatchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBuildBatchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartBuildBatchOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBuildBatchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartBuildBatchOutputResponse(buildBatch: \(String(describing: buildBatch)))"}
}

extension StartBuildBatchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartBuildBatchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.buildBatch = output.buildBatch
        } else {
            self.buildBatch = nil
        }
    }
}

public struct StartBuildBatchOutputResponse: Equatable {
    /// <p>A <code>BuildBatch</code> object that contains information about the batch build.</p>
    public let buildBatch: BuildBatch?

    public init (
        buildBatch: BuildBatch? = nil
    )
    {
        self.buildBatch = buildBatch
    }
}

struct StartBuildBatchOutputResponseBody: Equatable {
    public let buildBatch: BuildBatch?
}

extension StartBuildBatchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case buildBatch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildBatchDecoded = try containerValues.decodeIfPresent(BuildBatch.self, forKey: .buildBatch)
        buildBatch = buildBatchDecoded
    }
}

public struct StartBuildInputBodyMiddleware: Middleware {
    public let id: String = "StartBuildInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBuildInput>
    public typealias MOutput = OperationOutput<StartBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBuildOutputError>
}

extension StartBuildInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartBuildInput(artifactsOverride: \(String(describing: artifactsOverride)), buildStatusConfigOverride: \(String(describing: buildStatusConfigOverride)), buildspecOverride: \(String(describing: buildspecOverride)), cacheOverride: \(String(describing: cacheOverride)), certificateOverride: \(String(describing: certificateOverride)), computeTypeOverride: \(String(describing: computeTypeOverride)), debugSessionEnabled: \(String(describing: debugSessionEnabled)), encryptionKeyOverride: \(String(describing: encryptionKeyOverride)), environmentTypeOverride: \(String(describing: environmentTypeOverride)), environmentVariablesOverride: \(String(describing: environmentVariablesOverride)), gitCloneDepthOverride: \(String(describing: gitCloneDepthOverride)), gitSubmodulesConfigOverride: \(String(describing: gitSubmodulesConfigOverride)), idempotencyToken: \(String(describing: idempotencyToken)), imageOverride: \(String(describing: imageOverride)), imagePullCredentialsTypeOverride: \(String(describing: imagePullCredentialsTypeOverride)), insecureSslOverride: \(String(describing: insecureSslOverride)), logsConfigOverride: \(String(describing: logsConfigOverride)), privilegedModeOverride: \(String(describing: privilegedModeOverride)), projectName: \(String(describing: projectName)), queuedTimeoutInMinutesOverride: \(String(describing: queuedTimeoutInMinutesOverride)), registryCredentialOverride: \(String(describing: registryCredentialOverride)), reportBuildStatusOverride: \(String(describing: reportBuildStatusOverride)), secondaryArtifactsOverride: \(String(describing: secondaryArtifactsOverride)), secondarySourcesOverride: \(String(describing: secondarySourcesOverride)), secondarySourcesVersionOverride: \(String(describing: secondarySourcesVersionOverride)), serviceRoleOverride: \(String(describing: serviceRoleOverride)), sourceAuthOverride: \(String(describing: sourceAuthOverride)), sourceLocationOverride: \(String(describing: sourceLocationOverride)), sourceTypeOverride: \(String(describing: sourceTypeOverride)), sourceVersion: \(String(describing: sourceVersion)), timeoutInMinutesOverride: \(String(describing: timeoutInMinutesOverride)))"}
}

extension StartBuildInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactsOverride
        case buildStatusConfigOverride
        case buildspecOverride
        case cacheOverride
        case certificateOverride
        case computeTypeOverride
        case debugSessionEnabled
        case encryptionKeyOverride
        case environmentTypeOverride
        case environmentVariablesOverride
        case gitCloneDepthOverride
        case gitSubmodulesConfigOverride
        case idempotencyToken
        case imageOverride
        case imagePullCredentialsTypeOverride
        case insecureSslOverride
        case logsConfigOverride
        case privilegedModeOverride
        case projectName
        case queuedTimeoutInMinutesOverride
        case registryCredentialOverride
        case reportBuildStatusOverride
        case secondaryArtifactsOverride
        case secondarySourcesOverride
        case secondarySourcesVersionOverride
        case serviceRoleOverride
        case sourceAuthOverride
        case sourceLocationOverride
        case sourceTypeOverride
        case sourceVersion
        case timeoutInMinutesOverride
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsOverride = artifactsOverride {
            try encodeContainer.encode(artifactsOverride, forKey: .artifactsOverride)
        }
        if let buildStatusConfigOverride = buildStatusConfigOverride {
            try encodeContainer.encode(buildStatusConfigOverride, forKey: .buildStatusConfigOverride)
        }
        if let buildspecOverride = buildspecOverride {
            try encodeContainer.encode(buildspecOverride, forKey: .buildspecOverride)
        }
        if let cacheOverride = cacheOverride {
            try encodeContainer.encode(cacheOverride, forKey: .cacheOverride)
        }
        if let certificateOverride = certificateOverride {
            try encodeContainer.encode(certificateOverride, forKey: .certificateOverride)
        }
        if let computeTypeOverride = computeTypeOverride {
            try encodeContainer.encode(computeTypeOverride.rawValue, forKey: .computeTypeOverride)
        }
        if let debugSessionEnabled = debugSessionEnabled {
            try encodeContainer.encode(debugSessionEnabled, forKey: .debugSessionEnabled)
        }
        if let encryptionKeyOverride = encryptionKeyOverride {
            try encodeContainer.encode(encryptionKeyOverride, forKey: .encryptionKeyOverride)
        }
        if let environmentTypeOverride = environmentTypeOverride {
            try encodeContainer.encode(environmentTypeOverride.rawValue, forKey: .environmentTypeOverride)
        }
        if let environmentVariablesOverride = environmentVariablesOverride {
            var environmentVariablesOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentVariablesOverride)
            for environmentvariables0 in environmentVariablesOverride {
                try environmentVariablesOverrideContainer.encode(environmentvariables0)
            }
        }
        if let gitCloneDepthOverride = gitCloneDepthOverride {
            try encodeContainer.encode(gitCloneDepthOverride, forKey: .gitCloneDepthOverride)
        }
        if let gitSubmodulesConfigOverride = gitSubmodulesConfigOverride {
            try encodeContainer.encode(gitSubmodulesConfigOverride, forKey: .gitSubmodulesConfigOverride)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let imageOverride = imageOverride {
            try encodeContainer.encode(imageOverride, forKey: .imageOverride)
        }
        if let imagePullCredentialsTypeOverride = imagePullCredentialsTypeOverride {
            try encodeContainer.encode(imagePullCredentialsTypeOverride.rawValue, forKey: .imagePullCredentialsTypeOverride)
        }
        if let insecureSslOverride = insecureSslOverride {
            try encodeContainer.encode(insecureSslOverride, forKey: .insecureSslOverride)
        }
        if let logsConfigOverride = logsConfigOverride {
            try encodeContainer.encode(logsConfigOverride, forKey: .logsConfigOverride)
        }
        if let privilegedModeOverride = privilegedModeOverride {
            try encodeContainer.encode(privilegedModeOverride, forKey: .privilegedModeOverride)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let queuedTimeoutInMinutesOverride = queuedTimeoutInMinutesOverride {
            try encodeContainer.encode(queuedTimeoutInMinutesOverride, forKey: .queuedTimeoutInMinutesOverride)
        }
        if let registryCredentialOverride = registryCredentialOverride {
            try encodeContainer.encode(registryCredentialOverride, forKey: .registryCredentialOverride)
        }
        if let reportBuildStatusOverride = reportBuildStatusOverride {
            try encodeContainer.encode(reportBuildStatusOverride, forKey: .reportBuildStatusOverride)
        }
        if let secondaryArtifactsOverride = secondaryArtifactsOverride {
            var secondaryArtifactsOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifactsOverride)
            for projectartifactslist0 in secondaryArtifactsOverride {
                try secondaryArtifactsOverrideContainer.encode(projectartifactslist0)
            }
        }
        if let secondarySourcesOverride = secondarySourcesOverride {
            var secondarySourcesOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourcesOverride)
            for projectsources0 in secondarySourcesOverride {
                try secondarySourcesOverrideContainer.encode(projectsources0)
            }
        }
        if let secondarySourcesVersionOverride = secondarySourcesVersionOverride {
            var secondarySourcesVersionOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourcesVersionOverride)
            for projectsecondarysourceversions0 in secondarySourcesVersionOverride {
                try secondarySourcesVersionOverrideContainer.encode(projectsecondarysourceversions0)
            }
        }
        if let serviceRoleOverride = serviceRoleOverride {
            try encodeContainer.encode(serviceRoleOverride, forKey: .serviceRoleOverride)
        }
        if let sourceAuthOverride = sourceAuthOverride {
            try encodeContainer.encode(sourceAuthOverride, forKey: .sourceAuthOverride)
        }
        if let sourceLocationOverride = sourceLocationOverride {
            try encodeContainer.encode(sourceLocationOverride, forKey: .sourceLocationOverride)
        }
        if let sourceTypeOverride = sourceTypeOverride {
            try encodeContainer.encode(sourceTypeOverride.rawValue, forKey: .sourceTypeOverride)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let timeoutInMinutesOverride = timeoutInMinutesOverride {
            try encodeContainer.encode(timeoutInMinutesOverride, forKey: .timeoutInMinutesOverride)
        }
    }
}

public struct StartBuildInputHeadersMiddleware: Middleware {
    public let id: String = "StartBuildInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBuildInput>
    public typealias MOutput = OperationOutput<StartBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBuildOutputError>
}

public struct StartBuildInputQueryItemMiddleware: Middleware {
    public let id: String = "StartBuildInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBuildInput>
    public typealias MOutput = OperationOutput<StartBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBuildOutputError>
}

public struct StartBuildInput: Equatable {
    /// <p>Build output artifact settings that override, for this build only, the latest ones
    ///             already defined in the build project.</p>
    public let artifactsOverride: ProjectArtifacts?
    /// <p>Contains information that defines how the build project reports the build status to
    ///             the source provider. This option is only used when the source provider is
    ///                 <code>GITHUB</code>, <code>GITHUB_ENTERPRISE</code>, or
    ///             <code>BITBUCKET</code>.</p>
    public let buildStatusConfigOverride: BuildStatusConfig?
    /// <p>A buildspec file declaration that overrides, for this build only, the latest one
    ///             already defined in the build project.</p>
    ///         <p> If this value is set, it can be either an inline buildspec definition, the path to an
    ///             alternate buildspec file relative to the value of the built-in
    ///                 <code>CODEBUILD_SRC_DIR</code> environment variable, or the path to an S3 bucket.
    ///             The bucket must be in the same AWS Region as the build project. Specify the buildspec
    ///             file using its ARN (for example,
    ///                 <code>arn:aws:s3:::my-codebuild-sample2/buildspec.yml</code>). If this value is not
    ///             provided or is set to an empty string, the source code must contain a buildspec file in
    ///             its root directory. For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-name-storage">Buildspec File Name and Storage Location</a>. </p>
    public let buildspecOverride: String?
    /// <p>A ProjectCache object specified for this build that overrides the one defined in the
    ///             build project.</p>
    public let cacheOverride: ProjectCache?
    /// <p>The name of a certificate for this build that overrides the one specified in the build
    ///             project.</p>
    public let certificateOverride: String?
    /// <p>The name of a compute type for this build that overrides the one specified in the
    ///             build project.</p>
    public let computeTypeOverride: ComputeType?
    /// <p>Specifies if session debugging is enabled for this build. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/session-manager.html">Viewing a running build in Session Manager</a>.</p>
    public let debugSessionEnabled: Bool?
    /// <p>The AWS Key Management Service (AWS KMS) customer master key (CMK) that overrides the one specified in the build
    ///             project. The CMK key encrypts the build output artifacts.</p>
    ///         <note>
    ///             <p> You can use a cross-account KMS key to encrypt the build output artifacts if your
    ///                 service role has permission to that key. </p>
    ///         </note>
    ///         <p>You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using
    ///             the format <code>alias/<alias-name></code>).</p>
    public let encryptionKeyOverride: String?
    /// <p>A container type for this build that overrides the one specified in the build
    ///             project.</p>
    public let environmentTypeOverride: EnvironmentType?
    /// <p>A set of environment variables that overrides, for this build only, the latest ones
    ///             already defined in the build project.</p>
    public let environmentVariablesOverride: [EnvironmentVariable]?
    /// <p>The user-defined depth of history, with a minimum value of 0, that overrides, for this
    ///             build only, any previous depth of history defined in the build project.</p>
    public let gitCloneDepthOverride: Int?
    /// <p> Information about the Git submodules configuration for this build of an AWS CodeBuild build
    ///             project. </p>
    public let gitSubmodulesConfigOverride: GitSubmodulesConfig?
    /// <p>A unique, case sensitive identifier you provide to ensure the idempotency of the
    ///             StartBuild request. The token is included in the StartBuild request and is valid for 5
    ///             minutes. If you repeat the StartBuild request with the same token, but change a
    ///             parameter, AWS CodeBuild returns a parameter mismatch error. </p>
    public let idempotencyToken: String?
    /// <p>The name of an image for this build that overrides the one specified in the build
    ///             project.</p>
    public let imageOverride: String?
    /// <p>The type of credentials AWS CodeBuild uses to pull images in your build. There are two valid
    ///             values: </p>
    ///         <dl>
    ///             <dt>CODEBUILD</dt>
    ///             <dd>
    ///                     <p>Specifies that AWS CodeBuild uses its own credentials. This requires that you
    ///                         modify your ECR repository policy to trust AWS CodeBuild's service principal.</p>
    ///                 </dd>
    ///             <dt>SERVICE_ROLE</dt>
    ///             <dd>
    ///                     <p>Specifies that AWS CodeBuild uses your build project's service role. </p>
    ///                 </dd>
    ///          </dl>
    ///         <p>When using a cross-account or private registry image, you must use
    ///             <code>SERVICE_ROLE</code> credentials. When using an AWS CodeBuild curated image,
    ///             you must use <code>CODEBUILD</code> credentials. </p>
    public let imagePullCredentialsTypeOverride: ImagePullCredentialsType?
    /// <p>Enable this flag to override the insecure SSL setting that is specified in the build
    ///             project. The insecure SSL setting determines whether to ignore SSL warnings while
    ///             connecting to the project source code. This override applies only if the build's source
    ///             is GitHub Enterprise.</p>
    public let insecureSslOverride: Bool?
    /// <p> Log settings for this build that override the log settings defined in the build
    ///             project. </p>
    public let logsConfigOverride: LogsConfig?
    /// <p>Enable this flag to override privileged mode in the build project.</p>
    public let privilegedModeOverride: Bool?
    /// <p>The name of the AWS CodeBuild build project to start running a build.</p>
    public let projectName: String?
    /// <p> The number of minutes a build is allowed to be queued before it times out. </p>
    public let queuedTimeoutInMinutesOverride: Int?
    /// <p> The credentials for access to a private registry. </p>
    public let registryCredentialOverride: RegistryCredential?
    /// <p> Set to true to report to your source provider the status of a build's start and
    ///             completion. If you use this option with a source provider other than GitHub, GitHub
    ///             Enterprise, or Bitbucket, an <code>invalidInputException</code> is thrown. </p>
    ///             <p>To be able to report the build status to the source provider, the user associated with the source provider must
    /// have write access to the repo. If the user does not have write access, the build status cannot be updated. For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/access-tokens.html">Source provider access</a> in the <i>AWS CodeBuild User Guide</i>.</p>
    ///         <note>
    ///             <p> The status of a build triggered by a webhook is always reported to your source
    ///                 provider. </p>
    ///         </note>
    public let reportBuildStatusOverride: Bool?
    /// <p> An array of <code>ProjectArtifacts</code> objects. </p>
    public let secondaryArtifactsOverride: [ProjectArtifacts]?
    /// <p> An array of <code>ProjectSource</code> objects. </p>
    public let secondarySourcesOverride: [ProjectSource]?
    /// <p> An array of <code>ProjectSourceVersion</code> objects that specify one or more
    ///             versions of the project's secondary sources to be used for this build only. </p>
    public let secondarySourcesVersionOverride: [ProjectSourceVersion]?
    /// <p>The name of a service role for this build that overrides the one specified in the
    ///             build project.</p>
    public let serviceRoleOverride: String?
    /// <p>An authorization type for this build that overrides the one defined in the build
    ///             project. This override applies only if the build project's source is BitBucket or
    ///             GitHub.</p>
    public let sourceAuthOverride: SourceAuth?
    /// <p>A location that overrides, for this build, the source location for the one defined in
    ///             the build project.</p>
    public let sourceLocationOverride: String?
    /// <p>A source input type, for this build, that overrides the source input defined in the
    ///             build project.</p>
    public let sourceTypeOverride: SourceType?
    /// <p>The version of the build input to be built, for this build only. If not specified,
    ///             the latest version is used. If specified, the contents depends on the source
    ///             provider:</p>
    ///         <dl>
    ///             <dt>AWS CodeCommit</dt>
    ///             <dd>
    ///                     <p>The commit ID, branch, or Git tag to use.</p>
    ///                 </dd>
    ///             <dt>GitHub</dt>
    ///             <dd>
    ///                     <p>The commit ID, pull request ID, branch name, or tag name that corresponds
    ///                         to the version of the source code you want to build. If a pull request ID is
    ///                         specified, it must use the format <code>pr/pull-request-ID</code> (for
    ///                         example <code>pr/25</code>). If a branch name is specified, the branch's
    ///                         HEAD commit ID is used. If not specified, the default branch's HEAD commit
    ///                         ID is used.</p>
    ///                 </dd>
    ///             <dt>Bitbucket</dt>
    ///             <dd>
    ///                     <p>The commit ID, branch name, or tag name that corresponds to the version of
    ///                         the source code you want to build. If a branch name is specified, the
    ///                         branch's HEAD commit ID is used. If not specified, the default branch's HEAD
    ///                         commit ID is used.</p>
    ///                 </dd>
    ///             <dt>Amazon S3</dt>
    ///             <dd>
    ///                     <p>The version ID of the object that represents the build input ZIP file to
    ///                         use.</p>
    ///                 </dd>
    ///          </dl>
    ///         <p>If <code>sourceVersion</code> is specified at the project level, then this
    ///             <code>sourceVersion</code> (at the build level) takes precedence. </p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html">Source Version Sample
    ///             with CodeBuild</a> in the <i>AWS CodeBuild User Guide</i>. </p>
    public let sourceVersion: String?
    /// <p>The number of build timeout minutes, from 5 to 480 (8 hours), that overrides, for this
    ///             build only, the latest setting already defined in the build project.</p>
    public let timeoutInMinutesOverride: Int?

    public init (
        artifactsOverride: ProjectArtifacts? = nil,
        buildStatusConfigOverride: BuildStatusConfig? = nil,
        buildspecOverride: String? = nil,
        cacheOverride: ProjectCache? = nil,
        certificateOverride: String? = nil,
        computeTypeOverride: ComputeType? = nil,
        debugSessionEnabled: Bool? = nil,
        encryptionKeyOverride: String? = nil,
        environmentTypeOverride: EnvironmentType? = nil,
        environmentVariablesOverride: [EnvironmentVariable]? = nil,
        gitCloneDepthOverride: Int? = nil,
        gitSubmodulesConfigOverride: GitSubmodulesConfig? = nil,
        idempotencyToken: String? = nil,
        imageOverride: String? = nil,
        imagePullCredentialsTypeOverride: ImagePullCredentialsType? = nil,
        insecureSslOverride: Bool? = nil,
        logsConfigOverride: LogsConfig? = nil,
        privilegedModeOverride: Bool? = nil,
        projectName: String? = nil,
        queuedTimeoutInMinutesOverride: Int? = nil,
        registryCredentialOverride: RegistryCredential? = nil,
        reportBuildStatusOverride: Bool? = nil,
        secondaryArtifactsOverride: [ProjectArtifacts]? = nil,
        secondarySourcesOverride: [ProjectSource]? = nil,
        secondarySourcesVersionOverride: [ProjectSourceVersion]? = nil,
        serviceRoleOverride: String? = nil,
        sourceAuthOverride: SourceAuth? = nil,
        sourceLocationOverride: String? = nil,
        sourceTypeOverride: SourceType? = nil,
        sourceVersion: String? = nil,
        timeoutInMinutesOverride: Int? = nil
    )
    {
        self.artifactsOverride = artifactsOverride
        self.buildStatusConfigOverride = buildStatusConfigOverride
        self.buildspecOverride = buildspecOverride
        self.cacheOverride = cacheOverride
        self.certificateOverride = certificateOverride
        self.computeTypeOverride = computeTypeOverride
        self.debugSessionEnabled = debugSessionEnabled
        self.encryptionKeyOverride = encryptionKeyOverride
        self.environmentTypeOverride = environmentTypeOverride
        self.environmentVariablesOverride = environmentVariablesOverride
        self.gitCloneDepthOverride = gitCloneDepthOverride
        self.gitSubmodulesConfigOverride = gitSubmodulesConfigOverride
        self.idempotencyToken = idempotencyToken
        self.imageOverride = imageOverride
        self.imagePullCredentialsTypeOverride = imagePullCredentialsTypeOverride
        self.insecureSslOverride = insecureSslOverride
        self.logsConfigOverride = logsConfigOverride
        self.privilegedModeOverride = privilegedModeOverride
        self.projectName = projectName
        self.queuedTimeoutInMinutesOverride = queuedTimeoutInMinutesOverride
        self.registryCredentialOverride = registryCredentialOverride
        self.reportBuildStatusOverride = reportBuildStatusOverride
        self.secondaryArtifactsOverride = secondaryArtifactsOverride
        self.secondarySourcesOverride = secondarySourcesOverride
        self.secondarySourcesVersionOverride = secondarySourcesVersionOverride
        self.serviceRoleOverride = serviceRoleOverride
        self.sourceAuthOverride = sourceAuthOverride
        self.sourceLocationOverride = sourceLocationOverride
        self.sourceTypeOverride = sourceTypeOverride
        self.sourceVersion = sourceVersion
        self.timeoutInMinutesOverride = timeoutInMinutesOverride
    }
}

struct StartBuildInputBody: Equatable {
    public let projectName: String?
    public let secondarySourcesOverride: [ProjectSource]?
    public let secondarySourcesVersionOverride: [ProjectSourceVersion]?
    public let sourceVersion: String?
    public let artifactsOverride: ProjectArtifacts?
    public let secondaryArtifactsOverride: [ProjectArtifacts]?
    public let environmentVariablesOverride: [EnvironmentVariable]?
    public let sourceTypeOverride: SourceType?
    public let sourceLocationOverride: String?
    public let sourceAuthOverride: SourceAuth?
    public let gitCloneDepthOverride: Int?
    public let gitSubmodulesConfigOverride: GitSubmodulesConfig?
    public let buildspecOverride: String?
    public let insecureSslOverride: Bool?
    public let reportBuildStatusOverride: Bool?
    public let buildStatusConfigOverride: BuildStatusConfig?
    public let environmentTypeOverride: EnvironmentType?
    public let imageOverride: String?
    public let computeTypeOverride: ComputeType?
    public let certificateOverride: String?
    public let cacheOverride: ProjectCache?
    public let serviceRoleOverride: String?
    public let privilegedModeOverride: Bool?
    public let timeoutInMinutesOverride: Int?
    public let queuedTimeoutInMinutesOverride: Int?
    public let encryptionKeyOverride: String?
    public let idempotencyToken: String?
    public let logsConfigOverride: LogsConfig?
    public let registryCredentialOverride: RegistryCredential?
    public let imagePullCredentialsTypeOverride: ImagePullCredentialsType?
    public let debugSessionEnabled: Bool?
}

extension StartBuildInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case artifactsOverride
        case buildStatusConfigOverride
        case buildspecOverride
        case cacheOverride
        case certificateOverride
        case computeTypeOverride
        case debugSessionEnabled
        case encryptionKeyOverride
        case environmentTypeOverride
        case environmentVariablesOverride
        case gitCloneDepthOverride
        case gitSubmodulesConfigOverride
        case idempotencyToken
        case imageOverride
        case imagePullCredentialsTypeOverride
        case insecureSslOverride
        case logsConfigOverride
        case privilegedModeOverride
        case projectName
        case queuedTimeoutInMinutesOverride
        case registryCredentialOverride
        case reportBuildStatusOverride
        case secondaryArtifactsOverride
        case secondarySourcesOverride
        case secondarySourcesVersionOverride
        case serviceRoleOverride
        case sourceAuthOverride
        case sourceLocationOverride
        case sourceTypeOverride
        case sourceVersion
        case timeoutInMinutesOverride
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let secondarySourcesOverrideContainer = try containerValues.decodeIfPresent([ProjectSource?].self, forKey: .secondarySourcesOverride)
        var secondarySourcesOverrideDecoded0:[ProjectSource]? = nil
        if let secondarySourcesOverrideContainer = secondarySourcesOverrideContainer {
            secondarySourcesOverrideDecoded0 = [ProjectSource]()
            for structure0 in secondarySourcesOverrideContainer {
                if let structure0 = structure0 {
                    secondarySourcesOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondarySourcesOverride = secondarySourcesOverrideDecoded0
        let secondarySourcesVersionOverrideContainer = try containerValues.decodeIfPresent([ProjectSourceVersion?].self, forKey: .secondarySourcesVersionOverride)
        var secondarySourcesVersionOverrideDecoded0:[ProjectSourceVersion]? = nil
        if let secondarySourcesVersionOverrideContainer = secondarySourcesVersionOverrideContainer {
            secondarySourcesVersionOverrideDecoded0 = [ProjectSourceVersion]()
            for structure0 in secondarySourcesVersionOverrideContainer {
                if let structure0 = structure0 {
                    secondarySourcesVersionOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondarySourcesVersionOverride = secondarySourcesVersionOverrideDecoded0
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let artifactsOverrideDecoded = try containerValues.decodeIfPresent(ProjectArtifacts.self, forKey: .artifactsOverride)
        artifactsOverride = artifactsOverrideDecoded
        let secondaryArtifactsOverrideContainer = try containerValues.decodeIfPresent([ProjectArtifacts?].self, forKey: .secondaryArtifactsOverride)
        var secondaryArtifactsOverrideDecoded0:[ProjectArtifacts]? = nil
        if let secondaryArtifactsOverrideContainer = secondaryArtifactsOverrideContainer {
            secondaryArtifactsOverrideDecoded0 = [ProjectArtifacts]()
            for structure0 in secondaryArtifactsOverrideContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifactsOverride = secondaryArtifactsOverrideDecoded0
        let environmentVariablesOverrideContainer = try containerValues.decodeIfPresent([EnvironmentVariable?].self, forKey: .environmentVariablesOverride)
        var environmentVariablesOverrideDecoded0:[EnvironmentVariable]? = nil
        if let environmentVariablesOverrideContainer = environmentVariablesOverrideContainer {
            environmentVariablesOverrideDecoded0 = [EnvironmentVariable]()
            for structure0 in environmentVariablesOverrideContainer {
                if let structure0 = structure0 {
                    environmentVariablesOverrideDecoded0?.append(structure0)
                }
            }
        }
        environmentVariablesOverride = environmentVariablesOverrideDecoded0
        let sourceTypeOverrideDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceTypeOverride)
        sourceTypeOverride = sourceTypeOverrideDecoded
        let sourceLocationOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationOverride)
        sourceLocationOverride = sourceLocationOverrideDecoded
        let sourceAuthOverrideDecoded = try containerValues.decodeIfPresent(SourceAuth.self, forKey: .sourceAuthOverride)
        sourceAuthOverride = sourceAuthOverrideDecoded
        let gitCloneDepthOverrideDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .gitCloneDepthOverride)
        gitCloneDepthOverride = gitCloneDepthOverrideDecoded
        let gitSubmodulesConfigOverrideDecoded = try containerValues.decodeIfPresent(GitSubmodulesConfig.self, forKey: .gitSubmodulesConfigOverride)
        gitSubmodulesConfigOverride = gitSubmodulesConfigOverrideDecoded
        let buildspecOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildspecOverride)
        buildspecOverride = buildspecOverrideDecoded
        let insecureSslOverrideDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .insecureSslOverride)
        insecureSslOverride = insecureSslOverrideDecoded
        let reportBuildStatusOverrideDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .reportBuildStatusOverride)
        reportBuildStatusOverride = reportBuildStatusOverrideDecoded
        let buildStatusConfigOverrideDecoded = try containerValues.decodeIfPresent(BuildStatusConfig.self, forKey: .buildStatusConfigOverride)
        buildStatusConfigOverride = buildStatusConfigOverrideDecoded
        let environmentTypeOverrideDecoded = try containerValues.decodeIfPresent(EnvironmentType.self, forKey: .environmentTypeOverride)
        environmentTypeOverride = environmentTypeOverrideDecoded
        let imageOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageOverride)
        imageOverride = imageOverrideDecoded
        let computeTypeOverrideDecoded = try containerValues.decodeIfPresent(ComputeType.self, forKey: .computeTypeOverride)
        computeTypeOverride = computeTypeOverrideDecoded
        let certificateOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateOverride)
        certificateOverride = certificateOverrideDecoded
        let cacheOverrideDecoded = try containerValues.decodeIfPresent(ProjectCache.self, forKey: .cacheOverride)
        cacheOverride = cacheOverrideDecoded
        let serviceRoleOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleOverride)
        serviceRoleOverride = serviceRoleOverrideDecoded
        let privilegedModeOverrideDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .privilegedModeOverride)
        privilegedModeOverride = privilegedModeOverrideDecoded
        let timeoutInMinutesOverrideDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInMinutesOverride)
        timeoutInMinutesOverride = timeoutInMinutesOverrideDecoded
        let queuedTimeoutInMinutesOverrideDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queuedTimeoutInMinutesOverride)
        queuedTimeoutInMinutesOverride = queuedTimeoutInMinutesOverrideDecoded
        let encryptionKeyOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyOverride)
        encryptionKeyOverride = encryptionKeyOverrideDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let logsConfigOverrideDecoded = try containerValues.decodeIfPresent(LogsConfig.self, forKey: .logsConfigOverride)
        logsConfigOverride = logsConfigOverrideDecoded
        let registryCredentialOverrideDecoded = try containerValues.decodeIfPresent(RegistryCredential.self, forKey: .registryCredentialOverride)
        registryCredentialOverride = registryCredentialOverrideDecoded
        let imagePullCredentialsTypeOverrideDecoded = try containerValues.decodeIfPresent(ImagePullCredentialsType.self, forKey: .imagePullCredentialsTypeOverride)
        imagePullCredentialsTypeOverride = imagePullCredentialsTypeOverrideDecoded
        let debugSessionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .debugSessionEnabled)
        debugSessionEnabled = debugSessionEnabledDecoded
    }
}

extension StartBuildOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBuildOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountLimitExceededException" : self = .accountLimitExceededException(try AccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartBuildOutputError: Equatable {
    case accountLimitExceededException(AccountLimitExceededException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBuildOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartBuildOutputResponse(build: \(String(describing: build)))"}
}

extension StartBuildOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartBuildOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.build = output.build
        } else {
            self.build = nil
        }
    }
}

public struct StartBuildOutputResponse: Equatable {
    /// <p>Information about the build to be run.</p>
    public let build: Build?

    public init (
        build: Build? = nil
    )
    {
        self.build = build
    }
}

struct StartBuildOutputResponseBody: Equatable {
    public let build: Build?
}

extension StartBuildOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case build
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildDecoded = try containerValues.decodeIfPresent(Build.self, forKey: .build)
        build = buildDecoded
    }
}

public enum StatusType {
    case failed
    case fault
    case inProgress
    case stopped
    case succeeded
    case timedOut
    case sdkUnknown(String)
}

extension StatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StatusType] {
        return [
            .failed,
            .fault,
            .inProgress,
            .stopped,
            .succeeded,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .fault: return "FAULT"
        case .inProgress: return "IN_PROGRESS"
        case .stopped: return "STOPPED"
        case .succeeded: return "SUCCEEDED"
        case .timedOut: return "TIMED_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StatusType(rawValue: rawValue) ?? StatusType.sdkUnknown(rawValue)
    }
}

public struct StopBuildBatchInputBodyMiddleware: Middleware {
    public let id: String = "StopBuildBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBuildBatchInput>
    public typealias MOutput = OperationOutput<StopBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBuildBatchOutputError>
}

extension StopBuildBatchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopBuildBatchInput(id: \(String(describing: id)))"}
}

extension StopBuildBatchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct StopBuildBatchInputHeadersMiddleware: Middleware {
    public let id: String = "StopBuildBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBuildBatchInput>
    public typealias MOutput = OperationOutput<StopBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBuildBatchOutputError>
}

public struct StopBuildBatchInputQueryItemMiddleware: Middleware {
    public let id: String = "StopBuildBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBuildBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBuildBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBuildBatchInput>
    public typealias MOutput = OperationOutput<StopBuildBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBuildBatchOutputError>
}

public struct StopBuildBatchInput: Equatable {
    /// <p>The identifier of the batch build to stop.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct StopBuildBatchInputBody: Equatable {
    public let id: String?
}

extension StopBuildBatchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension StopBuildBatchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopBuildBatchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopBuildBatchOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopBuildBatchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopBuildBatchOutputResponse(buildBatch: \(String(describing: buildBatch)))"}
}

extension StopBuildBatchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopBuildBatchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.buildBatch = output.buildBatch
        } else {
            self.buildBatch = nil
        }
    }
}

public struct StopBuildBatchOutputResponse: Equatable {
    /// <p>Contains information about a batch build.</p>
    public let buildBatch: BuildBatch?

    public init (
        buildBatch: BuildBatch? = nil
    )
    {
        self.buildBatch = buildBatch
    }
}

struct StopBuildBatchOutputResponseBody: Equatable {
    public let buildBatch: BuildBatch?
}

extension StopBuildBatchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case buildBatch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildBatchDecoded = try containerValues.decodeIfPresent(BuildBatch.self, forKey: .buildBatch)
        buildBatch = buildBatchDecoded
    }
}

public struct StopBuildInputBodyMiddleware: Middleware {
    public let id: String = "StopBuildInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBuildInput>
    public typealias MOutput = OperationOutput<StopBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBuildOutputError>
}

extension StopBuildInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopBuildInput(id: \(String(describing: id)))"}
}

extension StopBuildInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct StopBuildInputHeadersMiddleware: Middleware {
    public let id: String = "StopBuildInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBuildInput>
    public typealias MOutput = OperationOutput<StopBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBuildOutputError>
}

public struct StopBuildInputQueryItemMiddleware: Middleware {
    public let id: String = "StopBuildInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBuildInput>
    public typealias MOutput = OperationOutput<StopBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBuildOutputError>
}

public struct StopBuildInput: Equatable {
    /// <p>The ID of the build.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct StopBuildInputBody: Equatable {
    public let id: String?
}

extension StopBuildInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension StopBuildOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopBuildOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopBuildOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopBuildOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopBuildOutputResponse(build: \(String(describing: build)))"}
}

extension StopBuildOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopBuildOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.build = output.build
        } else {
            self.build = nil
        }
    }
}

public struct StopBuildOutputResponse: Equatable {
    /// <p>Information about the build.</p>
    public let build: Build?

    public init (
        build: Build? = nil
    )
    {
        self.build = build
    }
}

struct StopBuildOutputResponseBody: Equatable {
    public let build: Build?
}

extension StopBuildOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case build
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildDecoded = try containerValues.decodeIfPresent(Build.self, forKey: .build)
        build = buildDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A tag, consisting of a key and a value.</p>
///         <p>This tag is available for use by AWS services that support tags in AWS CodeBuild.</p>
public struct Tag: Equatable {
    /// <p>The tag's key.</p>
    public let key: String?
    /// <p>The tag's value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TestCase: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationInNanoSeconds
        case expired
        case message
        case name
        case prefix
        case reportArn
        case status
        case testRawDataPath
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInNanoSeconds = durationInNanoSeconds {
            try encodeContainer.encode(durationInNanoSeconds, forKey: .durationInNanoSeconds)
        }
        if let expired = expired {
            try encodeContainer.encode(expired.timeIntervalSince1970, forKey: .expired)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
        if let reportArn = reportArn {
            try encodeContainer.encode(reportArn, forKey: .reportArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let testRawDataPath = testRawDataPath {
            try encodeContainer.encode(testRawDataPath, forKey: .testRawDataPath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportArn)
        reportArn = reportArnDecoded
        let testRawDataPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testRawDataPath)
        testRawDataPath = testRawDataPathDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let durationInNanoSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInNanoSeconds)
        durationInNanoSeconds = durationInNanoSecondsDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let expiredDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expired)
        expired = expiredDecoded
    }
}

extension TestCase: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestCase(durationInNanoSeconds: \(String(describing: durationInNanoSeconds)), expired: \(String(describing: expired)), message: \(String(describing: message)), name: \(String(describing: name)), prefix: \(String(describing: prefix)), reportArn: \(String(describing: reportArn)), status: \(String(describing: status)), testRawDataPath: \(String(describing: testRawDataPath)))"}
}

/// <p> Information about a test case created using a framework such as NUnit or Cucumber. A
///             test case might be a unit test or a configuration test. </p>
public struct TestCase: Equatable {
    /// <p> The number of nanoseconds it took to run this test case. </p>
    public let durationInNanoSeconds: Int?
    /// <p> The date and time a test case expires. A test case expires 30 days after it is
    ///             created. An expired test case is not available to view in CodeBuild. </p>
    public let expired: Date?
    /// <p> A message associated with a test case. For example, an error message or stack trace.
    ///         </p>
    public let message: String?
    /// <p> The name of the test case. </p>
    public let name: String?
    /// <p> A string that is applied to a series of related test cases. CodeBuild generates the
    ///             prefix. The prefix depends on the framework used to generate the tests. </p>
    public let prefix: String?
    /// <p> The ARN of the report to which the test case belongs. </p>
    public let reportArn: String?
    /// <p> The status returned by the test case after it was run. Valid statuses are
    ///                 <code>SUCCEEDED</code>, <code>FAILED</code>, <code>ERROR</code>,
    ///                 <code>SKIPPED</code>, and <code>UNKNOWN</code>. </p>
    public let status: String?
    /// <p> The path to the raw data file that contains the test result. </p>
    public let testRawDataPath: String?

    public init (
        durationInNanoSeconds: Int? = nil,
        expired: Date? = nil,
        message: String? = nil,
        name: String? = nil,
        prefix: String? = nil,
        reportArn: String? = nil,
        status: String? = nil,
        testRawDataPath: String? = nil
    )
    {
        self.durationInNanoSeconds = durationInNanoSeconds
        self.expired = expired
        self.message = message
        self.name = name
        self.prefix = prefix
        self.reportArn = reportArn
        self.status = status
        self.testRawDataPath = testRawDataPath
    }
}

extension TestCaseFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyword
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyword = keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyword)
        keyword = keywordDecoded
    }
}

extension TestCaseFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestCaseFilter(keyword: \(String(describing: keyword)), status: \(String(describing: status)))"}
}

/// <p>A filter used to return specific types of test cases. In order to pass the filter, the
///             report must meet all of the filter properties.</p>
public struct TestCaseFilter: Equatable {
    /// <p>A keyword that is used to filter on the <code>name</code> or the <code>prefix</code>
    ///             of the test cases. Only test cases where the keyword is a substring of the
    ///                 <code>name</code> or the <code>prefix</code> will be returned.</p>
    public let keyword: String?
    /// <p>The status used to filter test cases. A <code>TestCaseFilter</code> can have one
    ///             status. Valid values are:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>SUCCEEDED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ERROR</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SKIPPED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>UNKNOWN</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        keyword: String? = nil,
        status: String? = nil
    )
    {
        self.keyword = keyword
        self.status = status
    }
}

extension TestReportSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationInNanoSeconds
        case statusCounts
        case total
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInNanoSeconds = durationInNanoSeconds {
            try encodeContainer.encode(durationInNanoSeconds, forKey: .durationInNanoSeconds)
        }
        if let statusCounts = statusCounts {
            var statusCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .statusCounts)
            for (dictKey0, reportstatuscounts0) in statusCounts {
                try statusCountsContainer.encode(reportstatuscounts0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .total)
        total = totalDecoded
        let statusCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .statusCounts)
        var statusCountsDecoded0: [String:Int]? = nil
        if let statusCountsContainer = statusCountsContainer {
            statusCountsDecoded0 = [String:Int]()
            for (key0, wrapperint0) in statusCountsContainer {
                if let wrapperint0 = wrapperint0 {
                    statusCountsDecoded0?[key0] = wrapperint0
                }
            }
        }
        statusCounts = statusCountsDecoded0
        let durationInNanoSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInNanoSeconds)
        durationInNanoSeconds = durationInNanoSecondsDecoded
    }
}

extension TestReportSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestReportSummary(durationInNanoSeconds: \(String(describing: durationInNanoSeconds)), statusCounts: \(String(describing: statusCounts)), total: \(String(describing: total)))"}
}

/// <p> Information about a test report. </p>
public struct TestReportSummary: Equatable {
    /// <p> The number of nanoseconds it took to run all of the test cases in this report.
    ///         </p>
    public let durationInNanoSeconds: Int?
    /// <p> A map that contains the number of each type of status returned by the test results in
    ///             this <code>TestReportSummary</code>. </p>
    public let statusCounts: [String:Int]?
    /// <p> The number of test cases in this <code>TestReportSummary</code>. The total includes
    ///             truncated test cases. </p>
    public let total: Int?

    public init (
        durationInNanoSeconds: Int? = nil,
        statusCounts: [String:Int]? = nil,
        total: Int? = nil
    )
    {
        self.durationInNanoSeconds = durationInNanoSeconds
        self.statusCounts = statusCounts
        self.total = total
    }
}

public struct UpdateProjectInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectInput(artifacts: \(String(describing: artifacts)), badgeEnabled: \(String(describing: badgeEnabled)), buildBatchConfig: \(String(describing: buildBatchConfig)), cache: \(String(describing: cache)), concurrentBuildLimit: \(String(describing: concurrentBuildLimit)), description: \(String(describing: description)), encryptionKey: \(String(describing: encryptionKey)), environment: \(String(describing: environment)), fileSystemLocations: \(String(describing: fileSystemLocations)), logsConfig: \(String(describing: logsConfig)), name: \(String(describing: name)), queuedTimeoutInMinutes: \(String(describing: queuedTimeoutInMinutes)), secondaryArtifacts: \(String(describing: secondaryArtifacts)), secondarySourceVersions: \(String(describing: secondarySourceVersions)), secondarySources: \(String(describing: secondarySources)), serviceRole: \(String(describing: serviceRole)), source: \(String(describing: source)), sourceVersion: \(String(describing: sourceVersion)), tags: \(String(describing: tags)), timeoutInMinutes: \(String(describing: timeoutInMinutes)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension UpdateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifacts
        case badgeEnabled
        case buildBatchConfig
        case cache
        case concurrentBuildLimit
        case description
        case encryptionKey
        case environment
        case fileSystemLocations
        case logsConfig
        case name
        case queuedTimeoutInMinutes
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case tags
        case timeoutInMinutes
        case vpcConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifacts = artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let badgeEnabled = badgeEnabled {
            try encodeContainer.encode(badgeEnabled, forKey: .badgeEnabled)
        }
        if let buildBatchConfig = buildBatchConfig {
            try encodeContainer.encode(buildBatchConfig, forKey: .buildBatchConfig)
        }
        if let cache = cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if let concurrentBuildLimit = concurrentBuildLimit {
            try encodeContainer.encode(concurrentBuildLimit, forKey: .concurrentBuildLimit)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocations0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocations0)
            }
        }
        if let logsConfig = logsConfig {
            try encodeContainer.encode(logsConfig, forKey: .logsConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queuedTimeoutInMinutes = queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for projectartifactslist0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(projectartifactslist0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsecondarysourceversions0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsecondarysourceversions0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsources0 in secondarySources {
                try secondarySourcesContainer.encode(projectsources0)
            }
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let timeoutInMinutes = timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInput: Equatable {
    /// <p>Information to be changed about the build output artifacts for the build
    ///         project.</p>
    public let artifacts: ProjectArtifacts?
    /// <p>Set this to true to generate a publicly accessible URL for your project's build
    ///       badge.</p>
    public let badgeEnabled: Bool?
    /// <p>Contains configuration information about a batch build project.</p>
    public let buildBatchConfig: ProjectBuildBatchConfig?
    /// <p>Stores recently used information so that it can be quickly accessed at a later
    ///       time.</p>
    public let cache: ProjectCache?
    /// <p>The maximum number of concurrent builds that are allowed for this project.</p>
    ///          <p>New builds are only started if the current number of builds is less than or equal to this limit.
    ///   If the current build count meets this limit, new builds are throttled and are not run.</p>
    ///          <p>To remove this limit, set this value to -1.</p>
    public let concurrentBuildLimit: Int?
    /// <p>A new or replacement description of the build project.</p>
    public let description: String?
    /// <p>The AWS Key Management Service (AWS KMS) customer master key (CMK) to be used for encrypting the build output
    ///     artifacts.</p>
    ///          <note>
    ///             <p> You can use a cross-account KMS key to encrypt the build output artifacts if your
    ///         service role has permission to that key. </p>
    ///          </note>
    ///          <p>You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using
    ///     the format <code>alias/<alias-name></code>).
    ///     </p>
    public let encryptionKey: String?
    /// <p>Information to be changed about the build environment for the build project.</p>
    public let environment: ProjectEnvironment?
    /// <p>
    ///       An array of <code>ProjectFileSystemLocation</code> objects for a CodeBuild build project. A <code>ProjectFileSystemLocation</code> object
    ///       specifies the <code>identifier</code>, <code>location</code>, <code>mountOptions</code>,
    ///       <code>mountPoint</code>, and <code>type</code> of a file system created using Amazon Elastic File System.
    ///   </p>
    public let fileSystemLocations: [ProjectFileSystemLocation]?
    /// <p> Information about logs for the build project. A project can create logs in Amazon CloudWatch Logs,
    ///     logs in an S3 bucket, or both. </p>
    public let logsConfig: LogsConfig?
    /// <p>The name of the build project.</p>
    ///          <note>
    ///             <p>You cannot change a build project's name.</p>
    ///          </note>
    public let name: String?
    /// <p> The number of minutes a build is allowed to be queued before it times out. </p>
    public let queuedTimeoutInMinutes: Int?
    /// <p> An array of <code>ProjectSource</code> objects. </p>
    public let secondaryArtifacts: [ProjectArtifacts]?
    /// <p> An array of <code>ProjectSourceVersion</code> objects. If
    ///       <code>secondarySourceVersions</code> is specified at the build level, then they take
    ///     over these <code>secondarySourceVersions</code> (at the project level). </p>
    public let secondarySourceVersions: [ProjectSourceVersion]?
    /// <p> An array of <code>ProjectSource</code> objects. </p>
    public let secondarySources: [ProjectSource]?
    /// <p>The replacement ARN of the AWS Identity and Access Management (IAM) role that enables AWS CodeBuild to interact with dependent
    ///     AWS services on behalf of the AWS account.</p>
    public let serviceRole: String?
    /// <p>Information to be changed about the build input source code for the build
    ///     project.</p>
    public let source: ProjectSource?
    /// <p> A version of the build input to be built for this project. If not specified, the
    ///     latest version is used. If specified, it must be one of: </p>
    ///          <ul>
    ///             <li>
    ///                <p>For AWS CodeCommit: the commit ID, branch, or Git tag to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>For GitHub: the commit ID, pull request ID, branch name, or tag name that
    ///             corresponds to the version of the source code you want to build. If a pull
    ///             request ID is specified, it must use the format <code>pr/pull-request-ID</code>
    ///             (for example <code>pr/25</code>). If a branch name is specified, the branch's
    ///             HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is
    ///             used.</p>
    ///             </li>
    ///             <li>
    ///                <p>For Bitbucket: the commit ID, branch name, or tag name that corresponds to the
    ///             version of the source code you want to build. If a branch name is specified, the
    ///             branch's HEAD commit ID is used. If not specified, the default branch's HEAD
    ///             commit ID is used.</p>
    ///             </li>
    ///             <li>
    ///                <p>For Amazon S3: the version ID of the object that represents the build input ZIP
    ///             file to use.</p>
    ///             </li>
    ///          </ul>
    ///          <p> If <code>sourceVersion</code> is specified at the build level, then that version
    ///     takes precedence over this <code>sourceVersion</code> (at the project level). </p>
    ///          <p> For more information, see <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html">Source Version Sample
    ///         with CodeBuild</a> in the <i>AWS CodeBuild User Guide</i>.
    ///     </p>
    public let sourceVersion: String?
    /// <p>An updated list of tag key and value pairs associated with this build project.</p>
    ///          <p>These tags are available for use by AWS services that support AWS CodeBuild build project
    ///       tags.</p>
    public let tags: [Tag]?
    /// <p>The replacement value in minutes, from 5 to 480 (8 hours), for AWS CodeBuild to wait before
    ///       timing out any related build that did not get marked as completed.</p>
    public let timeoutInMinutes: Int?
    /// <p>VpcConfig enables AWS CodeBuild to access resources in an Amazon VPC.</p>
    public let vpcConfig: VpcConfig?

    public init (
        artifacts: ProjectArtifacts? = nil,
        badgeEnabled: Bool? = nil,
        buildBatchConfig: ProjectBuildBatchConfig? = nil,
        cache: ProjectCache? = nil,
        concurrentBuildLimit: Int? = nil,
        description: String? = nil,
        encryptionKey: String? = nil,
        environment: ProjectEnvironment? = nil,
        fileSystemLocations: [ProjectFileSystemLocation]? = nil,
        logsConfig: LogsConfig? = nil,
        name: String? = nil,
        queuedTimeoutInMinutes: Int? = nil,
        secondaryArtifacts: [ProjectArtifacts]? = nil,
        secondarySourceVersions: [ProjectSourceVersion]? = nil,
        secondarySources: [ProjectSource]? = nil,
        serviceRole: String? = nil,
        source: ProjectSource? = nil,
        sourceVersion: String? = nil,
        tags: [Tag]? = nil,
        timeoutInMinutes: Int? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.artifacts = artifacts
        self.badgeEnabled = badgeEnabled
        self.buildBatchConfig = buildBatchConfig
        self.cache = cache
        self.concurrentBuildLimit = concurrentBuildLimit
        self.description = description
        self.encryptionKey = encryptionKey
        self.environment = environment
        self.fileSystemLocations = fileSystemLocations
        self.logsConfig = logsConfig
        self.name = name
        self.queuedTimeoutInMinutes = queuedTimeoutInMinutes
        self.secondaryArtifacts = secondaryArtifacts
        self.secondarySourceVersions = secondarySourceVersions
        self.secondarySources = secondarySources
        self.serviceRole = serviceRole
        self.source = source
        self.sourceVersion = sourceVersion
        self.tags = tags
        self.timeoutInMinutes = timeoutInMinutes
        self.vpcConfig = vpcConfig
    }
}

struct UpdateProjectInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let source: ProjectSource?
    public let secondarySources: [ProjectSource]?
    public let sourceVersion: String?
    public let secondarySourceVersions: [ProjectSourceVersion]?
    public let artifacts: ProjectArtifacts?
    public let secondaryArtifacts: [ProjectArtifacts]?
    public let cache: ProjectCache?
    public let environment: ProjectEnvironment?
    public let serviceRole: String?
    public let timeoutInMinutes: Int?
    public let queuedTimeoutInMinutes: Int?
    public let encryptionKey: String?
    public let tags: [Tag]?
    public let vpcConfig: VpcConfig?
    public let badgeEnabled: Bool?
    public let logsConfig: LogsConfig?
    public let fileSystemLocations: [ProjectFileSystemLocation]?
    public let buildBatchConfig: ProjectBuildBatchConfig?
    public let concurrentBuildLimit: Int?
}

extension UpdateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case artifacts
        case badgeEnabled
        case buildBatchConfig
        case cache
        case concurrentBuildLimit
        case description
        case encryptionKey
        case environment
        case fileSystemLocations
        case logsConfig
        case name
        case queuedTimeoutInMinutes
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case tags
        case timeoutInMinutes
        case vpcConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(ProjectSource.self, forKey: .source)
        source = sourceDecoded
        let secondarySourcesContainer = try containerValues.decodeIfPresent([ProjectSource?].self, forKey: .secondarySources)
        var secondarySourcesDecoded0:[ProjectSource]? = nil
        if let secondarySourcesContainer = secondarySourcesContainer {
            secondarySourcesDecoded0 = [ProjectSource]()
            for structure0 in secondarySourcesContainer {
                if let structure0 = structure0 {
                    secondarySourcesDecoded0?.append(structure0)
                }
            }
        }
        secondarySources = secondarySourcesDecoded0
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let secondarySourceVersionsContainer = try containerValues.decodeIfPresent([ProjectSourceVersion?].self, forKey: .secondarySourceVersions)
        var secondarySourceVersionsDecoded0:[ProjectSourceVersion]? = nil
        if let secondarySourceVersionsContainer = secondarySourceVersionsContainer {
            secondarySourceVersionsDecoded0 = [ProjectSourceVersion]()
            for structure0 in secondarySourceVersionsContainer {
                if let structure0 = structure0 {
                    secondarySourceVersionsDecoded0?.append(structure0)
                }
            }
        }
        secondarySourceVersions = secondarySourceVersionsDecoded0
        let artifactsDecoded = try containerValues.decodeIfPresent(ProjectArtifacts.self, forKey: .artifacts)
        artifacts = artifactsDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([ProjectArtifacts?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[ProjectArtifacts]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [ProjectArtifacts]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
        let cacheDecoded = try containerValues.decodeIfPresent(ProjectCache.self, forKey: .cache)
        cache = cacheDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(ProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
        let queuedTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queuedTimeoutInMinutes)
        queuedTimeoutInMinutes = queuedTimeoutInMinutesDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let badgeEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .badgeEnabled)
        badgeEnabled = badgeEnabledDecoded
        let logsConfigDecoded = try containerValues.decodeIfPresent(LogsConfig.self, forKey: .logsConfig)
        logsConfig = logsConfigDecoded
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([ProjectFileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[ProjectFileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [ProjectFileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
        let buildBatchConfigDecoded = try containerValues.decodeIfPresent(ProjectBuildBatchConfig.self, forKey: .buildBatchConfig)
        buildBatchConfig = buildBatchConfigDecoded
        let concurrentBuildLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .concurrentBuildLimit)
        concurrentBuildLimit = concurrentBuildLimitDecoded
    }
}

extension UpdateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectOutputResponse(project: \(String(describing: project)))"}
}

extension UpdateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct UpdateProjectOutputResponse: Equatable {
    /// <p>Information about the build project that was changed.</p>
    public let project: Project?

    public init (
        project: Project? = nil
    )
    {
        self.project = project
    }
}

struct UpdateProjectOutputResponseBody: Equatable {
    public let project: Project?
}

extension UpdateProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case project
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(Project.self, forKey: .project)
        project = projectDecoded
    }
}

public struct UpdateReportGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateReportGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReportGroupInput>
    public typealias MOutput = OperationOutput<UpdateReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReportGroupOutputError>
}

extension UpdateReportGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReportGroupInput(arn: \(String(describing: arn)), exportConfig: \(String(describing: exportConfig)), tags: \(String(describing: tags)))"}
}

extension UpdateReportGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case exportConfig
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let exportConfig = exportConfig {
            try encodeContainer.encode(exportConfig, forKey: .exportConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct UpdateReportGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateReportGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReportGroupInput>
    public typealias MOutput = OperationOutput<UpdateReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReportGroupOutputError>
}

public struct UpdateReportGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateReportGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReportGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReportGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReportGroupInput>
    public typealias MOutput = OperationOutput<UpdateReportGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReportGroupOutputError>
}

public struct UpdateReportGroupInput: Equatable {
    /// <p>
    ///       The ARN of the report group to update.
    ///     </p>
    public let arn: String?
    /// <p>
    ///       Used to specify an updated export type. Valid values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>S3</code>: The report results are exported to an S3 bucket.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NO_EXPORT</code>: The report results are not exported.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let exportConfig: ReportExportConfig?
    /// <p>
    ///       An updated list of tag key and value pairs associated with this report group.
    ///     </p>
    ///          <p>These tags are available for use by AWS services that support AWS CodeBuild report group
    ///       tags.</p>
    public let tags: [Tag]?

    public init (
        arn: String? = nil,
        exportConfig: ReportExportConfig? = nil,
        tags: [Tag]? = nil
    )
    {
        self.arn = arn
        self.exportConfig = exportConfig
        self.tags = tags
    }
}

struct UpdateReportGroupInputBody: Equatable {
    public let arn: String?
    public let exportConfig: ReportExportConfig?
    public let tags: [Tag]?
}

extension UpdateReportGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case exportConfig
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let exportConfigDecoded = try containerValues.decodeIfPresent(ReportExportConfig.self, forKey: .exportConfig)
        exportConfig = exportConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateReportGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReportGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReportGroupOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReportGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReportGroupOutputResponse(reportGroup: \(String(describing: reportGroup)))"}
}

extension UpdateReportGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateReportGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reportGroup = output.reportGroup
        } else {
            self.reportGroup = nil
        }
    }
}

public struct UpdateReportGroupOutputResponse: Equatable {
    /// <p>
    ///       Information about the updated report group.
    ///     </p>
    public let reportGroup: ReportGroup?

    public init (
        reportGroup: ReportGroup? = nil
    )
    {
        self.reportGroup = reportGroup
    }
}

struct UpdateReportGroupOutputResponseBody: Equatable {
    public let reportGroup: ReportGroup?
}

extension UpdateReportGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportGroup
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupDecoded = try containerValues.decodeIfPresent(ReportGroup.self, forKey: .reportGroup)
        reportGroup = reportGroupDecoded
    }
}

public struct UpdateWebhookInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWebhookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebhookInput>
    public typealias MOutput = OperationOutput<UpdateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebhookOutputError>
}

extension UpdateWebhookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWebhookInput(branchFilter: \(String(describing: branchFilter)), buildType: \(String(describing: buildType)), filterGroups: \(String(describing: filterGroups)), projectName: \(String(describing: projectName)), rotateSecret: \(String(describing: rotateSecret)))"}
}

extension UpdateWebhookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchFilter
        case buildType
        case filterGroups
        case projectName
        case rotateSecret
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchFilter = branchFilter {
            try encodeContainer.encode(branchFilter, forKey: .branchFilter)
        }
        if let buildType = buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let filterGroups = filterGroups {
            var filterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterGroups)
            for filtergroups0 in filterGroups {
                var filtergroups0Container = filterGroupsContainer.nestedUnkeyedContainer()
                for filtergroup1 in filtergroups0 {
                    try filtergroups0Container.encode(filtergroup1)
                }
            }
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if rotateSecret != false {
            try encodeContainer.encode(rotateSecret, forKey: .rotateSecret)
        }
    }
}

public struct UpdateWebhookInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWebhookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebhookInput>
    public typealias MOutput = OperationOutput<UpdateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebhookOutputError>
}

public struct UpdateWebhookInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWebhookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebhookInput>
    public typealias MOutput = OperationOutput<UpdateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebhookOutputError>
}

public struct UpdateWebhookInput: Equatable {
    /// <p>A regular expression used to determine which repository branches are built when a
    ///       webhook is triggered. If the name of a branch matches the regular expression, then it is
    ///       built. If <code>branchFilter</code> is empty, then all branches are built.</p>
    ///          <note>
    ///             <p> It is recommended that you use <code>filterGroups</code> instead of
    ///         <code>branchFilter</code>. </p>
    ///          </note>
    public let branchFilter: String?
    /// <p>Specifies the type of build this webhook will trigger.</p>
    public let buildType: WebhookBuildType?
    /// <p> An array of arrays of <code>WebhookFilter</code> objects used to determine if a
    ///       webhook event can trigger a build. A filter group must contain at least one
    ///       <code>EVENT</code>
    ///             <code>WebhookFilter</code>. </p>
    public let filterGroups: [[WebhookFilter]]?
    /// <p>The name of the AWS CodeBuild project.</p>
    public let projectName: String?
    /// <p> A boolean value that specifies whether the associated GitHub repository's secret
    ///       token should be updated. If you use Bitbucket for your repository,
    ///       <code>rotateSecret</code> is ignored. </p>
    public let rotateSecret: Bool

    public init (
        branchFilter: String? = nil,
        buildType: WebhookBuildType? = nil,
        filterGroups: [[WebhookFilter]]? = nil,
        projectName: String? = nil,
        rotateSecret: Bool = false
    )
    {
        self.branchFilter = branchFilter
        self.buildType = buildType
        self.filterGroups = filterGroups
        self.projectName = projectName
        self.rotateSecret = rotateSecret
    }
}

struct UpdateWebhookInputBody: Equatable {
    public let projectName: String?
    public let branchFilter: String?
    public let rotateSecret: Bool
    public let filterGroups: [[WebhookFilter]]?
    public let buildType: WebhookBuildType?
}

extension UpdateWebhookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branchFilter
        case buildType
        case filterGroups
        case projectName
        case rotateSecret
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let branchFilterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchFilter)
        branchFilter = branchFilterDecoded
        let rotateSecretDecoded = try containerValues.decode(Bool.self, forKey: .rotateSecret)
        rotateSecret = rotateSecretDecoded
        let filterGroupsContainer = try containerValues.decodeIfPresent([[WebhookFilter?]?].self, forKey: .filterGroups)
        var filterGroupsDecoded0:[[WebhookFilter]]? = nil
        if let filterGroupsContainer = filterGroupsContainer {
            filterGroupsDecoded0 = [[WebhookFilter]]()
            for list0 in filterGroupsContainer {
                var list0Decoded0: [WebhookFilter]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [WebhookFilter]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    filterGroupsDecoded0?.append(list0Decoded0)
                }
            }
        }
        filterGroups = filterGroupsDecoded0
        let buildTypeDecoded = try containerValues.decodeIfPresent(WebhookBuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
    }
}

extension UpdateWebhookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWebhookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OAuthProviderException" : self = .oAuthProviderException(try OAuthProviderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWebhookOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case oAuthProviderException(OAuthProviderException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWebhookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWebhookOutputResponse(webhook: \(String(describing: webhook)))"}
}

extension UpdateWebhookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateWebhookOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

public struct UpdateWebhookOutputResponse: Equatable {
    /// <p> Information about a repository's webhook that is associated with a project in AWS CodeBuild.
    ///     </p>
    public let webhook: Webhook?

    public init (
        webhook: Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct UpdateWebhookOutputResponseBody: Equatable {
    public let webhook: Webhook?
}

extension UpdateWebhookOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webhook
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

extension VpcConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds
        case subnets
        case vpcId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnets0 in subnets {
                try subnetsContainer.encode(subnets0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnets)
        var subnetsDecoded0:[String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension VpcConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfig(securityGroupIds: \(String(describing: securityGroupIds)), subnets: \(String(describing: subnets)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Information about the VPC configuration that AWS CodeBuild accesses.</p>
public struct VpcConfig: Equatable {
    /// <p>A list of one or more security groups IDs in your Amazon VPC.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of one or more subnet IDs in your Amazon VPC.</p>
    public let subnets: [String]?
    /// <p>The ID of the Amazon VPC.</p>
    public let vpcId: String?

    public init (
        securityGroupIds: [String]? = nil,
        subnets: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnets = subnets
        self.vpcId = vpcId
    }
}

extension Webhook: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchFilter
        case buildType
        case filterGroups
        case lastModifiedSecret
        case payloadUrl
        case secret
        case url
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchFilter = branchFilter {
            try encodeContainer.encode(branchFilter, forKey: .branchFilter)
        }
        if let buildType = buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let filterGroups = filterGroups {
            var filterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterGroups)
            for filtergroups0 in filterGroups {
                var filtergroups0Container = filterGroupsContainer.nestedUnkeyedContainer()
                for filtergroup1 in filtergroups0 {
                    try filtergroups0Container.encode(filtergroup1)
                }
            }
        }
        if let lastModifiedSecret = lastModifiedSecret {
            try encodeContainer.encode(lastModifiedSecret.timeIntervalSince1970, forKey: .lastModifiedSecret)
        }
        if let payloadUrl = payloadUrl {
            try encodeContainer.encode(payloadUrl, forKey: .payloadUrl)
        }
        if let secret = secret {
            try encodeContainer.encode(secret, forKey: .secret)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let payloadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payloadUrl)
        payloadUrl = payloadUrlDecoded
        let secretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secret)
        secret = secretDecoded
        let branchFilterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchFilter)
        branchFilter = branchFilterDecoded
        let filterGroupsContainer = try containerValues.decodeIfPresent([[WebhookFilter?]?].self, forKey: .filterGroups)
        var filterGroupsDecoded0:[[WebhookFilter]]? = nil
        if let filterGroupsContainer = filterGroupsContainer {
            filterGroupsDecoded0 = [[WebhookFilter]]()
            for list0 in filterGroupsContainer {
                var list0Decoded0: [WebhookFilter]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [WebhookFilter]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    filterGroupsDecoded0?.append(list0Decoded0)
                }
            }
        }
        filterGroups = filterGroupsDecoded0
        let buildTypeDecoded = try containerValues.decodeIfPresent(WebhookBuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
        let lastModifiedSecretDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedSecret)
        lastModifiedSecret = lastModifiedSecretDecoded
    }
}

extension Webhook: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Webhook(branchFilter: \(String(describing: branchFilter)), buildType: \(String(describing: buildType)), filterGroups: \(String(describing: filterGroups)), lastModifiedSecret: \(String(describing: lastModifiedSecret)), payloadUrl: \(String(describing: payloadUrl)), secret: \(String(describing: secret)), url: \(String(describing: url)))"}
}

/// <p>Information about a webhook that connects repository events to a build project in
///       AWS CodeBuild.</p>
public struct Webhook: Equatable {
    /// <p>A regular expression used to determine which repository branches are built when a
    ///       webhook is triggered. If the name of a branch matches the regular expression, then it is
    ///       built. If <code>branchFilter</code> is empty, then all branches are built.</p>
    ///          <note>
    ///             <p>It is recommended that you use <code>filterGroups</code> instead of
    ///         <code>branchFilter</code>. </p>
    ///          </note>
    public let branchFilter: String?
    /// <p>Specifies the type of build this webhook will trigger.</p>
    public let buildType: WebhookBuildType?
    /// <p>An array of arrays of <code>WebhookFilter</code> objects used to determine which
    ///       webhooks are triggered. At least one <code>WebhookFilter</code> in the array must
    ///       specify <code>EVENT</code> as its <code>type</code>. </p>
    ///          <p>For a build to be triggered, at least one filter group in the
    ///       <code>filterGroups</code> array must pass. For a filter group to pass, each of its
    ///       filters must pass. </p>
    public let filterGroups: [[WebhookFilter]]?
    /// <p>A timestamp that indicates the last time a repository's secret token was modified.
    ///     </p>
    public let lastModifiedSecret: Date?
    /// <p>The AWS CodeBuild endpoint where webhook events are sent.</p>
    public let payloadUrl: String?
    /// <p>The secret token of the associated repository. </p>
    ///          <note>
    ///             <p>A Bitbucket webhook does not support <code>secret</code>. </p>
    ///          </note>
    public let secret: String?
    /// <p>The URL to the webhook.</p>
    public let url: String?

    public init (
        branchFilter: String? = nil,
        buildType: WebhookBuildType? = nil,
        filterGroups: [[WebhookFilter]]? = nil,
        lastModifiedSecret: Date? = nil,
        payloadUrl: String? = nil,
        secret: String? = nil,
        url: String? = nil
    )
    {
        self.branchFilter = branchFilter
        self.buildType = buildType
        self.filterGroups = filterGroups
        self.lastModifiedSecret = lastModifiedSecret
        self.payloadUrl = payloadUrl
        self.secret = secret
        self.url = url
    }
}

public enum WebhookBuildType {
    case build
    case buildBatch
    case sdkUnknown(String)
}

extension WebhookBuildType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WebhookBuildType] {
        return [
            .build,
            .buildBatch,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .build: return "BUILD"
        case .buildBatch: return "BUILD_BATCH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WebhookBuildType(rawValue: rawValue) ?? WebhookBuildType.sdkUnknown(rawValue)
    }
}

extension WebhookFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludeMatchedPattern
        case pattern
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeMatchedPattern = excludeMatchedPattern {
            try encodeContainer.encode(excludeMatchedPattern, forKey: .excludeMatchedPattern)
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WebhookFilterType.self, forKey: .type)
        type = typeDecoded
        let patternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pattern)
        pattern = patternDecoded
        let excludeMatchedPatternDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .excludeMatchedPattern)
        excludeMatchedPattern = excludeMatchedPatternDecoded
    }
}

extension WebhookFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebhookFilter(excludeMatchedPattern: \(String(describing: excludeMatchedPattern)), pattern: \(String(describing: pattern)), type: \(String(describing: type)))"}
}

/// <p> A filter used to determine which webhooks trigger a build. </p>
public struct WebhookFilter: Equatable {
    /// <p> Used to indicate that the <code>pattern</code> determines which webhook events do not
    ///             trigger a build. If true, then a webhook event that does not match the
    ///                 <code>pattern</code> triggers a build. If false, then a webhook event that matches
    ///             the <code>pattern</code> triggers a build. </p>
    public let excludeMatchedPattern: Bool?
    /// <p> For a <code>WebHookFilter</code> that uses <code>EVENT</code> type, a comma-separated
    ///             string that specifies one or more events. For example, the webhook filter <code>PUSH,
    ///                 PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED</code> allows all push, pull request
    ///             created, and pull request updated events to trigger a build. </p>
    ///         <p> For a <code>WebHookFilter</code> that uses any of the other filter types, a regular
    ///             expression pattern. For example, a <code>WebHookFilter</code> that uses
    ///                 <code>HEAD_REF</code> for its <code>type</code> and the pattern
    ///                 <code>^refs/heads/</code> triggers a build when the head reference is a branch with
    ///             a reference name <code>refs/heads/branch-name</code>. </p>
    public let pattern: String?
    /// <p> The type of webhook filter. There are six webhook filter types: <code>EVENT</code>,
    ///                 <code>ACTOR_ACCOUNT_ID</code>, <code>HEAD_REF</code>, <code>BASE_REF</code>,
    ///                 <code>FILE_PATH</code>, and <code>COMMIT_MESSAGE</code>. </p>
    ///         <dl>
    ///             <dt>
    ///                EVENT
    ///             </dt>
    ///             <dd>
    ///                     <p> A webhook event triggers a build when the provided <code>pattern</code>
    ///                         matches one of five event types: <code>PUSH</code>,
    ///                             <code>PULL_REQUEST_CREATED</code>, <code>PULL_REQUEST_UPDATED</code>,
    ///                             <code>PULL_REQUEST_REOPENED</code>, and
    ///                         <code>PULL_REQUEST_MERGED</code>. The <code>EVENT</code> patterns are
    ///                         specified as a comma-separated string. For example, <code>PUSH,
    ///                             PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED</code> filters all push, pull
    ///                         request created, and pull request updated events. </p>
    ///                     <note>
    ///                         <p> The <code>PULL_REQUEST_REOPENED</code> works with GitHub and GitHub
    ///                             Enterprise only. </p>
    ///                     </note>
    ///                 </dd>
    ///             <dt>
    ///                ACTOR_ACCOUNT_ID
    ///             </dt>
    ///             <dd>
    ///                     <p> A webhook event triggers a build when a GitHub, GitHub Enterprise, or
    ///                         Bitbucket account ID matches the regular expression <code>pattern</code>.
    ///                     </p>
    ///                 </dd>
    ///             <dt>
    ///                HEAD_REF
    ///             </dt>
    ///             <dd>
    ///                     <p> A webhook event triggers a build when the head reference matches the
    ///                         regular expression <code>pattern</code>. For example,
    ///                             <code>refs/heads/branch-name</code> and <code>refs/tags/tag-name</code>. </p>
    ///                     <p> Works with GitHub and GitHub Enterprise push, GitHub and GitHub
    ///                         Enterprise pull request, Bitbucket push, and Bitbucket pull request events.
    ///                     </p>
    ///                 </dd>
    ///             <dt>
    ///                BASE_REF
    ///             </dt>
    ///             <dd>
    ///                     <p> A webhook event triggers a build when the base reference matches the
    ///                         regular expression <code>pattern</code>. For example,
    ///                             <code>refs/heads/branch-name</code>. </p>
    ///                     <note>
    ///                         <p> Works with pull request events only. </p>
    ///                     </note>
    ///                 </dd>
    ///             <dt>
    ///                FILE_PATH
    ///             </dt>
    ///             <dd>
    ///                     <p> A webhook triggers a build when the path of a changed file matches the
    ///                         regular expression <code>pattern</code>. </p>
    ///                     <note>
    ///                         <p> Works with GitHub and Bitbucket events push and pull requests events.
    ///                             Also works with GitHub Enterprise push events, but does not work with
    ///                             GitHub Enterprise pull request events. </p>
    ///                     </note>
    ///                 </dd>
    ///             <dt>COMMIT_MESSAGE</dt>
    ///             <dd>
    ///                     <p>A webhook triggers a build when the head commit message matches the
    ///                         regular expression <code>pattern</code>.</p>
    ///                     <note>
    ///                         <p> Works with GitHub and Bitbucket events push and pull requests events.
    ///                             Also works with GitHub Enterprise push events, but does not work with
    ///                             GitHub Enterprise pull request events. </p>
    ///                     </note>
    ///                 </dd>
    ///          </dl>
    public let type: WebhookFilterType?

    public init (
        excludeMatchedPattern: Bool? = nil,
        pattern: String? = nil,
        type: WebhookFilterType? = nil
    )
    {
        self.excludeMatchedPattern = excludeMatchedPattern
        self.pattern = pattern
        self.type = type
    }
}

public enum WebhookFilterType {
    case actorAccountId
    case baseRef
    case commitMessage
    case event
    case filePath
    case headRef
    case sdkUnknown(String)
}

extension WebhookFilterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WebhookFilterType] {
        return [
            .actorAccountId,
            .baseRef,
            .commitMessage,
            .event,
            .filePath,
            .headRef,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .actorAccountId: return "ACTOR_ACCOUNT_ID"
        case .baseRef: return "BASE_REF"
        case .commitMessage: return "COMMIT_MESSAGE"
        case .event: return "EVENT"
        case .filePath: return "FILE_PATH"
        case .headRef: return "HEAD_REF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WebhookFilterType(rawValue: rawValue) ?? WebhookFilterType.sdkUnknown(rawValue)
    }
}
