// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

public struct CreateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputBodyMiddleware: Middleware {
    public let id: String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifacts
        case badgeEnabled
        case buildBatchConfig
        case cache
        case concurrentBuildLimit
        case description
        case encryptionKey
        case environment
        case fileSystemLocations
        case logsConfig
        case name
        case queuedTimeoutInMinutes
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case tags
        case timeoutInMinutes
        case vpcConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifacts = artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let badgeEnabled = badgeEnabled {
            try encodeContainer.encode(badgeEnabled, forKey: .badgeEnabled)
        }
        if let buildBatchConfig = buildBatchConfig {
            try encodeContainer.encode(buildBatchConfig, forKey: .buildBatchConfig)
        }
        if let cache = cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if let concurrentBuildLimit = concurrentBuildLimit {
            try encodeContainer.encode(concurrentBuildLimit, forKey: .concurrentBuildLimit)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocations0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocations0)
            }
        }
        if let logsConfig = logsConfig {
            try encodeContainer.encode(logsConfig, forKey: .logsConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queuedTimeoutInMinutes = queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for projectartifactslist0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(projectartifactslist0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsecondarysourceversions0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsecondarysourceversions0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsources0 in secondarySources {
                try secondarySourcesContainer.encode(projectsources0)
            }
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let timeoutInMinutes = timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}
