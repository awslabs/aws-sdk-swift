// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

public struct StartBuildInputHeadersMiddleware: Middleware {
    public let id: String = "StartBuildInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBuildInput>
    public typealias MOutput = OperationOutput<StartBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBuildOutputError>
}

public struct StartBuildInputQueryItemMiddleware: Middleware {
    public let id: String = "StartBuildInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBuildInput>
    public typealias MOutput = OperationOutput<StartBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBuildOutputError>
}

public struct StartBuildInputBodyMiddleware: Middleware {
    public let id: String = "StartBuildInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBuildInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBuildOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBuildInput>
    public typealias MOutput = OperationOutput<StartBuildOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBuildOutputError>
}

extension StartBuildInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactsOverride
        case buildStatusConfigOverride
        case buildspecOverride
        case cacheOverride
        case certificateOverride
        case computeTypeOverride
        case debugSessionEnabled
        case encryptionKeyOverride
        case environmentTypeOverride
        case environmentVariablesOverride
        case gitCloneDepthOverride
        case gitSubmodulesConfigOverride
        case idempotencyToken
        case imageOverride
        case imagePullCredentialsTypeOverride
        case insecureSslOverride
        case logsConfigOverride
        case privilegedModeOverride
        case projectName
        case queuedTimeoutInMinutesOverride
        case registryCredentialOverride
        case reportBuildStatusOverride
        case secondaryArtifactsOverride
        case secondarySourcesOverride
        case secondarySourcesVersionOverride
        case serviceRoleOverride
        case sourceAuthOverride
        case sourceLocationOverride
        case sourceTypeOverride
        case sourceVersion
        case timeoutInMinutesOverride
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsOverride = artifactsOverride {
            try encodeContainer.encode(artifactsOverride, forKey: .artifactsOverride)
        }
        if let buildStatusConfigOverride = buildStatusConfigOverride {
            try encodeContainer.encode(buildStatusConfigOverride, forKey: .buildStatusConfigOverride)
        }
        if let buildspecOverride = buildspecOverride {
            try encodeContainer.encode(buildspecOverride, forKey: .buildspecOverride)
        }
        if let cacheOverride = cacheOverride {
            try encodeContainer.encode(cacheOverride, forKey: .cacheOverride)
        }
        if let certificateOverride = certificateOverride {
            try encodeContainer.encode(certificateOverride, forKey: .certificateOverride)
        }
        if let computeTypeOverride = computeTypeOverride {
            try encodeContainer.encode(computeTypeOverride.rawValue, forKey: .computeTypeOverride)
        }
        if let debugSessionEnabled = debugSessionEnabled {
            try encodeContainer.encode(debugSessionEnabled, forKey: .debugSessionEnabled)
        }
        if let encryptionKeyOverride = encryptionKeyOverride {
            try encodeContainer.encode(encryptionKeyOverride, forKey: .encryptionKeyOverride)
        }
        if let environmentTypeOverride = environmentTypeOverride {
            try encodeContainer.encode(environmentTypeOverride.rawValue, forKey: .environmentTypeOverride)
        }
        if let environmentVariablesOverride = environmentVariablesOverride {
            var environmentVariablesOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentVariablesOverride)
            for environmentvariables0 in environmentVariablesOverride {
                try environmentVariablesOverrideContainer.encode(environmentvariables0)
            }
        }
        if let gitCloneDepthOverride = gitCloneDepthOverride {
            try encodeContainer.encode(gitCloneDepthOverride, forKey: .gitCloneDepthOverride)
        }
        if let gitSubmodulesConfigOverride = gitSubmodulesConfigOverride {
            try encodeContainer.encode(gitSubmodulesConfigOverride, forKey: .gitSubmodulesConfigOverride)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let imageOverride = imageOverride {
            try encodeContainer.encode(imageOverride, forKey: .imageOverride)
        }
        if let imagePullCredentialsTypeOverride = imagePullCredentialsTypeOverride {
            try encodeContainer.encode(imagePullCredentialsTypeOverride.rawValue, forKey: .imagePullCredentialsTypeOverride)
        }
        if let insecureSslOverride = insecureSslOverride {
            try encodeContainer.encode(insecureSslOverride, forKey: .insecureSslOverride)
        }
        if let logsConfigOverride = logsConfigOverride {
            try encodeContainer.encode(logsConfigOverride, forKey: .logsConfigOverride)
        }
        if let privilegedModeOverride = privilegedModeOverride {
            try encodeContainer.encode(privilegedModeOverride, forKey: .privilegedModeOverride)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let queuedTimeoutInMinutesOverride = queuedTimeoutInMinutesOverride {
            try encodeContainer.encode(queuedTimeoutInMinutesOverride, forKey: .queuedTimeoutInMinutesOverride)
        }
        if let registryCredentialOverride = registryCredentialOverride {
            try encodeContainer.encode(registryCredentialOverride, forKey: .registryCredentialOverride)
        }
        if let reportBuildStatusOverride = reportBuildStatusOverride {
            try encodeContainer.encode(reportBuildStatusOverride, forKey: .reportBuildStatusOverride)
        }
        if let secondaryArtifactsOverride = secondaryArtifactsOverride {
            var secondaryArtifactsOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifactsOverride)
            for projectartifactslist0 in secondaryArtifactsOverride {
                try secondaryArtifactsOverrideContainer.encode(projectartifactslist0)
            }
        }
        if let secondarySourcesOverride = secondarySourcesOverride {
            var secondarySourcesOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourcesOverride)
            for projectsources0 in secondarySourcesOverride {
                try secondarySourcesOverrideContainer.encode(projectsources0)
            }
        }
        if let secondarySourcesVersionOverride = secondarySourcesVersionOverride {
            var secondarySourcesVersionOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourcesVersionOverride)
            for projectsecondarysourceversions0 in secondarySourcesVersionOverride {
                try secondarySourcesVersionOverrideContainer.encode(projectsecondarysourceversions0)
            }
        }
        if let serviceRoleOverride = serviceRoleOverride {
            try encodeContainer.encode(serviceRoleOverride, forKey: .serviceRoleOverride)
        }
        if let sourceAuthOverride = sourceAuthOverride {
            try encodeContainer.encode(sourceAuthOverride, forKey: .sourceAuthOverride)
        }
        if let sourceLocationOverride = sourceLocationOverride {
            try encodeContainer.encode(sourceLocationOverride, forKey: .sourceLocationOverride)
        }
        if let sourceTypeOverride = sourceTypeOverride {
            try encodeContainer.encode(sourceTypeOverride.rawValue, forKey: .sourceTypeOverride)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let timeoutInMinutesOverride = timeoutInMinutesOverride {
            try encodeContainer.encode(timeoutInMinutesOverride, forKey: .timeoutInMinutesOverride)
        }
    }
}
