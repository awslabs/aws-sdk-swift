// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error code.</p>
    public var code: String?
    /// <p>The message string of the error output.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum CodeGenerationStatus {
    case createComplete
    case createFailed
    case createInProgress
    case sdkUnknown(String)
}

extension CodeGenerationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CodeGenerationStatus] {
        return [
            .createComplete,
            .createFailed,
            .createInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createComplete: return "CREATE_COMPLETE"
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CodeGenerationStatus(rawValue: rawValue) ?? CodeGenerationStatus.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error code.</p>
    public var code: String?
    /// <p>The message string of the error output.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateDiscovererInputBodyMiddleware: Middleware {
    public let id: String = "CreateDiscovererInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDiscovererInput>
    public typealias MOutput = OperationOutput<CreateDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDiscovererOutputError>
}

extension CreateDiscovererInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDiscovererInput(description: \(String(describing: description)), sourceArn: \(String(describing: sourceArn)), tags: \(String(describing: tags)))"}
}

extension CreateDiscovererInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case sourceArn = "SourceArn"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDiscovererInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDiscovererInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDiscovererInput>
    public typealias MOutput = OperationOutput<CreateDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDiscovererOutputError>
}

public struct CreateDiscovererInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDiscovererInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDiscovererInput>
    public typealias MOutput = OperationOutput<CreateDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDiscovererOutputError>
}

public struct CreateDiscovererInput: Equatable {
    /// <p>A description for the discoverer.</p>
    public let description: String?
    /// <p>The ARN of the event bus.</p>
    public let sourceArn: String?
    /// <p>Tags associated with the resource.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        sourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.sourceArn = sourceArn
        self.tags = tags
    }
}

struct CreateDiscovererInputBody: Equatable {
    public let description: String?
    public let sourceArn: String?
    public let tags: [String:String]?
}

extension CreateDiscovererInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case sourceArn = "SourceArn"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDiscovererOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDiscovererOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDiscovererOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDiscovererOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDiscovererOutputResponse(description: \(String(describing: description)), discovererArn: \(String(describing: discovererArn)), discovererId: \(String(describing: discovererId)), sourceArn: \(String(describing: sourceArn)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

extension CreateDiscovererOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct CreateDiscovererOutputResponse: Equatable {
    /// <p>The description of the discoverer.</p>
    public let description: String?
    /// <p>The ARN of the discoverer.</p>
    public let discovererArn: String?
    /// <p>The ID of the discoverer.</p>
    public let discovererId: String?
    /// <p>The ARN of the event bus.</p>
    public let sourceArn: String?
    /// <p>The state of the discoverer.</p>
    public let state: DiscovererState?
    /// <p>Tags associated with the resource.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        discovererArn: String? = nil,
        discovererId: String? = nil,
        sourceArn: String? = nil,
        state: DiscovererState? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct CreateDiscovererOutputResponseBody: Equatable {
    public let description: String?
    public let discovererArn: String?
    public let discovererId: String?
    public let sourceArn: String?
    public let state: DiscovererState?
    public let tags: [String:String]?
}

extension CreateDiscovererOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DiscovererState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateRegistryInputBodyMiddleware: Middleware {
    public let id: String = "CreateRegistryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegistryInput>
    public typealias MOutput = OperationOutput<CreateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegistryOutputError>
}

extension CreateRegistryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRegistryInput(description: \(String(describing: description)), registryName: \(String(describing: registryName)), tags: \(String(describing: tags)))"}
}

extension CreateRegistryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRegistryInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRegistryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegistryInput>
    public typealias MOutput = OperationOutput<CreateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegistryOutputError>
}

public struct CreateRegistryInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRegistryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegistryInput>
    public typealias MOutput = OperationOutput<CreateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegistryOutputError>
}

public struct CreateRegistryInput: Equatable {
    /// <p>A description of the registry to be created.</p>
    public let description: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>Tags to associate with the registry.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        registryName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.registryName = registryName
        self.tags = tags
    }
}

struct CreateRegistryInputBody: Equatable {
    public let description: String?
    public let tags: [String:String]?
}

extension CreateRegistryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRegistryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRegistryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRegistryOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRegistryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRegistryOutputResponse(description: \(String(describing: description)), registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)), tags: \(String(describing: tags)))"}
}

extension CreateRegistryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRegistryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct CreateRegistryOutputResponse: Equatable {
    /// <p>The description of the registry.</p>
    public let description: String?
    /// <p>The ARN of the registry.</p>
    public let registryArn: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>Tags associated with the registry.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        registryArn: String? = nil,
        registryName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct CreateRegistryOutputResponseBody: Equatable {
    public let description: String?
    public let registryArn: String?
    public let registryName: String?
    public let tags: [String:String]?
}

extension CreateRegistryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateSchemaInputBodyMiddleware: Middleware {
    public let id: String = "CreateSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

extension CreateSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSchemaInput(content: \(String(describing: content)), description: \(String(describing: description)), registryName: \(String(describing: registryName)), schemaName: \(String(describing: schemaName)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case description = "Description"
        case tags = "tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInput: Equatable {
    /// <p>The source of the schema definition.</p>
    public let content: String?
    /// <p>A description of the schema.</p>
    public let description: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>Tags associated with the schema.</p>
    public let tags: [String:String]?
    /// <p>The type of schema.</p>
    public let type: `Type`?

    public init (
        content: String? = nil,
        description: String? = nil,
        registryName: String? = nil,
        schemaName: String? = nil,
        tags: [String:String]? = nil,
        type: `Type`? = nil
    )
    {
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.tags = tags
        self.type = type
    }
}

struct CreateSchemaInputBody: Equatable {
    public let content: String?
    public let description: String?
    public let tags: [String:String]?
    public let type: `Type`?
}

extension CreateSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case description = "Description"
        case tags = "tags"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSchemaOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSchemaOutputResponse(description: \(String(describing: description)), lastModified: \(String(describing: lastModified)), schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)), schemaVersion: \(String(describing: schemaVersion)), tags: \(String(describing: tags)), type: \(String(describing: type)), versionCreatedDate: \(String(describing: versionCreatedDate)))"}
}

extension CreateSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct CreateSchemaOutputResponse: Equatable {
    /// <p>The description of the schema.</p>
    public let description: String?
    /// <p>The date and time that schema was modified.</p>
    public let lastModified: Date?
    /// <p>The ARN of the schema.</p>
    public let schemaArn: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>The version number of the schema</p>
    public let schemaVersion: String?
    /// <p>Key-value pairs associated with a resource.</p>
    public let tags: [String:String]?
    /// <p>The type of the schema.</p>
    public let type: String?
    /// <p>The date the schema version was created.</p>
    public let versionCreatedDate: Date?

    public init (
        description: String? = nil,
        lastModified: Date? = nil,
        schemaArn: String? = nil,
        schemaName: String? = nil,
        schemaVersion: String? = nil,
        tags: [String:String]? = nil,
        type: String? = nil,
        versionCreatedDate: Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct CreateSchemaOutputResponseBody: Equatable {
    public let description: String?
    public let lastModified: Date?
    public let schemaArn: String?
    public let schemaName: String?
    public let schemaVersion: String?
    public let tags: [String:String]?
    public let type: String?
    public let versionCreatedDate: Date?
}

extension CreateSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}

extension DeleteDiscovererInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDiscovererInput(discovererId: \(String(describing: discovererId)))"}
}

extension DeleteDiscovererInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDiscovererInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDiscovererInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDiscovererInput>
    public typealias MOutput = OperationOutput<DeleteDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDiscovererOutputError>
}

public struct DeleteDiscovererInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDiscovererInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDiscovererInput>
    public typealias MOutput = OperationOutput<DeleteDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDiscovererOutputError>
}

public struct DeleteDiscovererInput: Equatable {
    /// <p>The ID of the discoverer.</p>
    public let discovererId: String?

    public init (
        discovererId: String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct DeleteDiscovererInputBody: Equatable {
}

extension DeleteDiscovererInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDiscovererOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDiscovererOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDiscovererOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDiscovererOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDiscovererOutputResponse()"}
}

extension DeleteDiscovererOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDiscovererOutputResponse: Equatable {

    public init() {}
}

struct DeleteDiscovererOutputResponseBody: Equatable {
}

extension DeleteDiscovererOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRegistryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegistryInput(registryName: \(String(describing: registryName)))"}
}

extension DeleteRegistryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRegistryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRegistryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegistryInput>
    public typealias MOutput = OperationOutput<DeleteRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegistryOutputError>
}

public struct DeleteRegistryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRegistryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegistryInput>
    public typealias MOutput = OperationOutput<DeleteRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegistryOutputError>
}

public struct DeleteRegistryInput: Equatable {
    /// <p>The name of the registry.</p>
    public let registryName: String?

    public init (
        registryName: String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct DeleteRegistryInputBody: Equatable {
}

extension DeleteRegistryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRegistryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRegistryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRegistryOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRegistryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegistryOutputResponse()"}
}

extension DeleteRegistryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRegistryOutputResponse: Equatable {

    public init() {}
}

struct DeleteRegistryOutputResponseBody: Equatable {
}

extension DeleteRegistryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyInput(registryName: \(String(describing: registryName)))"}
}

extension DeleteResourcePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let registryName = input.operationInput.registryName {
            let registryNameQueryItem = URLQueryItem(name: "registryName".urlPercentEncoding(), value: String(registryName).urlPercentEncoding())
            input.builder.withQueryItem(registryNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInput: Equatable {
    /// <p>The name of the registry.</p>
    public let registryName: String?

    public init (
        registryName: String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct DeleteResourcePolicyInputBody: Equatable {
}

extension DeleteResourcePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyOutputResponse()"}
}

extension DeleteResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourcePolicyOutputResponseBody: Equatable {
}

extension DeleteResourcePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaInput(registryName: \(String(describing: registryName)), schemaName: \(String(describing: schemaName)))"}
}

extension DeleteSchemaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInput: Equatable {
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?

    public init (
        registryName: String? = nil,
        schemaName: String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

struct DeleteSchemaInputBody: Equatable {
}

extension DeleteSchemaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSchemaOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaOutputResponse()"}
}

extension DeleteSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSchemaOutputResponse: Equatable {

    public init() {}
}

struct DeleteSchemaOutputResponseBody: Equatable {
}

extension DeleteSchemaOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSchemaVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaVersionInput(registryName: \(String(describing: registryName)), schemaName: \(String(describing: schemaName)), schemaVersion: \(String(describing: schemaVersion)))"}
}

extension DeleteSchemaVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSchemaVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSchemaVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaVersionInput>
    public typealias MOutput = OperationOutput<DeleteSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaVersionOutputError>
}

public struct DeleteSchemaVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSchemaVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaVersionInput>
    public typealias MOutput = OperationOutput<DeleteSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaVersionOutputError>
}

public struct DeleteSchemaVersionInput: Equatable {
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// The version number of the schema
    public let schemaVersion: String?

    public init (
        registryName: String? = nil,
        schemaName: String? = nil,
        schemaVersion: String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct DeleteSchemaVersionInputBody: Equatable {
}

extension DeleteSchemaVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSchemaVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSchemaVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaVersionOutputResponse()"}
}

extension DeleteSchemaVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSchemaVersionOutputResponse: Equatable {

    public init() {}
}

struct DeleteSchemaVersionOutputResponseBody: Equatable {
}

extension DeleteSchemaVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeCodeBindingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCodeBindingInput(language: \(String(describing: language)), registryName: \(String(describing: registryName)), schemaName: \(String(describing: schemaName)), schemaVersion: \(String(describing: schemaVersion)))"}
}

extension DescribeCodeBindingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeCodeBindingInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCodeBindingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCodeBindingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCodeBindingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCodeBindingInput>
    public typealias MOutput = OperationOutput<DescribeCodeBindingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCodeBindingOutputError>
}

public struct DescribeCodeBindingInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCodeBindingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCodeBindingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCodeBindingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaVersion = input.operationInput.schemaVersion {
            let schemaVersionQueryItem = URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: String(schemaVersion).urlPercentEncoding())
            input.builder.withQueryItem(schemaVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCodeBindingInput>
    public typealias MOutput = OperationOutput<DescribeCodeBindingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCodeBindingOutputError>
}

public struct DescribeCodeBindingInput: Equatable {
    /// <p>The language of the code binding.</p>
    public let language: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>Specifying this limits the results to only this schema version.</p>
    public let schemaVersion: String?

    public init (
        language: String? = nil,
        registryName: String? = nil,
        schemaName: String? = nil,
        schemaVersion: String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct DescribeCodeBindingInputBody: Equatable {
}

extension DescribeCodeBindingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeCodeBindingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCodeBindingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCodeBindingOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCodeBindingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCodeBindingOutputResponse(creationDate: \(String(describing: creationDate)), lastModified: \(String(describing: lastModified)), schemaVersion: \(String(describing: schemaVersion)), status: \(String(describing: status)))"}
}

extension DescribeCodeBindingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCodeBindingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.lastModified = output.lastModified
            self.schemaVersion = output.schemaVersion
            self.status = output.status
        } else {
            self.creationDate = nil
            self.lastModified = nil
            self.schemaVersion = nil
            self.status = nil
        }
    }
}

public struct DescribeCodeBindingOutputResponse: Equatable {
    /// <p>The time and date that the code binding was created.</p>
    public let creationDate: Date?
    /// <p>The date and time that code bindings were modified.</p>
    public let lastModified: Date?
    /// <p>The version number of the schema.</p>
    public let schemaVersion: String?
    /// <p>The current status of code binding generation.</p>
    public let status: CodeGenerationStatus?

    public init (
        creationDate: Date? = nil,
        lastModified: Date? = nil,
        schemaVersion: String? = nil,
        status: CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

struct DescribeCodeBindingOutputResponseBody: Equatable {
    public let creationDate: Date?
    public let lastModified: Date?
    public let schemaVersion: String?
    public let status: CodeGenerationStatus?
}

extension DescribeCodeBindingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case lastModified = "LastModified"
        case schemaVersion = "SchemaVersion"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeGenerationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDiscovererInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDiscovererInput(discovererId: \(String(describing: discovererId)))"}
}

extension DescribeDiscovererInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDiscovererInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDiscovererInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDiscovererInput>
    public typealias MOutput = OperationOutput<DescribeDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDiscovererOutputError>
}

public struct DescribeDiscovererInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDiscovererInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDiscovererInput>
    public typealias MOutput = OperationOutput<DescribeDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDiscovererOutputError>
}

public struct DescribeDiscovererInput: Equatable {
    /// <p>The ID of the discoverer.</p>
    public let discovererId: String?

    public init (
        discovererId: String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct DescribeDiscovererInputBody: Equatable {
}

extension DescribeDiscovererInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDiscovererOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDiscovererOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDiscovererOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDiscovererOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDiscovererOutputResponse(description: \(String(describing: description)), discovererArn: \(String(describing: discovererArn)), discovererId: \(String(describing: discovererId)), sourceArn: \(String(describing: sourceArn)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

extension DescribeDiscovererOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct DescribeDiscovererOutputResponse: Equatable {
    /// <p>The description of the discoverer.</p>
    public let description: String?
    /// <p>The ARN of the discoverer.</p>
    public let discovererArn: String?
    /// <p>The ID of the discoverer.</p>
    public let discovererId: String?
    /// <p>The ARN of the event bus.</p>
    public let sourceArn: String?
    /// <p>The state of the discoverer.</p>
    public let state: DiscovererState?
    /// <p>Tags associated with the resource.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        discovererArn: String? = nil,
        discovererId: String? = nil,
        sourceArn: String? = nil,
        state: DiscovererState? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct DescribeDiscovererOutputResponseBody: Equatable {
    public let description: String?
    public let discovererArn: String?
    public let discovererId: String?
    public let sourceArn: String?
    public let state: DiscovererState?
    public let tags: [String:String]?
}

extension DescribeDiscovererOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DiscovererState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeRegistryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRegistryInput(registryName: \(String(describing: registryName)))"}
}

extension DescribeRegistryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRegistryInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRegistryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegistryInput>
    public typealias MOutput = OperationOutput<DescribeRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegistryOutputError>
}

public struct DescribeRegistryInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRegistryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegistryInput>
    public typealias MOutput = OperationOutput<DescribeRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegistryOutputError>
}

public struct DescribeRegistryInput: Equatable {
    /// <p>The name of the registry.</p>
    public let registryName: String?

    public init (
        registryName: String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct DescribeRegistryInputBody: Equatable {
}

extension DescribeRegistryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRegistryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegistryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRegistryOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegistryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRegistryOutputResponse(description: \(String(describing: description)), registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)), tags: \(String(describing: tags)))"}
}

extension DescribeRegistryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRegistryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct DescribeRegistryOutputResponse: Equatable {
    /// <p>The description of the registry.</p>
    public let description: String?
    /// <p>The ARN of the registry.</p>
    public let registryArn: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>Tags associated with the registry.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        registryArn: String? = nil,
        registryName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct DescribeRegistryOutputResponseBody: Equatable {
    public let description: String?
    public let registryArn: String?
    public let registryName: String?
    public let tags: [String:String]?
}

extension DescribeRegistryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSchemaInput(registryName: \(String(describing: registryName)), schemaName: \(String(describing: schemaName)), schemaVersion: \(String(describing: schemaVersion)))"}
}

extension DescribeSchemaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSchemaInput>
    public typealias MOutput = OperationOutput<DescribeSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSchemaOutputError>
}

public struct DescribeSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaVersion = input.operationInput.schemaVersion {
            let schemaVersionQueryItem = URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: String(schemaVersion).urlPercentEncoding())
            input.builder.withQueryItem(schemaVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSchemaInput>
    public typealias MOutput = OperationOutput<DescribeSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSchemaOutputError>
}

public struct DescribeSchemaInput: Equatable {
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>Specifying this limits the results to only this schema version.</p>
    public let schemaVersion: String?

    public init (
        registryName: String? = nil,
        schemaName: String? = nil,
        schemaVersion: String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct DescribeSchemaInputBody: Equatable {
}

extension DescribeSchemaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSchemaOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSchemaOutputResponse(content: \(String(describing: content)), description: \(String(describing: description)), lastModified: \(String(describing: lastModified)), schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)), schemaVersion: \(String(describing: schemaVersion)), tags: \(String(describing: tags)), type: \(String(describing: type)), versionCreatedDate: \(String(describing: versionCreatedDate)))"}
}

extension DescribeSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.content = output.content
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.content = nil
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct DescribeSchemaOutputResponse: Equatable {
    /// <p>The source of the schema definition.</p>
    public let content: String?
    /// <p>The description of the schema.</p>
    public let description: String?
    /// <p>The date and time that schema was modified.</p>
    public let lastModified: Date?
    /// <p>The ARN of the schema.</p>
    public let schemaArn: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>The version number of the schema</p>
    public let schemaVersion: String?
    /// <p>Tags associated with the resource.</p>
    public let tags: [String:String]?
    /// <p>The type of the schema.</p>
    public let type: String?
    /// <p>The date the schema version was created.</p>
    public let versionCreatedDate: Date?

    public init (
        content: String? = nil,
        description: String? = nil,
        lastModified: Date? = nil,
        schemaArn: String? = nil,
        schemaName: String? = nil,
        schemaVersion: String? = nil,
        tags: [String:String]? = nil,
        type: String? = nil,
        versionCreatedDate: Date? = nil
    )
    {
        self.content = content
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct DescribeSchemaOutputResponseBody: Equatable {
    public let content: String?
    public let description: String?
    public let lastModified: Date?
    public let schemaArn: String?
    public let schemaName: String?
    public let schemaVersion: String?
    public let tags: [String:String]?
    public let type: String?
    public let versionCreatedDate: Date?
}

extension DescribeSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}

public enum DiscovererState {
    case started
    case stopped
    case sdkUnknown(String)
}

extension DiscovererState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DiscovererState] {
        return [
            .started,
            .stopped,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .started: return "STARTED"
        case .stopped: return "STOPPED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DiscovererState(rawValue: rawValue) ?? DiscovererState.sdkUnknown(rawValue)
    }
}

extension DiscovererSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let discovererArn = discovererArn {
            try encodeContainer.encode(discovererArn, forKey: .discovererArn)
        }
        if let discovererId = discovererId {
            try encodeContainer.encode(discovererId, forKey: .discovererId)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DiscovererState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DiscovererSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DiscovererSummary(discovererArn: \(String(describing: discovererArn)), discovererId: \(String(describing: discovererId)), sourceArn: \(String(describing: sourceArn)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

public struct DiscovererSummary: Equatable {
    /// <p>The ARN of the discoverer.</p>
    public let discovererArn: String?
    /// <p>The ID of the discoverer.</p>
    public let discovererId: String?
    /// <p>The ARN of the event bus.</p>
    public let sourceArn: String?
    /// <p>The state of the discoverer.</p>
    public let state: DiscovererState?
    /// <p>Tags associated with the resource.</p>
    public let tags: [String:String]?

    public init (
        discovererArn: String? = nil,
        discovererId: String? = nil,
        sourceArn: String? = nil,
        state: DiscovererState? = nil,
        tags: [String:String]? = nil
    )
    {
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

extension ExportSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportSchemaInput(registryName: \(String(describing: registryName)), schemaName: \(String(describing: schemaName)), schemaVersion: \(String(describing: schemaVersion)), type: \(String(describing: type)))"}
}

extension ExportSchemaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ExportSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "ExportSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportSchemaInput>
    public typealias MOutput = OperationOutput<ExportSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportSchemaOutputError>
}

public struct ExportSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "ExportSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let type = input.operationInput.type {
            let typeQueryItem = URLQueryItem(name: "type".urlPercentEncoding(), value: String(type).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let schemaVersion = input.operationInput.schemaVersion {
            let schemaVersionQueryItem = URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: String(schemaVersion).urlPercentEncoding())
            input.builder.withQueryItem(schemaVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportSchemaInput>
    public typealias MOutput = OperationOutput<ExportSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportSchemaOutputError>
}

public struct ExportSchemaInput: Equatable {
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>Specifying this limits the results to only this schema version.</p>
    public let schemaVersion: String?
    public let type: String?

    public init (
        registryName: String? = nil,
        schemaName: String? = nil,
        schemaVersion: String? = nil,
        type: String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

struct ExportSchemaInputBody: Equatable {
}

extension ExportSchemaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ExportSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportSchemaOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportSchemaOutputResponse(content: \(String(describing: content)), schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)), schemaVersion: \(String(describing: schemaVersion)), type: \(String(describing: type)))"}
}

extension ExportSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExportSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.content = output.content
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.type = output.type
        } else {
            self.content = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.type = nil
        }
    }
}

public struct ExportSchemaOutputResponse: Equatable {
    public let content: String?
    public let schemaArn: String?
    public let schemaName: String?
    public let schemaVersion: String?
    public let type: String?

    public init (
        content: String? = nil,
        schemaArn: String? = nil,
        schemaName: String? = nil,
        schemaVersion: String? = nil,
        type: String? = nil
    )
    {
        self.content = content
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

struct ExportSchemaOutputResponseBody: Equatable {
    public let content: String?
    public let schemaArn: String?
    public let schemaName: String?
    public let schemaVersion: String?
    public let type: String?
}

extension ExportSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error code.</p>
    public var code: String?
    /// <p>The message string of the error output.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetCodeBindingSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCodeBindingSourceInput(language: \(String(describing: language)), registryName: \(String(describing: registryName)), schemaName: \(String(describing: schemaName)), schemaVersion: \(String(describing: schemaVersion)))"}
}

extension GetCodeBindingSourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCodeBindingSourceInputHeadersMiddleware: Middleware {
    public let id: String = "GetCodeBindingSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCodeBindingSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCodeBindingSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCodeBindingSourceInput>
    public typealias MOutput = OperationOutput<GetCodeBindingSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCodeBindingSourceOutputError>
}

public struct GetCodeBindingSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCodeBindingSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCodeBindingSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCodeBindingSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaVersion = input.operationInput.schemaVersion {
            let schemaVersionQueryItem = URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: String(schemaVersion).urlPercentEncoding())
            input.builder.withQueryItem(schemaVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCodeBindingSourceInput>
    public typealias MOutput = OperationOutput<GetCodeBindingSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCodeBindingSourceOutputError>
}

public struct GetCodeBindingSourceInput: Equatable {
    /// <p>The language of the code binding.</p>
    public let language: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>Specifying this limits the results to only this schema version.</p>
    public let schemaVersion: String?

    public init (
        language: String? = nil,
        registryName: String? = nil,
        schemaName: String? = nil,
        schemaVersion: String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct GetCodeBindingSourceInputBody: Equatable {
}

extension GetCodeBindingSourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCodeBindingSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCodeBindingSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCodeBindingSourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCodeBindingSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCodeBindingSourceOutputResponse(body: \(String(describing: body)))"}
}

extension GetCodeBindingSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.body = unwrappedData
        } else {
            self.body = nil
        }
    }
}

public struct GetCodeBindingSourceOutputResponse: Equatable {
    public let body: Data?

    public init (
        body: Data? = nil
    )
    {
        self.body = body
    }
}

struct GetCodeBindingSourceOutputResponseBody: Equatable {
    public let body: Data?
}

extension GetCodeBindingSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

public struct GetDiscoveredSchemaInputBodyMiddleware: Middleware {
    public let id: String = "GetDiscoveredSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDiscoveredSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDiscoveredSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDiscoveredSchemaInput>
    public typealias MOutput = OperationOutput<GetDiscoveredSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDiscoveredSchemaOutputError>
}

extension GetDiscoveredSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDiscoveredSchemaInput(events: \(String(describing: events)), type: \(String(describing: type)))"}
}

extension GetDiscoveredSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for __listofgetdiscoveredschemaversioniteminput0 in events {
                try eventsContainer.encode(__listofgetdiscoveredschemaversioniteminput0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct GetDiscoveredSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "GetDiscoveredSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDiscoveredSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDiscoveredSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDiscoveredSchemaInput>
    public typealias MOutput = OperationOutput<GetDiscoveredSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDiscoveredSchemaOutputError>
}

public struct GetDiscoveredSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDiscoveredSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDiscoveredSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDiscoveredSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDiscoveredSchemaInput>
    public typealias MOutput = OperationOutput<GetDiscoveredSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDiscoveredSchemaOutputError>
}

public struct GetDiscoveredSchemaInput: Equatable {
    /// <p>An array of strings where each string is a JSON event. These are the events that were used to generate the schema. The array includes a single type of event and has a maximum size of 10 events.</p>
    public let events: [String]?
    /// <p>The type of event.</p>
    public let type: `Type`?

    public init (
        events: [String]? = nil,
        type: `Type`? = nil
    )
    {
        self.events = events
        self.type = type
    }
}

struct GetDiscoveredSchemaInputBody: Equatable {
    public let events: [String]?
    public let type: `Type`?
}

extension GetDiscoveredSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .events)
        var eventsDecoded0:[String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [String]()
            for string0 in eventsContainer {
                if let string0 = string0 {
                    eventsDecoded0?.append(string0)
                }
            }
        }
        events = eventsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension GetDiscoveredSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDiscoveredSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDiscoveredSchemaOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDiscoveredSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDiscoveredSchemaOutputResponse(content: \(String(describing: content)))"}
}

extension GetDiscoveredSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDiscoveredSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct GetDiscoveredSchemaOutputResponse: Equatable {
    /// <p>The source of the schema definition.</p>
    public let content: String?

    public init (
        content: String? = nil
    )
    {
        self.content = content
    }
}

struct GetDiscoveredSchemaOutputResponseBody: Equatable {
    public let content: String?
}

extension GetDiscoveredSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
    }
}

extension GetResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePolicyInput(registryName: \(String(describing: registryName)))"}
}

extension GetResourcePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let registryName = input.operationInput.registryName {
            let registryNameQueryItem = URLQueryItem(name: "registryName".urlPercentEncoding(), value: String(registryName).urlPercentEncoding())
            input.builder.withQueryItem(registryNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInput: Equatable {
    /// <p>The name of the registry.</p>
    public let registryName: String?

    public init (
        registryName: String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct GetResourcePolicyInputBody: Equatable {
}

extension GetResourcePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePolicyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePolicyOutputResponse(policy: \(String(describing: policy)), revisionId: \(String(describing: revisionId)))"}
}

extension GetResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Equatable {
    /// <p>The resource-based policy.</p>
    public let policy: String?
    /// <p>The revision ID.</p>
    public let revisionId: String?

    public init (
        policy: String? = nil,
        revisionId: String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetResourcePolicyOutputResponseBody: Equatable {
    public let policy: String?
    public let revisionId: String?
}

extension GetResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GoneException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GoneException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension GoneException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GoneExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct GoneException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error code.</p>
    public var code: String?
    /// <p>The message string of the error output.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct GoneExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension GoneExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The error code.</p>
    public var code: String?
    /// <p>The message string of the error output.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDiscoverersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDiscoverersInput(discovererIdPrefix: \(String(describing: discovererIdPrefix)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), sourceArnPrefix: \(String(describing: sourceArnPrefix)))"}
}

extension ListDiscoverersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDiscoverersInputHeadersMiddleware: Middleware {
    public let id: String = "ListDiscoverersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDiscoverersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDiscoverersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDiscoverersInput>
    public typealias MOutput = OperationOutput<ListDiscoverersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDiscoverersOutputError>
}

public struct ListDiscoverersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDiscoverersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDiscoverersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDiscoverersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let sourceArnPrefix = input.operationInput.sourceArnPrefix {
            let sourceArnPrefixQueryItem = URLQueryItem(name: "sourceArnPrefix".urlPercentEncoding(), value: String(sourceArnPrefix).urlPercentEncoding())
            input.builder.withQueryItem(sourceArnPrefixQueryItem)
        }
        if let discovererIdPrefix = input.operationInput.discovererIdPrefix {
            let discovererIdPrefixQueryItem = URLQueryItem(name: "discovererIdPrefix".urlPercentEncoding(), value: String(discovererIdPrefix).urlPercentEncoding())
            input.builder.withQueryItem(discovererIdPrefixQueryItem)
        }
        let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(input.operationInput.limit).urlPercentEncoding())
        input.builder.withQueryItem(limitQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDiscoverersInput>
    public typealias MOutput = OperationOutput<ListDiscoverersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDiscoverersOutputError>
}

public struct ListDiscoverersInput: Equatable {
    /// <p>Specifying this limits the results to only those discoverer IDs that start with the specified prefix.</p>
    public let discovererIdPrefix: String?
    public let limit: Int
    /// <p>The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.</p>
    public let nextToken: String?
    /// <p>Specifying this limits the results to only those ARNs that start with the specified prefix.</p>
    public let sourceArnPrefix: String?

    public init (
        discovererIdPrefix: String? = nil,
        limit: Int = 0,
        nextToken: String? = nil,
        sourceArnPrefix: String? = nil
    )
    {
        self.discovererIdPrefix = discovererIdPrefix
        self.limit = limit
        self.nextToken = nextToken
        self.sourceArnPrefix = sourceArnPrefix
    }
}

struct ListDiscoverersInputBody: Equatable {
}

extension ListDiscoverersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDiscoverersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDiscoverersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDiscoverersOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDiscoverersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDiscoverersOutputResponse(discoverers: \(String(describing: discoverers)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDiscoverersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDiscoverersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.discoverers = output.discoverers
            self.nextToken = output.nextToken
        } else {
            self.discoverers = nil
            self.nextToken = nil
        }
    }
}

public struct ListDiscoverersOutputResponse: Equatable {
    /// <p>An array of DiscovererSummary information.</p>
    public let discoverers: [DiscovererSummary]?
    /// <p>The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.</p>
    public let nextToken: String?

    public init (
        discoverers: [DiscovererSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.discoverers = discoverers
        self.nextToken = nextToken
    }
}

struct ListDiscoverersOutputResponseBody: Equatable {
    public let discoverers: [DiscovererSummary]?
    public let nextToken: String?
}

extension ListDiscoverersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case discoverers = "Discoverers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discoverersContainer = try containerValues.decodeIfPresent([DiscovererSummary?].self, forKey: .discoverers)
        var discoverersDecoded0:[DiscovererSummary]? = nil
        if let discoverersContainer = discoverersContainer {
            discoverersDecoded0 = [DiscovererSummary]()
            for structure0 in discoverersContainer {
                if let structure0 = structure0 {
                    discoverersDecoded0?.append(structure0)
                }
            }
        }
        discoverers = discoverersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRegistriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegistriesInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), registryNamePrefix: \(String(describing: registryNamePrefix)), scope: \(String(describing: scope)))"}
}

extension ListRegistriesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRegistriesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRegistriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegistriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegistriesInput>
    public typealias MOutput = OperationOutput<ListRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegistriesOutputError>
}

public struct ListRegistriesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRegistriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegistriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let scope = input.operationInput.scope {
            let scopeQueryItem = URLQueryItem(name: "scope".urlPercentEncoding(), value: String(scope).urlPercentEncoding())
            input.builder.withQueryItem(scopeQueryItem)
        }
        if let registryNamePrefix = input.operationInput.registryNamePrefix {
            let registryNamePrefixQueryItem = URLQueryItem(name: "registryNamePrefix".urlPercentEncoding(), value: String(registryNamePrefix).urlPercentEncoding())
            input.builder.withQueryItem(registryNamePrefixQueryItem)
        }
        let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(input.operationInput.limit).urlPercentEncoding())
        input.builder.withQueryItem(limitQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegistriesInput>
    public typealias MOutput = OperationOutput<ListRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegistriesOutputError>
}

public struct ListRegistriesInput: Equatable {
    public let limit: Int
    /// <p>The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.</p>
    public let nextToken: String?
    /// <p>Specifying this limits the results to only those registry names that start with the specified prefix.</p>
    public let registryNamePrefix: String?
    /// <p>Can be set to Local or AWS to limit responses to your custom registries, or the ones provided by AWS.</p>
    public let scope: String?

    public init (
        limit: Int = 0,
        nextToken: String? = nil,
        registryNamePrefix: String? = nil,
        scope: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryNamePrefix = registryNamePrefix
        self.scope = scope
    }
}

struct ListRegistriesInputBody: Equatable {
}

extension ListRegistriesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRegistriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRegistriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRegistriesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRegistriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegistriesOutputResponse(nextToken: \(String(describing: nextToken)), registries: \(String(describing: registries)))"}
}

extension ListRegistriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRegistriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.registries = output.registries
        } else {
            self.nextToken = nil
            self.registries = nil
        }
    }
}

public struct ListRegistriesOutputResponse: Equatable {
    /// <p>The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.</p>
    public let nextToken: String?
    /// <p>An array of registry summaries.</p>
    public let registries: [RegistrySummary]?

    public init (
        nextToken: String? = nil,
        registries: [RegistrySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.registries = registries
    }
}

struct ListRegistriesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let registries: [RegistrySummary]?
}

extension ListRegistriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case registries = "Registries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let registriesContainer = try containerValues.decodeIfPresent([RegistrySummary?].self, forKey: .registries)
        var registriesDecoded0:[RegistrySummary]? = nil
        if let registriesContainer = registriesContainer {
            registriesDecoded0 = [RegistrySummary]()
            for structure0 in registriesContainer {
                if let structure0 = structure0 {
                    registriesDecoded0?.append(structure0)
                }
            }
        }
        registries = registriesDecoded0
    }
}

extension ListSchemaVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemaVersionsInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), registryName: \(String(describing: registryName)), schemaName: \(String(describing: schemaName)))"}
}

extension ListSchemaVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSchemaVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSchemaVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemaVersionsInput>
    public typealias MOutput = OperationOutput<ListSchemaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemaVersionsOutputError>
}

public struct ListSchemaVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSchemaVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(input.operationInput.limit).urlPercentEncoding())
        input.builder.withQueryItem(limitQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemaVersionsInput>
    public typealias MOutput = OperationOutput<ListSchemaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemaVersionsOutputError>
}

public struct ListSchemaVersionsInput: Equatable {
    public let limit: Int
    /// <p>The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.</p>
    public let nextToken: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?

    public init (
        limit: Int = 0,
        nextToken: String? = nil,
        registryName: String? = nil,
        schemaName: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

struct ListSchemaVersionsInputBody: Equatable {
}

extension ListSchemaVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSchemaVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemaVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSchemaVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemaVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemaVersionsOutputResponse(nextToken: \(String(describing: nextToken)), schemaVersions: \(String(describing: schemaVersions)))"}
}

extension ListSchemaVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSchemaVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemaVersions = output.schemaVersions
        } else {
            self.nextToken = nil
            self.schemaVersions = nil
        }
    }
}

public struct ListSchemaVersionsOutputResponse: Equatable {
    /// <p>The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.</p>
    public let nextToken: String?
    /// <p>An array of schema version summaries.</p>
    public let schemaVersions: [SchemaVersionSummary]?

    public init (
        nextToken: String? = nil,
        schemaVersions: [SchemaVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaVersions = schemaVersions
    }
}

struct ListSchemaVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let schemaVersions: [SchemaVersionSummary]?
}

extension ListSchemaVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemaVersions = "SchemaVersions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemaVersionsContainer = try containerValues.decodeIfPresent([SchemaVersionSummary?].self, forKey: .schemaVersions)
        var schemaVersionsDecoded0:[SchemaVersionSummary]? = nil
        if let schemaVersionsContainer = schemaVersionsContainer {
            schemaVersionsDecoded0 = [SchemaVersionSummary]()
            for structure0 in schemaVersionsContainer {
                if let structure0 = structure0 {
                    schemaVersionsDecoded0?.append(structure0)
                }
            }
        }
        schemaVersions = schemaVersionsDecoded0
    }
}

extension ListSchemasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemasInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), registryName: \(String(describing: registryName)), schemaNamePrefix: \(String(describing: schemaNamePrefix)))"}
}

extension ListSchemasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSchemasInputHeadersMiddleware: Middleware {
    public let id: String = "ListSchemasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemasInput>
    public typealias MOutput = OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemasOutputError>
}

public struct ListSchemasInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSchemasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let schemaNamePrefix = input.operationInput.schemaNamePrefix {
            let schemaNamePrefixQueryItem = URLQueryItem(name: "schemaNamePrefix".urlPercentEncoding(), value: String(schemaNamePrefix).urlPercentEncoding())
            input.builder.withQueryItem(schemaNamePrefixQueryItem)
        }
        let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(input.operationInput.limit).urlPercentEncoding())
        input.builder.withQueryItem(limitQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemasInput>
    public typealias MOutput = OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemasOutputError>
}

public struct ListSchemasInput: Equatable {
    public let limit: Int
    /// <p>The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.</p>
    public let nextToken: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>Specifying this limits the results to only those schema names that start with the specified prefix.</p>
    public let schemaNamePrefix: String?

    public init (
        limit: Int = 0,
        nextToken: String? = nil,
        registryName: String? = nil,
        schemaNamePrefix: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaNamePrefix = schemaNamePrefix
    }
}

struct ListSchemasInputBody: Equatable {
}

extension ListSchemasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSchemasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSchemasOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemasOutputResponse(nextToken: \(String(describing: nextToken)), schemas: \(String(describing: schemas)))"}
}

extension ListSchemasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSchemasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemasOutputResponse: Equatable {
    /// <p>The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.</p>
    public let nextToken: String?
    /// <p>An array of schema summaries.</p>
    public let schemas: [SchemaSummary]?

    public init (
        nextToken: String? = nil,
        schemas: [SchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemasOutputResponseBody: Equatable {
    public let nextToken: String?
    public let schemas: [SchemaSummary]?
}

extension ListSchemasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemasContainer = try containerValues.decodeIfPresent([SchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[SchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Key-value pairs associated with a resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error code.</p>
    public var code: String?
    /// <p>The message string of the error output.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreconditionFailedException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension PreconditionFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct PreconditionFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error code.</p>
    public var code: String?
    /// <p>The message string of the error output.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct PreconditionFailedExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension PreconditionFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutCodeBindingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutCodeBindingInput(language: \(String(describing: language)), registryName: \(String(describing: registryName)), schemaName: \(String(describing: schemaName)), schemaVersion: \(String(describing: schemaVersion)))"}
}

extension PutCodeBindingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct PutCodeBindingInputHeadersMiddleware: Middleware {
    public let id: String = "PutCodeBindingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutCodeBindingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutCodeBindingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutCodeBindingInput>
    public typealias MOutput = OperationOutput<PutCodeBindingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutCodeBindingOutputError>
}

public struct PutCodeBindingInputQueryItemMiddleware: Middleware {
    public let id: String = "PutCodeBindingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutCodeBindingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutCodeBindingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaVersion = input.operationInput.schemaVersion {
            let schemaVersionQueryItem = URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: String(schemaVersion).urlPercentEncoding())
            input.builder.withQueryItem(schemaVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutCodeBindingInput>
    public typealias MOutput = OperationOutput<PutCodeBindingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutCodeBindingOutputError>
}

public struct PutCodeBindingInput: Equatable {
    /// <p>The language of the code binding.</p>
    public let language: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>Specifying this limits the results to only this schema version.</p>
    public let schemaVersion: String?

    public init (
        language: String? = nil,
        registryName: String? = nil,
        schemaName: String? = nil,
        schemaVersion: String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct PutCodeBindingInputBody: Equatable {
}

extension PutCodeBindingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension PutCodeBindingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutCodeBindingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GoneException" : self = .goneException(try GoneException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutCodeBindingOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case goneException(GoneException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutCodeBindingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutCodeBindingOutputResponse(creationDate: \(String(describing: creationDate)), lastModified: \(String(describing: lastModified)), schemaVersion: \(String(describing: schemaVersion)), status: \(String(describing: status)))"}
}

extension PutCodeBindingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutCodeBindingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.lastModified = output.lastModified
            self.schemaVersion = output.schemaVersion
            self.status = output.status
        } else {
            self.creationDate = nil
            self.lastModified = nil
            self.schemaVersion = nil
            self.status = nil
        }
    }
}

public struct PutCodeBindingOutputResponse: Equatable {
    /// <p>The time and date that the code binding was created.</p>
    public let creationDate: Date?
    /// <p>The date and time that code bindings were modified.</p>
    public let lastModified: Date?
    /// <p>The version number of the schema.</p>
    public let schemaVersion: String?
    /// <p>The current status of code binding generation.</p>
    public let status: CodeGenerationStatus?

    public init (
        creationDate: Date? = nil,
        lastModified: Date? = nil,
        schemaVersion: String? = nil,
        status: CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

struct PutCodeBindingOutputResponseBody: Equatable {
    public let creationDate: Date?
    public let lastModified: Date?
    public let schemaVersion: String?
    public let status: CodeGenerationStatus?
}

extension PutCodeBindingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case lastModified = "LastModified"
        case schemaVersion = "SchemaVersion"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeGenerationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct PutResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

extension PutResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyInput(policy: \(String(describing: policy)), registryName: \(String(describing: registryName)), revisionId: \(String(describing: revisionId)))"}
}

extension PutResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

public struct PutResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let registryName = input.operationInput.registryName {
            let registryNameQueryItem = URLQueryItem(name: "registryName".urlPercentEncoding(), value: String(registryName).urlPercentEncoding())
            input.builder.withQueryItem(registryNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

/// <p>The name of the policy.</p>
public struct PutResourcePolicyInput: Equatable {
    /// <p>The resource-based policy.</p>
    public let policy: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The revision ID of the policy.</p>
    public let revisionId: String?

    public init (
        policy: String? = nil,
        registryName: String? = nil,
        revisionId: String? = nil
    )
    {
        self.policy = policy
        self.registryName = registryName
        self.revisionId = revisionId
    }
}

struct PutResourcePolicyInputBody: Equatable {
    public let policy: String?
    public let revisionId: String?
}

extension PutResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension PutResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourcePolicyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyOutputResponse(policy: \(String(describing: policy)), revisionId: \(String(describing: revisionId)))"}
}

extension PutResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct PutResourcePolicyOutputResponse: Equatable {
    /// <p>The resource-based policy.</p>
    public let policy: String?
    /// <p>The revision ID of the policy.</p>
    public let revisionId: String?

    public init (
        policy: String? = nil,
        revisionId: String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct PutResourcePolicyOutputResponseBody: Equatable {
    public let policy: String?
    public let revisionId: String?
}

extension PutResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension RegistrySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryArn = registryArn {
            try encodeContainer.encode(registryArn, forKey: .registryArn)
        }
        if let registryName = registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RegistrySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegistrySummary(registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)), tags: \(String(describing: tags)))"}
}

public struct RegistrySummary: Equatable {
    /// <p>The ARN of the registry.</p>
    public let registryArn: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>Tags associated with the registry.</p>
    public let tags: [String:String]?

    public init (
        registryArn: String? = nil,
        registryName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

extension SchemaSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case tags = "tags"
        case versionCount = "VersionCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if versionCount != 0 {
            try encodeContainer.encode(versionCount, forKey: .versionCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let versionCountDecoded = try containerValues.decode(Int.self, forKey: .versionCount)
        versionCount = versionCountDecoded
    }
}

extension SchemaSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaSummary(lastModified: \(String(describing: lastModified)), schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)), tags: \(String(describing: tags)), versionCount: \(String(describing: versionCount)))"}
}

/// <p>A summary of schema details.</p>
public struct SchemaSummary: Equatable {
    /// <p>The date and time that schema was modified.</p>
    public let lastModified: Date?
    /// <p>The ARN of the schema.</p>
    public let schemaArn: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>Tags associated with the schema.</p>
    public let tags: [String:String]?
    /// <p>The number of versions available for the schema.</p>
    public let versionCount: Int

    public init (
        lastModified: Date? = nil,
        schemaArn: String? = nil,
        schemaName: String? = nil,
        tags: [String:String]? = nil,
        versionCount: Int = 0
    )
    {
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.tags = tags
        self.versionCount = versionCount
    }
}

extension SchemaVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension SchemaVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaVersionSummary(schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)), schemaVersion: \(String(describing: schemaVersion)), type: \(String(describing: type)))"}
}

public struct SchemaVersionSummary: Equatable {
    /// <p>The ARN of the schema version.</p>
    public let schemaArn: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>The version number of the schema.</p>
    public let schemaVersion: String?
    /// <p>The type of schema.</p>
    public let type: `Type`?

    public init (
        schemaArn: String? = nil,
        schemaName: String? = nil,
        schemaVersion: String? = nil,
        type: `Type`? = nil
    )
    {
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

extension SearchSchemaSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryName = "RegistryName"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersions = "SchemaVersions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryName = registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let schemaVersions = schemaVersions {
            var schemaVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaVersions)
            for __listofsearchschemaversionsummary0 in schemaVersions {
                try schemaVersionsContainer.encode(__listofsearchschemaversionsummary0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionsContainer = try containerValues.decodeIfPresent([SearchSchemaVersionSummary?].self, forKey: .schemaVersions)
        var schemaVersionsDecoded0:[SearchSchemaVersionSummary]? = nil
        if let schemaVersionsContainer = schemaVersionsContainer {
            schemaVersionsDecoded0 = [SearchSchemaVersionSummary]()
            for structure0 in schemaVersionsContainer {
                if let structure0 = structure0 {
                    schemaVersionsDecoded0?.append(structure0)
                }
            }
        }
        schemaVersions = schemaVersionsDecoded0
    }
}

extension SearchSchemaSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchSchemaSummary(registryName: \(String(describing: registryName)), schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)), schemaVersions: \(String(describing: schemaVersions)))"}
}

public struct SearchSchemaSummary: Equatable {
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The ARN of the schema.</p>
    public let schemaArn: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>An array of schema version summaries.</p>
    public let schemaVersions: [SearchSchemaVersionSummary]?

    public init (
        registryName: String? = nil,
        schemaArn: String? = nil,
        schemaName: String? = nil,
        schemaVersions: [SearchSchemaVersionSummary]? = nil
    )
    {
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersions = schemaVersions
    }
}

extension SearchSchemaVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "CreatedDate"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension SearchSchemaVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchSchemaVersionSummary(createdDate: \(String(describing: createdDate)), schemaVersion: \(String(describing: schemaVersion)), type: \(String(describing: type)))"}
}

public struct SearchSchemaVersionSummary: Equatable {
    /// <p>The date the schema version was created.</p>
    public let createdDate: Date?
    /// <p>The version number of the schema</p>
    public let schemaVersion: String?
    /// <p>The type of schema.</p>
    public let type: `Type`?

    public init (
        createdDate: Date? = nil,
        schemaVersion: String? = nil,
        type: `Type`? = nil
    )
    {
        self.createdDate = createdDate
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

extension SearchSchemasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchSchemasInput(keywords: \(String(describing: keywords)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), registryName: \(String(describing: registryName)))"}
}

extension SearchSchemasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct SearchSchemasInputHeadersMiddleware: Middleware {
    public let id: String = "SearchSchemasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchSchemasInput>
    public typealias MOutput = OperationOutput<SearchSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchSchemasOutputError>
}

public struct SearchSchemasInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchSchemasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let keywords = input.operationInput.keywords {
            let keywordsQueryItem = URLQueryItem(name: "keywords".urlPercentEncoding(), value: String(keywords).urlPercentEncoding())
            input.builder.withQueryItem(keywordsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(input.operationInput.limit).urlPercentEncoding())
        input.builder.withQueryItem(limitQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchSchemasInput>
    public typealias MOutput = OperationOutput<SearchSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchSchemasOutputError>
}

public struct SearchSchemasInput: Equatable {
    /// <p>Specifying this limits the results to only schemas that include the provided keywords.</p>
    public let keywords: String?
    public let limit: Int
    /// <p>The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.</p>
    public let nextToken: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?

    public init (
        keywords: String? = nil,
        limit: Int = 0,
        nextToken: String? = nil,
        registryName: String? = nil
    )
    {
        self.keywords = keywords
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
    }
}

struct SearchSchemasInputBody: Equatable {
}

extension SearchSchemasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SearchSchemasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchSchemasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchSchemasOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchSchemasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchSchemasOutputResponse(nextToken: \(String(describing: nextToken)), schemas: \(String(describing: schemas)))"}
}

extension SearchSchemasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchSchemasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct SearchSchemasOutputResponse: Equatable {
    /// <p>The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.</p>
    public let nextToken: String?
    /// <p>An array of SearchSchemaSummary information.</p>
    public let schemas: [SearchSchemaSummary]?

    public init (
        nextToken: String? = nil,
        schemas: [SearchSchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct SearchSchemasOutputResponseBody: Equatable {
    public let nextToken: String?
    public let schemas: [SearchSchemaSummary]?
}

extension SearchSchemasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemasContainer = try containerValues.decodeIfPresent([SearchSchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[SearchSchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SearchSchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The error code.</p>
    public var code: String?
    /// <p>The message string of the error output.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartDiscovererInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDiscovererInput(discovererId: \(String(describing: discovererId)))"}
}

extension StartDiscovererInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StartDiscovererInputHeadersMiddleware: Middleware {
    public let id: String = "StartDiscovererInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDiscovererInput>
    public typealias MOutput = OperationOutput<StartDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDiscovererOutputError>
}

public struct StartDiscovererInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDiscovererInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDiscovererInput>
    public typealias MOutput = OperationOutput<StartDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDiscovererOutputError>
}

public struct StartDiscovererInput: Equatable {
    /// <p>The ID of the discoverer.</p>
    public let discovererId: String?

    public init (
        discovererId: String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct StartDiscovererInputBody: Equatable {
}

extension StartDiscovererInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StartDiscovererOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDiscovererOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDiscovererOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDiscovererOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDiscovererOutputResponse(discovererId: \(String(describing: discovererId)), state: \(String(describing: state)))"}
}

extension StartDiscovererOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.discovererId = output.discovererId
            self.state = output.state
        } else {
            self.discovererId = nil
            self.state = nil
        }
    }
}

public struct StartDiscovererOutputResponse: Equatable {
    /// <p>The ID of the discoverer.</p>
    public let discovererId: String?
    /// <p>The state of the discoverer.</p>
    public let state: DiscovererState?

    public init (
        discovererId: String? = nil,
        state: DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

struct StartDiscovererOutputResponseBody: Equatable {
    public let discovererId: String?
    public let state: DiscovererState?
}

extension StartDiscovererOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case discovererId = "DiscovererId"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DiscovererState.self, forKey: .state)
        state = stateDecoded
    }
}

extension StopDiscovererInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDiscovererInput(discovererId: \(String(describing: discovererId)))"}
}

extension StopDiscovererInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopDiscovererInputHeadersMiddleware: Middleware {
    public let id: String = "StopDiscovererInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDiscovererInput>
    public typealias MOutput = OperationOutput<StopDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDiscovererOutputError>
}

public struct StopDiscovererInputQueryItemMiddleware: Middleware {
    public let id: String = "StopDiscovererInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDiscovererInput>
    public typealias MOutput = OperationOutput<StopDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDiscovererOutputError>
}

public struct StopDiscovererInput: Equatable {
    /// <p>The ID of the discoverer.</p>
    public let discovererId: String?

    public init (
        discovererId: String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct StopDiscovererInputBody: Equatable {
}

extension StopDiscovererInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopDiscovererOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDiscovererOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDiscovererOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDiscovererOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDiscovererOutputResponse(discovererId: \(String(describing: discovererId)), state: \(String(describing: state)))"}
}

extension StopDiscovererOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.discovererId = output.discovererId
            self.state = output.state
        } else {
            self.discovererId = nil
            self.state = nil
        }
    }
}

public struct StopDiscovererOutputResponse: Equatable {
    /// <p>The ID of the discoverer.</p>
    public let discovererId: String?
    /// <p>The state of the discoverer.</p>
    public let state: DiscovererState?

    public init (
        discovererId: String? = nil,
        state: DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

struct StopDiscovererOutputResponseBody: Equatable {
    public let discovererId: String?
    public let state: DiscovererState?
}

extension StopDiscovererOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case discovererId = "DiscovererId"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DiscovererState.self, forKey: .state)
        state = stateDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// <p></p>
public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?
    /// <p>Tags associated with the resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error code.</p>
    public var code: String?
    /// <p>The message string of the error output.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum `Type` {
    case jsonschemadraft4
    case openapi3
    case sdkUnknown(String)
}

extension `Type` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Type`] {
        return [
            .jsonschemadraft4,
            .openapi3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .jsonschemadraft4: return "JSONSchemaDraft4"
        case .openapi3: return "OpenApi3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Type`(rawValue: rawValue) ?? `Type`.sdkUnknown(rawValue)
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error code.</p>
    public var code: String?
    /// <p>The message string of the error output.</p>
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?
    /// <p>Keys of key-value pairs.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDiscovererInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDiscovererInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDiscovererInput>
    public typealias MOutput = OperationOutput<UpdateDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDiscovererOutputError>
}

extension UpdateDiscovererInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDiscovererInput(description: \(String(describing: description)), discovererId: \(String(describing: discovererId)))"}
}

extension UpdateDiscovererInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateDiscovererInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDiscovererInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDiscovererInput>
    public typealias MOutput = OperationOutput<UpdateDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDiscovererOutputError>
}

public struct UpdateDiscovererInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDiscovererInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDiscovererInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDiscovererOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDiscovererInput>
    public typealias MOutput = OperationOutput<UpdateDiscovererOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDiscovererOutputError>
}

public struct UpdateDiscovererInput: Equatable {
    /// <p>The description of the discoverer to update.</p>
    public let description: String?
    /// <p>The ID of the discoverer.</p>
    public let discovererId: String?

    public init (
        description: String? = nil,
        discovererId: String? = nil
    )
    {
        self.description = description
        self.discovererId = discovererId
    }
}

struct UpdateDiscovererInputBody: Equatable {
    public let description: String?
}

extension UpdateDiscovererInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDiscovererOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDiscovererOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDiscovererOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDiscovererOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDiscovererOutputResponse(description: \(String(describing: description)), discovererArn: \(String(describing: discovererArn)), discovererId: \(String(describing: discovererId)), sourceArn: \(String(describing: sourceArn)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

extension UpdateDiscovererOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct UpdateDiscovererOutputResponse: Equatable {
    /// <p>The description of the discoverer.</p>
    public let description: String?
    /// <p>The ARN of the discoverer.</p>
    public let discovererArn: String?
    /// <p>The ID of the discoverer.</p>
    public let discovererId: String?
    /// <p>The ARN of the event bus.</p>
    public let sourceArn: String?
    /// <p>The state of the discoverer.</p>
    public let state: DiscovererState?
    /// <p>Tags associated with the resource.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        discovererArn: String? = nil,
        discovererId: String? = nil,
        sourceArn: String? = nil,
        state: DiscovererState? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct UpdateDiscovererOutputResponseBody: Equatable {
    public let description: String?
    public let discovererArn: String?
    public let discovererId: String?
    public let sourceArn: String?
    public let state: DiscovererState?
    public let tags: [String:String]?
}

extension UpdateDiscovererOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DiscovererState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateRegistryInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRegistryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegistryInput>
    public typealias MOutput = OperationOutput<UpdateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegistryOutputError>
}

extension UpdateRegistryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegistryInput(description: \(String(describing: description)), registryName: \(String(describing: registryName)))"}
}

extension UpdateRegistryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateRegistryInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRegistryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegistryInput>
    public typealias MOutput = OperationOutput<UpdateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegistryOutputError>
}

public struct UpdateRegistryInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRegistryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegistryInput>
    public typealias MOutput = OperationOutput<UpdateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegistryOutputError>
}

/// <p>Updates the registry.</p>
public struct UpdateRegistryInput: Equatable {
    /// <p>The description of the registry to update.</p>
    public let description: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?

    public init (
        description: String? = nil,
        registryName: String? = nil
    )
    {
        self.description = description
        self.registryName = registryName
    }
}

struct UpdateRegistryInputBody: Equatable {
    public let description: String?
}

extension UpdateRegistryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRegistryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRegistryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRegistryOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRegistryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegistryOutputResponse(description: \(String(describing: description)), registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)), tags: \(String(describing: tags)))"}
}

extension UpdateRegistryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRegistryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct UpdateRegistryOutputResponse: Equatable {
    /// <p>The description of the registry.</p>
    public let description: String?
    /// <p>The ARN of the registry.</p>
    public let registryArn: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>Tags associated with the registry.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        registryArn: String? = nil,
        registryName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct UpdateRegistryOutputResponseBody: Equatable {
    public let description: String?
    public let registryArn: String?
    public let registryName: String?
    public let tags: [String:String]?
}

extension UpdateRegistryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateSchemaInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSchemaOutputError>
}

extension UpdateSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSchemaInput(clientTokenId: \(String(describing: clientTokenId)), content: \(String(describing: content)), description: \(String(describing: description)), registryName: \(String(describing: registryName)), schemaName: \(String(describing: schemaName)), type: \(String(describing: type)))"}
}

extension UpdateSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientTokenId = "ClientTokenId"
        case content = "Content"
        case description = "Description"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientTokenId = clientTokenId {
            try encodeContainer.encode(clientTokenId, forKey: .clientTokenId)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSchemaOutputError>
}

public struct UpdateSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSchemaOutputError>
}

public struct UpdateSchemaInput: Equatable {
    /// <p>The ID of the client token.</p>
    public var clientTokenId: String?
    /// <p>The source of the schema definition.</p>
    public let content: String?
    /// <p>The description of the schema.</p>
    public let description: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>The schema type for the events schema.</p>
    public let type: `Type`?

    public init (
        clientTokenId: String? = nil,
        content: String? = nil,
        description: String? = nil,
        registryName: String? = nil,
        schemaName: String? = nil,
        type: `Type`? = nil
    )
    {
        self.clientTokenId = clientTokenId
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.type = type
    }
}

struct UpdateSchemaInputBody: Equatable {
    public let clientTokenId: String?
    public let content: String?
    public let description: String?
    public let type: `Type`?
}

extension UpdateSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientTokenId = "ClientTokenId"
        case content = "Content"
        case description = "Description"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientTokenId)
        clientTokenId = clientTokenIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSchemaOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSchemaOutputResponse(description: \(String(describing: description)), lastModified: \(String(describing: lastModified)), schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)), schemaVersion: \(String(describing: schemaVersion)), tags: \(String(describing: tags)), type: \(String(describing: type)), versionCreatedDate: \(String(describing: versionCreatedDate)))"}
}

extension UpdateSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct UpdateSchemaOutputResponse: Equatable {
    /// <p>The description of the schema.</p>
    public let description: String?
    /// <p>The date and time that schema was modified.</p>
    public let lastModified: Date?
    /// <p>The ARN of the schema.</p>
    public let schemaArn: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>The version number of the schema</p>
    public let schemaVersion: String?
    /// <p>Key-value pairs associated with a resource.</p>
    public let tags: [String:String]?
    /// <p>The type of the schema.</p>
    public let type: String?
    /// <p>The date the schema version was created.</p>
    public let versionCreatedDate: Date?

    public init (
        description: String? = nil,
        lastModified: Date? = nil,
        schemaArn: String? = nil,
        schemaName: String? = nil,
        schemaVersion: String? = nil,
        tags: [String:String]? = nil,
        type: String? = nil,
        versionCreatedDate: Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct UpdateSchemaOutputResponseBody: Equatable {
    public let description: String?
    public let lastModified: Date?
    public let schemaArn: String?
    public let schemaName: String?
    public let schemaVersion: String?
    public let tags: [String:String]?
    public let type: String?
    public let versionCreatedDate: Date?
}

extension UpdateSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}
