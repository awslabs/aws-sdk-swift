// Code generated by smithy-swift-codegen. DO NOT EDIT!



public struct ModifyCurrentDBClusterCapacityInput: Equatable {
    /// <p>The DB cluster capacity.</p>
    ///         <p>When you change the capacity of a paused Aurora Serverless DB cluster, it automatically resumes.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For Aurora MySQL, valid capacity values are <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>, and <code>256</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For Aurora PostgreSQL, valid capacity values are <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>192</code>, and <code>384</code>.</p>
    ///             </li>
    ///          </ul>
    public let capacity: Int?
    /// <p>The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must match the identifier of an existing DB cluster.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>The amount of time, in seconds, that Aurora Serverless tries to find a scaling point
    ///             to perform seamless scaling before enforcing the timeout action. The default is
    ///             300.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Value must be from 10 through 600.</p>
    ///             </li>
    ///          </ul>
    public let secondsBeforeTimeout: Int?
    /// <p>The action to take when the timeout is reached, either <code>ForceApplyCapacityChange</code> or <code>RollbackCapacityChange</code>.</p>
    ///         <p>
    ///             <code>ForceApplyCapacityChange</code>, the default, sets the capacity to the specified value as soon as possible.</p>
    ///         <p>
    ///             <code>RollbackCapacityChange</code> ignores the capacity change if a scaling point isn't found in the timeout period.</p>
    public let timeoutAction: String?

    public init (
        capacity: Int? = nil,
        dBClusterIdentifier: String? = nil,
        secondsBeforeTimeout: Int? = nil,
        timeoutAction: String? = nil
    )
    {
        self.capacity = capacity
        self.dBClusterIdentifier = dBClusterIdentifier
        self.secondsBeforeTimeout = secondsBeforeTimeout
        self.timeoutAction = timeoutAction
    }
}
