// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension OptionGroupOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultPort = "DefaultPort"
        case description = "Description"
        case engineName = "EngineName"
        case majorEngineVersion = "MajorEngineVersion"
        case minimumRequiredMinorEngineVersion = "MinimumRequiredMinorEngineVersion"
        case name = "Name"
        case optionGroupOptionSettings = "OptionGroupOptionSettings"
        case optionGroupOptionVersions = "OptionGroupOptionVersions"
        case optionsConflictsWith = "OptionsConflictsWith"
        case optionsDependedOn = "OptionsDependedOn"
        case permanent = "Permanent"
        case persistent = "Persistent"
        case portRequired = "PortRequired"
        case requiresAutoMinorEngineVersionUpgrade = "RequiresAutoMinorEngineVersionUpgrade"
        case supportsOptionVersionDowngrade = "SupportsOptionVersionDowngrade"
        case vpcOnly = "VpcOnly"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultPort = defaultPort {
            try container.encode(defaultPort, forKey: Key("DefaultPort"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let engineName = engineName {
            try container.encode(engineName, forKey: Key("EngineName"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: Key("MajorEngineVersion"))
        }
        if let minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersion {
            try container.encode(minimumRequiredMinorEngineVersion, forKey: Key("MinimumRequiredMinorEngineVersion"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let optionGroupOptionSettings = optionGroupOptionSettings {
            var optionGroupOptionSettingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionGroupOptionSettings"))
            for (index0, optiongroupoptionsetting0) in optionGroupOptionSettings.enumerated() {
                try optionGroupOptionSettingsContainer.encode(optiongroupoptionsetting0, forKey: Key("OptionGroupOptionSetting.\(index0.advanced(by: 1))"))
            }
        }
        if let optionGroupOptionVersions = optionGroupOptionVersions {
            var optionGroupOptionVersionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionGroupOptionVersions"))
            for (index0, optionversion0) in optionGroupOptionVersions.enumerated() {
                try optionGroupOptionVersionsContainer.encode(optionversion0, forKey: Key("OptionVersion.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsConflictsWith = optionsConflictsWith {
            var optionsConflictsWithContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionsConflictsWith"))
            for (index0, string0) in optionsConflictsWith.enumerated() {
                try optionsConflictsWithContainer.encode(string0, forKey: Key("OptionConflictName.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsDependedOn = optionsDependedOn {
            var optionsDependedOnContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionsDependedOn"))
            for (index0, string0) in optionsDependedOn.enumerated() {
                try optionsDependedOnContainer.encode(string0, forKey: Key("OptionName.\(index0.advanced(by: 1))"))
            }
        }
        if permanent != false {
            try container.encode(permanent, forKey: Key("Permanent"))
        }
        if persistent != false {
            try container.encode(persistent, forKey: Key("Persistent"))
        }
        if portRequired != false {
            try container.encode(portRequired, forKey: Key("PortRequired"))
        }
        if requiresAutoMinorEngineVersionUpgrade != false {
            try container.encode(requiresAutoMinorEngineVersionUpgrade, forKey: Key("RequiresAutoMinorEngineVersionUpgrade"))
        }
        if let supportsOptionVersionDowngrade = supportsOptionVersionDowngrade {
            try container.encode(supportsOptionVersionDowngrade, forKey: Key("SupportsOptionVersionDowngrade"))
        }
        if vpcOnly != false {
            try container.encode(vpcOnly, forKey: Key("VpcOnly"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        let minimumRequiredMinorEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minimumRequiredMinorEngineVersion)
        minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersionDecoded
        let portRequiredDecoded = try containerValues.decode(Bool.self, forKey: .portRequired)
        portRequired = portRequiredDecoded
        let defaultPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultPort)
        defaultPort = defaultPortDecoded
        if containerValues.contains(.optionsDependedOn) {
            struct KeyVal0{struct OptionName{}}
            let optionsDependedOnWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionName>.CodingKeys.self, forKey: .optionsDependedOn)
            if let optionsDependedOnWrappedContainer = optionsDependedOnWrappedContainer {
                let optionsDependedOnContainer = try optionsDependedOnWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var optionsDependedOnBuffer:[String]? = nil
                if let optionsDependedOnContainer = optionsDependedOnContainer {
                    optionsDependedOnBuffer = [String]()
                    for stringContainer0 in optionsDependedOnContainer {
                        optionsDependedOnBuffer?.append(stringContainer0)
                    }
                }
                optionsDependedOn = optionsDependedOnBuffer
            } else {
                optionsDependedOn = []
            }
        } else {
            optionsDependedOn = nil
        }
        if containerValues.contains(.optionsConflictsWith) {
            struct KeyVal0{struct OptionConflictName{}}
            let optionsConflictsWithWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionConflictName>.CodingKeys.self, forKey: .optionsConflictsWith)
            if let optionsConflictsWithWrappedContainer = optionsConflictsWithWrappedContainer {
                let optionsConflictsWithContainer = try optionsConflictsWithWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var optionsConflictsWithBuffer:[String]? = nil
                if let optionsConflictsWithContainer = optionsConflictsWithContainer {
                    optionsConflictsWithBuffer = [String]()
                    for stringContainer0 in optionsConflictsWithContainer {
                        optionsConflictsWithBuffer?.append(stringContainer0)
                    }
                }
                optionsConflictsWith = optionsConflictsWithBuffer
            } else {
                optionsConflictsWith = []
            }
        } else {
            optionsConflictsWith = nil
        }
        let persistentDecoded = try containerValues.decode(Bool.self, forKey: .persistent)
        persistent = persistentDecoded
        let permanentDecoded = try containerValues.decode(Bool.self, forKey: .permanent)
        permanent = permanentDecoded
        let requiresAutoMinorEngineVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .requiresAutoMinorEngineVersionUpgrade)
        requiresAutoMinorEngineVersionUpgrade = requiresAutoMinorEngineVersionUpgradeDecoded
        let vpcOnlyDecoded = try containerValues.decode(Bool.self, forKey: .vpcOnly)
        vpcOnly = vpcOnlyDecoded
        let supportsOptionVersionDowngradeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .supportsOptionVersionDowngrade)
        supportsOptionVersionDowngrade = supportsOptionVersionDowngradeDecoded
        if containerValues.contains(.optionGroupOptionSettings) {
            struct KeyVal0{struct OptionGroupOptionSetting{}}
            let optionGroupOptionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupOptionSetting>.CodingKeys.self, forKey: .optionGroupOptionSettings)
            if let optionGroupOptionSettingsWrappedContainer = optionGroupOptionSettingsWrappedContainer {
                let optionGroupOptionSettingsContainer = try optionGroupOptionSettingsWrappedContainer.decodeIfPresent([OptionGroupOptionSetting].self, forKey: .member)
                var optionGroupOptionSettingsBuffer:[OptionGroupOptionSetting]? = nil
                if let optionGroupOptionSettingsContainer = optionGroupOptionSettingsContainer {
                    optionGroupOptionSettingsBuffer = [OptionGroupOptionSetting]()
                    for structureContainer0 in optionGroupOptionSettingsContainer {
                        optionGroupOptionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupOptionSettings = optionGroupOptionSettingsBuffer
            } else {
                optionGroupOptionSettings = []
            }
        } else {
            optionGroupOptionSettings = nil
        }
        if containerValues.contains(.optionGroupOptionVersions) {
            struct KeyVal0{struct OptionVersion{}}
            let optionGroupOptionVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionVersion>.CodingKeys.self, forKey: .optionGroupOptionVersions)
            if let optionGroupOptionVersionsWrappedContainer = optionGroupOptionVersionsWrappedContainer {
                let optionGroupOptionVersionsContainer = try optionGroupOptionVersionsWrappedContainer.decodeIfPresent([OptionVersion].self, forKey: .member)
                var optionGroupOptionVersionsBuffer:[OptionVersion]? = nil
                if let optionGroupOptionVersionsContainer = optionGroupOptionVersionsContainer {
                    optionGroupOptionVersionsBuffer = [OptionVersion]()
                    for structureContainer0 in optionGroupOptionVersionsContainer {
                        optionGroupOptionVersionsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupOptionVersions = optionGroupOptionVersionsBuffer
            } else {
                optionGroupOptionVersions = []
            }
        } else {
            optionGroupOptionVersions = nil
        }
    }
}
