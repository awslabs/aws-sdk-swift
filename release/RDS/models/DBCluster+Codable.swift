// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DBCluster: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activityStreamKinesisStreamName = "ActivityStreamKinesisStreamName"
        case activityStreamKmsKeyId = "ActivityStreamKmsKeyId"
        case activityStreamMode = "ActivityStreamMode"
        case activityStreamStatus = "ActivityStreamStatus"
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case availabilityZones = "AvailabilityZones"
        case backtrackConsumedChangeRecords = "BacktrackConsumedChangeRecords"
        case backtrackWindow = "BacktrackWindow"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case capacity = "Capacity"
        case characterSetName = "CharacterSetName"
        case cloneGroupId = "CloneGroupId"
        case clusterCreateTime = "ClusterCreateTime"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case crossAccountClone = "CrossAccountClone"
        case customEndpoints = "CustomEndpoints"
        case dBClusterArn = "DBClusterArn"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterMembers = "DBClusterMembers"
        case dBClusterOptionGroupMemberships = "DBClusterOptionGroupMemberships"
        case dBClusterParameterGroup = "DBClusterParameterGroup"
        case dBSubnetGroup = "DBSubnetGroup"
        case databaseName = "DatabaseName"
        case dbClusterResourceId = "DbClusterResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case earliestBacktrackTime = "EarliestBacktrackTime"
        case earliestRestorableTime = "EarliestRestorableTime"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case globalWriteForwardingRequested = "GlobalWriteForwardingRequested"
        case globalWriteForwardingStatus = "GlobalWriteForwardingStatus"
        case hostedZoneId = "HostedZoneId"
        case httpEndpointEnabled = "HttpEndpointEnabled"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case masterUsername = "MasterUsername"
        case multiAZ = "MultiAZ"
        case pendingModifiedValues = "PendingModifiedValues"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case readReplicaIdentifiers = "ReadReplicaIdentifiers"
        case readerEndpoint = "ReaderEndpoint"
        case replicationSourceIdentifier = "ReplicationSourceIdentifier"
        case scalingConfigurationInfo = "ScalingConfigurationInfo"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case tagList = "TagList"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let activityStreamKinesisStreamName = activityStreamKinesisStreamName {
            try container.encode(activityStreamKinesisStreamName, forKey: Key("ActivityStreamKinesisStreamName"))
        }
        if let activityStreamKmsKeyId = activityStreamKmsKeyId {
            try container.encode(activityStreamKmsKeyId, forKey: Key("ActivityStreamKmsKeyId"))
        }
        if let activityStreamMode = activityStreamMode {
            try container.encode(activityStreamMode, forKey: Key("ActivityStreamMode"))
        }
        if let activityStreamStatus = activityStreamStatus {
            try container.encode(activityStreamStatus, forKey: Key("ActivityStreamStatus"))
        }
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AssociatedRoles"))
            for (index0, dbclusterrole0) in associatedRoles.enumerated() {
                try associatedRolesContainer.encode(dbclusterrole0, forKey: Key("DBClusterRole.\(index0.advanced(by: 1))"))
            }
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackConsumedChangeRecords = backtrackConsumedChangeRecords {
            try container.encode(backtrackConsumedChangeRecords, forKey: Key("BacktrackConsumedChangeRecords"))
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let capacity = capacity {
            try container.encode(capacity, forKey: Key("Capacity"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
        if let cloneGroupId = cloneGroupId {
            try container.encode(cloneGroupId, forKey: Key("CloneGroupId"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: Key("clusterCreateTime"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let crossAccountClone = crossAccountClone {
            try container.encode(crossAccountClone, forKey: Key("CrossAccountClone"))
        }
        if let customEndpoints = customEndpoints {
            var customEndpointsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("CustomEndpoints"))
            for (index0, string0) in customEndpoints.enumerated() {
                try customEndpointsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterArn = dBClusterArn {
            try container.encode(dBClusterArn, forKey: Key("DBClusterArn"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterMembers = dBClusterMembers {
            var dBClusterMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBClusterMembers"))
            for (index0, dbclustermember0) in dBClusterMembers.enumerated() {
                try dBClusterMembersContainer.encode(dbclustermember0, forKey: Key("DBClusterMember.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships {
            var dBClusterOptionGroupMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBClusterOptionGroupMemberships"))
            for (index0, dbclusteroptiongroupstatus0) in dBClusterOptionGroupMemberships.enumerated() {
                try dBClusterOptionGroupMembershipsContainer.encode(dbclusteroptiongroupstatus0, forKey: Key("DBClusterOptionGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterParameterGroup = dBClusterParameterGroup {
            try container.encode(dBClusterParameterGroup, forKey: Key("DBClusterParameterGroup"))
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: Key("DBSubnetGroup"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let dbClusterResourceId = dbClusterResourceId {
            try container.encode(dbClusterResourceId, forKey: Key("DbClusterResourceId"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DomainMemberships"))
            for (index0, domainmembership0) in domainMemberships.enumerated() {
                try domainMembershipsContainer.encode(domainmembership0, forKey: Key("DomainMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let earliestBacktrackTime = earliestBacktrackTime {
            try container.encode(TimestampWrapper(earliestBacktrackTime, format: .dateTime), forKey: Key("earliestBacktrackTime"))
        }
        if let earliestRestorableTime = earliestRestorableTime {
            try container.encode(TimestampWrapper(earliestRestorableTime, format: .dateTime), forKey: Key("earliestRestorableTime"))
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let globalWriteForwardingRequested = globalWriteForwardingRequested {
            try container.encode(globalWriteForwardingRequested, forKey: Key("GlobalWriteForwardingRequested"))
        }
        if let globalWriteForwardingStatus = globalWriteForwardingStatus {
            try container.encode(globalWriteForwardingStatus, forKey: Key("GlobalWriteForwardingStatus"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: Key("HostedZoneId"))
        }
        if let httpEndpointEnabled = httpEndpointEnabled {
            try container.encode(httpEndpointEnabled, forKey: Key("HttpEndpointEnabled"))
        }
        if let iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: Key("latestRestorableTime"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: Key("PendingModifiedValues"))
        }
        if let percentProgress = percentProgress {
            try container.encode(percentProgress, forKey: Key("PercentProgress"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let readReplicaIdentifiers = readReplicaIdentifiers {
            var readReplicaIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReadReplicaIdentifiers"))
            for (index0, string0) in readReplicaIdentifiers.enumerated() {
                try readReplicaIdentifiersContainer.encode(string0, forKey: Key("ReadReplicaIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readerEndpoint = readerEndpoint {
            try container.encode(readerEndpoint, forKey: Key("ReaderEndpoint"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: Key("ReplicationSourceIdentifier"))
        }
        if let scalingConfigurationInfo = scalingConfigurationInfo {
            try container.encode(scalingConfigurationInfo, forKey: Key("ScalingConfigurationInfo"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let characterSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let earliestRestorableTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .earliestRestorableTime)
        var earliestRestorableTimeBuffer:Date? = nil
        if let earliestRestorableTimeDecoded = earliestRestorableTimeDecoded {
            earliestRestorableTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(earliestRestorableTimeDecoded, format: .dateTime)
        }
        earliestRestorableTime = earliestRestorableTimeBuffer
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let readerEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readerEndpoint)
        readerEndpoint = readerEndpointDecoded
        if containerValues.contains(.customEndpoints) {
            struct KeyVal0{struct member{}}
            let customEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .customEndpoints)
            if let customEndpointsWrappedContainer = customEndpointsWrappedContainer {
                let customEndpointsContainer = try customEndpointsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var customEndpointsBuffer:[String]? = nil
                if let customEndpointsContainer = customEndpointsContainer {
                    customEndpointsBuffer = [String]()
                    for stringContainer0 in customEndpointsContainer {
                        customEndpointsBuffer?.append(stringContainer0)
                    }
                }
                customEndpoints = customEndpointsBuffer
            } else {
                customEndpoints = []
            }
        } else {
            customEndpoints = nil
        }
        let multiAZDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        if containerValues.contains(.dBClusterOptionGroupMemberships) {
            struct KeyVal0{struct DBClusterOptionGroup{}}
            let dBClusterOptionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterOptionGroup>.CodingKeys.self, forKey: .dBClusterOptionGroupMemberships)
            if let dBClusterOptionGroupMembershipsWrappedContainer = dBClusterOptionGroupMembershipsWrappedContainer {
                let dBClusterOptionGroupMembershipsContainer = try dBClusterOptionGroupMembershipsWrappedContainer.decodeIfPresent([DBClusterOptionGroupStatus].self, forKey: .member)
                var dBClusterOptionGroupMembershipsBuffer:[DBClusterOptionGroupStatus]? = nil
                if let dBClusterOptionGroupMembershipsContainer = dBClusterOptionGroupMembershipsContainer {
                    dBClusterOptionGroupMembershipsBuffer = [DBClusterOptionGroupStatus]()
                    for structureContainer0 in dBClusterOptionGroupMembershipsContainer {
                        dBClusterOptionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterOptionGroupMemberships = dBClusterOptionGroupMembershipsBuffer
            } else {
                dBClusterOptionGroupMemberships = []
            }
        } else {
            dBClusterOptionGroupMemberships = nil
        }
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let replicationSourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationSourceIdentifier)
        replicationSourceIdentifier = replicationSourceIdentifierDecoded
        if containerValues.contains(.readReplicaIdentifiers) {
            struct KeyVal0{struct ReadReplicaIdentifier{}}
            let readReplicaIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaIdentifier>.CodingKeys.self, forKey: .readReplicaIdentifiers)
            if let readReplicaIdentifiersWrappedContainer = readReplicaIdentifiersWrappedContainer {
                let readReplicaIdentifiersContainer = try readReplicaIdentifiersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var readReplicaIdentifiersBuffer:[String]? = nil
                if let readReplicaIdentifiersContainer = readReplicaIdentifiersContainer {
                    readReplicaIdentifiersBuffer = [String]()
                    for stringContainer0 in readReplicaIdentifiersContainer {
                        readReplicaIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaIdentifiers = readReplicaIdentifiersBuffer
            } else {
                readReplicaIdentifiers = []
            }
        } else {
            readReplicaIdentifiers = nil
        }
        if containerValues.contains(.dBClusterMembers) {
            struct KeyVal0{struct DBClusterMember{}}
            let dBClusterMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterMember>.CodingKeys.self, forKey: .dBClusterMembers)
            if let dBClusterMembersWrappedContainer = dBClusterMembersWrappedContainer {
                let dBClusterMembersContainer = try dBClusterMembersWrappedContainer.decodeIfPresent([DBClusterMember].self, forKey: .member)
                var dBClusterMembersBuffer:[DBClusterMember]? = nil
                if let dBClusterMembersContainer = dBClusterMembersContainer {
                    dBClusterMembersBuffer = [DBClusterMember]()
                    for structureContainer0 in dBClusterMembersContainer {
                        dBClusterMembersBuffer?.append(structureContainer0)
                    }
                }
                dBClusterMembers = dBClusterMembersBuffer
            } else {
                dBClusterMembers = []
            }
        } else {
            dBClusterMembers = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let storageEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbClusterResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterResourceId)
        dbClusterResourceId = dbClusterResourceIdDecoded
        let dBClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterArn)
        dBClusterArn = dBClusterArnDecoded
        if containerValues.contains(.associatedRoles) {
            struct KeyVal0{struct DBClusterRole{}}
            let associatedRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterRole>.CodingKeys.self, forKey: .associatedRoles)
            if let associatedRolesWrappedContainer = associatedRolesWrappedContainer {
                let associatedRolesContainer = try associatedRolesWrappedContainer.decodeIfPresent([DBClusterRole].self, forKey: .member)
                var associatedRolesBuffer:[DBClusterRole]? = nil
                if let associatedRolesContainer = associatedRolesContainer {
                    associatedRolesBuffer = [DBClusterRole]()
                    for structureContainer0 in associatedRolesContainer {
                        associatedRolesBuffer?.append(structureContainer0)
                    }
                }
                associatedRoles = associatedRolesBuffer
            } else {
                associatedRoles = []
            }
        } else {
            associatedRoles = nil
        }
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let cloneGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloneGroupId)
        cloneGroupId = cloneGroupIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let earliestBacktrackTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .earliestBacktrackTime)
        var earliestBacktrackTimeBuffer:Date? = nil
        if let earliestBacktrackTimeDecoded = earliestBacktrackTimeDecoded {
            earliestBacktrackTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(earliestBacktrackTimeDecoded, format: .dateTime)
        }
        earliestBacktrackTime = earliestBacktrackTimeBuffer
        let backtrackWindowDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backtrackWindow)
        backtrackWindow = backtrackWindowDecoded
        let backtrackConsumedChangeRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backtrackConsumedChangeRecords)
        backtrackConsumedChangeRecords = backtrackConsumedChangeRecordsDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        let capacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let engineModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let scalingConfigurationInfoDecoded = try containerValues.decodeIfPresent(ScalingConfigurationInfo.self, forKey: .scalingConfigurationInfo)
        scalingConfigurationInfo = scalingConfigurationInfoDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let httpEndpointEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .httpEndpointEnabled)
        httpEndpointEnabled = httpEndpointEnabledDecoded
        let activityStreamModeDecoded = try containerValues.decodeIfPresent(ActivityStreamMode.self, forKey: .activityStreamMode)
        activityStreamMode = activityStreamModeDecoded
        let activityStreamStatusDecoded = try containerValues.decodeIfPresent(ActivityStreamStatus.self, forKey: .activityStreamStatus)
        activityStreamStatus = activityStreamStatusDecoded
        let activityStreamKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityStreamKmsKeyId)
        activityStreamKmsKeyId = activityStreamKmsKeyIdDecoded
        let activityStreamKinesisStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityStreamKinesisStreamName)
        activityStreamKinesisStreamName = activityStreamKinesisStreamNameDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let crossAccountCloneDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .crossAccountClone)
        crossAccountClone = crossAccountCloneDecoded
        if containerValues.contains(.domainMemberships) {
            struct KeyVal0{struct DomainMembership{}}
            let domainMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DomainMembership>.CodingKeys.self, forKey: .domainMemberships)
            if let domainMembershipsWrappedContainer = domainMembershipsWrappedContainer {
                let domainMembershipsContainer = try domainMembershipsWrappedContainer.decodeIfPresent([DomainMembership].self, forKey: .member)
                var domainMembershipsBuffer:[DomainMembership]? = nil
                if let domainMembershipsContainer = domainMembershipsContainer {
                    domainMembershipsBuffer = [DomainMembership]()
                    for structureContainer0 in domainMembershipsContainer {
                        domainMembershipsBuffer?.append(structureContainer0)
                    }
                }
                domainMemberships = domainMembershipsBuffer
            } else {
                domainMemberships = []
            }
        } else {
            domainMemberships = nil
        }
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagListBuffer:[Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        let globalWriteForwardingStatusDecoded = try containerValues.decodeIfPresent(WriteForwardingStatus.self, forKey: .globalWriteForwardingStatus)
        globalWriteForwardingStatus = globalWriteForwardingStatusDecoded
        let globalWriteForwardingRequestedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .globalWriteForwardingRequested)
        globalWriteForwardingRequested = globalWriteForwardingRequestedDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(ClusterPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
    }
}
