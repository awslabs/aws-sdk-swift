// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension OrderableDBInstanceOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZoneGroup = "AvailabilityZoneGroup"
        case availabilityZones = "AvailabilityZones"
        case availableProcessorFeatures = "AvailableProcessorFeatures"
        case dBInstanceClass = "DBInstanceClass"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case licenseModel = "LicenseModel"
        case maxIopsPerDbInstance = "MaxIopsPerDbInstance"
        case maxIopsPerGib = "MaxIopsPerGib"
        case maxStorageSize = "MaxStorageSize"
        case minIopsPerDbInstance = "MinIopsPerDbInstance"
        case minIopsPerGib = "MinIopsPerGib"
        case minStorageSize = "MinStorageSize"
        case multiAZCapable = "MultiAZCapable"
        case outpostCapable = "OutpostCapable"
        case readReplicaCapable = "ReadReplicaCapable"
        case storageType = "StorageType"
        case supportedEngineModes = "SupportedEngineModes"
        case supportsEnhancedMonitoring = "SupportsEnhancedMonitoring"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsIAMDatabaseAuthentication = "SupportsIAMDatabaseAuthentication"
        case supportsIops = "SupportsIops"
        case supportsKerberosAuthentication = "SupportsKerberosAuthentication"
        case supportsPerformanceInsights = "SupportsPerformanceInsights"
        case supportsStorageAutoscaling = "SupportsStorageAutoscaling"
        case supportsStorageEncryption = "SupportsStorageEncryption"
        case vpc = "Vpc"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZoneGroup = availabilityZoneGroup {
            try container.encode(availabilityZoneGroup, forKey: Key("AvailabilityZoneGroup"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let availableProcessorFeatures = availableProcessorFeatures {
            var availableProcessorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailableProcessorFeatures"))
            for (index0, availableprocessorfeature0) in availableProcessorFeatures.enumerated() {
                try availableProcessorFeaturesContainer.encode(availableprocessorfeature0, forKey: Key("AvailableProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let maxIopsPerDbInstance = maxIopsPerDbInstance {
            try container.encode(maxIopsPerDbInstance, forKey: Key("MaxIopsPerDbInstance"))
        }
        if let maxIopsPerGib = maxIopsPerGib {
            try container.encode(maxIopsPerGib, forKey: Key("MaxIopsPerGib"))
        }
        if let maxStorageSize = maxStorageSize {
            try container.encode(maxStorageSize, forKey: Key("MaxStorageSize"))
        }
        if let minIopsPerDbInstance = minIopsPerDbInstance {
            try container.encode(minIopsPerDbInstance, forKey: Key("MinIopsPerDbInstance"))
        }
        if let minIopsPerGib = minIopsPerGib {
            try container.encode(minIopsPerGib, forKey: Key("MinIopsPerGib"))
        }
        if let minStorageSize = minStorageSize {
            try container.encode(minStorageSize, forKey: Key("MinStorageSize"))
        }
        if multiAZCapable != false {
            try container.encode(multiAZCapable, forKey: Key("MultiAZCapable"))
        }
        if outpostCapable != false {
            try container.encode(outpostCapable, forKey: Key("OutpostCapable"))
        }
        if readReplicaCapable != false {
            try container.encode(readReplicaCapable, forKey: Key("ReadReplicaCapable"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if supportsEnhancedMonitoring != false {
            try container.encode(supportsEnhancedMonitoring, forKey: Key("SupportsEnhancedMonitoring"))
        }
        if supportsGlobalDatabases != false {
            try container.encode(supportsGlobalDatabases, forKey: Key("SupportsGlobalDatabases"))
        }
        if supportsIAMDatabaseAuthentication != false {
            try container.encode(supportsIAMDatabaseAuthentication, forKey: Key("SupportsIAMDatabaseAuthentication"))
        }
        if supportsIops != false {
            try container.encode(supportsIops, forKey: Key("SupportsIops"))
        }
        if let supportsKerberosAuthentication = supportsKerberosAuthentication {
            try container.encode(supportsKerberosAuthentication, forKey: Key("SupportsKerberosAuthentication"))
        }
        if supportsPerformanceInsights != false {
            try container.encode(supportsPerformanceInsights, forKey: Key("SupportsPerformanceInsights"))
        }
        if let supportsStorageAutoscaling = supportsStorageAutoscaling {
            try container.encode(supportsStorageAutoscaling, forKey: Key("SupportsStorageAutoscaling"))
        }
        if supportsStorageEncryption != false {
            try container.encode(supportsStorageEncryption, forKey: Key("SupportsStorageEncryption"))
        }
        if vpc != false {
            try container.encode(vpc, forKey: Key("Vpc"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let availabilityZoneGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneGroup)
        availabilityZoneGroup = availabilityZoneGroupDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let multiAZCapableDecoded = try containerValues.decode(Bool.self, forKey: .multiAZCapable)
        multiAZCapable = multiAZCapableDecoded
        let readReplicaCapableDecoded = try containerValues.decode(Bool.self, forKey: .readReplicaCapable)
        readReplicaCapable = readReplicaCapableDecoded
        let vpcDecoded = try containerValues.decode(Bool.self, forKey: .vpc)
        vpc = vpcDecoded
        let supportsStorageEncryptionDecoded = try containerValues.decode(Bool.self, forKey: .supportsStorageEncryption)
        supportsStorageEncryption = supportsStorageEncryptionDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let supportsIopsDecoded = try containerValues.decode(Bool.self, forKey: .supportsIops)
        supportsIops = supportsIopsDecoded
        let supportsEnhancedMonitoringDecoded = try containerValues.decode(Bool.self, forKey: .supportsEnhancedMonitoring)
        supportsEnhancedMonitoring = supportsEnhancedMonitoringDecoded
        let supportsIAMDatabaseAuthenticationDecoded = try containerValues.decode(Bool.self, forKey: .supportsIAMDatabaseAuthentication)
        supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthenticationDecoded
        let supportsPerformanceInsightsDecoded = try containerValues.decode(Bool.self, forKey: .supportsPerformanceInsights)
        supportsPerformanceInsights = supportsPerformanceInsightsDecoded
        let minStorageSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minStorageSize)
        minStorageSize = minStorageSizeDecoded
        let maxStorageSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxStorageSize)
        maxStorageSize = maxStorageSizeDecoded
        let minIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minIopsPerDbInstance)
        minIopsPerDbInstance = minIopsPerDbInstanceDecoded
        let maxIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxIopsPerDbInstance)
        maxIopsPerDbInstance = maxIopsPerDbInstanceDecoded
        let minIopsPerGibDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .minIopsPerGib)
        minIopsPerGib = minIopsPerGibDecoded
        let maxIopsPerGibDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxIopsPerGib)
        maxIopsPerGib = maxIopsPerGibDecoded
        if containerValues.contains(.availableProcessorFeatures) {
            struct KeyVal0{struct AvailableProcessorFeature{}}
            let availableProcessorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailableProcessorFeature>.CodingKeys.self, forKey: .availableProcessorFeatures)
            if let availableProcessorFeaturesWrappedContainer = availableProcessorFeaturesWrappedContainer {
                let availableProcessorFeaturesContainer = try availableProcessorFeaturesWrappedContainer.decodeIfPresent([AvailableProcessorFeature].self, forKey: .member)
                var availableProcessorFeaturesBuffer:[AvailableProcessorFeature]? = nil
                if let availableProcessorFeaturesContainer = availableProcessorFeaturesContainer {
                    availableProcessorFeaturesBuffer = [AvailableProcessorFeature]()
                    for structureContainer0 in availableProcessorFeaturesContainer {
                        availableProcessorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                availableProcessorFeatures = availableProcessorFeaturesBuffer
            } else {
                availableProcessorFeatures = []
            }
        } else {
            availableProcessorFeatures = nil
        }
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedEngineModesBuffer:[String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        let supportsStorageAutoscalingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .supportsStorageAutoscaling)
        supportsStorageAutoscaling = supportsStorageAutoscalingDecoded
        let supportsKerberosAuthenticationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .supportsKerberosAuthentication)
        supportsKerberosAuthentication = supportsKerberosAuthenticationDecoded
        let outpostCapableDecoded = try containerValues.decode(Bool.self, forKey: .outpostCapable)
        outpostCapable = outpostCapableDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
    }
}
