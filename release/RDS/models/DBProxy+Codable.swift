// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DBProxy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auth = "Auth"
        case createdDate = "CreatedDate"
        case dBProxyArn = "DBProxyArn"
        case dBProxyName = "DBProxyName"
        case debugLogging = "DebugLogging"
        case endpoint = "Endpoint"
        case engineFamily = "EngineFamily"
        case idleClientTimeout = "IdleClientTimeout"
        case requireTLS = "RequireTLS"
        case roleArn = "RoleArn"
        case status = "Status"
        case updatedDate = "UpdatedDate"
        case vpcId = "VpcId"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        case vpcSubnetIds = "VpcSubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let auth = auth {
            var authContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Auth"))
            for (index0, userauthconfiginfo0) in auth.enumerated() {
                try authContainer.encode(userauthconfiginfo0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let createdDate = createdDate {
            try container.encode(TimestampWrapper(createdDate, format: .dateTime), forKey: Key("createdDate"))
        }
        if let dBProxyArn = dBProxyArn {
            try container.encode(dBProxyArn, forKey: Key("DBProxyArn"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if debugLogging != false {
            try container.encode(debugLogging, forKey: Key("DebugLogging"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let engineFamily = engineFamily {
            try container.encode(engineFamily, forKey: Key("EngineFamily"))
        }
        if idleClientTimeout != 0 {
            try container.encode(idleClientTimeout, forKey: Key("IdleClientTimeout"))
        }
        if requireTLS != false {
            try container.encode(requireTLS, forKey: Key("RequireTLS"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let updatedDate = updatedDate {
            try container.encode(TimestampWrapper(updatedDate, format: .dateTime), forKey: Key("updatedDate"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let dBProxyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBProxyArn)
        dBProxyArn = dBProxyArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DBProxyStatus.self, forKey: .status)
        status = statusDecoded
        let engineFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineFamily)
        engineFamily = engineFamilyDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct member{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        if containerValues.contains(.vpcSubnetIds) {
            struct KeyVal0{struct member{}}
            let vpcSubnetIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSubnetIds)
            if let vpcSubnetIdsWrappedContainer = vpcSubnetIdsWrappedContainer {
                let vpcSubnetIdsContainer = try vpcSubnetIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var vpcSubnetIdsBuffer:[String]? = nil
                if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
                    vpcSubnetIdsBuffer = [String]()
                    for stringContainer0 in vpcSubnetIdsContainer {
                        vpcSubnetIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSubnetIds = vpcSubnetIdsBuffer
            } else {
                vpcSubnetIds = []
            }
        } else {
            vpcSubnetIds = nil
        }
        if containerValues.contains(.auth) {
            struct KeyVal0{struct member{}}
            let authWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .auth)
            if let authWrappedContainer = authWrappedContainer {
                let authContainer = try authWrappedContainer.decodeIfPresent([UserAuthConfigInfo].self, forKey: .member)
                var authBuffer:[UserAuthConfigInfo]? = nil
                if let authContainer = authContainer {
                    authBuffer = [UserAuthConfigInfo]()
                    for structureContainer0 in authContainer {
                        authBuffer?.append(structureContainer0)
                    }
                }
                auth = authBuffer
            } else {
                auth = []
            }
        } else {
            auth = nil
        }
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let requireTLSDecoded = try containerValues.decode(Bool.self, forKey: .requireTLS)
        requireTLS = requireTLSDecoded
        let idleClientTimeoutDecoded = try containerValues.decode(Int.self, forKey: .idleClientTimeout)
        idleClientTimeout = idleClientTimeoutDecoded
        let debugLoggingDecoded = try containerValues.decode(Bool.self, forKey: .debugLogging)
        debugLogging = debugLoggingDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        var createdDateBuffer:Date? = nil
        if let createdDateDecoded = createdDateDecoded {
            createdDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdDateDecoded, format: .dateTime)
        }
        createdDate = createdDateBuffer
        let updatedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedDate)
        var updatedDateBuffer:Date? = nil
        if let updatedDateDecoded = updatedDateDecoded {
            updatedDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(updatedDateDecoded, format: .dateTime)
        }
        updatedDate = updatedDateBuffer
    }
}
