// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountQuota: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountQuotaName = "AccountQuotaName"
        case max = "Max"
        case used = "Used"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accountQuotaName = accountQuotaName {
            try container.encode(accountQuotaName, forKey: Key("AccountQuotaName"))
        }
        if max != 0 {
            try container.encode(max, forKey: Key("Max"))
        }
        if used != 0 {
            try container.encode(used, forKey: Key("Used"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountQuotaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountQuotaName)
        accountQuotaName = accountQuotaNameDecoded
        let usedDecoded = try containerValues.decode(Int.self, forKey: .used)
        used = usedDecoded
        let maxDecoded = try containerValues.decode(Int.self, forKey: .max)
        max = maxDecoded
    }
}

extension AccountQuota: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountQuota(accountQuotaName: \(String(describing: accountQuotaName)), max: \(String(describing: max)), used: \(String(describing: used)))"}
}

/// <p>Describes a quota for an AWS account.</p>
///          <p>The following are account quotas:</p>
///          <ul>
///             <li>
///               <p>
///                   <code>AllocatedStorage</code> - The total allocated storage per account, in GiB.
///                     The used value is the total allocated storage in the account, in GiB.</p>
///             </li>
///             <li>
///               <p>
///                   <code>AuthorizationsPerDBSecurityGroup</code> - The number of ingress rules per DB security group.
///                   The used value is the highest number of ingress rules in a DB security group in the account. Other
///                   DB security groups in the account might have a lower number of ingress rules.</p>
///             </li>
///             <li>
///               <p>
///                   <code>CustomEndpointsPerDBCluster</code> - The number of custom endpoints per DB cluster.
///                   The used value is the highest number of custom endpoints in a DB clusters in the account. Other
///                   DB clusters in the account might have a lower number of custom endpoints.</p>
///             </li>
///             <li>
///               <p>
///                   <code>DBClusterParameterGroups</code> - The number of DB cluster parameter groups
///                     per account, excluding default parameter groups. The used value is the count of
///                     nondefault DB cluster parameter groups in the account.</p>
///             </li>
///             <li>
///               <p>
///                   <code>DBClusterRoles</code> - The number of associated AWS Identity and Access Management (IAM) roles per DB cluster.
///                   The used value is the highest number of associated IAM roles for a DB cluster in the account. Other
///                   DB clusters in the account might have a lower number of associated IAM roles.</p>
///             </li>
///             <li>
///               <p>
///                   <code>DBClusters</code> - The number of DB clusters per account.
///                   The used value is the count of DB clusters in the account.</p>
///             </li>
///             <li>
///               <p>
///                   <code>DBInstanceRoles</code> - The number of associated IAM roles per DB instance.
///                   The used value is the highest number of associated IAM roles for a DB instance in the account. Other
///                   DB instances in the account might have a lower number of associated IAM roles.</p>
///             </li>
///             <li>
///               <p>
///                   <code>DBInstances</code> - The number of DB instances per account.
///                   The used value is the count of the DB instances in the account.</p>
///                   <p>Amazon RDS DB instances, Amazon Aurora DB instances, Amazon Neptune instances, and Amazon DocumentDB
///                       instances apply to this quota.</p>
///             </li>
///             <li>
///               <p>
///                   <code>DBParameterGroups</code> - The number of DB parameter groups per account,
///                     excluding default parameter groups. The used value is the count of nondefault DB
///                     parameter groups in the account.</p>
///             </li>
///             <li>
///               <p>
///                   <code>DBSecurityGroups</code> - The number of DB security groups (not VPC
///                     security groups) per account, excluding the default security group. The used
///                     value is the count of nondefault DB security groups in the account.</p>
///             </li>
///             <li>
///               <p>
///                   <code>DBSubnetGroups</code> - The number of DB subnet groups per account.
///                   The used value is the count of the DB subnet groups in the account.</p>
///             </li>
///             <li>
///               <p>
///                   <code>EventSubscriptions</code> - The number of event subscriptions per account.
///                   The used value is the count of the event subscriptions in the account.</p>
///             </li>
///             <li>
///               <p>
///                   <code>ManualClusterSnapshots</code> - The number of manual DB cluster snapshots per account.
///                   The used value is the count of the manual DB cluster snapshots in the account.</p>
///             </li>
///             <li>
///               <p>
///                   <code>ManualSnapshots</code> - The number of manual DB instance snapshots per account.
///                   The used value is the count of the manual DB instance snapshots in the account.</p>
///             </li>
///             <li>
///               <p>
///                   <code>OptionGroups</code> - The number of DB option groups per account, excluding
///                     default option groups. The used value is the count of nondefault DB option
///                     groups in the account.</p>
///             </li>
///             <li>
///               <p>
///                   <code>ReadReplicasPerMaster</code> - The number of read replicas per DB
///                     instance. The used value is the highest number of read replicas for a DB
///                     instance in the account. Other DB instances in the account might have a lower
///                     number of read replicas.</p>
///             </li>
///             <li>
///               <p>
///                   <code>ReservedDBInstances</code> - The number of reserved DB instances per account.
///                   The used value is the count of the active reserved DB instances in the account.</p>
///             </li>
///             <li>
///               <p>
///                   <code>SubnetsPerDBSubnetGroup</code> - The number of subnets per DB subnet group.
///                   The used value is highest number of subnets for a DB subnet group in the account. Other
///                   DB subnet groups in the account might have a lower number of subnets.</p>
///             </li>
///          </ul>
///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html">Quotas for Amazon RDS</a> in the
///                 <i>Amazon RDS User Guide</i> and <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_Limits.html">Quotas for Amazon Aurora</a> in the
///                 <i>Amazon Aurora User Guide</i>.</p>
public struct AccountQuota: Equatable {
    /// <p>The name of the Amazon RDS quota for this AWS account.</p>
    public let accountQuotaName: String?
    /// <p>The maximum allowed value for the quota.</p>
    public let max: Int
    /// <p>The amount currently used toward the quota maximum.</p>
    public let used: Int

    public init (
        accountQuotaName: String? = nil,
        max: Int = 0,
        used: Int = 0
    )
    {
        self.accountQuotaName = accountQuotaName
        self.max = max
        self.used = used
    }
}

public enum ActivityStreamMode {
    case async
    case sync
    case sdkUnknown(String)
}

extension ActivityStreamMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActivityStreamMode] {
        return [
            .async,
            .sync,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .async: return "async"
        case .sync: return "sync"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActivityStreamMode(rawValue: rawValue) ?? ActivityStreamMode.sdkUnknown(rawValue)
    }
}

public enum ActivityStreamStatus {
    case started
    case starting
    case stopped
    case stopping
    case sdkUnknown(String)
}

extension ActivityStreamStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActivityStreamStatus] {
        return [
            .started,
            .starting,
            .stopped,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .started: return "started"
        case .starting: return "starting"
        case .stopped: return "stopped"
        case .stopping: return "stopping"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActivityStreamStatus(rawValue: rawValue) ?? ActivityStreamStatus.sdkUnknown(rawValue)
    }
}

public struct AddRoleToDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "AddRoleToDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToDBClusterOutputError>
}

extension AddRoleToDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddRoleToDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), featureName: \(String(describing: featureName)), roleArn: \(String(describing: roleArn)))"}
}

extension AddRoleToDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        try container.encode("AddRoleToDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct AddRoleToDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "AddRoleToDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToDBClusterOutputError>
}

public struct AddRoleToDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "AddRoleToDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToDBClusterOutputError>
}

public struct AddRoleToDBClusterInput: Equatable {
    /// <p>The name of the DB cluster to associate the IAM role with.</p>
    public let dBClusterIdentifier: String?
    /// <p>The name of the feature for the DB cluster that the IAM role is to be associated with.
    ///             For the list of supported feature names, see <a>DBEngineVersion</a>.</p>
    public let featureName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to associate with the Aurora DB
    ///             cluster, for example, <code>arn:aws:iam::123456789012:role/AuroraAccessRole</code>.</p>
    public let roleArn: String?

    public init (
        dBClusterIdentifier: String? = nil,
        featureName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension AddRoleToDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddRoleToDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleAlreadyExistsFault" : self = .dBClusterRoleAlreadyExistsFault(try DBClusterRoleAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleQuotaExceededFault" : self = .dBClusterRoleQuotaExceededFault(try DBClusterRoleQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddRoleToDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterRoleAlreadyExistsFault(DBClusterRoleAlreadyExistsFault)
    case dBClusterRoleQuotaExceededFault(DBClusterRoleQuotaExceededFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddRoleToDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddRoleToDBClusterOutputResponse()"}
}

extension AddRoleToDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddRoleToDBClusterOutputResponse: Equatable {

    public init() {}
}

struct AddRoleToDBClusterOutputResponseBody: Equatable {
}

extension AddRoleToDBClusterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddRoleToDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "AddRoleToDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToDBInstanceInput>
    public typealias MOutput = OperationOutput<AddRoleToDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToDBInstanceOutputError>
}

extension AddRoleToDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddRoleToDBInstanceInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), featureName: \(String(describing: featureName)), roleArn: \(String(describing: roleArn)))"}
}

extension AddRoleToDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        try container.encode("AddRoleToDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct AddRoleToDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "AddRoleToDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToDBInstanceInput>
    public typealias MOutput = OperationOutput<AddRoleToDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToDBInstanceOutputError>
}

public struct AddRoleToDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "AddRoleToDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToDBInstanceInput>
    public typealias MOutput = OperationOutput<AddRoleToDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToDBInstanceOutputError>
}

public struct AddRoleToDBInstanceInput: Equatable {
    /// <p>The name of the DB instance to associate the IAM role with.</p>
    public let dBInstanceIdentifier: String?
    /// <p>The name of the feature for the DB instance that the IAM role is to be associated with.
    ///             For the list of supported feature names, see <a>DBEngineVersion</a>.
    ///         </p>
    public let featureName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to associate with the DB instance, for
    ///             example <code>arn:aws:iam::123456789012:role/AccessRole</code>. </p>
    public let roleArn: String?

    public init (
        dBInstanceIdentifier: String? = nil,
        featureName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension AddRoleToDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddRoleToDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceRoleAlreadyExistsFault" : self = .dBInstanceRoleAlreadyExistsFault(try DBInstanceRoleAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceRoleQuotaExceededFault" : self = .dBInstanceRoleQuotaExceededFault(try DBInstanceRoleQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddRoleToDBInstanceOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBInstanceRoleAlreadyExistsFault(DBInstanceRoleAlreadyExistsFault)
    case dBInstanceRoleQuotaExceededFault(DBInstanceRoleQuotaExceededFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddRoleToDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddRoleToDBInstanceOutputResponse()"}
}

extension AddRoleToDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddRoleToDBInstanceOutputResponse: Equatable {

    public init() {}
}

struct AddRoleToDBInstanceOutputResponseBody: Equatable {
}

extension AddRoleToDBInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddSourceIdentifierToSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "AddSourceIdentifierToSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

extension AddSourceIdentifierToSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddSourceIdentifierToSubscriptionInput(sourceIdentifier: \(String(describing: sourceIdentifier)), subscriptionName: \(String(describing: subscriptionName)))"}
}

extension AddSourceIdentifierToSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: Key("SourceIdentifier"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("AddSourceIdentifierToSubscription", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct AddSourceIdentifierToSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "AddSourceIdentifierToSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

public struct AddSourceIdentifierToSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "AddSourceIdentifierToSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

/// <p></p>
public struct AddSourceIdentifierToSubscriptionInput: Equatable {
    /// <p>The identifier of the event source to be added.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the source type is a DB instance, a <code>DBInstanceIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB cluster, a <code>DBClusterIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB parameter group, a <code>DBParameterGroupName</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB security group, a <code>DBSecurityGroupName</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB snapshot, a <code>DBSnapshotIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB cluster snapshot, a <code>DBClusterSnapshotIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///          </ul>
    public let sourceIdentifier: String?
    /// <p>The name of the RDS event notification subscription you want to add a source identifier to.</p>
    public let subscriptionName: String?

    public init (
        sourceIdentifier: String? = nil,
        subscriptionName: String? = nil
    )
    {
        self.sourceIdentifier = sourceIdentifier
        self.subscriptionName = subscriptionName
    }
}

extension AddSourceIdentifierToSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddSourceIdentifierToSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddSourceIdentifierToSubscriptionOutputError: Equatable {
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddSourceIdentifierToSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddSourceIdentifierToSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension AddSourceIdentifierToSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddSourceIdentifierToSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct AddSourceIdentifierToSubscriptionOutputResponse: Equatable {
    /// <p>Contains the results of a successful invocation of the <code>DescribeEventSubscriptions</code> action.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct AddSourceIdentifierToSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension AddSourceIdentifierToSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AddSourceIdentifierToSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct AddTagsToResourceInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceInput(resourceName: \(String(describing: resourceName)), tags: \(String(describing: tags)))"}
}

extension AddTagsToResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AddTagsToResource", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

/// <p></p>
public struct AddTagsToResourceInput: Equatable {
    /// <p>The Amazon RDS resource that the tags are added to. This value is an Amazon Resource Name (ARN). For information about
    ///             creating an ARN,
    ///         see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///             Constructing an RDS Amazon Resource Name (ARN)</a>.</p>
    public let resourceName: String?
    /// <p>The tags to be assigned to the Amazon RDS resource.</p>
    public let tags: [Tag]?

    public init (
        resourceName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceName = resourceName
        self.tags = tags
    }
}

extension AddTagsToResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceOutputResponse()"}
}

extension AddTagsToResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToResourceOutputResponse: Equatable {

    public init() {}
}

struct AddTagsToResourceOutputResponseBody: Equatable {
}

extension AddTagsToResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ApplyMethod {
    case immediate
    case pendingReboot
    case sdkUnknown(String)
}

extension ApplyMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApplyMethod] {
        return [
            .immediate,
            .pendingReboot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .immediate: return "immediate"
        case .pendingReboot: return "pending-reboot"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApplyMethod(rawValue: rawValue) ?? ApplyMethod.sdkUnknown(rawValue)
    }
}

public struct ApplyPendingMaintenanceActionInputBodyMiddleware: Middleware {
    public let id: String = "ApplyPendingMaintenanceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyPendingMaintenanceActionOutputError>
}

extension ApplyPendingMaintenanceActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplyPendingMaintenanceActionInput(applyAction: \(String(describing: applyAction)), optInType: \(String(describing: optInType)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

extension ApplyPendingMaintenanceActionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applyAction = applyAction {
            try container.encode(applyAction, forKey: Key("ApplyAction"))
        }
        if let optInType = optInType {
            try container.encode(optInType, forKey: Key("OptInType"))
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: Key("ResourceIdentifier"))
        }
        try container.encode("ApplyPendingMaintenanceAction", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ApplyPendingMaintenanceActionInputHeadersMiddleware: Middleware {
    public let id: String = "ApplyPendingMaintenanceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyPendingMaintenanceActionOutputError>
}

public struct ApplyPendingMaintenanceActionInputQueryItemMiddleware: Middleware {
    public let id: String = "ApplyPendingMaintenanceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyPendingMaintenanceActionOutputError>
}

/// <p></p>
public struct ApplyPendingMaintenanceActionInput: Equatable {
    /// <p>The pending maintenance action to apply to this resource.</p>
    ///          <p>Valid values: <code>system-update</code>, <code>db-upgrade</code>,
    ///           <code>hardware-maintenance</code>, <code>ca-certificate-rotation</code>
    ///          </p>
    public let applyAction: String?
    /// <p>A value that specifies the type of opt-in request, or undoes an opt-in request. An opt-in
    ///            request of type <code>immediate</code> can't be undone.</p>
    ///          <p>Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>immediate</code> - Apply the maintenance action immediately.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>next-maintenance</code> - Apply the maintenance action during
    ///             the next maintenance window for the resource.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>undo-opt-in</code> - Cancel any existing <code>next-maintenance</code>
    ///             opt-in requests.</p>
    ///             </li>
    ///          </ul>
    public let optInType: String?
    /// <p>The RDS Amazon Resource Name (ARN) of the resource that the
    ///       pending maintenance action applies to. For information about
    ///       creating an ARN,
    ///       see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///         Constructing an RDS Amazon Resource Name (ARN)</a>.</p>
    public let resourceIdentifier: String?

    public init (
        applyAction: String? = nil,
        optInType: String? = nil,
        resourceIdentifier: String? = nil
    )
    {
        self.applyAction = applyAction
        self.optInType = optInType
        self.resourceIdentifier = resourceIdentifier
    }
}

extension ApplyPendingMaintenanceActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ApplyPendingMaintenanceActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplyPendingMaintenanceActionOutputError: Equatable {
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyPendingMaintenanceActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplyPendingMaintenanceActionOutputResponse(resourcePendingMaintenanceActions: \(String(describing: resourcePendingMaintenanceActions)))"}
}

extension ApplyPendingMaintenanceActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApplyPendingMaintenanceActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourcePendingMaintenanceActions = output.resourcePendingMaintenanceActions
        } else {
            self.resourcePendingMaintenanceActions = nil
        }
    }
}

public struct ApplyPendingMaintenanceActionOutputResponse: Equatable {
    /// <p>Describes the pending maintenance actions for a resource.</p>
    public let resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions?

    public init (
        resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions? = nil
    )
    {
        self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
    }
}

struct ApplyPendingMaintenanceActionOutputResponseBody: Equatable {
    public let resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions?
}

extension ApplyPendingMaintenanceActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ApplyPendingMaintenanceActionResult"))
        let resourcePendingMaintenanceActionsDecoded = try containerValues.decodeIfPresent(ResourcePendingMaintenanceActions.self, forKey: .resourcePendingMaintenanceActions)
        resourcePendingMaintenanceActions = resourcePendingMaintenanceActionsDecoded
    }
}

public enum AuthScheme {
    case secrets
    case sdkUnknown(String)
}

extension AuthScheme : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthScheme] {
        return [
            .secrets,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .secrets: return "SECRETS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthScheme(rawValue: rawValue) ?? AuthScheme.sdkUnknown(rawValue)
    }
}

extension AuthorizationAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension AuthorizationAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AuthorizationAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified CIDR IP range or Amazon EC2 security group is already authorized for
///             the specified DB security group.</p>
public struct AuthorizationAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension AuthorizationAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuthorizationNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationNotFoundFault(message: \(String(describing: message)))"}
}

extension AuthorizationNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AuthorizationNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified CIDR IP range or Amazon EC2 security group might not be authorized
///             for the specified DB security group.</p>
///         <p>Or, RDS might not be authorized to perform necessary actions using IAM on your
///             behalf.</p>
public struct AuthorizationNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationNotFoundFaultBody: Equatable {
    public let message: String?
}

extension AuthorizationNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuthorizationQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationQuotaExceededFault(message: \(String(describing: message)))"}
}

extension AuthorizationQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AuthorizationQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB security group authorization quota has been reached.</p>
public struct AuthorizationQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension AuthorizationQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AuthorizeDBSecurityGroupIngressInputBodyMiddleware: Middleware {
    public let id: String = "AuthorizeDBSecurityGroupIngressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeDBSecurityGroupIngressOutputError>
}

extension AuthorizeDBSecurityGroupIngressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizeDBSecurityGroupIngressInput(cIDRIP: \(String(describing: cIDRIP)), dBSecurityGroupName: \(String(describing: dBSecurityGroupName)), eC2SecurityGroupId: \(String(describing: eC2SecurityGroupId)), eC2SecurityGroupName: \(String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(String(describing: eC2SecurityGroupOwnerId)))"}
}

extension AuthorizeDBSecurityGroupIngressInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: Key("CIDRIP"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: Key("DBSecurityGroupName"))
        }
        if let eC2SecurityGroupId = eC2SecurityGroupId {
            try container.encode(eC2SecurityGroupId, forKey: Key("EC2SecurityGroupId"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: Key("EC2SecurityGroupOwnerId"))
        }
        try container.encode("AuthorizeDBSecurityGroupIngress", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct AuthorizeDBSecurityGroupIngressInputHeadersMiddleware: Middleware {
    public let id: String = "AuthorizeDBSecurityGroupIngressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeDBSecurityGroupIngressOutputError>
}

public struct AuthorizeDBSecurityGroupIngressInputQueryItemMiddleware: Middleware {
    public let id: String = "AuthorizeDBSecurityGroupIngressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeDBSecurityGroupIngressOutputError>
}

/// <p></p>
public struct AuthorizeDBSecurityGroupIngressInput: Equatable {
    /// <p>The IP range to authorize.</p>
    public let cIDRIP: String?
    /// <p>The name of the DB security group to add authorization to.</p>
    public let dBSecurityGroupName: String?
    /// <p>
    ///         Id of the EC2 security group to authorize.
    ///         For VPC DB security groups, <code>EC2SecurityGroupId</code> must be provided.
    ///         Otherwise, <code>EC2SecurityGroupOwnerId</code> and either <code>EC2SecurityGroupName</code> or <code>EC2SecurityGroupId</code> must be provided.
    ///         </p>
    public let eC2SecurityGroupId: String?
    /// <p>
    ///         Name of the EC2 security group to authorize.
    ///         For VPC DB security groups, <code>EC2SecurityGroupId</code> must be provided.
    ///         Otherwise, <code>EC2SecurityGroupOwnerId</code> and either <code>EC2SecurityGroupName</code>
    ///       or <code>EC2SecurityGroupId</code> must be provided.
    ///         </p>
    public let eC2SecurityGroupName: String?
    /// <p>
    ///         AWS account number of the owner of the EC2 security group
    ///         specified in the <code>EC2SecurityGroupName</code> parameter.
    ///         The AWS access key ID isn't an acceptable value.
    ///         For VPC DB security groups, <code>EC2SecurityGroupId</code> must be provided.
    ///         Otherwise, <code>EC2SecurityGroupOwnerId</code> and either <code>EC2SecurityGroupName</code> or <code>EC2SecurityGroupId</code> must be provided.
    ///         </p>
    public let eC2SecurityGroupOwnerId: String?

    public init (
        cIDRIP: String? = nil,
        dBSecurityGroupName: String? = nil,
        eC2SecurityGroupId: String? = nil,
        eC2SecurityGroupName: String? = nil,
        eC2SecurityGroupOwnerId: String? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.dBSecurityGroupName = dBSecurityGroupName
        self.eC2SecurityGroupId = eC2SecurityGroupId
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
    }
}

extension AuthorizeDBSecurityGroupIngressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AuthorizeDBSecurityGroupIngressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationAlreadyExistsFault" : self = .authorizationAlreadyExistsFault(try AuthorizationAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationQuotaExceededFault" : self = .authorizationQuotaExceededFault(try AuthorizationQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupStateFault" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AuthorizeDBSecurityGroupIngressOutputError: Equatable {
    case authorizationAlreadyExistsFault(AuthorizationAlreadyExistsFault)
    case authorizationQuotaExceededFault(AuthorizationQuotaExceededFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeDBSecurityGroupIngressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizeDBSecurityGroupIngressOutputResponse(dBSecurityGroup: \(String(describing: dBSecurityGroup)))"}
}

extension AuthorizeDBSecurityGroupIngressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AuthorizeDBSecurityGroupIngressOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSecurityGroup = output.dBSecurityGroup
        } else {
            self.dBSecurityGroup = nil
        }
    }
}

public struct AuthorizeDBSecurityGroupIngressOutputResponse: Equatable {
    /// <p>Contains the details for an Amazon RDS DB security group.
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBSecurityGroups</code> action.
    ///       </p>
    public let dBSecurityGroup: DBSecurityGroup?

    public init (
        dBSecurityGroup: DBSecurityGroup? = nil
    )
    {
        self.dBSecurityGroup = dBSecurityGroup
    }
}

struct AuthorizeDBSecurityGroupIngressOutputResponseBody: Equatable {
    public let dBSecurityGroup: DBSecurityGroup?
}

extension AuthorizeDBSecurityGroupIngressOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSecurityGroup = "DBSecurityGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AuthorizeDBSecurityGroupIngressResult"))
        let dBSecurityGroupDecoded = try containerValues.decodeIfPresent(DBSecurityGroup.self, forKey: .dBSecurityGroup)
        dBSecurityGroup = dBSecurityGroupDecoded
    }
}

extension AvailabilityZone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AvailabilityZone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailabilityZone(name: \(String(describing: name)))"}
}

/// <p>Contains Availability Zone information.</p>
///         <p> This data type is used as an element in the <code>OrderableDBInstanceOption</code>
///             data type.</p>
public struct AvailabilityZone: Equatable {
    /// <p>The name of the Availability Zone.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension AvailableProcessorFeature: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedValues = "AllowedValues"
        case defaultValue = "DefaultValue"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: Key("AllowedValues"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
    }
}

extension AvailableProcessorFeature: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailableProcessorFeature(allowedValues: \(String(describing: allowedValues)), defaultValue: \(String(describing: defaultValue)), name: \(String(describing: name)))"}
}

/// <p>Contains the available processor feature information for the DB instance class of a DB instance.</p>
///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor">Configuring the
///                 Processor of the DB Instance Class</a> in the <i>Amazon RDS User Guide.
///             </i>
///          </p>
public struct AvailableProcessorFeature: Equatable {
    /// <p>The allowed values for the processor feature of the DB instance class.</p>
    public let allowedValues: String?
    /// <p>The default value for the processor feature of the DB instance class.</p>
    public let defaultValue: String?
    /// <p>The name of the processor feature. Valid names are <code>coreCount</code>
    ///             and <code>threadsPerCore</code>.</p>
    public let name: String?

    public init (
        allowedValues: String? = nil,
        defaultValue: String? = nil,
        name: String? = nil
    )
    {
        self.allowedValues = allowedValues
        self.defaultValue = defaultValue
        self.name = name
    }
}

public struct BacktrackDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "BacktrackDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BacktrackDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<BacktrackDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BacktrackDBClusterInput>
    public typealias MOutput = OperationOutput<BacktrackDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BacktrackDBClusterOutputError>
}

extension BacktrackDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BacktrackDBClusterInput(backtrackTo: \(String(describing: backtrackTo)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), force: \(String(describing: force)), useEarliestTimeOnPointInTimeUnavailable: \(String(describing: useEarliestTimeOnPointInTimeUnavailable)))"}
}

extension BacktrackDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let backtrackTo = backtrackTo {
            try container.encode(TimestampWrapper(backtrackTo, format: .dateTime), forKey: Key("backtrackTo"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let force = force {
            try container.encode(force, forKey: Key("Force"))
        }
        if let useEarliestTimeOnPointInTimeUnavailable = useEarliestTimeOnPointInTimeUnavailable {
            try container.encode(useEarliestTimeOnPointInTimeUnavailable, forKey: Key("UseEarliestTimeOnPointInTimeUnavailable"))
        }
        try container.encode("BacktrackDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct BacktrackDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "BacktrackDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BacktrackDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<BacktrackDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BacktrackDBClusterInput>
    public typealias MOutput = OperationOutput<BacktrackDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BacktrackDBClusterOutputError>
}

public struct BacktrackDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "BacktrackDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BacktrackDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<BacktrackDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BacktrackDBClusterInput>
    public typealias MOutput = OperationOutput<BacktrackDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BacktrackDBClusterOutputError>
}

/// <p></p>
public struct BacktrackDBClusterInput: Equatable {
    /// <p>The timestamp of the time to backtrack the DB cluster to, specified in ISO
    ///             8601 format. For more information about ISO 8601, see the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia
    ///             page.</a>
    ///          </p>
    ///         <note>
    ///             <p>If the specified time isn't a consistent time for the DB cluster,
    ///                 Aurora automatically chooses the nearest possible consistent time for the DB cluster.</p>
    ///         </note>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must contain a valid ISO 8601 timestamp.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Can't contain a timestamp set in the future.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>2017-07-08T18:00Z</code>
    ///          </p>
    public let backtrackTo: Date?
    /// <p>The DB cluster identifier of the DB cluster to be backtracked. This parameter is
    ///             stored as a lowercase string.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>my-cluster1</code>
    ///         </p>
    public let dBClusterIdentifier: String?
    /// <p>A value that indicates whether to force the DB cluster to backtrack when binary logging is
    ///             enabled. Otherwise, an error occurs when binary logging is enabled.</p>
    public let force: Bool?
    /// <p>A value that indicates whether to backtrack the DB cluster to the earliest possible
    ///             backtrack time when <i>BacktrackTo</i> is set to a timestamp earlier than the earliest
    ///             backtrack time. When this parameter is disabled and <i>BacktrackTo</i> is set to a timestamp earlier than the earliest
    ///             backtrack time, an error occurs.</p>
    public let useEarliestTimeOnPointInTimeUnavailable: Bool?

    public init (
        backtrackTo: Date? = nil,
        dBClusterIdentifier: String? = nil,
        force: Bool? = nil,
        useEarliestTimeOnPointInTimeUnavailable: Bool? = nil
    )
    {
        self.backtrackTo = backtrackTo
        self.dBClusterIdentifier = dBClusterIdentifier
        self.force = force
        self.useEarliestTimeOnPointInTimeUnavailable = useEarliestTimeOnPointInTimeUnavailable
    }
}

extension BacktrackDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension BacktrackDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BacktrackDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension BacktrackDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BacktrackDBClusterOutputResponse(backtrackIdentifier: \(String(describing: backtrackIdentifier)), backtrackRequestCreationTime: \(String(describing: backtrackRequestCreationTime)), backtrackTo: \(String(describing: backtrackTo)), backtrackedFrom: \(String(describing: backtrackedFrom)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), status: \(String(describing: status)))"}
}

extension BacktrackDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BacktrackDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backtrackIdentifier = output.backtrackIdentifier
            self.backtrackRequestCreationTime = output.backtrackRequestCreationTime
            self.backtrackTo = output.backtrackTo
            self.backtrackedFrom = output.backtrackedFrom
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.status = output.status
        } else {
            self.backtrackIdentifier = nil
            self.backtrackRequestCreationTime = nil
            self.backtrackTo = nil
            self.backtrackedFrom = nil
            self.dBClusterIdentifier = nil
            self.status = nil
        }
    }
}

/// <p>This data type is used as a response element in the <code>DescribeDBClusterBacktracks</code> action.</p>
public struct BacktrackDBClusterOutputResponse: Equatable {
    /// <p>Contains the backtrack identifier.</p>
    public let backtrackIdentifier: String?
    /// <p>The timestamp of the time at which the backtrack was requested.</p>
    public let backtrackRequestCreationTime: Date?
    /// <p>The timestamp of the time to which the DB cluster was backtracked.</p>
    public let backtrackTo: Date?
    /// <p>The timestamp of the time from which the DB cluster was backtracked.</p>
    public let backtrackedFrom: Date?
    /// <p>Contains a user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.</p>
    public let dBClusterIdentifier: String?
    /// <p>The status of the backtrack. This property returns one of the following
    ///             values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>applying</code> - The backtrack is currently being applied to or rolled back from the DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>completed</code> - The backtrack has successfully been applied to or rolled back from the DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>failed</code> - An error occurred while the backtrack was applied to or rolled back from the DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code> - The backtrack is currently pending application to or rollback from the DB cluster.</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        backtrackIdentifier: String? = nil,
        backtrackRequestCreationTime: Date? = nil,
        backtrackTo: Date? = nil,
        backtrackedFrom: Date? = nil,
        dBClusterIdentifier: String? = nil,
        status: String? = nil
    )
    {
        self.backtrackIdentifier = backtrackIdentifier
        self.backtrackRequestCreationTime = backtrackRequestCreationTime
        self.backtrackTo = backtrackTo
        self.backtrackedFrom = backtrackedFrom
        self.dBClusterIdentifier = dBClusterIdentifier
        self.status = status
    }
}

struct BacktrackDBClusterOutputResponseBody: Equatable {
    public let dBClusterIdentifier: String?
    public let backtrackIdentifier: String?
    public let backtrackTo: Date?
    public let backtrackedFrom: Date?
    public let backtrackRequestCreationTime: Date?
    public let status: String?
}

extension BacktrackDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backtrackIdentifier = "BacktrackIdentifier"
        case backtrackRequestCreationTime = "BacktrackRequestCreationTime"
        case backtrackTo = "BacktrackTo"
        case backtrackedFrom = "BacktrackedFrom"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("BacktrackDBClusterResult"))
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let backtrackIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backtrackIdentifier)
        backtrackIdentifier = backtrackIdentifierDecoded
        let backtrackToDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backtrackTo)
        var backtrackToBuffer:Date? = nil
        if let backtrackToDecoded = backtrackToDecoded {
            backtrackToBuffer = try TimestampWrapperDecoder.parseDateStringValue(backtrackToDecoded, format: .dateTime)
        }
        backtrackTo = backtrackToBuffer
        let backtrackedFromDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backtrackedFrom)
        var backtrackedFromBuffer:Date? = nil
        if let backtrackedFromDecoded = backtrackedFromDecoded {
            backtrackedFromBuffer = try TimestampWrapperDecoder.parseDateStringValue(backtrackedFromDecoded, format: .dateTime)
        }
        backtrackedFrom = backtrackedFromBuffer
        let backtrackRequestCreationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backtrackRequestCreationTime)
        var backtrackRequestCreationTimeBuffer:Date? = nil
        if let backtrackRequestCreationTimeDecoded = backtrackRequestCreationTimeDecoded {
            backtrackRequestCreationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(backtrackRequestCreationTimeDecoded, format: .dateTime)
        }
        backtrackRequestCreationTime = backtrackRequestCreationTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension BackupPolicyNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupPolicyNotFoundFault(message: \(String(describing: message)))"}
}

extension BackupPolicyNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<BackupPolicyNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

@available(*, deprecated, message: "Please avoid using this fault")
public struct BackupPolicyNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BackupPolicyNotFoundFaultBody: Equatable {
    public let message: String?
}

extension BackupPolicyNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelExportTaskInputBodyMiddleware: Middleware {
    public let id: String = "CancelExportTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelExportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelExportTaskInput>
    public typealias MOutput = OperationOutput<CancelExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelExportTaskOutputError>
}

extension CancelExportTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelExportTaskInput(exportTaskIdentifier: \(String(describing: exportTaskIdentifier)))"}
}

extension CancelExportTaskInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: Key("ExportTaskIdentifier"))
        }
        try container.encode("CancelExportTask", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CancelExportTaskInputHeadersMiddleware: Middleware {
    public let id: String = "CancelExportTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelExportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelExportTaskInput>
    public typealias MOutput = OperationOutput<CancelExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelExportTaskOutputError>
}

public struct CancelExportTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelExportTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelExportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelExportTaskInput>
    public typealias MOutput = OperationOutput<CancelExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelExportTaskOutputError>
}

public struct CancelExportTaskInput: Equatable {
    /// <p>The identifier of the snapshot export task to cancel.</p>
    public let exportTaskIdentifier: String?

    public init (
        exportTaskIdentifier: String? = nil
    )
    {
        self.exportTaskIdentifier = exportTaskIdentifier
    }
}

extension CancelExportTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CancelExportTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExportTaskNotFoundFault" : self = .exportTaskNotFoundFault(try ExportTaskNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExportTaskStateFault" : self = .invalidExportTaskStateFault(try InvalidExportTaskStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelExportTaskOutputError: Equatable {
    case exportTaskNotFoundFault(ExportTaskNotFoundFault)
    case invalidExportTaskStateFault(InvalidExportTaskStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelExportTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelExportTaskOutputResponse(exportOnly: \(String(describing: exportOnly)), exportTaskIdentifier: \(String(describing: exportTaskIdentifier)), failureCause: \(String(describing: failureCause)), iamRoleArn: \(String(describing: iamRoleArn)), kmsKeyId: \(String(describing: kmsKeyId)), percentProgress: \(String(describing: percentProgress)), s3Bucket: \(String(describing: s3Bucket)), s3Prefix: \(String(describing: s3Prefix)), snapshotTime: \(String(describing: snapshotTime)), sourceArn: \(String(describing: sourceArn)), status: \(String(describing: status)), taskEndTime: \(String(describing: taskEndTime)), taskStartTime: \(String(describing: taskStartTime)), totalExtractedDataInGB: \(String(describing: totalExtractedDataInGB)), warningMessage: \(String(describing: warningMessage)))"}
}

extension CancelExportTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelExportTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exportOnly = output.exportOnly
            self.exportTaskIdentifier = output.exportTaskIdentifier
            self.failureCause = output.failureCause
            self.iamRoleArn = output.iamRoleArn
            self.kmsKeyId = output.kmsKeyId
            self.percentProgress = output.percentProgress
            self.s3Bucket = output.s3Bucket
            self.s3Prefix = output.s3Prefix
            self.snapshotTime = output.snapshotTime
            self.sourceArn = output.sourceArn
            self.status = output.status
            self.taskEndTime = output.taskEndTime
            self.taskStartTime = output.taskStartTime
            self.totalExtractedDataInGB = output.totalExtractedDataInGB
            self.warningMessage = output.warningMessage
        } else {
            self.exportOnly = nil
            self.exportTaskIdentifier = nil
            self.failureCause = nil
            self.iamRoleArn = nil
            self.kmsKeyId = nil
            self.percentProgress = 0
            self.s3Bucket = nil
            self.s3Prefix = nil
            self.snapshotTime = nil
            self.sourceArn = nil
            self.status = nil
            self.taskEndTime = nil
            self.taskStartTime = nil
            self.totalExtractedDataInGB = 0
            self.warningMessage = nil
        }
    }
}

/// <p>Contains the details of a snapshot export to Amazon S3.
///         </p>
///         <p>This data type is used as a response element in the <code>DescribeExportTasks</code> action.
///         </p>
public struct CancelExportTaskOutputResponse: Equatable {
    /// <p>The data exported from the snapshot. Valid values are the following:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>database</code> - Export all the data from a specified database.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.table</code>
    ///                   <i>table-name</i> -
    ///                 Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.schema</code>
    ///                   <i>schema-name</i> - Export a database schema of the snapshot.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.schema.table</code>
    ///                   <i>table-name</i> - Export a table of the database schema.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p>
    ///             </li>
    ///          </ul>
    public let exportOnly: [String]?
    /// <p>A unique identifier for the snapshot export task. This ID isn't an identifier for
    ///             the Amazon S3 bucket where the snapshot is exported to. </p>
    public let exportTaskIdentifier: String?
    /// <p>The reason the export failed, if it failed.</p>
    public let failureCause: String?
    /// <p>The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot. </p>
    public let iamRoleArn: String?
    /// <p>The key identifier of the AWS KMS customer master key (CMK) that is used to encrypt the snapshot when it's exported to
    ///             Amazon S3. The AWS KMS CMK identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the snapshot export
    ///             must have encryption and decryption permissions to use this AWS KMS CMK. </p>
    public let kmsKeyId: String?
    /// <p>The progress of the snapshot export task as a percentage.</p>
    public let percentProgress: Int
    /// <p>The Amazon S3 bucket that the snapshot is exported to.</p>
    public let s3Bucket: String?
    /// <p>The Amazon S3 bucket prefix that is the file name and path of the exported snapshot.</p>
    public let s3Prefix: String?
    /// <p>The time that the snapshot was created.</p>
    public let snapshotTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.</p>
    public let sourceArn: String?
    /// <p>The progress status of the export task.</p>
    public let status: String?
    /// <p>The time that the snapshot export task completed.</p>
    public let taskEndTime: Date?
    /// <p>The time that the snapshot export task started.</p>
    public let taskStartTime: Date?
    /// <p>The total amount of data exported, in gigabytes.</p>
    public let totalExtractedDataInGB: Int
    /// <p>A warning about the snapshot export task.</p>
    public let warningMessage: String?

    public init (
        exportOnly: [String]? = nil,
        exportTaskIdentifier: String? = nil,
        failureCause: String? = nil,
        iamRoleArn: String? = nil,
        kmsKeyId: String? = nil,
        percentProgress: Int = 0,
        s3Bucket: String? = nil,
        s3Prefix: String? = nil,
        snapshotTime: Date? = nil,
        sourceArn: String? = nil,
        status: String? = nil,
        taskEndTime: Date? = nil,
        taskStartTime: Date? = nil,
        totalExtractedDataInGB: Int = 0,
        warningMessage: String? = nil
    )
    {
        self.exportOnly = exportOnly
        self.exportTaskIdentifier = exportTaskIdentifier
        self.failureCause = failureCause
        self.iamRoleArn = iamRoleArn
        self.kmsKeyId = kmsKeyId
        self.percentProgress = percentProgress
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
        self.snapshotTime = snapshotTime
        self.sourceArn = sourceArn
        self.status = status
        self.taskEndTime = taskEndTime
        self.taskStartTime = taskStartTime
        self.totalExtractedDataInGB = totalExtractedDataInGB
        self.warningMessage = warningMessage
    }
}

struct CancelExportTaskOutputResponseBody: Equatable {
    public let exportTaskIdentifier: String?
    public let sourceArn: String?
    public let exportOnly: [String]?
    public let snapshotTime: Date?
    public let taskStartTime: Date?
    public let taskEndTime: Date?
    public let s3Bucket: String?
    public let s3Prefix: String?
    public let iamRoleArn: String?
    public let kmsKeyId: String?
    public let status: String?
    public let percentProgress: Int
    public let totalExtractedDataInGB: Int
    public let failureCause: String?
    public let warningMessage: String?
}

extension CancelExportTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportOnly = "ExportOnly"
        case exportTaskIdentifier = "ExportTaskIdentifier"
        case failureCause = "FailureCause"
        case iamRoleArn = "IamRoleArn"
        case kmsKeyId = "KmsKeyId"
        case percentProgress = "PercentProgress"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case snapshotTime = "SnapshotTime"
        case sourceArn = "SourceArn"
        case status = "Status"
        case taskEndTime = "TaskEndTime"
        case taskStartTime = "TaskStartTime"
        case totalExtractedDataInGB = "TotalExtractedDataInGB"
        case warningMessage = "WarningMessage"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CancelExportTaskResult"))
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        if containerValues.contains(.exportOnly) {
            struct KeyVal0{struct member{}}
            let exportOnlyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportOnly)
            if let exportOnlyWrappedContainer = exportOnlyWrappedContainer {
                let exportOnlyContainer = try exportOnlyWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var exportOnlyBuffer:[String]? = nil
                if let exportOnlyContainer = exportOnlyContainer {
                    exportOnlyBuffer = [String]()
                    for stringContainer0 in exportOnlyContainer {
                        exportOnlyBuffer?.append(stringContainer0)
                    }
                }
                exportOnly = exportOnlyBuffer
            } else {
                exportOnly = []
            }
        } else {
            exportOnly = nil
        }
        let snapshotTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotTime)
        var snapshotTimeBuffer:Date? = nil
        if let snapshotTimeDecoded = snapshotTimeDecoded {
            snapshotTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(snapshotTimeDecoded, format: .dateTime)
        }
        snapshotTime = snapshotTimeBuffer
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskStartTime)
        var taskStartTimeBuffer:Date? = nil
        if let taskStartTimeDecoded = taskStartTimeDecoded {
            taskStartTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(taskStartTimeDecoded, format: .dateTime)
        }
        taskStartTime = taskStartTimeBuffer
        let taskEndTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskEndTime)
        var taskEndTimeBuffer:Date? = nil
        if let taskEndTimeDecoded = taskEndTimeDecoded {
            taskEndTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(taskEndTimeDecoded, format: .dateTime)
        }
        taskEndTime = taskEndTimeBuffer
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decode(Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let totalExtractedDataInGBDecoded = try containerValues.decode(Int.self, forKey: .totalExtractedDataInGB)
        totalExtractedDataInGB = totalExtractedDataInGBDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
        let warningMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .warningMessage)
        warningMessage = warningMessageDecoded
    }
}

extension Certificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case certificateIdentifier = "CertificateIdentifier"
        case certificateType = "CertificateType"
        case customerOverride = "CustomerOverride"
        case customerOverrideValidTill = "CustomerOverrideValidTill"
        case thumbprint = "Thumbprint"
        case validFrom = "ValidFrom"
        case validTill = "ValidTill"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificateArn = certificateArn {
            try container.encode(certificateArn, forKey: Key("CertificateArn"))
        }
        if let certificateIdentifier = certificateIdentifier {
            try container.encode(certificateIdentifier, forKey: Key("CertificateIdentifier"))
        }
        if let certificateType = certificateType {
            try container.encode(certificateType, forKey: Key("CertificateType"))
        }
        if let customerOverride = customerOverride {
            try container.encode(customerOverride, forKey: Key("CustomerOverride"))
        }
        if let customerOverrideValidTill = customerOverrideValidTill {
            try container.encode(TimestampWrapper(customerOverrideValidTill, format: .dateTime), forKey: Key("customerOverrideValidTill"))
        }
        if let thumbprint = thumbprint {
            try container.encode(thumbprint, forKey: Key("Thumbprint"))
        }
        if let validFrom = validFrom {
            try container.encode(TimestampWrapper(validFrom, format: .dateTime), forKey: Key("validFrom"))
        }
        if let validTill = validTill {
            try container.encode(TimestampWrapper(validTill, format: .dateTime), forKey: Key("validTill"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificateTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateType)
        certificateType = certificateTypeDecoded
        let thumbprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thumbprint)
        thumbprint = thumbprintDecoded
        let validFromDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validFrom)
        var validFromBuffer:Date? = nil
        if let validFromDecoded = validFromDecoded {
            validFromBuffer = try TimestampWrapperDecoder.parseDateStringValue(validFromDecoded, format: .dateTime)
        }
        validFrom = validFromBuffer
        let validTillDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validTill)
        var validTillBuffer:Date? = nil
        if let validTillDecoded = validTillDecoded {
            validTillBuffer = try TimestampWrapperDecoder.parseDateStringValue(validTillDecoded, format: .dateTime)
        }
        validTill = validTillBuffer
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let customerOverrideDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .customerOverride)
        customerOverride = customerOverrideDecoded
        let customerOverrideValidTillDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerOverrideValidTill)
        var customerOverrideValidTillBuffer:Date? = nil
        if let customerOverrideValidTillDecoded = customerOverrideValidTillDecoded {
            customerOverrideValidTillBuffer = try TimestampWrapperDecoder.parseDateStringValue(customerOverrideValidTillDecoded, format: .dateTime)
        }
        customerOverrideValidTill = customerOverrideValidTillBuffer
    }
}

extension Certificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Certificate(certificateArn: \(String(describing: certificateArn)), certificateIdentifier: \(String(describing: certificateIdentifier)), certificateType: \(String(describing: certificateType)), customerOverride: \(String(describing: customerOverride)), customerOverrideValidTill: \(String(describing: customerOverrideValidTill)), thumbprint: \(String(describing: thumbprint)), validFrom: \(String(describing: validFrom)), validTill: \(String(describing: validTill)))"}
}

/// <p>A CA certificate for an AWS account.</p>
public struct Certificate: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the certificate.</p>
    public let certificateArn: String?
    /// <p>The unique key that identifies a certificate.</p>
    public let certificateIdentifier: String?
    /// <p>The type of the certificate.</p>
    public let certificateType: String?
    /// <p>Whether there is an override for the default certificate identifier.</p>
    public let customerOverride: Bool?
    /// <p>If there is an override for the default certificate identifier, when the override
    ///             expires.</p>
    public let customerOverrideValidTill: Date?
    /// <p>The thumbprint of the certificate.</p>
    public let thumbprint: String?
    /// <p>The starting date from which the certificate is valid.</p>
    public let validFrom: Date?
    /// <p>The final date that the certificate continues to be valid.</p>
    public let validTill: Date?

    public init (
        certificateArn: String? = nil,
        certificateIdentifier: String? = nil,
        certificateType: String? = nil,
        customerOverride: Bool? = nil,
        customerOverrideValidTill: Date? = nil,
        thumbprint: String? = nil,
        validFrom: Date? = nil,
        validTill: Date? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateIdentifier = certificateIdentifier
        self.certificateType = certificateType
        self.customerOverride = customerOverride
        self.customerOverrideValidTill = customerOverrideValidTill
        self.thumbprint = thumbprint
        self.validFrom = validFrom
        self.validTill = validTill
    }
}

extension CertificateNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateNotFoundFault(message: \(String(describing: message)))"}
}

extension CertificateNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CertificateNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>CertificateIdentifier</code> doesn't refer to an
///         existing certificate.
///         </p>
public struct CertificateNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateNotFoundFaultBody: Equatable {
    public let message: String?
}

extension CertificateNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CharacterSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case characterSetDescription = "CharacterSetDescription"
        case characterSetName = "CharacterSetName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let characterSetDescription = characterSetDescription {
            try container.encode(characterSetDescription, forKey: Key("CharacterSetDescription"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let characterSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let characterSetDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .characterSetDescription)
        characterSetDescription = characterSetDescriptionDecoded
    }
}

extension CharacterSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CharacterSet(characterSetDescription: \(String(describing: characterSetDescription)), characterSetName: \(String(describing: characterSetName)))"}
}

/// <p>
///             This data type is used as a response element in the action <code>DescribeDBEngineVersions</code>.
///         </p>
public struct CharacterSet: Equatable {
    /// <p>The description of the character set.</p>
    public let characterSetDescription: String?
    /// <p>The name of the character set.</p>
    public let characterSetName: String?

    public init (
        characterSetDescription: String? = nil,
        characterSetName: String? = nil
    )
    {
        self.characterSetDescription = characterSetDescription
        self.characterSetName = characterSetName
    }
}

extension CloudwatchLogsExportConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case disableLogTypes = "DisableLogTypes"
        case enableLogTypes = "EnableLogTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let disableLogTypes = disableLogTypes {
            var disableLogTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DisableLogTypes"))
            for (index0, string0) in disableLogTypes.enumerated() {
                try disableLogTypesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableLogTypes = enableLogTypes {
            var enableLogTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableLogTypes"))
            for (index0, string0) in enableLogTypes.enumerated() {
                try enableLogTypesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.enableLogTypes) {
            struct KeyVal0{struct member{}}
            let enableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableLogTypes)
            if let enableLogTypesWrappedContainer = enableLogTypesWrappedContainer {
                let enableLogTypesContainer = try enableLogTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var enableLogTypesBuffer:[String]? = nil
                if let enableLogTypesContainer = enableLogTypesContainer {
                    enableLogTypesBuffer = [String]()
                    for stringContainer0 in enableLogTypesContainer {
                        enableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                enableLogTypes = enableLogTypesBuffer
            } else {
                enableLogTypes = []
            }
        } else {
            enableLogTypes = nil
        }
        if containerValues.contains(.disableLogTypes) {
            struct KeyVal0{struct member{}}
            let disableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .disableLogTypes)
            if let disableLogTypesWrappedContainer = disableLogTypesWrappedContainer {
                let disableLogTypesContainer = try disableLogTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var disableLogTypesBuffer:[String]? = nil
                if let disableLogTypesContainer = disableLogTypesContainer {
                    disableLogTypesBuffer = [String]()
                    for stringContainer0 in disableLogTypesContainer {
                        disableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                disableLogTypes = disableLogTypesBuffer
            } else {
                disableLogTypes = []
            }
        } else {
            disableLogTypes = nil
        }
    }
}

extension CloudwatchLogsExportConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudwatchLogsExportConfiguration(disableLogTypes: \(String(describing: disableLogTypes)), enableLogTypes: \(String(describing: enableLogTypes)))"}
}

/// <p>The configuration setting for the log types to be enabled for export to CloudWatch
///             Logs for a specific DB instance or DB cluster.</p>
///         <p>The <code>EnableLogTypes</code> and <code>DisableLogTypes</code> arrays determine which logs will be exported
///             (or not exported) to CloudWatch Logs. The values within these arrays depend on the DB
///             engine being used.</p>
///         <p>For more information about exporting CloudWatch Logs for Amazon RDS DB instances, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs </a> in the <i>Amazon RDS User Guide</i>.</p>
///         <p>For more information about exporting CloudWatch Logs for Amazon Aurora DB clusters, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs</a> in the <i>Amazon Aurora User Guide</i>.</p>
public struct CloudwatchLogsExportConfiguration: Equatable {
    /// <p>The list of log types to disable.</p>
    public let disableLogTypes: [String]?
    /// <p>The list of log types to enable.</p>
    public let enableLogTypes: [String]?

    public init (
        disableLogTypes: [String]? = nil,
        enableLogTypes: [String]? = nil
    )
    {
        self.disableLogTypes = disableLogTypes
        self.enableLogTypes = enableLogTypes
    }
}

extension ClusterPendingModifiedValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case masterUserPassword = "MasterUserPassword"
        case pendingCloudwatchLogsExports = "PendingCloudwatchLogsExports"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let pendingCloudwatchLogsExports = pendingCloudwatchLogsExports {
            try container.encode(pendingCloudwatchLogsExports, forKey: Key("PendingCloudwatchLogsExports"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingCloudwatchLogsExportsDecoded = try containerValues.decodeIfPresent(PendingCloudwatchLogsExports.self, forKey: .pendingCloudwatchLogsExports)
        pendingCloudwatchLogsExports = pendingCloudwatchLogsExportsDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension ClusterPendingModifiedValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterPendingModifiedValues(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), engineVersion: \(String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(String(describing: iAMDatabaseAuthenticationEnabled)), masterUserPassword: \(String(describing: masterUserPassword)), pendingCloudwatchLogsExports: \(String(describing: pendingCloudwatchLogsExports)))"}
}

/// <p>This data type is used as a response element in the <code>ModifyDBCluster</code> operation and
///             contains changes that will be applied during the next maintenance window.</p>
public struct ClusterPendingModifiedValues: Equatable {
    /// <p>The DBClusterIdentifier value for the DB cluster.</p>
    public let dBClusterIdentifier: String?
    /// <p>The database engine version.</p>
    public let engineVersion: String?
    /// <p>A value that indicates whether mapping of AWS Identity and Access Management (IAM) accounts to database accounts is enabled.</p>
    public let iAMDatabaseAuthenticationEnabled: Bool?
    /// <p>The master credentials for the DB cluster.</p>
    public let masterUserPassword: String?
    /// <p>A list of the log types whose configuration is still pending. In other words, these log types are in the process of being activated or deactivated.</p>
    public let pendingCloudwatchLogsExports: PendingCloudwatchLogsExports?

    public init (
        dBClusterIdentifier: String? = nil,
        engineVersion: String? = nil,
        iAMDatabaseAuthenticationEnabled: Bool? = nil,
        masterUserPassword: String? = nil,
        pendingCloudwatchLogsExports: PendingCloudwatchLogsExports? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.engineVersion = engineVersion
        self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
        self.masterUserPassword = masterUserPassword
        self.pendingCloudwatchLogsExports = pendingCloudwatchLogsExports
    }
}

extension ConnectionPoolConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionBorrowTimeout = "ConnectionBorrowTimeout"
        case initQuery = "InitQuery"
        case maxConnectionsPercent = "MaxConnectionsPercent"
        case maxIdleConnectionsPercent = "MaxIdleConnectionsPercent"
        case sessionPinningFilters = "SessionPinningFilters"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let connectionBorrowTimeout = connectionBorrowTimeout {
            try container.encode(connectionBorrowTimeout, forKey: Key("ConnectionBorrowTimeout"))
        }
        if let initQuery = initQuery {
            try container.encode(initQuery, forKey: Key("InitQuery"))
        }
        if let maxConnectionsPercent = maxConnectionsPercent {
            try container.encode(maxConnectionsPercent, forKey: Key("MaxConnectionsPercent"))
        }
        if let maxIdleConnectionsPercent = maxIdleConnectionsPercent {
            try container.encode(maxIdleConnectionsPercent, forKey: Key("MaxIdleConnectionsPercent"))
        }
        if let sessionPinningFilters = sessionPinningFilters {
            var sessionPinningFiltersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SessionPinningFilters"))
            for (index0, string0) in sessionPinningFilters.enumerated() {
                try sessionPinningFiltersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsPercentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxConnectionsPercent)
        maxConnectionsPercent = maxConnectionsPercentDecoded
        let maxIdleConnectionsPercentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxIdleConnectionsPercent)
        maxIdleConnectionsPercent = maxIdleConnectionsPercentDecoded
        let connectionBorrowTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .connectionBorrowTimeout)
        connectionBorrowTimeout = connectionBorrowTimeoutDecoded
        if containerValues.contains(.sessionPinningFilters) {
            struct KeyVal0{struct member{}}
            let sessionPinningFiltersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sessionPinningFilters)
            if let sessionPinningFiltersWrappedContainer = sessionPinningFiltersWrappedContainer {
                let sessionPinningFiltersContainer = try sessionPinningFiltersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var sessionPinningFiltersBuffer:[String]? = nil
                if let sessionPinningFiltersContainer = sessionPinningFiltersContainer {
                    sessionPinningFiltersBuffer = [String]()
                    for stringContainer0 in sessionPinningFiltersContainer {
                        sessionPinningFiltersBuffer?.append(stringContainer0)
                    }
                }
                sessionPinningFilters = sessionPinningFiltersBuffer
            } else {
                sessionPinningFilters = []
            }
        } else {
            sessionPinningFilters = nil
        }
        let initQueryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initQuery)
        initQuery = initQueryDecoded
    }
}

extension ConnectionPoolConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionPoolConfiguration(connectionBorrowTimeout: \(String(describing: connectionBorrowTimeout)), initQuery: \(String(describing: initQuery)), maxConnectionsPercent: \(String(describing: maxConnectionsPercent)), maxIdleConnectionsPercent: \(String(describing: maxIdleConnectionsPercent)), sessionPinningFilters: \(String(describing: sessionPinningFilters)))"}
}

/// <p>Specifies the settings that control the size and behavior of the connection pool associated with a <code>DBProxyTargetGroup</code>.</p>
public struct ConnectionPoolConfiguration: Equatable {
    /// <p>The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the
    ///         proxy has opened its maximum number of connections and all connections are busy with client sessions.</p>
    ///          <p>Default: 120</p>
    ///          <p>Constraints: between 1 and 3600, or 0 representing unlimited</p>
    public let connectionBorrowTimeout: Int?
    /// <p>
    ///         One or more SQL statements for the proxy to run when opening each new database connection.
    ///         Typically used with <code>SET</code> statements to make sure that each connection has identical
    ///         settings such as time zone and character set. For multiple statements, use semicolons as the separator.
    ///         You can also include multiple variables in a single <code>SET</code> statement, such as
    ///         <code>SET x=1, y=2</code>.
    ///       </p>
    ///          <p>Default: no initialization query</p>
    public let initQuery: String?
    /// <p>The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the
    ///         <code>max_connections</code> setting for the RDS DB instance or Aurora DB cluster used by the target group.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: between 1 and 100</p>
    public let maxConnectionsPercent: Int?
    /// <p>
    ///         Controls how actively the proxy closes idle database connections in the connection pool.
    ///         A high value enables the proxy to leave a high percentage of idle connections open.
    ///         A low value causes the proxy to close idle client connections and return the underlying
    ///         database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the
    ///         <code>max_connections</code> setting for the RDS DB instance or Aurora DB cluster used by the target group.
    ///       </p>
    ///          <p>Default: 50</p>
    ///          <p>Constraints: between 0 and <code>MaxConnectionsPercent</code>
    ///          </p>
    public let maxIdleConnectionsPercent: Int?
    /// <p>Each item in the list represents a class of SQL operations that normally cause all later statements
    ///         in a session using a proxy to be pinned to the same underlying database connection. Including an item
    ///         in the list exempts that class of SQL operations from the pinning behavior.</p>
    ///          <p>Default: no session pinning filters</p>
    public let sessionPinningFilters: [String]?

    public init (
        connectionBorrowTimeout: Int? = nil,
        initQuery: String? = nil,
        maxConnectionsPercent: Int? = nil,
        maxIdleConnectionsPercent: Int? = nil,
        sessionPinningFilters: [String]? = nil
    )
    {
        self.connectionBorrowTimeout = connectionBorrowTimeout
        self.initQuery = initQuery
        self.maxConnectionsPercent = maxConnectionsPercent
        self.maxIdleConnectionsPercent = maxIdleConnectionsPercent
        self.sessionPinningFilters = sessionPinningFilters
    }
}

extension ConnectionPoolConfigurationInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionBorrowTimeout = "ConnectionBorrowTimeout"
        case initQuery = "InitQuery"
        case maxConnectionsPercent = "MaxConnectionsPercent"
        case maxIdleConnectionsPercent = "MaxIdleConnectionsPercent"
        case sessionPinningFilters = "SessionPinningFilters"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if connectionBorrowTimeout != 0 {
            try container.encode(connectionBorrowTimeout, forKey: Key("ConnectionBorrowTimeout"))
        }
        if let initQuery = initQuery {
            try container.encode(initQuery, forKey: Key("InitQuery"))
        }
        if maxConnectionsPercent != 0 {
            try container.encode(maxConnectionsPercent, forKey: Key("MaxConnectionsPercent"))
        }
        if maxIdleConnectionsPercent != 0 {
            try container.encode(maxIdleConnectionsPercent, forKey: Key("MaxIdleConnectionsPercent"))
        }
        if let sessionPinningFilters = sessionPinningFilters {
            var sessionPinningFiltersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SessionPinningFilters"))
            for (index0, string0) in sessionPinningFilters.enumerated() {
                try sessionPinningFiltersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsPercentDecoded = try containerValues.decode(Int.self, forKey: .maxConnectionsPercent)
        maxConnectionsPercent = maxConnectionsPercentDecoded
        let maxIdleConnectionsPercentDecoded = try containerValues.decode(Int.self, forKey: .maxIdleConnectionsPercent)
        maxIdleConnectionsPercent = maxIdleConnectionsPercentDecoded
        let connectionBorrowTimeoutDecoded = try containerValues.decode(Int.self, forKey: .connectionBorrowTimeout)
        connectionBorrowTimeout = connectionBorrowTimeoutDecoded
        if containerValues.contains(.sessionPinningFilters) {
            struct KeyVal0{struct member{}}
            let sessionPinningFiltersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sessionPinningFilters)
            if let sessionPinningFiltersWrappedContainer = sessionPinningFiltersWrappedContainer {
                let sessionPinningFiltersContainer = try sessionPinningFiltersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var sessionPinningFiltersBuffer:[String]? = nil
                if let sessionPinningFiltersContainer = sessionPinningFiltersContainer {
                    sessionPinningFiltersBuffer = [String]()
                    for stringContainer0 in sessionPinningFiltersContainer {
                        sessionPinningFiltersBuffer?.append(stringContainer0)
                    }
                }
                sessionPinningFilters = sessionPinningFiltersBuffer
            } else {
                sessionPinningFilters = []
            }
        } else {
            sessionPinningFilters = nil
        }
        let initQueryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initQuery)
        initQuery = initQueryDecoded
    }
}

extension ConnectionPoolConfigurationInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionPoolConfigurationInfo(connectionBorrowTimeout: \(String(describing: connectionBorrowTimeout)), initQuery: \(String(describing: initQuery)), maxConnectionsPercent: \(String(describing: maxConnectionsPercent)), maxIdleConnectionsPercent: \(String(describing: maxIdleConnectionsPercent)), sessionPinningFilters: \(String(describing: sessionPinningFilters)))"}
}

/// <p>Displays the settings that control the size and behavior of the connection pool associated with a <code>DBProxyTarget</code>.</p>
public struct ConnectionPoolConfigurationInfo: Equatable {
    /// <p>The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the
    ///         proxy has opened its maximum number of connections and all connections are busy with client sessions.</p>
    public let connectionBorrowTimeout: Int
    /// <p>
    ///         One or more SQL statements for the proxy to run when opening each new database connection.
    ///         Typically used with <code>SET</code> statements to make sure that each connection has identical
    ///         settings such as time zone and character set. This setting is empty by default.
    ///         For multiple statements, use semicolons as the separator.
    ///         You can also include multiple variables in a single <code>SET</code> statement, such as
    ///         <code>SET x=1, y=2</code>.
    ///       </p>
    public let initQuery: String?
    /// <p>The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the
    ///         <code>max_connections</code> setting for the RDS DB instance or Aurora DB cluster used by the target group.</p>
    public let maxConnectionsPercent: Int
    /// <p>
    ///         Controls how actively the proxy closes idle database connections in the connection pool.
    ///         A high value enables the proxy to leave a high percentage of idle connections open.
    ///         A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool.
    ///         For Aurora MySQL, it is expressed as a percentage of the <code>max_connections</code> setting for the RDS DB instance or Aurora DB cluster used by the target group.
    ///       </p>
    public let maxIdleConnectionsPercent: Int
    /// <p>Each item in the list represents a class of SQL operations that normally cause all later statements
    ///         in a session using a proxy to be pinned to the same underlying database connection. Including an item
    ///         in the list exempts that class of SQL operations from the pinning behavior. Currently, the only
    ///         allowed value is <code>EXCLUDE_VARIABLE_SETS</code>.</p>
    public let sessionPinningFilters: [String]?

    public init (
        connectionBorrowTimeout: Int = 0,
        initQuery: String? = nil,
        maxConnectionsPercent: Int = 0,
        maxIdleConnectionsPercent: Int = 0,
        sessionPinningFilters: [String]? = nil
    )
    {
        self.connectionBorrowTimeout = connectionBorrowTimeout
        self.initQuery = initQuery
        self.maxConnectionsPercent = maxConnectionsPercent
        self.maxIdleConnectionsPercent = maxIdleConnectionsPercent
        self.sessionPinningFilters = sessionPinningFilters
    }
}

public struct CopyDBClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "CopyDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterParameterGroupOutputError>
}

extension CopyDBClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBClusterParameterGroupInput(sourceDBClusterParameterGroupIdentifier: \(String(describing: sourceDBClusterParameterGroupIdentifier)), tags: \(String(describing: tags)), targetDBClusterParameterGroupDescription: \(String(describing: targetDBClusterParameterGroupDescription)), targetDBClusterParameterGroupIdentifier: \(String(describing: targetDBClusterParameterGroupIdentifier)))"}
}

extension CopyDBClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifier {
            try container.encode(sourceDBClusterParameterGroupIdentifier, forKey: Key("SourceDBClusterParameterGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescription {
            try container.encode(targetDBClusterParameterGroupDescription, forKey: Key("TargetDBClusterParameterGroupDescription"))
        }
        if let targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifier {
            try container.encode(targetDBClusterParameterGroupIdentifier, forKey: Key("TargetDBClusterParameterGroupIdentifier"))
        }
        try container.encode("CopyDBClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CopyDBClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CopyDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterParameterGroupOutputError>
}

public struct CopyDBClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterParameterGroupOutputError>
}

public struct CopyDBClusterParameterGroupInput: Equatable {
    /// <p>The identifier or Amazon Resource Name (ARN) for the source DB cluster parameter group.
    ///             For information about
    ///             creating an ARN,
    ///             see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///                 Constructing an ARN for Amazon RDS</a> in the <i>Amazon Aurora User Guide</i>.
    ///         </p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must specify a valid DB cluster parameter group.</p>
    ///             </li>
    ///          </ul>
    public let sourceDBClusterParameterGroupIdentifier: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?
    /// <p>A description for the copied DB cluster parameter group.</p>
    public let targetDBClusterParameterGroupDescription: String?
    /// <p>The identifier for the copied DB cluster parameter group.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Can't be null, empty, or blank</p>
    ///             </li>
    ///             <li>
    ///                <p>Must contain from 1 to 255 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>my-cluster-param-group1</code>
    ///         </p>
    public let targetDBClusterParameterGroupIdentifier: String?

    public init (
        sourceDBClusterParameterGroupIdentifier: String? = nil,
        tags: [Tag]? = nil,
        targetDBClusterParameterGroupDescription: String? = nil,
        targetDBClusterParameterGroupIdentifier: String? = nil
    )
    {
        self.sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifier
        self.tags = tags
        self.targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescription
        self.targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifier
    }
}

extension CopyDBClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBClusterParameterGroupOutputError: Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBClusterParameterGroupOutputResponse(dBClusterParameterGroup: \(String(describing: dBClusterParameterGroup)))"}
}

extension CopyDBClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterParameterGroup = output.dBClusterParameterGroup
        } else {
            self.dBClusterParameterGroup = nil
        }
    }
}

public struct CopyDBClusterParameterGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB cluster parameter group.
    ///         </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusterParameterGroups</code> action.
    ///         </p>
    public let dBClusterParameterGroup: DBClusterParameterGroup?

    public init (
        dBClusterParameterGroup: DBClusterParameterGroup? = nil
    )
    {
        self.dBClusterParameterGroup = dBClusterParameterGroup
    }
}

struct CopyDBClusterParameterGroupOutputResponseBody: Equatable {
    public let dBClusterParameterGroup: DBClusterParameterGroup?
}

extension CopyDBClusterParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroup = "DBClusterParameterGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CopyDBClusterParameterGroupResult"))
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(DBClusterParameterGroup.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
    }
}

public struct CopyDBClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "CopyDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterSnapshotOutputError>
}

extension CopyDBClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBClusterSnapshotInput(copyTags: \(String(describing: copyTags)), kmsKeyId: \(String(describing: kmsKeyId)), preSignedUrl: \(String(describing: preSignedUrl)), sourceDBClusterSnapshotIdentifier: \(String(describing: sourceDBClusterSnapshotIdentifier)), tags: \(String(describing: tags)), targetDBClusterSnapshotIdentifier: \(String(describing: targetDBClusterSnapshotIdentifier)))"}
}

extension CopyDBClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let copyTags = copyTags {
            try container.encode(copyTags, forKey: Key("CopyTags"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: Key("PreSignedUrl"))
        }
        if let sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifier {
            try container.encode(sourceDBClusterSnapshotIdentifier, forKey: Key("SourceDBClusterSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifier {
            try container.encode(targetDBClusterSnapshotIdentifier, forKey: Key("TargetDBClusterSnapshotIdentifier"))
        }
        try container.encode("CopyDBClusterSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CopyDBClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CopyDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterSnapshotOutputError>
}

public struct CopyDBClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterSnapshotOutputError>
}

/// <p></p>
public struct CopyDBClusterSnapshotInput: Equatable {
    /// <p>A value that indicates whether to copy all tags from the source DB cluster snapshot to the target DB cluster snapshot.
    ///             By default, tags are not copied.</p>
    public let copyTags: Bool?
    /// <p>The AWS KMS key identifier for an encrypted DB cluster snapshot.
    ///             The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    ///
    ///         <p>If you copy an encrypted DB cluster snapshot from your AWS account, you can specify a value for <code>KmsKeyId</code> to encrypt the copy with a new AWS KMS CMK.
    ///             If you don't specify a value for <code>KmsKeyId</code>, then the copy of the DB cluster snapshot is encrypted with the same AWS KMS key as the source DB cluster snapshot.
    ///         </p>
    ///
    ///         <p>If you copy an encrypted DB cluster snapshot that is shared from another AWS account, then you must specify a value for <code>KmsKeyId</code>. </p>
    ///
    ///         <p>To copy an encrypted DB cluster snapshot to another AWS Region, you must set <code>KmsKeyId</code> to the AWS KMS key identifier you want to use to encrypt the copy of the DB cluster snapshot
    ///             in the destination AWS Region. AWS KMS CMKs are specific to the AWS Region that they are created in, and you can't use CMKs from one AWS Region
    ///             in another AWS Region.</p>
    ///
    ///         <p>If you copy an unencrypted DB cluster snapshot and specify a value for the <code>KmsKeyId</code> parameter,
    ///             an error is returned.</p>
    public let kmsKeyId: String?
    /// <p>The URL that contains a Signature Version 4 signed request for the <code>CopyDBClusterSnapshot</code> API action in the AWS Region that contains the
    ///             source DB cluster snapshot to copy. The <code>PreSignedUrl</code> parameter must be used when copying an encrypted DB cluster snapshot from another AWS Region.
    ///             Don't specify <code>PreSignedUrl</code> when you are copying an encrypted DB cluster snapshot in the same AWS Region.</p>
    ///         <p>The pre-signed URL must be a valid request for the <code>CopyDBClusterSnapshot</code> API action that can be
    ///             executed in the source AWS Region that contains the encrypted DB cluster snapshot to be copied.
    ///             The pre-signed URL request must contain the following parameter values:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>KmsKeyId</code> - The AWS KMS key identifier for the customer master key (CMK) to use to encrypt the copy of the DB
    ///                 cluster snapshot in the destination AWS Region. This is the same identifier for both the <code>CopyDBClusterSnapshot</code>
    ///                 action that is called in the destination AWS Region, and the action contained in the pre-signed URL.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DestinationRegion</code> - The name of the AWS Region that the DB cluster snapshot is to be created in.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SourceDBClusterSnapshotIdentifier</code> - The DB cluster snapshot identifier for the encrypted DB cluster
    ///                 snapshot to be copied. This identifier must be in the Amazon Resource Name (ARN) format for the source AWS Region. For example,
    ///                 if you are copying an encrypted DB cluster snapshot from the us-west-2 AWS Region, then your <code>SourceDBClusterSnapshotIdentifier</code>
    ///                 looks like the following example: <code>arn:aws:rds:us-west-2:123456789012:cluster-snapshot:aurora-cluster1-snapshot-20161115</code>.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>To learn how to generate a Signature Version 4 signed request, see
    ///
    ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">
    ///                 Authenticating Requests: Using Query Parameters (AWS Signature Version 4)</a> and
    ///             <a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">
    ///                 Signature Version 4 Signing Process</a>.</p>
    ///
    ///         <note>
    ///             <p>If you are using an AWS SDK tool or the AWS CLI, you can specify <code>SourceRegion</code> (or <code>--source-region</code> for the AWS CLI)
    ///                 instead of specifying <code>PreSignedUrl</code> manually. Specifying <code>SourceRegion</code> autogenerates a pre-signed URL that is a valid
    ///                 request for the operation that can be executed in the source AWS Region.</p>
    ///         </note>
    public let preSignedUrl: String?
    /// <p>The identifier of the DB cluster snapshot to copy. This parameter isn't case-sensitive.</p>
    ///          <p>You can't copy an encrypted, shared DB cluster snapshot from one AWS Region to another.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must specify a valid system snapshot in the "available" state.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source snapshot is in the same AWS Region as the copy, specify a valid DB snapshot identifier.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source snapshot is in a different AWS Region than the copy,
    ///               specify a valid DB cluster snapshot ARN. For more information, go to
    ///               <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_CopySnapshot.html#USER_CopySnapshot.AcrossRegions">
    ///                   Copying Snapshots Across AWS Regions</a> in the <i>Amazon Aurora User Guide.</i>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster-snapshot1</code>
    ///          </p>
    public let sourceDBClusterSnapshotIdentifier: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?
    /// <p>The identifier of the new DB cluster snapshot to create from the source DB cluster snapshot. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster-snapshot2</code>
    ///          </p>
    public let targetDBClusterSnapshotIdentifier: String?

    public init (
        copyTags: Bool? = nil,
        kmsKeyId: String? = nil,
        preSignedUrl: String? = nil,
        sourceDBClusterSnapshotIdentifier: String? = nil,
        tags: [Tag]? = nil,
        targetDBClusterSnapshotIdentifier: String? = nil
    )
    {
        self.copyTags = copyTags
        self.kmsKeyId = kmsKeyId
        self.preSignedUrl = preSignedUrl
        self.sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifier
        self.tags = tags
        self.targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifier
    }
}

extension CopyDBClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBClusterSnapshotOutputError: Equatable {
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(String(describing: dBClusterSnapshot)))"}
}

extension CopyDBClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct CopyDBClusterSnapshotOutputResponse: Equatable {
    /// <p>Contains the details for an Amazon RDS DB cluster snapshot
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBClusterSnapshots</code> action.
    ///       </p>
    public let dBClusterSnapshot: DBClusterSnapshot?

    public init (
        dBClusterSnapshot: DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct CopyDBClusterSnapshotOutputResponseBody: Equatable {
    public let dBClusterSnapshot: DBClusterSnapshot?
}

extension CopyDBClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CopyDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct CopyDBParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "CopyDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBParameterGroupOutputError>
}

extension CopyDBParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBParameterGroupInput(sourceDBParameterGroupIdentifier: \(String(describing: sourceDBParameterGroupIdentifier)), tags: \(String(describing: tags)), targetDBParameterGroupDescription: \(String(describing: targetDBParameterGroupDescription)), targetDBParameterGroupIdentifier: \(String(describing: targetDBParameterGroupIdentifier)))"}
}

extension CopyDBParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifier {
            try container.encode(sourceDBParameterGroupIdentifier, forKey: Key("SourceDBParameterGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBParameterGroupDescription = targetDBParameterGroupDescription {
            try container.encode(targetDBParameterGroupDescription, forKey: Key("TargetDBParameterGroupDescription"))
        }
        if let targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifier {
            try container.encode(targetDBParameterGroupIdentifier, forKey: Key("TargetDBParameterGroupIdentifier"))
        }
        try container.encode("CopyDBParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CopyDBParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CopyDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBParameterGroupOutputError>
}

public struct CopyDBParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBParameterGroupOutputError>
}

/// <p></p>
public struct CopyDBParameterGroupInput: Equatable {
    /// <p>
    ///         The identifier or ARN for the source DB parameter group.
    ///         For information about
    ///         creating an ARN,
    ///         see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///             Constructing an ARN for Amazon RDS</a> in the <i>Amazon RDS User Guide</i>.
    ///         </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must specify a valid DB parameter group.</p>
    ///             </li>
    ///          </ul>
    public let sourceDBParameterGroupIdentifier: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?
    /// <p>A description for the copied DB parameter group.</p>
    public let targetDBParameterGroupDescription: String?
    /// <p>The identifier for the copied DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Can't be null, empty, or blank</p>
    ///             </li>
    ///             <li>
    ///                <p>Must contain from 1 to 255 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-db-parameter-group</code>
    ///          </p>
    public let targetDBParameterGroupIdentifier: String?

    public init (
        sourceDBParameterGroupIdentifier: String? = nil,
        tags: [Tag]? = nil,
        targetDBParameterGroupDescription: String? = nil,
        targetDBParameterGroupIdentifier: String? = nil
    )
    {
        self.sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifier
        self.tags = tags
        self.targetDBParameterGroupDescription = targetDBParameterGroupDescription
        self.targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifier
    }
}

extension CopyDBParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBParameterGroupOutputError: Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBParameterGroupOutputResponse(dBParameterGroup: \(String(describing: dBParameterGroup)))"}
}

extension CopyDBParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBParameterGroup = output.dBParameterGroup
        } else {
            self.dBParameterGroup = nil
        }
    }
}

public struct CopyDBParameterGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB parameter group.
    ///         </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBParameterGroups</code> action.
    ///         </p>
    public let dBParameterGroup: DBParameterGroup?

    public init (
        dBParameterGroup: DBParameterGroup? = nil
    )
    {
        self.dBParameterGroup = dBParameterGroup
    }
}

struct CopyDBParameterGroupOutputResponseBody: Equatable {
    public let dBParameterGroup: DBParameterGroup?
}

extension CopyDBParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroup = "DBParameterGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CopyDBParameterGroupResult"))
        let dBParameterGroupDecoded = try containerValues.decodeIfPresent(DBParameterGroup.self, forKey: .dBParameterGroup)
        dBParameterGroup = dBParameterGroupDecoded
    }
}

public struct CopyDBSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "CopyDBSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBSnapshotInput>
    public typealias MOutput = OperationOutput<CopyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBSnapshotOutputError>
}

extension CopyDBSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBSnapshotInput(copyTags: \(String(describing: copyTags)), kmsKeyId: \(String(describing: kmsKeyId)), optionGroupName: \(String(describing: optionGroupName)), preSignedUrl: \(String(describing: preSignedUrl)), sourceDBSnapshotIdentifier: \(String(describing: sourceDBSnapshotIdentifier)), tags: \(String(describing: tags)), targetCustomAvailabilityZone: \(String(describing: targetCustomAvailabilityZone)), targetDBSnapshotIdentifier: \(String(describing: targetDBSnapshotIdentifier)))"}
}

extension CopyDBSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let copyTags = copyTags {
            try container.encode(copyTags, forKey: Key("CopyTags"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: Key("PreSignedUrl"))
        }
        if let sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier {
            try container.encode(sourceDBSnapshotIdentifier, forKey: Key("SourceDBSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetCustomAvailabilityZone = targetCustomAvailabilityZone {
            try container.encode(targetCustomAvailabilityZone, forKey: Key("TargetCustomAvailabilityZone"))
        }
        if let targetDBSnapshotIdentifier = targetDBSnapshotIdentifier {
            try container.encode(targetDBSnapshotIdentifier, forKey: Key("TargetDBSnapshotIdentifier"))
        }
        try container.encode("CopyDBSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CopyDBSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CopyDBSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBSnapshotInput>
    public typealias MOutput = OperationOutput<CopyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBSnapshotOutputError>
}

public struct CopyDBSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyDBSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBSnapshotInput>
    public typealias MOutput = OperationOutput<CopyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBSnapshotOutputError>
}

/// <p></p>
public struct CopyDBSnapshotInput: Equatable {
    /// <p>A value that indicates whether to copy all tags from the source DB snapshot to the target DB snapshot. By default, tags are not copied.</p>
    public let copyTags: Bool?
    /// <p>The AWS KMS key identifier for an encrypted DB snapshot.
    ///             The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).
    ///         </p>
    ///
    ///         <p>If you copy an encrypted DB snapshot from your AWS account,
    ///             you can specify a value for this parameter to encrypt the copy with a new AWS KMS CMK.
    ///             If you don't specify a value for this parameter,
    ///             then the copy of the DB snapshot is encrypted with the same AWS KMS key as the source DB snapshot.
    ///         </p>
    ///
    ///         <p>If you copy an encrypted DB snapshot that is shared from another AWS account,
    ///             then you must specify a value for this parameter.
    ///         </p>
    ///
    ///         <p>If you specify this parameter when you copy an unencrypted snapshot,
    ///             the copy is encrypted.
    ///         </p>
    ///
    ///         <p>If you copy an encrypted snapshot to a different AWS Region, then you must specify
    ///             a AWS KMS key identifier for the destination AWS Region. AWS KMS CMKs are specific to the AWS Region
    ///             that they are created in, and you can't use CMKs from one AWS Region in another
    ///             AWS Region.
    ///         </p>
    public let kmsKeyId: String?
    /// <p>The name of an option group to associate with the copy of the snapshot.</p>
    ///
    ///         <p>Specify this option if you are copying a snapshot from one AWS Region to another,
    ///             and your DB instance uses a nondefault option group.
    ///             If your source DB instance uses Transparent Data Encryption for Oracle or Microsoft SQL Server,
    ///             you must specify this option when copying across AWS Regions.
    ///             For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_CopySnapshot.html#USER_CopySnapshot.Options">Option group considerations</a> in the <i>Amazon RDS User Guide.</i>
    ///         </p>
    public let optionGroupName: String?
    /// <p>The URL that contains a Signature Version 4 signed request for the
    ///                 <code>CopyDBSnapshot</code> API action in the source AWS Region that contains the
    ///             source DB snapshot to copy. </p>
    ///
    ///         <p>You must specify this parameter when you copy an encrypted DB snapshot from another
    ///             AWS Region by using the Amazon RDS API. Don't specify <code>PreSignedUrl</code> when you are
    ///             copying an encrypted DB snapshot in the same AWS Region.</p>
    ///
    ///         <p>The presigned URL must be a valid request for the <code>CopyDBSnapshot</code> API action
    ///             that can be executed in the source AWS Region that contains the encrypted DB snapshot to be copied.
    ///             The presigned URL request must contain the following parameter values:
    ///         </p>
    ///
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DestinationRegion</code> - The AWS Region that the encrypted DB snapshot is copied to.
    ///                     This AWS Region is the same one where the <code>CopyDBSnapshot</code> action is called that contains this presigned URL.
    ///                 </p>
    ///
    ///                 <p>For example, if you copy an encrypted DB snapshot from the us-west-2 AWS Region
    ///                     to the us-east-1 AWS Region, then you call the <code>CopyDBSnapshot</code> action in
    ///                     the us-east-1 AWS Region and provide a presigned URL that contains a call to the
    ///                         <code>CopyDBSnapshot</code> action in the us-west-2 AWS Region. For this
    ///                     example, the <code>DestinationRegion</code> in the presigned URL must be set to
    ///                     the us-east-1 AWS Region. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>KmsKeyId</code> - The AWS KMS key identifier for the customer master key (CMK) to use to encrypt the copy of the DB snapshot in the destination AWS Region.
    ///                     This is the same identifier for both the <code>CopyDBSnapshot</code> action that is called in the destination AWS Region,
    ///                     and the action contained in the presigned URL.
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SourceDBSnapshotIdentifier</code> - The DB snapshot identifier for the encrypted snapshot to be copied.
    ///                     This identifier must be in the Amazon Resource Name (ARN) format for the source AWS Region.
    ///                     For example, if you are copying an encrypted DB snapshot from the us-west-2 AWS Region, then your <code>SourceDBSnapshotIdentifier</code> looks like
    ///                     the following example: <code>arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20161115</code>.
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///
    /// 	        <p>To learn how to generate a Signature Version 4 signed request, see
    /// 		<a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">Authenticating Requests: Using Query Parameters (AWS Signature Version 4)</a> and
    /// 		<a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">Signature Version 4 Signing Process</a>.
    /// 	   </p>
    ///
    ///          <note>
    ///            <p>If you are using an AWS SDK tool or the AWS CLI, you can specify <code>SourceRegion</code> (or <code>--source-region</code> for the AWS CLI)
    ///                instead of specifying <code>PreSignedUrl</code> manually. Specifying <code>SourceRegion</code> autogenerates a pre-signed URL that is a valid
    ///                request for the operation that can be executed in the source AWS Region.</p>
    ///          </note>
    public let preSignedUrl: String?
    /// <p>The identifier for the source DB snapshot.</p>
    ///
    ///          <p>If the source snapshot is in the same AWS Region as the copy, specify a valid DB
    ///             snapshot identifier. For example, you might specify
    ///                 <code>rds:mysql-instance1-snapshot-20130805</code>. </p>
    ///
    ///          <p>If the source snapshot is in a different AWS Region than the copy, specify a valid DB
    ///             snapshot ARN. For example, you might specify
    ///                 <code>arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20130805</code>. </p>
    ///
    ///          <p>If you are copying from a shared manual DB snapshot,
    ///           this parameter must be the Amazon Resource Name (ARN) of the shared DB snapshot.
    ///       </p>
    ///
    ///          <p>If you are copying an encrypted snapshot
    ///             this parameter must be in the ARN format for the source AWS Region,
    ///             and must match the <code>SourceDBSnapshotIdentifier</code> in the <code>PreSignedUrl</code> parameter.
    ///       </p>
    ///
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must specify a valid system snapshot in the "available" state.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>Example: <code>rds:mydb-2012-04-02-00-01</code>
    ///          </p>
    ///
    ///          <p>Example: <code>arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20130805</code>
    ///          </p>
    public let sourceDBSnapshotIdentifier: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?
    /// <p>The external custom Availability Zone (CAZ) identifier for the target CAZ.</p>
    ///         <p>Example: <code>rds-caz-aiqhTgQv</code>.</p>
    public let targetCustomAvailabilityZone: String?
    /// <p>The identifier for the copy of the snapshot.
    ///         </p>
    ///
    ///         <p>Constraints:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                <p>Can't be null, empty, or blank</p>
    ///             </li>
    ///             <li>
    ///                <p>Must contain from 1 to 255 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>Example: <code>my-db-snapshot</code>
    ///          </p>
    public let targetDBSnapshotIdentifier: String?

    public init (
        copyTags: Bool? = nil,
        kmsKeyId: String? = nil,
        optionGroupName: String? = nil,
        preSignedUrl: String? = nil,
        sourceDBSnapshotIdentifier: String? = nil,
        tags: [Tag]? = nil,
        targetCustomAvailabilityZone: String? = nil,
        targetDBSnapshotIdentifier: String? = nil
    )
    {
        self.copyTags = copyTags
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.preSignedUrl = preSignedUrl
        self.sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier
        self.tags = tags
        self.targetCustomAvailabilityZone = targetCustomAvailabilityZone
        self.targetDBSnapshotIdentifier = targetDBSnapshotIdentifier
    }
}

extension CopyDBSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFoundFault" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExistsFault" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotStateFault" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBSnapshotOutputError: Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBSnapshotOutputResponse(dBSnapshot: \(String(describing: dBSnapshot)))"}
}

extension CopyDBSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct CopyDBSnapshotOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB snapshot.
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBSnapshots</code> action.
    ///       </p>
    public let dBSnapshot: DBSnapshot?

    public init (
        dBSnapshot: DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct CopyDBSnapshotOutputResponseBody: Equatable {
    public let dBSnapshot: DBSnapshot?
}

extension CopyDBSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CopyDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

public struct CopyOptionGroupInputBodyMiddleware: Middleware {
    public let id: String = "CopyOptionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyOptionGroupInput>
    public typealias MOutput = OperationOutput<CopyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyOptionGroupOutputError>
}

extension CopyOptionGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyOptionGroupInput(sourceOptionGroupIdentifier: \(String(describing: sourceOptionGroupIdentifier)), tags: \(String(describing: tags)), targetOptionGroupDescription: \(String(describing: targetOptionGroupDescription)), targetOptionGroupIdentifier: \(String(describing: targetOptionGroupIdentifier)))"}
}

extension CopyOptionGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceOptionGroupIdentifier = sourceOptionGroupIdentifier {
            try container.encode(sourceOptionGroupIdentifier, forKey: Key("SourceOptionGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetOptionGroupDescription = targetOptionGroupDescription {
            try container.encode(targetOptionGroupDescription, forKey: Key("TargetOptionGroupDescription"))
        }
        if let targetOptionGroupIdentifier = targetOptionGroupIdentifier {
            try container.encode(targetOptionGroupIdentifier, forKey: Key("TargetOptionGroupIdentifier"))
        }
        try container.encode("CopyOptionGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CopyOptionGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CopyOptionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyOptionGroupInput>
    public typealias MOutput = OperationOutput<CopyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyOptionGroupOutputError>
}

public struct CopyOptionGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyOptionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyOptionGroupInput>
    public typealias MOutput = OperationOutput<CopyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyOptionGroupOutputError>
}

/// <p></p>
public struct CopyOptionGroupInput: Equatable {
    /// <p>The identifier for the source option group.
    ///         </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must specify a valid option group.</p>
    ///             </li>
    ///          </ul>
    public let sourceOptionGroupIdentifier: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?
    /// <p>The description for the copied option group.</p>
    public let targetOptionGroupDescription: String?
    /// <p>The identifier for the copied option group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Can't be null, empty, or blank</p>
    ///             </li>
    ///             <li>
    ///                <p>Must contain from 1 to 255 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-option-group</code>
    ///          </p>
    public let targetOptionGroupIdentifier: String?

    public init (
        sourceOptionGroupIdentifier: String? = nil,
        tags: [Tag]? = nil,
        targetOptionGroupDescription: String? = nil,
        targetOptionGroupIdentifier: String? = nil
    )
    {
        self.sourceOptionGroupIdentifier = sourceOptionGroupIdentifier
        self.tags = tags
        self.targetOptionGroupDescription = targetOptionGroupDescription
        self.targetOptionGroupIdentifier = targetOptionGroupIdentifier
    }
}

extension CopyOptionGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyOptionGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OptionGroupAlreadyExistsFault" : self = .optionGroupAlreadyExistsFault(try OptionGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupQuotaExceededFault" : self = .optionGroupQuotaExceededFault(try OptionGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyOptionGroupOutputError: Equatable {
    case optionGroupAlreadyExistsFault(OptionGroupAlreadyExistsFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case optionGroupQuotaExceededFault(OptionGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyOptionGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyOptionGroupOutputResponse(optionGroup: \(String(describing: optionGroup)))"}
}

extension CopyOptionGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyOptionGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.optionGroup = output.optionGroup
        } else {
            self.optionGroup = nil
        }
    }
}

public struct CopyOptionGroupOutputResponse: Equatable {
    /// <p></p>
    public let optionGroup: OptionGroup?

    public init (
        optionGroup: OptionGroup? = nil
    )
    {
        self.optionGroup = optionGroup
    }
}

struct CopyOptionGroupOutputResponseBody: Equatable {
    public let optionGroup: OptionGroup?
}

extension CopyOptionGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case optionGroup = "OptionGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CopyOptionGroupResult"))
        let optionGroupDecoded = try containerValues.decodeIfPresent(OptionGroup.self, forKey: .optionGroup)
        optionGroup = optionGroupDecoded
    }
}

public struct CreateCustomAvailabilityZoneInputBodyMiddleware: Middleware {
    public let id: String = "CreateCustomAvailabilityZoneInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomAvailabilityZoneInput>
    public typealias MOutput = OperationOutput<CreateCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomAvailabilityZoneOutputError>
}

extension CreateCustomAvailabilityZoneInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomAvailabilityZoneInput(customAvailabilityZoneName: \(String(describing: customAvailabilityZoneName)), existingVpnId: \(String(describing: existingVpnId)), newVpnTunnelName: \(String(describing: newVpnTunnelName)), vpnTunnelOriginatorIP: \(String(describing: vpnTunnelOriginatorIP)))"}
}

extension CreateCustomAvailabilityZoneInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customAvailabilityZoneName = customAvailabilityZoneName {
            try container.encode(customAvailabilityZoneName, forKey: Key("CustomAvailabilityZoneName"))
        }
        if let existingVpnId = existingVpnId {
            try container.encode(existingVpnId, forKey: Key("ExistingVpnId"))
        }
        if let newVpnTunnelName = newVpnTunnelName {
            try container.encode(newVpnTunnelName, forKey: Key("NewVpnTunnelName"))
        }
        if let vpnTunnelOriginatorIP = vpnTunnelOriginatorIP {
            try container.encode(vpnTunnelOriginatorIP, forKey: Key("VpnTunnelOriginatorIP"))
        }
        try container.encode("CreateCustomAvailabilityZone", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateCustomAvailabilityZoneInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCustomAvailabilityZoneInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomAvailabilityZoneInput>
    public typealias MOutput = OperationOutput<CreateCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomAvailabilityZoneOutputError>
}

public struct CreateCustomAvailabilityZoneInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCustomAvailabilityZoneInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomAvailabilityZoneInput>
    public typealias MOutput = OperationOutput<CreateCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomAvailabilityZoneOutputError>
}

/// <p></p>
public struct CreateCustomAvailabilityZoneInput: Equatable {
    /// <p>The name of the custom Availability Zone (AZ).</p>
    public let customAvailabilityZoneName: String?
    /// <p>The ID of an existing virtual private network (VPN) between the Amazon RDS website and
    ///             the VMware vSphere cluster.</p>
    public let existingVpnId: String?
    /// <p>The name of a new VPN tunnel between the Amazon RDS website and the VMware vSphere cluster.</p>
    ///         <p>Specify this parameter only if <code>ExistingVpnId</code> isn't specified.</p>
    public let newVpnTunnelName: String?
    /// <p>The IP address of network traffic from your on-premises data center. A custom AZ receives the network traffic.</p>
    ///         <p>Specify this parameter only if <code>ExistingVpnId</code> isn't specified.</p>
    public let vpnTunnelOriginatorIP: String?

    public init (
        customAvailabilityZoneName: String? = nil,
        existingVpnId: String? = nil,
        newVpnTunnelName: String? = nil,
        vpnTunnelOriginatorIP: String? = nil
    )
    {
        self.customAvailabilityZoneName = customAvailabilityZoneName
        self.existingVpnId = existingVpnId
        self.newVpnTunnelName = newVpnTunnelName
        self.vpnTunnelOriginatorIP = vpnTunnelOriginatorIP
    }
}

extension CreateCustomAvailabilityZoneOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCustomAvailabilityZoneOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneAlreadyExistsFault" : self = .customAvailabilityZoneAlreadyExistsFault(try CustomAvailabilityZoneAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomAvailabilityZoneQuotaExceededFault" : self = .customAvailabilityZoneQuotaExceededFault(try CustomAvailabilityZoneQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomAvailabilityZoneOutputError: Equatable {
    case customAvailabilityZoneAlreadyExistsFault(CustomAvailabilityZoneAlreadyExistsFault)
    case customAvailabilityZoneQuotaExceededFault(CustomAvailabilityZoneQuotaExceededFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomAvailabilityZoneOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomAvailabilityZoneOutputResponse(customAvailabilityZone: \(String(describing: customAvailabilityZone)))"}
}

extension CreateCustomAvailabilityZoneOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCustomAvailabilityZoneOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customAvailabilityZone = output.customAvailabilityZone
        } else {
            self.customAvailabilityZone = nil
        }
    }
}

public struct CreateCustomAvailabilityZoneOutputResponse: Equatable {
    /// <p>A custom Availability Zone (AZ) is an on-premises AZ that is integrated with a VMware vSphere cluster.</p>
    ///         <p>For more information about RDS on VMware, see the
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html">
    ///                 RDS on VMware User Guide.</a>
    ///          </p>
    public let customAvailabilityZone: CustomAvailabilityZone?

    public init (
        customAvailabilityZone: CustomAvailabilityZone? = nil
    )
    {
        self.customAvailabilityZone = customAvailabilityZone
    }
}

struct CreateCustomAvailabilityZoneOutputResponseBody: Equatable {
    public let customAvailabilityZone: CustomAvailabilityZone?
}

extension CreateCustomAvailabilityZoneOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customAvailabilityZone = "CustomAvailabilityZone"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateCustomAvailabilityZoneResult"))
        let customAvailabilityZoneDecoded = try containerValues.decodeIfPresent(CustomAvailabilityZone.self, forKey: .customAvailabilityZone)
        customAvailabilityZone = customAvailabilityZoneDecoded
    }
}

public struct CreateDBClusterEndpointInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterEndpointOutputError>
}

extension CreateDBClusterEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterEndpointInput(dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)), tags: \(String(describing: tags)))"}
}

extension CreateDBClusterEndpointInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterEndpoint", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBClusterEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterEndpointOutputError>
}

public struct CreateDBClusterEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterEndpointOutputError>
}

public struct CreateDBClusterEndpointInput: Equatable {
    /// <p>The identifier to use for the new endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///             stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>ANY</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///        All other eligible instances are reachable through the custom endpoint.
    ///        Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?
    /// <p>The tags to be assigned to the Amazon RDS resource.</p>
    public let tags: [Tag]?

    public init (
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.tags = tags
    }
}

extension CreateDBClusterEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointAlreadyExistsFault" : self = .dBClusterEndpointAlreadyExistsFault(try DBClusterEndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterEndpointQuotaExceededFault" : self = .dBClusterEndpointQuotaExceededFault(try DBClusterEndpointQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterEndpointOutputError: Equatable {
    case dBClusterEndpointAlreadyExistsFault(DBClusterEndpointAlreadyExistsFault)
    case dBClusterEndpointQuotaExceededFault(DBClusterEndpointQuotaExceededFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterEndpointOutputResponse(customEndpointType: \(String(describing: customEndpointType)), dBClusterEndpointArn: \(String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), endpoint: \(String(describing: endpoint)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)), status: \(String(describing: status)))"}
}

extension CreateDBClusterEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// <p>This data type represents the information you need to connect to an Amazon Aurora DB cluster.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBClusterEndpoint</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon RDS DB instance endpoints,
///         see <code>Endpoint</code>.</p>
public struct CreateDBClusterEndpointOutputResponse: Equatable {
    /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
    ///        <code>WRITER</code>, <code>ANY</code>.</p>
    public let customEndpointType: String?
    /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
    public let dBClusterEndpointArn: String?
    /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
    public let dBClusterEndpointResourceIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///             stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>The DNS address of the endpoint.</p>
    public let endpoint: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///        All other eligible instances are reachable through the custom endpoint.
    ///        Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?
    /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that can't be used for a certain kind of cluster,
    ///      such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
    public let status: String?

    public init (
        customEndpointType: String? = nil,
        dBClusterEndpointArn: String? = nil,
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterEndpointResourceIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        endpoint: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil,
        status: String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct CreateDBClusterEndpointOutputResponseBody: Equatable {
    public let dBClusterEndpointIdentifier: String?
    public let dBClusterIdentifier: String?
    public let dBClusterEndpointResourceIdentifier: String?
    public let endpoint: String?
    public let status: String?
    public let endpointType: String?
    public let customEndpointType: String?
    public let staticMembers: [String]?
    public let excludedMembers: [String]?
    public let dBClusterEndpointArn: String?
}

extension CreateDBClusterEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var staticMembersBuffer:[String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var excludedMembersBuffer:[String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct CreateDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterOutputError>
}

extension CreateDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterInput(availabilityZones: \(String(describing: availabilityZones)), backtrackWindow: \(String(describing: backtrackWindow)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), characterSetName: \(String(describing: characterSetName)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), databaseName: \(String(describing: databaseName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableGlobalWriteForwarding: \(String(describing: enableGlobalWriteForwarding)), enableHttpEndpoint: \(String(describing: enableHttpEndpoint)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), engine: \(String(describing: engine)), engineMode: \(String(describing: engineMode)), engineVersion: \(String(describing: engineVersion)), globalClusterIdentifier: \(String(describing: globalClusterIdentifier)), kmsKeyId: \(String(describing: kmsKeyId)), masterUserPassword: \(String(describing: masterUserPassword)), masterUsername: \(String(describing: masterUsername)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), preSignedUrl: \(String(describing: preSignedUrl)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), replicationSourceIdentifier: \(String(describing: replicationSourceIdentifier)), scalingConfiguration: \(String(describing: scalingConfiguration)), storageEncrypted: \(String(describing: storageEncrypted)), tags: \(String(describing: tags)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension CreateDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableGlobalWriteForwarding = enableGlobalWriteForwarding {
            try container.encode(enableGlobalWriteForwarding, forKey: Key("EnableGlobalWriteForwarding"))
        }
        if let enableHttpEndpoint = enableHttpEndpoint {
            try container.encode(enableHttpEndpoint, forKey: Key("EnableHttpEndpoint"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: Key("GlobalClusterIdentifier"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: Key("PreSignedUrl"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: Key("ReplicationSourceIdentifier"))
        }
        if let scalingConfiguration = scalingConfiguration {
            try container.encode(scalingConfiguration, forKey: Key("ScalingConfiguration"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterOutputError>
}

public struct CreateDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterOutputError>
}

/// <p></p>
public struct CreateDBClusterInput: Equatable {
    /// <p>A list of Availability Zones (AZs) where instances in the DB cluster can be created. For information on
    ///             AWS Regions and Availability Zones, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.RegionsAndAvailabilityZones.html">Choosing the Regions and
    ///                 Availability Zones</a> in the <i>Amazon Aurora User Guide</i>.
    ///         </p>
    public let availabilityZones: [String]?
    /// <p>The target backtrack window, in seconds. To disable backtracking, set this value to
    ///             0. </p>
    ///         <note>
    ///             <p>Currently, Backtrack is only supported for Aurora MySQL DB clusters.</p>
    ///         </note>
    ///          <p>Default: 0</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If specified, this value must be set to a number from 0 to 259,200 (72 hours).</p>
    ///             </li>
    ///          </ul>
    public let backtrackWindow: Int?
    /// <p>The number of days for which automated backups are retained.</p>
    ///          <p>Default: 1</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be a value from 1 to 35</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Int?
    /// <p>A value that indicates that the DB cluster should be associated with the specified CharacterSet.</p>
    public let characterSetName: String?
    /// <p>A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster.
    ///             The default is not to copy them.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The DB cluster identifier. This parameter is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster1</code>
    ///          </p>
    public let dBClusterIdentifier: String?
    /// <p>
    ///             The name of the DB cluster parameter group to associate
    ///             with this DB cluster. If you do not specify a value, then
    ///           the default DB cluster parameter group for the specified DB engine and version is used.
    ///         </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DB cluster parameter group.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?
    /// <p>A DB subnet group to associate with this DB cluster.</p>
    ///          <p>Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>The name for your database of up to 64 alphanumeric characters. If you do not
    ///             provide a name, Amazon RDS doesn't create a database in the DB cluster you are
    ///             creating.</p>
    public let databaseName: String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled.</p>
    public let deletionProtection: Bool?
    /// <p>The Active Directory directory ID to create the DB cluster in.</p>
    ///          <p>
    ///          For Amazon Aurora DB clusters, Amazon RDS can use Kerberos Authentication to authenticate users that connect to the DB cluster.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html">Kerberos Authentication</a>
    ///          in the <i>Amazon Aurora User Guide</i>.
    ///        </p>
    public let domain: String?
    /// <p>Specify the name of the IAM role to be used when making API calls to the Directory Service.</p>
    public let domainIAMRoleName: String?
    /// <p>The list of log types that need to be enabled for exporting to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs</a> in the <i>Amazon Aurora User Guide</i>.</p>
    ///         <p>
    ///             <b>Aurora MySQL</b>
    ///         </p>
    ///         <p>Possible values are <code>audit</code>, <code>error</code>, <code>general</code>, and <code>slowquery</code>.
    ///         </p>
    ///         <p>
    ///             <b>Aurora PostgreSQL</b>
    ///         </p>
    ///         <p>Possible value is <code>postgresql</code>.
    ///         </p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>A value that indicates whether to enable this DB cluster to forward write operations to the primary cluster of an
    ///       Aurora global database (<a>GlobalCluster</a>). By default, write operations are not allowed on Aurora DB clusters that
    ///       are secondary clusters in an Aurora global database.</p>
    ///          <p>You can set this value only on Aurora DB clusters that are members of an Aurora global database. With this parameter
    ///       enabled, a secondary cluster can forward writes to the current primary cluster and the resulting changes are replicated back to
    ///       this cluster. For the primary DB cluster of an Aurora global database, this value is used immediately if the
    ///         primary is demoted by the <a>FailoverGlobalCluster</a> API operation, but it does nothing until then.
    ///     </p>
    public let enableGlobalWriteForwarding: Bool?
    /// <p>A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster. By default, the HTTP endpoint
    ///             is disabled.</p>
    ///         <p>When enabled, the HTTP endpoint provides a connectionless web service API for running
    ///             SQL queries on the Aurora Serverless DB cluster. You can also query your database
    ///             from inside the RDS console with the query editor.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html">Using the Data API for Aurora Serverless</a> in the
    ///             <i>Amazon Aurora User Guide</i>.</p>
    public let enableHttpEndpoint: Bool?
    /// <p>A value that indicates whether to enable mapping of AWS Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.</p>
    ///
    ///         <p>For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html">
    ///                 IAM Database Authentication</a> in the <i>Amazon Aurora User Guide.</i>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>The name of the database engine to be used for this DB cluster.</p>
    ///          <p>Valid Values: <code>aurora</code> (for MySQL 5.6-compatible Aurora), <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora), and <code>aurora-postgresql</code>
    ///          </p>
    public let engine: String?
    /// <p>The DB engine mode of the DB cluster, either <code>provisioned</code>, <code>serverless</code>,
    ///             <code>parallelquery</code>, <code>global</code>, or <code>multimaster</code>.</p>
    ///         <p>The <code>parallelquery</code> engine mode isn't required for Aurora MySQL version 1.23 and higher 1.x versions,
    ///             and version 2.09 and higher 2.x versions.</p>
    ///         <p>The <code>global</code> engine mode isn't required for Aurora MySQL version 1.22 and higher 1.x versions,
    ///             and <code>global</code> engine mode isn't required for any 2.x versions.</p>
    ///         <p>The <code>multimaster</code> engine mode only applies for DB clusters created with Aurora MySQL version 5.6.10a.</p>
    ///         <p>For Aurora PostgreSQL, the <code>global</code> engine mode isn't required, and both the <code>parallelquery</code>
    ///             and the <code>multimaster</code> engine modes currently aren't supported.</p>
    ///         <p>Limitations and requirements apply to some DB engine modes. For more information, see the
    ///             following sections in the <i>Amazon Aurora User Guide</i>:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.limitations">
    ///                         Limitations of Aurora Serverless</a>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-mysql-parallel-query.html#aurora-mysql-parallel-query-limitations">
    ///                         Limitations of Parallel Query</a>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html#aurora-global-database.limitations">
    ///                         Limitations of Aurora Global Databases</a>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-multi-master.html#aurora-multi-master-limitations">
    ///                         Limitations of Multi-Master Clusters</a>
    ///                 </p>
    ///             </li>
    ///          </ul>
    public let engineMode: String?
    /// <p>The version number of the database engine to use.</p>
    ///          <p>To list all of the available engine versions for <code>aurora</code> (for MySQL 5.6-compatible Aurora), use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    ///          <p>To list all of the available engine versions for <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora), use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    ///          <p>To list all of the available engine versions for <code>aurora-postgresql</code>, use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    ///          <p>
    ///             <b>Aurora MySQL</b>
    ///          </p>
    ///          <p>Example: <code>5.6.10a</code>, <code>5.6.mysql_aurora.1.19.2</code>, <code>5.7.12</code>, <code>5.7.mysql_aurora.2.04.5</code>
    ///          </p>
    ///          <p>
    ///             <b>Aurora PostgreSQL</b>
    ///          </p>
    ///          <p>Example: <code>9.6.3</code>, <code>10.7</code>
    ///          </p>
    public let engineVersion: String?
    /// <p>
    ///         The global cluster ID of an Aurora cluster that becomes the primary cluster
    ///         in the new global database cluster.
    ///       </p>
    public let globalClusterIdentifier: String?
    /// <p>The AWS KMS key identifier for an encrypted DB cluster.</p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).
    ///                  To use a CMK in a different AWS account, specify the key ARN or alias ARN.</p>
    ///         <p>When a CMK isn't specified in <code>KmsKeyId</code>:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If <code>ReplicationSourceIdentifier</code> identifies an encrypted
    ///                     source, then Amazon RDS will use the CMK used to encrypt the
    ///                     source. Otherwise, Amazon RDS will use your default CMK. </p>
    ///             </li>
    ///             <li>
    ///                 <p>If the <code>StorageEncrypted</code> parameter is enabled and
    ///                         <code>ReplicationSourceIdentifier</code> isn't specified, then Amazon RDS
    ///                     will use your default CMK.</p>
    ///             </li>
    ///          </ul>
    ///         <p>There is a default CMK for your AWS account. Your AWS account
    ///             has a different default CMK for each AWS Region.</p>
    ///         <p>If you create a read replica of an encrypted DB cluster in another AWS Region, you
    ///             must set <code>KmsKeyId</code> to a AWS KMS key identifier that is valid in the destination AWS
    ///             Region. This CMK is used to encrypt the read replica in that AWS Region.</p>
    public let kmsKeyId: String?
    /// <p>The password for the master database user. This password can contain any printable ASCII character except "/", """, or "@".</p>
    ///          <p>Constraints: Must contain from 8 to 41 characters.</p>
    public let masterUserPassword: String?
    /// <p>The name of the master user for the DB cluster.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 16 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be a reserved word for the chosen database engine.</p>
    ///             </li>
    ///          </ul>
    public let masterUsername: String?
    /// <p>A value that indicates that the DB cluster should be associated with the specified option group.</p>
    ///          <p>Permanent options can't be removed from an option group. The option group can't be removed from a DB cluster once it is associated with a DB cluster.</p>
    public let optionGroupName: String?
    /// <p>The port number on which the instances in the DB cluster accept connections.</p>
    ///          <p>
    ///             Default: <code>3306</code> if engine is set as aurora or <code>5432</code> if set to aurora-postgresql.
    ///       </p>
    public let port: Int?
    /// <p>A URL that contains a Signature Version 4 signed request for
    ///             the <code>CreateDBCluster</code> action to be called in the source AWS Region where the DB cluster is replicated from.
    ///             You only need to specify <code>PreSignedUrl</code> when you are performing cross-region replication from an encrypted DB cluster.</p>
    ///
    ///         <p>The pre-signed URL must be a valid request for the <code>CreateDBCluster</code> API action
    ///             that can be executed in the source AWS Region that contains the encrypted DB cluster to be copied.</p>
    ///         <p>The pre-signed URL request must contain the following parameter values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>KmsKeyId</code> - The AWS KMS key identifier for the key to use to encrypt the copy of
    ///                 the DB cluster in the destination AWS Region. This should refer to the same AWS KMS CMK for both the <code>CreateDBCluster</code>
    ///                 action that is called in the destination AWS Region, and the action contained in the pre-signed URL.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DestinationRegion</code> - The name of the AWS Region that Aurora read replica will
    ///                     be created in.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ReplicationSourceIdentifier</code> - The DB cluster identifier for the encrypted DB cluster to be copied.
    ///                 This identifier must be in the Amazon Resource Name (ARN) format for the source AWS Region. For example, if you are copying an
    ///                 encrypted DB cluster from the us-west-2 AWS Region, then your <code>ReplicationSourceIdentifier</code> would look like
    ///                 Example: <code>arn:aws:rds:us-west-2:123456789012:cluster:aurora-cluster1</code>.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>To learn how to generate a Signature Version 4 signed request, see
    ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">
    ///                 Authenticating Requests: Using Query Parameters (AWS Signature Version 4)</a> and
    ///             <a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">
    ///                 Signature Version 4 Signing Process</a>.</p>
    ///         <note>
    ///             <p>If you are using an AWS SDK tool or the AWS CLI, you can specify <code>SourceRegion</code> (or <code>--source-region</code> for the AWS CLI)
    ///                 instead of specifying <code>PreSignedUrl</code> manually. Specifying <code>SourceRegion</code> autogenerates a pre-signed URL that is a valid
    ///                 request for the operation that can be executed in the source AWS Region.</p>
    ///         </note>
    public let preSignedUrl: String?
    /// <p>The daily time range during which automated backups are created
    ///         if automated backups are enabled
    ///         using the <code>BackupRetentionPeriod</code> parameter.
    ///         </p>
    ///          <p>The default is a 30-minute window selected at random from an
    ///         8-hour block of time for each AWS Region.
    ///         To view the time blocks available, see
    ///         <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow">
    ///             Backup window</a> in the <i>Amazon Aurora User Guide.</i>
    ///         </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be in the format <code>hh24:mi-hh24:mi</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Coordinated Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes.</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: String?
    /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
    ///          <p>Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///          </p>
    ///          <p>The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each AWS Region, occurring on a random day of the
    ///             week. To see the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora">
    ///                 Adjusting the Preferred DB Cluster Maintenance Window</a> in the <i>Amazon Aurora User Guide.</i>
    ///         </p>
    ///          <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    ///          <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB
    ///             cluster is created as a read replica.</p>
    public let replicationSourceIdentifier: String?
    /// <p>For DB clusters in <code>serverless</code> DB engine mode, the scaling properties of the DB cluster.</p>
    public let scalingConfiguration: ScalingConfiguration?
    /// <p>A value that indicates whether the DB cluster is encrypted.</p>
    public let storageEncrypted: Bool?
    /// <p>Tags to assign to the DB cluster.</p>
    public let tags: [Tag]?
    /// <p>A list of EC2 VPC security groups to associate with this DB cluster.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        availabilityZones: [String]? = nil,
        backtrackWindow: Int? = nil,
        backupRetentionPeriod: Int? = nil,
        characterSetName: String? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterParameterGroupName: String? = nil,
        dBSubnetGroupName: String? = nil,
        databaseName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableGlobalWriteForwarding: Bool? = nil,
        enableHttpEndpoint: Bool? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        engine: String? = nil,
        engineMode: String? = nil,
        engineVersion: String? = nil,
        globalClusterIdentifier: String? = nil,
        kmsKeyId: String? = nil,
        masterUserPassword: String? = nil,
        masterUsername: String? = nil,
        optionGroupName: String? = nil,
        port: Int? = nil,
        preSignedUrl: String? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        replicationSourceIdentifier: String? = nil,
        scalingConfiguration: ScalingConfiguration? = nil,
        storageEncrypted: Bool? = nil,
        tags: [Tag]? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backtrackWindow = backtrackWindow
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableGlobalWriteForwarding = enableGlobalWriteForwarding
        self.enableHttpEndpoint = enableHttpEndpoint
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineMode = engineMode
        self.engineVersion = engineVersion
        self.globalClusterIdentifier = globalClusterIdentifier
        self.kmsKeyId = kmsKeyId
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.optionGroupName = optionGroupName
        self.port = port
        self.preSignedUrl = preSignedUrl
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationSourceIdentifier = replicationSourceIdentifier
        self.scalingConfiguration = scalingConfiguration
        self.storageEncrypted = storageEncrypted
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacityFault" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterOutputError: Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension CreateDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct CreateDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Aurora DB cluster.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusters</code>,
    ///         <code>StopDBCluster</code>, and <code>StartDBCluster</code> actions.
    ///       </p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct CreateDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension CreateDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct CreateDBClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterParameterGroupOutputError>
}

extension CreateDBClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterParameterGroupInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), description: \(String(describing: description)), tags: \(String(describing: tags)))"}
}

extension CreateDBClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterParameterGroupOutputError>
}

public struct CreateDBClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterParameterGroupOutputError>
}

/// <p></p>
public struct CreateDBClusterParameterGroupInput: Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the name of an existing DB cluster parameter group.</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBClusterParameterGroupName: String?
    /// <p>The DB cluster parameter group family name. A DB cluster parameter group can be associated with one and only one DB cluster
    ///           parameter group family, and can be applied only to a DB cluster running a database engine and engine version compatible with that DB cluster parameter group family.</p>
    ///          <p>
    ///             <b>Aurora MySQL</b>
    ///          </p>
    ///          <p>Example: <code>aurora5.6</code>, <code>aurora-mysql5.7</code>
    ///          </p>
    ///          <p>
    ///             <b>Aurora PostgreSQL</b>
    ///          </p>
    ///          <p>Example: <code>aurora-postgresql9.6</code>
    ///          </p>
    ///          <p>To list all of the available parameter group families for a DB engine, use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine <engine></code>
    ///          </p>
    ///          <p>For example, to list all of the available parameter group families for the Aurora PostgreSQL DB engine, use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine aurora-postgresql</code>
    ///          </p>
    ///          <note>
    ///             <p>The output contains duplicates.</p>
    ///          </note>
    ///          <p>The following are the valid DB engine values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>aurora</code> (for MySQL 5.6-compatible Aurora)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>aurora-postgresql</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupFamily: String?
    /// <p>The description for the DB cluster parameter group.</p>
    public let description: String?
    /// <p>Tags to assign to the DB cluster parameter group.</p>
    public let tags: [Tag]?

    public init (
        dBClusterParameterGroupName: String? = nil,
        dBParameterGroupFamily: String? = nil,
        description: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.description = description
        self.tags = tags
    }
}

extension CreateDBClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterParameterGroupOutputError: Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterParameterGroupOutputResponse(dBClusterParameterGroup: \(String(describing: dBClusterParameterGroup)))"}
}

extension CreateDBClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterParameterGroup = output.dBClusterParameterGroup
        } else {
            self.dBClusterParameterGroup = nil
        }
    }
}

public struct CreateDBClusterParameterGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB cluster parameter group.
    ///         </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusterParameterGroups</code> action.
    ///         </p>
    public let dBClusterParameterGroup: DBClusterParameterGroup?

    public init (
        dBClusterParameterGroup: DBClusterParameterGroup? = nil
    )
    {
        self.dBClusterParameterGroup = dBClusterParameterGroup
    }
}

struct CreateDBClusterParameterGroupOutputResponseBody: Equatable {
    public let dBClusterParameterGroup: DBClusterParameterGroup?
}

extension CreateDBClusterParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroup = "DBClusterParameterGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBClusterParameterGroupResult"))
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(DBClusterParameterGroup.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
    }
}

public struct CreateDBClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterSnapshotOutputError>
}

extension CreateDBClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterSnapshotInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)), tags: \(String(describing: tags)))"}
}

extension CreateDBClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterSnapshotOutputError>
}

public struct CreateDBClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterSnapshotOutputError>
}

/// <p></p>
public struct CreateDBClusterSnapshotInput: Equatable {
    /// <p>The identifier of the DB cluster to create a snapshot for. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster1</code>
    ///          </p>
    public let dBClusterIdentifier: String?
    /// <p>The identifier of the DB cluster snapshot. This parameter is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster1-snapshot1</code>
    ///          </p>
    public let dBClusterSnapshotIdentifier: String?
    /// <p>The tags to be assigned to the DB cluster snapshot.</p>
    public let tags: [Tag]?

    public init (
        dBClusterIdentifier: String? = nil,
        dBClusterSnapshotIdentifier: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.tags = tags
    }
}

extension CreateDBClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterSnapshotOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(String(describing: dBClusterSnapshot)))"}
}

extension CreateDBClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct CreateDBClusterSnapshotOutputResponse: Equatable {
    /// <p>Contains the details for an Amazon RDS DB cluster snapshot
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBClusterSnapshots</code> action.
    ///       </p>
    public let dBClusterSnapshot: DBClusterSnapshot?

    public init (
        dBClusterSnapshot: DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct CreateDBClusterSnapshotOutputResponseBody: Equatable {
    public let dBClusterSnapshot: DBClusterSnapshot?
}

extension CreateDBClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct CreateDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBInstanceOutputError>
}

extension CreateDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBInstanceInput(allocatedStorage: \(String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), availabilityZone: \(String(describing: availabilityZone)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), characterSetName: \(String(describing: characterSetName)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBName: \(String(describing: dBName)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), dBSecurityGroups: \(String(describing: dBSecurityGroups)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableCustomerOwnedIp: \(String(describing: enableCustomerOwnedIp)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(String(describing: enablePerformanceInsights)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), iops: \(String(describing: iops)), kmsKeyId: \(String(describing: kmsKeyId)), licenseModel: \(String(describing: licenseModel)), masterUserPassword: \(String(describing: masterUserPassword)), masterUsername: \(String(describing: masterUsername)), maxAllocatedStorage: \(String(describing: maxAllocatedStorage)), monitoringInterval: \(String(describing: monitoringInterval)), monitoringRoleArn: \(String(describing: monitoringRoleArn)), multiAZ: \(String(describing: multiAZ)), ncharCharacterSetName: \(String(describing: ncharCharacterSetName)), optionGroupName: \(String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(String(describing: performanceInsightsKMSKeyId)), performanceInsightsRetentionPeriod: \(String(describing: performanceInsightsRetentionPeriod)), port: \(String(describing: port)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), processorFeatures: \(String(describing: processorFeatures)), promotionTier: \(String(describing: promotionTier)), publiclyAccessible: \(String(describing: publiclyAccessible)), storageEncrypted: \(String(describing: storageEncrypted)), storageType: \(String(describing: storageType)), tags: \(String(describing: tags)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), tdeCredentialPassword: \(String(describing: tdeCredentialPassword)), timezone: \(String(describing: timezone)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension CreateDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: Key("EnablePerformanceInsights"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let ncharCharacterSetName = ncharCharacterSetName {
            try container.encode(ncharCharacterSetName, forKey: Key("NcharCharacterSetName"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: Key("PromotionTier"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: Key("TdeCredentialPassword"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: Key("Timezone"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBInstanceOutputError>
}

public struct CreateDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBInstanceOutputError>
}

/// <p></p>
public struct CreateDBInstanceInput: Equatable {
    /// <p>The amount of storage (in gibibytes) to allocate for the DB instance.</p>
    ///          <p>Type: Integer</p>
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>Not applicable. Aurora cluster volumes automatically grow as the amount of data in your
    ///           database increases, though you are only charged for the space that you use in an Aurora cluster volume.</p>
    ///
    ///          <p>
    ///             <b>MySQL</b>
    ///          </p>
    ///          <p>Constraints to the amount of storage for each storage type are the following:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.</p>
    ///             </li>
    ///             <li>
    ///                <p>Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.</p>
    ///             </li>
    ///             <li>
    ///                <p>Magnetic storage (standard): Must be an integer from 5 to 3072.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>
    ///             <b>MariaDB</b>
    ///          </p>
    ///          <p>Constraints to the amount of storage for each storage type are the following:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.</p>
    ///             </li>
    ///             <li>
    ///                <p>Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.</p>
    ///             </li>
    ///             <li>
    ///                <p>Magnetic storage (standard): Must be an integer from 5 to 3072.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>
    ///             <b>PostgreSQL</b>
    ///          </p>
    ///          <p>Constraints to the amount of storage for each storage type are the following:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.</p>
    ///             </li>
    ///             <li>
    ///                <p>Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.</p>
    ///             </li>
    ///             <li>
    ///                <p>Magnetic storage (standard): Must be an integer from 5 to 3072.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///          <p>Constraints to the amount of storage for each storage type are the following:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.</p>
    ///             </li>
    ///             <li>
    ///                <p>Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.</p>
    ///             </li>
    ///             <li>
    ///                <p>Magnetic storage (standard): Must be an integer from 10 to 3072.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>
    ///             <b>SQL Server</b>
    ///          </p>
    ///          <p>Constraints to the amount of storage for each storage type are the following:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>General Purpose (SSD) storage (gp2):</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Enterprise and Standard editions: Must be an integer from 200 to 16384.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Web and Express editions: Must be an integer from 20 to 16384.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Provisioned IOPS storage (io1):</p>
    ///               <ul>
    ///                   <li>
    ///                      <p>Enterprise and Standard editions: Must be an integer from 200 to 16384.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Web and Express editions: Must be an integer from 100 to 16384.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Magnetic storage (standard):</p>
    ///               <ul>
    ///                   <li>
    ///                      <p>Enterprise and Standard editions: Must be an integer from 200 to 1024.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Web and Express editions: Must be an integer from 20 to 1024.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let allocatedStorage: Int?
    /// <p>A value that indicates whether minor engine upgrades are applied automatically to the DB instance during the maintenance window.
    ///           By default, minor engine upgrades are applied automatically.</p>
    public let autoMinorVersionUpgrade: Bool?
    /// <p>
    ///         The Availability Zone (AZ) where the database will be created. For information on
    ///         AWS Regions and Availability Zones, see
    ///         <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html">Regions
    ///         and Availability Zones</a>.
    ///         </p>
    ///          <p>Default: A random, system-chosen Availability Zone in the endpoint's AWS Region.</p>
    ///          <p>
    ///             Example: <code>us-east-1d</code>
    ///          </p>
    ///          <p>
    ///           Constraint: The <code>AvailabilityZone</code> parameter can't be specified if the DB instance is a Multi-AZ deployment.
    ///             The specified Availability Zone must be in the same AWS Region as the current endpoint.
    ///         </p>
    ///          <note>
    ///             <p>If you're creating a DB instance in an RDS on VMware environment,
    ///                 specify the identifier of the custom Availability Zone to create the DB instance
    ///                 in.</p>
    ///             <p>For more information about RDS on VMware, see the
    ///               <a href="https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html">
    ///                   RDS on VMware User Guide.</a>
    ///             </p>
    ///          </note>
    public let availabilityZone: String?
    /// <p>The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.</p>
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>Not applicable. The retention period for automated backups is managed by the DB
    ///           cluster.</p>
    ///          <p>Default: 1</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be a value from 0 to 35</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be set to 0 if the DB instance is a source to read replicas</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Int?
    /// <p>For supported engines, indicates that the DB instance should be associated with the specified CharacterSet.</p>
    ///
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>Not applicable. The character set is managed by
    ///           the DB cluster. For more information, see <code>CreateDBCluster</code>.</p>
    public let characterSetName: String?
    /// <p>A value that indicates whether to copy tags from the DB instance to snapshots of the DB instance. By default, tags are not copied.</p>
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this
    ///           value for an Aurora DB instance has no effect on the DB cluster setting.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The identifier of the DB cluster that the instance will belong to.</p>
    public let dBClusterIdentifier: String?
    /// <p>The compute and memory capacity of the DB instance, for example, <code>db.m4.large</code>.
    ///           Not all DB instance classes are available in all AWS Regions, or for all database engines.
    ///           For the full list of DB instance classes,
    ///           and availability for your engine, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance Class</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let dBInstanceClass: String?
    /// <p>The DB instance identifier. This parameter is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>mydbinstance</code>
    ///          </p>
    public let dBInstanceIdentifier: String?
    /// <p>The meaning of this parameter differs according to the database engine you use.</p>
    ///          <p>
    ///             <b>MySQL</b>
    ///          </p>
    ///          <p>The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain 1 to 64 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be a word reserved by the specified database engine</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>MariaDB</b>
    ///          </p>
    ///          <p>The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain 1 to 64 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be a word reserved by the specified database engine</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>PostgreSQL</b>
    ///          </p>
    ///          <p>The name of the database to create when the DB instance is created. If this parameter isn't specified, a database named <code>postgres</code>
    ///           is created in the DB instance.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain 1 to 63 letters, numbers, or underscores.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be a word reserved by the specified database engine</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///          <p>The Oracle System ID (SID) of the created DB instance.
    ///           If you specify <code>null</code>, the default value <code>ORCL</code> is used.
    ///           You can't specify the string NULL, or any other reserved word, for <code>DBName</code>.
    ///       </p>
    ///          <p>Default: <code>ORCL</code>
    ///          </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Can't be longer than 8 characters</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>SQL Server</b>
    ///          </p>
    ///          <p>Not applicable. Must be null.</p>
    ///          <p>
    ///             <b>Amazon Aurora MySQL</b>
    ///          </p>
    ///          <p>The name of the database to create when the primary DB instance of the Aurora MySQL DB cluster is
    ///           created. If this parameter isn't specified for an Aurora MySQL DB cluster, no database is created
    ///           in the DB cluster.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///               <p>It must contain 1 to 64 alphanumeric characters.</p>
    ///             </li>
    ///             <li>
    ///               <p>It can't be a word reserved by the database engine.</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>Amazon Aurora PostgreSQL</b>
    ///          </p>
    ///          <p>The name of the database to create when the primary DB instance of the Aurora PostgreSQL DB cluster is
    ///           created. If this parameter isn't specified for an Aurora PostgreSQL DB cluster,
    ///           a database named <code>postgres</code> is created in the DB cluster.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///               <p>It must contain 1 to 63 alphanumeric characters.</p>
    ///             </li>
    ///             <li>
    ///               <p>It must begin with a letter or an underscore.
    ///                   Subsequent characters can be letters, underscores, or digits
    ///                   (0 to 9).</p>
    ///             </li>
    ///             <li>
    ///               <p>It can't be a word reserved by the
    ///                   database engine.</p>
    ///             </li>
    ///          </ul>
    public let dBName: String?
    /// <p>The name of the DB parameter group to associate with this DB instance. If you do not specify a value, then
    ///           the default DB parameter group for the specified DB engine and version is used.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>A list of DB security groups to associate with this DB instance.</p>
    ///          <p>Default: The default DB security group for the database engine.</p>
    public let dBSecurityGroups: [String]?
    /// <p>A DB subnet group to associate with this DB instance.</p>
    ///          <p>If there is no DB subnet group, then it is a non-VPC DB instance.</p>
    public let dBSubnetGroupName: String?
    /// <p>A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance</a>.
    ///         </p>
    ///         <p>
    ///             <b>Amazon Aurora</b>
    ///         </p>
    ///         <p>Not applicable. You can enable or disable deletion protection for the DB cluster.
    ///             For more information, see <code>CreateDBCluster</code>. DB instances in a DB
    ///             cluster can be deleted even when deletion protection is enabled for the DB cluster.
    ///         </p>
    public let deletionProtection: Bool?
    /// <p>The Active Directory directory ID to create the DB instance in. Currently, only MySQL, Microsoft SQL
    ///             Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///            Kerberos Authentication</a> in the <i>Amazon RDS User Guide</i>.</p>
    public let domain: String?
    /// <p>Specify the name of the IAM role to be used when making API calls to the Directory Service.</p>
    public let domainIAMRoleName: String?
    /// <p>The list of log types that need to be enabled for exporting to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs </a> in the <i>Amazon Relational Database
    ///                     Service User Guide</i>.</p>
    ///         <p>
    ///             <b>Amazon Aurora</b>
    ///         </p>
    ///         <p>Not applicable. CloudWatch Logs exports are managed by the DB cluster.
    ///         </p>
    ///         <p>
    ///             <b>MariaDB</b>
    ///         </p>
    ///         <p>Possible values are <code>audit</code>, <code>error</code>, <code>general</code>, and <code>slowquery</code>.
    ///         </p>
    ///         <p>
    ///             <b>Microsoft SQL Server</b>
    ///         </p>
    ///         <p>Possible values are <code>agent</code> and <code>error</code>.
    ///         </p>
    ///          <p>
    ///             <b>MySQL</b>
    ///         </p>
    ///         <p>Possible values are <code>audit</code>, <code>error</code>, <code>general</code>, and <code>slowquery</code>.
    ///         </p>
    ///         <p>
    ///             <b>Oracle</b>
    ///         </p>
    ///         <p>Possible values are <code>alert</code>, <code>audit</code>, <code>listener</code>, <code>trace</code>, and
    ///             <code>oemagent</code>.
    ///         </p>
    ///         <p>
    ///             <b>PostgreSQL</b>
    ///         </p>
    ///         <p>Possible values are <code>postgresql</code> and <code>upgrade</code>.
    ///         </p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS
    ///             on Outposts DB instance.</p>
    ///         <p>A <i>CoIP</i> provides local or external connectivity to resources in
    ///             your Outpost subnets through your on-premises network. For some use cases, a CoIP can
    ///             provide lower latency for connections to the DB instance from outside of its virtual
    ///             private cloud (VPC) on your local network.</p>
    ///         <p>For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Working with Amazon RDS on AWS Outposts</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    ///         <p>For more information about CoIPs, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing">Customer-owned IP addresses</a>
    ///             in the <i>AWS Outposts User Guide</i>.</p>
    public let enableCustomerOwnedIp: Bool?
    /// <p>A value that indicates whether to enable mapping of AWS Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.</p>
    ///
    ///          <p>This setting doesn't apply to Amazon Aurora. Mapping AWS IAM accounts to database accounts is managed by the DB
    ///         cluster.</p>
    ///
    ///          <p>For more information, see
    ///        <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///            IAM Database Authentication for MySQL and PostgreSQL</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>A value that indicates whether to enable Performance Insights for the DB instance.
    ///         </p>
    ///         <p>For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html">Using Amazon Performance Insights</a> in the <i>Amazon Relational Database Service
    ///                     User Guide</i>.
    ///         </p>
    public let enablePerformanceInsights: Bool?
    /// <p>The name of the database engine to be used for this instance.
    ///       </p>
    ///
    ///          <p>Not every database engine is available for every AWS Region.
    ///       </p>
    ///
    ///          <p>Valid Values:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>aurora</code> (for MySQL 5.6-compatible Aurora)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>aurora-postgresql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mariadb</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mysql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se2</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se1</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>postgres</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ex</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-web</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let engine: String?
    /// <p>The version number of the database engine to use.</p>
    ///          <p>For a list of valid engine versions, use the  <code>DescribeDBEngineVersions</code> action.</p>
    ///          <p>The following are the database engines and links to information about the major and minor versions that are available with
    ///           Amazon RDS. Not every database engine is available for every AWS Region.</p>
    ///
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///         <p>Not applicable. The version number of the database engine to be used by the DB
    ///             instance is managed by the DB cluster.</p>
    ///
    ///          <p>
    ///             <b>MariaDB</b>
    ///          </p>
    ///
    ///          <p>See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MariaDB.html#MariaDB.Concepts.VersionMgmt">MariaDB on Amazon RDS Versions</a> in the
    ///           <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///
    ///          <p>
    ///             <b>Microsoft SQL Server</b>
    ///          </p>
    ///
    ///          <p>See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport">Microsoft SQL Server Versions on Amazon RDS</a> in the
    ///           <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///
    ///          <p>
    ///             <b>MySQL</b>
    ///          </p>
    ///
    ///          <p>See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt">MySQL on Amazon RDS Versions</a> in the
    ///           <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///
    ///          <p>See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.Oracle.PatchComposition.html">Oracle Database Engine Release Notes</a> in the
    ///           <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///
    ///          <p>
    ///             <b>PostgreSQL</b>
    ///          </p>
    ///
    ///          <p>See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts">Amazon RDS for PostgreSQL versions and extensions</a> in the
    ///           <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let engineVersion: String?
    /// <p>The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance.
    ///           For information about valid Iops values, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS">Amazon RDS Provisioned IOPS Storage to Improve Performance</a> in the <i>Amazon RDS User Guide</i>.
    ///       </p>
    ///          <p>Constraints: For MariaDB, MySQL, Oracle, and PostgreSQL DB instances, must be a multiple between .5 and 50 of the storage amount for the DB instance.
    ///           For SQL Server DB instances, must be a multiple between 1 and 50 of the storage amount for the DB instance.
    ///     </p>
    public let iops: Int?
    /// <p>The AWS KMS key identifier for an encrypted DB instance.</p>
    ///          <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).
    ///           To use a CMK in a different AWS account, specify the key ARN or alias ARN.</p>
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>Not applicable. The AWS KMS key identifier is managed by
    ///           the DB cluster. For more information, see <code>CreateDBCluster</code>.</p>
    ///          <p>If <code>StorageEncrypted</code> is enabled, and you do
    ///         not specify a value for the <code>KmsKeyId</code> parameter, then
    ///         Amazon RDS uses your default CMK. There is a
    ///         default CMK for your AWS account. Your AWS account has a different
    ///         default CMK for each AWS Region.</p>
    public let kmsKeyId: String?
    /// <p>License model information for this DB instance.</p>
    ///          <p>
    ///             Valid values:  <code>license-included</code> | <code>bring-your-own-license</code> | <code>general-public-license</code>
    ///          </p>
    public let licenseModel: String?
    /// <p>The password for the master user. The password can include any printable ASCII character except "/", """, or "@".</p>
    ///
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///         <p>Not applicable. The password for the master user is managed by the DB
    ///             cluster.</p>
    ///
    ///          <p>
    ///             <b>MariaDB</b>
    ///          </p>
    ///          <p>Constraints: Must contain from 8 to 41 characters.</p>
    ///
    ///          <p>
    ///             <b>Microsoft SQL Server</b>
    ///          </p>
    ///          <p>Constraints: Must contain from 8 to 128 characters.</p>
    ///
    ///          <p>
    ///             <b>MySQL</b>
    ///          </p>
    ///          <p>Constraints: Must contain from 8 to 41 characters.</p>
    ///
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///          <p>Constraints: Must contain from 8 to 30 characters.</p>
    ///
    ///          <p>
    ///             <b>PostgreSQL</b>
    ///          </p>
    ///          <p>Constraints: Must contain from 8 to 128 characters.</p>
    public let masterUserPassword: String?
    /// <p>The name for the master user.</p>
    ///
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///         <p>Not applicable. The name for the master user is managed by the DB cluster.
    ///         </p>
    ///
    ///          <p>
    ///             <b>MariaDB</b>
    ///          </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///               <p>Required for MariaDB.</p>
    ///             </li>
    ///             <li>
    ///               <p>Must be 1 to 16 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///               <p>Can't be a reserved word for the chosen database engine.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>
    ///             <b>Microsoft SQL Server</b>
    ///          </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///               <p>Required for SQL Server.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be 1 to 128 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>The first character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be a reserved word for the chosen database engine.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>
    ///             <b>MySQL</b>
    ///          </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///               <p>Required for MySQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be 1 to 16 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be a reserved word for the chosen database engine.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///               <p>Required for Oracle.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be 1 to 30 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be a reserved word for the chosen database engine.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>
    ///             <b>PostgreSQL</b>
    ///          </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///               <p>Required for PostgreSQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be 1 to 63 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be a reserved word for the chosen database engine.</p>
    ///             </li>
    ///          </ul>
    public let masterUsername: String?
    /// <p>The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.</p>
    ///         <p>For more information about this setting, including limitations that apply to it, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling">
    ///                 Managing capacity automatically with Amazon RDS storage autoscaling</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    public let maxAllocatedStorage: Int?
    /// <p>The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0.</p>
    ///          <p>If <code>MonitoringRoleArn</code> is specified, then you must also set <code>MonitoringInterval</code>
    ///       to a value other than 0.</p>
    ///          <p>Valid Values: <code>0, 1, 5, 10, 15, 30, 60</code>
    ///          </p>
    public let monitoringInterval: Int?
    /// <p>The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For
    ///       example, <code>arn:aws:iam:123456789012:role/emaccess</code>. For information on creating a monitoring role,
    ///       go to <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling">Setting Up and Enabling Enhanced Monitoring</a>
    ///           in the <i>Amazon RDS User Guide</i>.</p>
    ///          <p>If <code>MonitoringInterval</code> is set to a value other than 0, then you must supply a <code>MonitoringRoleArn</code> value.</p>
    public let monitoringRoleArn: String?
    /// <p>A value that indicates whether the DB instance is a Multi-AZ deployment. You can't set
    ///           the <code>AvailabilityZone</code> parameter if the DB instance is a Multi-AZ deployment.</p>
    public let multiAZ: Bool?
    /// <p>The name of the NCHAR character set for the Oracle DB instance.</p>
    public let ncharCharacterSetName: String?
    /// <p>A value that indicates that the DB instance should be associated with the specified option group.</p>
    ///          <p>Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group. Also, that option group can't be removed from a DB instance once it is associated with a DB instance</p>
    public let optionGroupName: String?
    /// <p>The AWS KMS key identifier for encryption of Performance Insights data.</p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    ///         <p>If you do not specify a value for <code>PerformanceInsightsKMSKeyId</code>, then Amazon RDS
    ///             uses your default CMK. There is a default CMK for your AWS account.
    ///             Your AWS account has a different default CMK for each AWS Region.</p>
    public let performanceInsightsKMSKeyId: String?
    /// <p>The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years). </p>
    public let performanceInsightsRetentionPeriod: Int?
    /// <p>The port number on which the database accepts connections.</p>
    ///          <p>
    ///             <b>MySQL</b>
    ///          </p>
    ///          <p>
    ///             Default: <code>3306</code>
    ///          </p>
    ///          <p> Valid values: <code>1150-65535</code>
    ///         </p>
    ///          <p>Type: Integer</p>
    ///          <p>
    ///             <b>MariaDB</b>
    ///          </p>
    ///          <p>
    ///       Default: <code>3306</code>
    ///          </p>
    ///          <p> Valid values: <code>1150-65535</code>
    ///         </p>
    ///          <p>Type: Integer</p>
    ///          <p>
    ///             <b>PostgreSQL</b>
    ///          </p>
    ///          <p>
    ///             Default: <code>5432</code>
    ///          </p>
    ///          <p> Valid values: <code>1150-65535</code>
    ///         </p>
    ///          <p>Type: Integer</p>
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///          <p>
    ///             Default: <code>1521</code>
    ///          </p>
    ///          <p> Valid values: <code>1150-65535</code>
    ///         </p>
    ///          <p>
    ///             <b>SQL Server</b>
    ///          </p>
    ///          <p>
    ///             Default: <code>1433</code>
    ///          </p>
    ///          <p> Valid values: <code>1150-65535</code> except <code>1234</code>, <code>1434</code>,
    ///                 <code>3260</code>, <code>3343</code>, <code>3389</code>, <code>47001</code>, and
    ///                 <code>49152-49156</code>.</p>
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>
    ///       Default: <code>3306</code>
    ///          </p>
    ///          <p> Valid values: <code>1150-65535</code>
    ///         </p>
    ///          <p>Type: Integer</p>
    public let port: Int?
    /// <p>
    ///         The daily time range during which automated backups are created
    ///         if automated backups are enabled,
    ///         using the <code>BackupRetentionPeriod</code> parameter.
    ///           The default is a 30-minute window selected at random from an
    ///           8-hour block of time for each AWS Region. For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow">Backup window</a> in the <i>Amazon RDS User Guide</i>.
    ///       </p>
    ///
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>Not applicable. The daily time range for creating automated backups is managed by
    ///           the DB cluster.</p>
    ///
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be in the format <code>hh24:mi-hh24:mi</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Coordinated Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes.</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: String?
    /// <p>The time range each week during which system maintenance can occur,
    ///           in Universal Coordinated Time (UTC).
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance">Amazon RDS Maintenance Window</a>.
    ///       </p>
    ///          <p>
    ///             Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///          </p>
    ///          <p>The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each AWS Region, occurring on a random day of the
    ///             week.
    ///         </p>
    ///          <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    ///          <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    public let processorFeatures: [ProcessorFeature]?
    /// <p>A value that specifies the order in which an Aurora Replica is promoted to the primary instance
    ///       after a failure of the existing primary instance. For more information,
    ///       see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance">
    ///           Fault Tolerance for an Aurora DB Cluster</a> in the <i>Amazon Aurora User Guide</i>.
    ///     </p>
    ///          <p>Default: 1</p>
    ///          <p>Valid Values: 0 - 15</p>
    public let promotionTier: Int?
    /// <p>A value that indicates whether the DB instance is publicly accessible.</p>
    ///          <p>When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///           and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///           and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.</p>
    ///          <p>When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.</p>
    ///          <p>Default: The default behavior varies depending on whether <code>DBSubnetGroupName</code> is specified.</p>
    ///          <p>If <code>DBSubnetGroupName</code> isn't specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    ///          <ul>
    ///             <li>
    ///               <p>If the default VPC in the target region doesnt have an Internet gateway attached to it, the DB instance is private.</p>
    ///             </li>
    ///             <li>
    ///               <p>If the default VPC in the target region has an Internet gateway attached to it, the DB instance is public.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If <code>DBSubnetGroupName</code> is specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    ///          <ul>
    ///             <li>
    ///               <p>If the subnets are part of a VPC that doesnt have an Internet gateway attached to it, the DB instance is private.</p>
    ///             </li>
    ///             <li>
    ///               <p>If the subnets are part of a VPC that has an Internet gateway attached to it, the DB instance is public.</p>
    ///             </li>
    ///          </ul>
    public let publiclyAccessible: Bool?
    /// <p>A value that indicates whether the DB instance is encrypted. By default, it isn't encrypted.</p>
    ///
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>Not applicable. The encryption for DB instances is managed by
    ///           the DB cluster.</p>
    public let storageEncrypted: Bool?
    /// <p>Specifies the storage type to be associated with the DB instance.</p>
    ///          <p>
    ///             Valid values: <code>standard | gp2 | io1</code>
    ///          </p>
    ///          <p>
    ///             If you specify <code>io1</code>, you must also include a value for the
    ///             <code>Iops</code> parameter.
    ///         </p>
    ///          <p>
    ///             Default: <code>io1</code> if the <code>Iops</code> parameter
    ///             is specified, otherwise <code>gp2</code>
    ///          </p>
    public let storageType: String?
    /// <p>Tags to assign to the DB instance.</p>
    public let tags: [Tag]?
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>The password for the given ARN from the key store in order to access the device.</p>
    public let tdeCredentialPassword: String?
    /// <p>The time zone of the DB instance.
    ///             The time zone parameter is currently supported only by
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone">Microsoft SQL Server</a>.
    ///         </p>
    public let timezone: String?
    /// <p>A list of Amazon EC2 VPC security groups to associate with this DB instance.</p>
    ///
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>Not applicable. The associated list of EC2 VPC security groups is managed by
    ///           the DB cluster.</p>
    ///
    ///          <p>Default: The default EC2 VPC security group for the DB subnet group's VPC.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        allocatedStorage: Int? = nil,
        autoMinorVersionUpgrade: Bool? = nil,
        availabilityZone: String? = nil,
        backupRetentionPeriod: Int? = nil,
        characterSetName: String? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBClusterIdentifier: String? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBName: String? = nil,
        dBParameterGroupName: String? = nil,
        dBSecurityGroups: [String]? = nil,
        dBSubnetGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableCustomerOwnedIp: Bool? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        enablePerformanceInsights: Bool? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        iops: Int? = nil,
        kmsKeyId: String? = nil,
        licenseModel: String? = nil,
        masterUserPassword: String? = nil,
        masterUsername: String? = nil,
        maxAllocatedStorage: Int? = nil,
        monitoringInterval: Int? = nil,
        monitoringRoleArn: String? = nil,
        multiAZ: Bool? = nil,
        ncharCharacterSetName: String? = nil,
        optionGroupName: String? = nil,
        performanceInsightsKMSKeyId: String? = nil,
        performanceInsightsRetentionPeriod: Int? = nil,
        port: Int? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        processorFeatures: [ProcessorFeature]? = nil,
        promotionTier: Int? = nil,
        publiclyAccessible: Bool? = nil,
        storageEncrypted: Bool? = nil,
        storageType: String? = nil,
        tags: [Tag]? = nil,
        tdeCredentialArn: String? = nil,
        tdeCredentialPassword: String? = nil,
        timezone: String? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engine = engine
        self.engineVersion = engineVersion
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.ncharCharacterSetName = ncharCharacterSetName
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.processorFeatures = processorFeatures
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tags = tags
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.timezone = timezone
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExistsFault" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceededFault" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacityFault" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupportedFault" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBInstanceOutputError: Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBInstanceOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension CreateDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct CreateDBInstanceOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB instance.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
    ///       </p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct CreateDBInstanceOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension CreateDBInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct CreateDBInstanceReadReplicaInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBInstanceReadReplicaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBInstanceReadReplicaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBInstanceReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBInstanceReadReplicaInput>
    public typealias MOutput = OperationOutput<CreateDBInstanceReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBInstanceReadReplicaOutputError>
}

extension CreateDBInstanceReadReplicaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBInstanceReadReplicaInput(autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), availabilityZone: \(String(describing: availabilityZone)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(String(describing: enablePerformanceInsights)), iops: \(String(describing: iops)), kmsKeyId: \(String(describing: kmsKeyId)), maxAllocatedStorage: \(String(describing: maxAllocatedStorage)), monitoringInterval: \(String(describing: monitoringInterval)), monitoringRoleArn: \(String(describing: monitoringRoleArn)), multiAZ: \(String(describing: multiAZ)), optionGroupName: \(String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(String(describing: performanceInsightsKMSKeyId)), performanceInsightsRetentionPeriod: \(String(describing: performanceInsightsRetentionPeriod)), port: \(String(describing: port)), preSignedUrl: \(String(describing: preSignedUrl)), processorFeatures: \(String(describing: processorFeatures)), publiclyAccessible: \(String(describing: publiclyAccessible)), replicaMode: \(String(describing: replicaMode)), sourceDBInstanceIdentifier: \(String(describing: sourceDBInstanceIdentifier)), storageType: \(String(describing: storageType)), tags: \(String(describing: tags)), useDefaultProcessorFeatures: \(String(describing: useDefaultProcessorFeatures)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension CreateDBInstanceReadReplicaInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: Key("EnablePerformanceInsights"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: Key("PreSignedUrl"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let replicaMode = replicaMode {
            try container.encode(replicaMode, forKey: Key("ReplicaMode"))
        }
        if let sourceDBInstanceIdentifier = sourceDBInstanceIdentifier {
            try container.encode(sourceDBInstanceIdentifier, forKey: Key("SourceDBInstanceIdentifier"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBInstanceReadReplica", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBInstanceReadReplicaInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBInstanceReadReplicaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBInstanceReadReplicaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBInstanceReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBInstanceReadReplicaInput>
    public typealias MOutput = OperationOutput<CreateDBInstanceReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBInstanceReadReplicaOutputError>
}

public struct CreateDBInstanceReadReplicaInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBInstanceReadReplicaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBInstanceReadReplicaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBInstanceReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBInstanceReadReplicaInput>
    public typealias MOutput = OperationOutput<CreateDBInstanceReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBInstanceReadReplicaOutputError>
}

public struct CreateDBInstanceReadReplicaInput: Equatable {
    /// <p>A value that indicates whether minor engine upgrades are applied automatically to the
    ///             read replica during the maintenance window.</p>
    ///          <p>Default: Inherits from the source DB instance</p>
    public let autoMinorVersionUpgrade: Bool?
    /// <p>The Availability Zone (AZ) where the read replica will be created.</p>
    ///          <p>Default: A random, system-chosen Availability Zone in the endpoint's AWS Region.</p>
    ///          <p>
    ///            Example: <code>us-east-1d</code>
    ///          </p>
    public let availabilityZone: String?
    /// <p>A value that indicates whether to copy all tags from the read replica to snapshots of
    ///             the read replica. By default, tags are not copied.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The compute and memory capacity of the read replica, for example,
    ///                 <code>db.m4.large</code>. Not all DB instance classes are available in all AWS
    ///             Regions, or for all database engines. For the full list of DB instance classes, and
    ///             availability for your engine, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance
    ///                 Class</a> in the <i>Amazon RDS User Guide.</i>
    ///         </p>
    ///          <p>Default: Inherits from the source DB instance.</p>
    public let dBInstanceClass: String?
    /// <p>The DB instance identifier of the read replica. This identifier is the unique key
    ///             that identifies a DB instance. This parameter is stored as a lowercase string.</p>
    public let dBInstanceIdentifier: String?
    /// <p>The name of the DB parameter group to associate with this DB instance.</p>
    ///         <p>If you do not specify a value for <code>DBParameterGroupName</code>, then Amazon RDS
    ///             uses the <code>DBParameterGroup</code> of source DB instance for a same region read
    ///             replica, or the default <code>DBParameterGroup</code> for the specified DB engine for a
    ///             cross region read replica.</p>
    ///         <note>
    ///             <p>Currently, specifying a parameter group for this operation is only supported for Oracle DB instances.</p>
    ///         </note>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>Specifies a DB subnet group for the DB instance. The new DB instance is created in the VPC associated with the DB subnet group. If no DB subnet group is specified, then the new DB instance isn't created in a VPC.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Can only be specified if the source DB instance identifier specifies a DB instance in another AWS Region.</p>
    ///             </li>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBSubnetGroup.</p>
    ///             </li>
    ///             <li>
    ///                <p>The specified DB subnet group must be in the same AWS Region in which the operation is running.</p>
    ///             </li>
    ///             <li>
    ///               <p>All read replicas in one AWS Region that are created from the same source DB
    ///                     instance must either:></p>
    ///               <ul>
    ///                   <li>
    ///                      <p>Specify DB subnet groups from the same VPC. All these read replicas are created in the same
    ///                             VPC.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Not specify a DB subnet group. All these read replicas are created outside of any
    ///                             VPC.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance</a>.
    ///         </p>
    public let deletionProtection: Bool?
    /// <p>The Active Directory directory ID to create the DB instance in. Currently, only MySQL, Microsoft SQL
    ///             Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///             Kerberos Authentication</a> in the <i>Amazon RDS User Guide</i>.</p>
    public let domain: String?
    /// <p>Specify the name of the IAM role to be used when making API calls to the Directory Service.</p>
    public let domainIAMRoleName: String?
    /// <p>The list of logs that the new DB instance is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing
    ///                 Database Logs to Amazon CloudWatch Logs </a> in the <i>Amazon RDS User Guide</i>.</p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>A value that indicates whether to enable mapping of AWS Identity and Access
    ///           Management (IAM) accounts to database accounts. By default, mapping is disabled.</p>
    ///
    ///          <p>For more information about IAM database authentication, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///               IAM Database Authentication for MySQL and PostgreSQL</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>A value that indicates whether to enable Performance Insights for the read replica. </p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html">Using
    ///             Amazon Performance Insights</a> in the <i>Amazon RDS User Guide</i>.
    ///         </p>
    public let enablePerformanceInsights: Bool?
    /// <p>The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance.</p>
    public let iops: Int?
    /// <p>The AWS KMS key identifier for an encrypted read replica.</p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS CMK.</p>
    ///         <p>If you create an encrypted read replica in the same AWS Region as the source DB
    ///             instance, then do not specify a value for this parameter. A read replica in the same Region
    ///             is always encrypted with the same AWS KMS CMK as the source DB instance.</p>
    ///         <p>If you create an encrypted read replica in a different AWS Region, then you must
    ///             specify a AWS KMS key identifier for the destination AWS Region. AWS KMS CMKs are specific to
    ///             the AWS Region that they are created in, and you can't use CMKs from one
    ///             AWS Region in another AWS Region.</p>
    ///         <p>You can't create an encrypted read replica from an unencrypted DB instance.</p>
    public let kmsKeyId: String?
    /// <p>The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.</p>
    ///         <p>For more information about this setting, including limitations that apply to it, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling">
    ///                 Managing capacity automatically with Amazon RDS storage autoscaling</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    public let maxAllocatedStorage: Int?
    /// <p>The interval, in seconds, between points when Enhanced Monitoring metrics are
    ///             collected for the read replica. To disable collecting Enhanced Monitoring metrics,
    ///             specify 0. The default is 0.</p>
    ///          <p>If <code>MonitoringRoleArn</code> is specified, then you must also set <code>MonitoringInterval</code>
    ///       to a value other than 0.</p>
    ///          <p>Valid Values: <code>0, 1, 5, 10, 15, 30, 60</code>
    ///          </p>
    public let monitoringInterval: Int?
    /// <p>The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For
    ///       example, <code>arn:aws:iam:123456789012:role/emaccess</code>. For information on creating a monitoring role,
    ///       go to <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.html#USER_Monitoring.OS.IAMRole">To
    ///           create an IAM role for Amazon RDS Enhanced Monitoring</a> in the <i>Amazon RDS User Guide</i>.</p>
    ///          <p>If <code>MonitoringInterval</code> is set to a value other than 0, then you must supply a <code>MonitoringRoleArn</code> value.</p>
    public let monitoringRoleArn: String?
    /// <p>A value that indicates whether the read replica is in a Multi-AZ deployment. </p>
    ///
    ///         <p>You can create a read replica as a Multi-AZ DB instance. RDS creates a standby of
    ///             your replica in another Availability Zone for failover support for the replica. Creating
    ///             your read replica as a Multi-AZ DB instance is independent of whether the source
    ///             database is a Multi-AZ DB instance. </p>
    public let multiAZ: Bool?
    /// <p>The option group the DB instance is associated with. If omitted, the option group associated with the source instance is used.</p>
    ///         <note>
    ///             <p>For SQL Server, you must use the option group associated with the source
    ///                 instance.</p>
    ///         </note>
    public let optionGroupName: String?
    /// <p>The AWS KMS key identifier for encryption of Performance Insights data.</p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    ///         <p>If you do not specify a value for <code>PerformanceInsightsKMSKeyId</code>, then Amazon RDS
    ///             uses your default CMK. There is a default CMK for your AWS account.
    ///             Your AWS account has a different default CMK for each AWS Region.</p>
    public let performanceInsightsKMSKeyId: String?
    /// <p>The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years). </p>
    public let performanceInsightsRetentionPeriod: Int?
    /// <p>The port number that the DB instance uses for connections.</p>
    ///          <p>Default: Inherits from the source DB instance</p>
    ///          <p>Valid Values: <code>1150-65535</code>
    ///          </p>
    public let port: Int?
    /// <p>The URL that contains a Signature Version 4 signed request for the <code>CreateDBInstanceReadReplica</code> API action
    ///             in the source AWS Region that contains the source DB instance.
    ///         </p>
    ///
    ///         <p>You must specify this parameter when you create an encrypted read replica from
    ///             another AWS Region by using the Amazon RDS API. Don't specify
    ///                 <code>PreSignedUrl</code> when you are creating an encrypted read replica in the
    ///             same AWS Region.</p>
    ///
    ///         <p>The presigned URL must be a valid request for the <code>CreateDBInstanceReadReplica</code> API action
    ///             that can be executed in the source AWS Region that contains the encrypted source DB instance.
    ///             The presigned URL request must contain the following parameter values:
    ///         </p>
    ///
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DestinationRegion</code> - The AWS Region that the encrypted read
    ///                     replica is created in. This AWS Region is the same one where the
    ///                         <code>CreateDBInstanceReadReplica</code> action is called that contains this presigned URL.</p>
    ///
    ///                 <p>For example, if you create an encrypted DB instance in the us-west-1 AWS Region,
    ///                     from a source DB instance in the us-east-2 AWS Region,
    ///                     then you call the <code>CreateDBInstanceReadReplica</code> action in
    ///                     the us-east-1 AWS Region and provide a presigned URL that contains a call to the
    ///                     <code>CreateDBInstanceReadReplica</code> action in the us-west-2 AWS Region. For this
    ///                     example, the <code>DestinationRegion</code> in the presigned URL must be set to
    ///                     the us-east-1 AWS Region.
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>KmsKeyId</code> - The AWS KMS key identifier for the key to use to
    ///                     encrypt the read replica in the destination AWS Region. This is the same
    ///                     identifier for both the <code>CreateDBInstanceReadReplica</code> action that is
    ///                     called in the destination AWS Region, and the action contained in the presigned
    ///                     URL. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SourceDBInstanceIdentifier</code> - The DB instance identifier for
    ///                     the encrypted DB instance to be replicated. This identifier must be in the
    ///                     Amazon Resource Name (ARN) format for the source AWS Region. For example, if you
    ///                     are creating an encrypted read replica from a DB instance in the us-west-2 AWS
    ///                     Region, then your <code>SourceDBInstanceIdentifier</code> looks like the
    ///                     following example:
    ///                         <code>arn:aws:rds:us-west-2:123456789012:instance:mysql-instance1-20161115</code>. </p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>To learn how to generate a Signature Version 4 signed request, see
    ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">Authenticating Requests: Using Query Parameters (AWS Signature Version 4)</a> and
    ///             <a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">Signature Version 4 Signing Process</a>.
    ///         </p>
    ///
    ///         <note>
    ///             <p>If you are using an AWS SDK tool or the AWS CLI, you can specify
    ///                     <code>SourceRegion</code> (or <code>--source-region</code> for the AWS CLI)
    ///                 instead of specifying <code>PreSignedUrl</code> manually. Specifying
    ///                     <code>SourceRegion</code> autogenerates a presigned URL that is a valid request
    ///                 for the operation that can be executed in the source AWS Region.</p>
    ///             <p>
    ///                <code>SourceRegion</code> isn't supported for SQL Server, because SQL Server on Amazon RDS
    ///                 doesn't support cross-region read replicas.</p>
    ///         </note>
    public let preSignedUrl: String?
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    public let processorFeatures: [ProcessorFeature]?
    /// <p>A value that indicates whether the DB instance is publicly accessible.</p>
    ///          <p>When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///               and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///               and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.</p>
    ///          <p>When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.</p>
    ///          <p>For more information, see <a>CreateDBInstance</a>.</p>
    public let publiclyAccessible: Bool?
    /// <p>The open mode of the replica database: mounted or read-only.</p>
    ///         <note>
    ///             <p>This parameter is only supported for Oracle DB instances.</p>
    ///         </note>
    ///         <p>Mounted DB replicas are included in Oracle Enterprise Edition. The main use case for
    ///             mounted replicas is cross-Region disaster recovery. The primary database doesn't use Active
    ///             Data Guard to transmit information to the mounted replica. Because it doesn't accept
    ///             user connections, a mounted replica can't serve a read-only workload.</p>
    ///         <p>You can create a combination of mounted and read-only DB replicas for the same primary DB instance.
    ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html">Working with Oracle Read Replicas for Amazon RDS</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    public let replicaMode: ReplicaMode?
    /// <p>The identifier of the DB instance that will act as the source for the read replica.
    ///             Each DB instance can have up to five read replicas.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be the identifier of an existing MySQL, MariaDB, Oracle, PostgreSQL, or SQL Server DB
    ///                     instance.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can specify a DB instance that is a MySQL read replica only if the source is running MySQL
    ///                     5.6 or later.</p>
    ///             </li>
    ///             <li>
    ///               <p>For the limitations of Oracle read replicas, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html">Read Replica Limitations with Oracle</a> in the
    ///                   <i>Amazon RDS User Guide</i>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the limitations of SQL Server read replicas, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/SQLServer.ReadReplicas.Limitations.html">Read Replica
    ///                         Limitations with Microsoft SQL Server</a> in the <i>Amazon RDS User Guide</i>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can specify a PostgreSQL DB instance only if the source is running PostgreSQL 9.3.5 or
    ///                     later (9.4.7 and higher for cross-region replication).</p>
    ///             </li>
    ///             <li>
    ///                <p>The specified DB instance must have automatic backups enabled, that is, its backup
    ///                     retention period must be greater than 0.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source DB instance is in the same AWS Region as the read replica, specify a valid DB
    ///                     instance identifier.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source DB instance is in a different AWS Region from the read replica, specify a valid DB instance ARN.
    ///              For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">Constructing an ARN for Amazon RDS</a>
    ///              in the <i>Amazon RDS User Guide</i>. This doesn't apply to SQL Server, which doesn't support cross-region replicas.</p>
    ///             </li>
    ///          </ul>
    public let sourceDBInstanceIdentifier: String?
    /// <p>Specifies the storage type to be associated with the read replica.</p>
    ///          <p>
    ///             Valid values: <code>standard | gp2 | io1</code>
    ///          </p>
    ///          <p>
    ///             If you specify <code>io1</code>, you must also include a value for the
    ///             <code>Iops</code> parameter.
    ///         </p>
    ///          <p>
    ///             Default: <code>io1</code> if the <code>Iops</code> parameter
    ///             is specified, otherwise <code>gp2</code>
    ///          </p>
    public let storageType: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?
    /// <p>A value that indicates whether the DB instance class of the DB instance uses its default
    ///             processor features.</p>
    public let useDefaultProcessorFeatures: Bool?
    /// <p> A list of EC2 VPC security groups to associate with the read replica. </p>
    ///         <p>
    ///             Default: The default EC2 VPC security group for the DB subnet group's VPC.
    ///         </p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        autoMinorVersionUpgrade: Bool? = nil,
        availabilityZone: String? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBParameterGroupName: String? = nil,
        dBSubnetGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        enablePerformanceInsights: Bool? = nil,
        iops: Int? = nil,
        kmsKeyId: String? = nil,
        maxAllocatedStorage: Int? = nil,
        monitoringInterval: Int? = nil,
        monitoringRoleArn: String? = nil,
        multiAZ: Bool? = nil,
        optionGroupName: String? = nil,
        performanceInsightsKMSKeyId: String? = nil,
        performanceInsightsRetentionPeriod: Int? = nil,
        port: Int? = nil,
        preSignedUrl: String? = nil,
        processorFeatures: [ProcessorFeature]? = nil,
        publiclyAccessible: Bool? = nil,
        replicaMode: ReplicaMode? = nil,
        sourceDBInstanceIdentifier: String? = nil,
        storageType: String? = nil,
        tags: [Tag]? = nil,
        useDefaultProcessorFeatures: Bool? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.port = port
        self.preSignedUrl = preSignedUrl
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.replicaMode = replicaMode
        self.sourceDBInstanceIdentifier = sourceDBInstanceIdentifier
        self.storageType = storageType
        self.tags = tags
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateDBInstanceReadReplicaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBInstanceReadReplicaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceAlreadyExistsFault" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotAllowedFault" : self = .dBSubnetGroupNotAllowedFault(try DBSubnetGroupNotAllowedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceededFault" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacityFault" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupFault" : self = .invalidDBSubnetGroupFault(try InvalidDBSubnetGroupFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupportedFault" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBInstanceReadReplicaOutputError: Equatable {
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotAllowedFault(DBSubnetGroupNotAllowedFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSubnetGroupFault(InvalidDBSubnetGroupFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBInstanceReadReplicaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBInstanceReadReplicaOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension CreateDBInstanceReadReplicaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBInstanceReadReplicaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct CreateDBInstanceReadReplicaOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB instance.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
    ///       </p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct CreateDBInstanceReadReplicaOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension CreateDBInstanceReadReplicaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBInstanceReadReplicaResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct CreateDBParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBParameterGroupOutputError>
}

extension CreateDBParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBParameterGroupInput(dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), description: \(String(describing: description)), tags: \(String(describing: tags)))"}
}

extension CreateDBParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBParameterGroupOutputError>
}

public struct CreateDBParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBParameterGroupOutputError>
}

/// <p></p>
public struct CreateDBParameterGroupInput: Equatable {
    /// <p>The DB parameter group family name. A DB parameter group can be associated with one and only one DB parameter group family, and can be applied only to a DB instance running a database engine and engine version compatible with that DB parameter group family.</p>
    ///          <p>To list all of the available parameter group families for a DB engine, use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine <engine></code>
    ///          </p>
    ///          <p>For example, to list all of the available parameter group families for the MySQL DB engine, use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine mysql</code>
    ///          </p>
    ///          <note>
    ///             <p>The output contains duplicates.</p>
    ///          </note>
    ///          <p>The following are the valid DB engine values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>aurora</code> (for MySQL 5.6-compatible Aurora)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>aurora-postgresql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mariadb</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mysql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se2</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se1</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>postgres</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ex</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-web</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupFamily: String?
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBParameterGroupName: String?
    /// <p>The description for the DB parameter group.</p>
    public let description: String?
    /// <p>Tags to assign to the DB parameter group.</p>
    public let tags: [Tag]?

    public init (
        dBParameterGroupFamily: String? = nil,
        dBParameterGroupName: String? = nil,
        description: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.dBParameterGroupName = dBParameterGroupName
        self.description = description
        self.tags = tags
    }
}

extension CreateDBParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBParameterGroupOutputError: Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBParameterGroupOutputResponse(dBParameterGroup: \(String(describing: dBParameterGroup)))"}
}

extension CreateDBParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBParameterGroup = output.dBParameterGroup
        } else {
            self.dBParameterGroup = nil
        }
    }
}

public struct CreateDBParameterGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB parameter group.
    ///         </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBParameterGroups</code> action.
    ///         </p>
    public let dBParameterGroup: DBParameterGroup?

    public init (
        dBParameterGroup: DBParameterGroup? = nil
    )
    {
        self.dBParameterGroup = dBParameterGroup
    }
}

struct CreateDBParameterGroupOutputResponseBody: Equatable {
    public let dBParameterGroup: DBParameterGroup?
}

extension CreateDBParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroup = "DBParameterGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBParameterGroupResult"))
        let dBParameterGroupDecoded = try containerValues.decodeIfPresent(DBParameterGroup.self, forKey: .dBParameterGroup)
        dBParameterGroup = dBParameterGroupDecoded
    }
}

public struct CreateDBProxyEndpointInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBProxyEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBProxyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBProxyEndpointInput>
    public typealias MOutput = OperationOutput<CreateDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBProxyEndpointOutputError>
}

extension CreateDBProxyEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBProxyEndpointInput(dBProxyEndpointName: \(String(describing: dBProxyEndpointName)), dBProxyName: \(String(describing: dBProxyName)), tags: \(String(describing: tags)), targetRole: \(String(describing: targetRole)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)), vpcSubnetIds: \(String(describing: vpcSubnetIds)))"}
}

extension CreateDBProxyEndpointInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: Key("DBProxyEndpointName"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetRole = targetRole {
            try container.encode(targetRole, forKey: Key("TargetRole"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBProxyEndpoint", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBProxyEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBProxyEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBProxyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBProxyEndpointInput>
    public typealias MOutput = OperationOutput<CreateDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBProxyEndpointOutputError>
}

public struct CreateDBProxyEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBProxyEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBProxyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBProxyEndpointInput>
    public typealias MOutput = OperationOutput<CreateDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBProxyEndpointOutputError>
}

public struct CreateDBProxyEndpointInput: Equatable {
    /// <p>The name of the DB proxy endpoint to create.</p>
    public let dBProxyEndpointName: String?
    /// <p>The name of the DB proxy associated with the DB proxy endpoint that you create.</p>
    public let dBProxyName: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?
    /// <p>A value that indicates whether the DB proxy endpoint can be used for read/write
    ///         or read-only operations. The default is <code>READ_WRITE</code>.</p>
    public let targetRole: DBProxyEndpointTargetRole?
    /// <p>The VPC security group IDs for the DB proxy endpoint that you create. You can
    ///         specify a different set of security group IDs than for the original DB proxy.
    ///         The default is the default security group for the VPC.</p>
    public let vpcSecurityGroupIds: [String]?
    /// <p>The VPC subnet IDs for the DB proxy endpoint that you create. You can specify a
    ///         different set of subnet IDs than for the original DB proxy.</p>
    public let vpcSubnetIds: [String]?

    public init (
        dBProxyEndpointName: String? = nil,
        dBProxyName: String? = nil,
        tags: [Tag]? = nil,
        targetRole: DBProxyEndpointTargetRole? = nil,
        vpcSecurityGroupIds: [String]? = nil,
        vpcSubnetIds: [String]? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
        self.dBProxyName = dBProxyName
        self.tags = tags
        self.targetRole = targetRole
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

extension CreateDBProxyEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBProxyEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointAlreadyExistsFault" : self = .dBProxyEndpointAlreadyExistsFault(try DBProxyEndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyEndpointQuotaExceededFault" : self = .dBProxyEndpointQuotaExceededFault(try DBProxyEndpointQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBProxyEndpointOutputError: Equatable {
    case dBProxyEndpointAlreadyExistsFault(DBProxyEndpointAlreadyExistsFault)
    case dBProxyEndpointQuotaExceededFault(DBProxyEndpointQuotaExceededFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case invalidSubnet(InvalidSubnet)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBProxyEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBProxyEndpointOutputResponse(dBProxyEndpoint: \(String(describing: dBProxyEndpoint)))"}
}

extension CreateDBProxyEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBProxyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBProxyEndpoint = output.dBProxyEndpoint
        } else {
            self.dBProxyEndpoint = nil
        }
    }
}

public struct CreateDBProxyEndpointOutputResponse: Equatable {
    /// <p>The <code>DBProxyEndpoint</code> object that is created by the API operation.
    ///         The DB proxy endpoint that you create might provide capabilities such as read/write
    ///         or read-only operations, or using a different VPC than the proxy's default VPC.</p>
    public let dBProxyEndpoint: DBProxyEndpoint?

    public init (
        dBProxyEndpoint: DBProxyEndpoint? = nil
    )
    {
        self.dBProxyEndpoint = dBProxyEndpoint
    }
}

struct CreateDBProxyEndpointOutputResponseBody: Equatable {
    public let dBProxyEndpoint: DBProxyEndpoint?
}

extension CreateDBProxyEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBProxyEndpoint = "DBProxyEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBProxyEndpointResult"))
        let dBProxyEndpointDecoded = try containerValues.decodeIfPresent(DBProxyEndpoint.self, forKey: .dBProxyEndpoint)
        dBProxyEndpoint = dBProxyEndpointDecoded
    }
}

public struct CreateDBProxyInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBProxyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBProxyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBProxyInput>
    public typealias MOutput = OperationOutput<CreateDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBProxyOutputError>
}

extension CreateDBProxyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBProxyInput(auth: \(String(describing: auth)), dBProxyName: \(String(describing: dBProxyName)), debugLogging: \(String(describing: debugLogging)), engineFamily: \(String(describing: engineFamily)), idleClientTimeout: \(String(describing: idleClientTimeout)), requireTLS: \(String(describing: requireTLS)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)), vpcSubnetIds: \(String(describing: vpcSubnetIds)))"}
}

extension CreateDBProxyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let auth = auth {
            var authContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Auth"))
            for (index0, userauthconfig0) in auth.enumerated() {
                try authContainer.encode(userauthconfig0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if debugLogging != false {
            try container.encode(debugLogging, forKey: Key("DebugLogging"))
        }
        if let engineFamily = engineFamily {
            try container.encode(engineFamily, forKey: Key("EngineFamily"))
        }
        if let idleClientTimeout = idleClientTimeout {
            try container.encode(idleClientTimeout, forKey: Key("IdleClientTimeout"))
        }
        if requireTLS != false {
            try container.encode(requireTLS, forKey: Key("RequireTLS"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBProxy", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBProxyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBProxyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBProxyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBProxyInput>
    public typealias MOutput = OperationOutput<CreateDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBProxyOutputError>
}

public struct CreateDBProxyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBProxyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBProxyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBProxyInput>
    public typealias MOutput = OperationOutput<CreateDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBProxyOutputError>
}

public struct CreateDBProxyInput: Equatable {
    /// <p>The authorization mechanism that the proxy uses.</p>
    public let auth: [UserAuthConfig]?
    /// <p>The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.</p>
    public let dBProxyName: String?
    /// <p>Whether the proxy includes detailed information about SQL statements in its logs.
    ///         This information helps you to debug issues involving SQL behavior or the performance
    ///         and scalability of the proxy connections. The debug information includes the text of
    ///         SQL statements that you submit through the proxy. Thus, only enable this setting
    ///         when needed for debugging, and only when you have security measures in place to
    ///         safeguard any sensitive information that appears in the logs.</p>
    public let debugLogging: Bool
    /// <p>The kinds of databases that the proxy can connect to.
    ///           This value determines which database network protocol the proxy recognizes when it interprets
    ///         network traffic to and from the database.
    ///         The engine family applies to MySQL and PostgreSQL for both RDS and Aurora.</p>
    public let engineFamily: EngineFamily?
    /// <p>The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this
    ///         value higher or lower than the connection timeout limit for the associated database.</p>
    public let idleClientTimeout: Int?
    /// <p>A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy.
    ///         By enabling this setting, you can enforce encrypted TLS connections to the proxy.</p>
    public let requireTLS: Bool
    /// <p>The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in AWS Secrets Manager.</p>
    public let roleArn: String?
    /// <p>An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.</p>
    public let tags: [Tag]?
    /// <p>One or more VPC security group IDs to associate with the new proxy.</p>
    public let vpcSecurityGroupIds: [String]?
    /// <p>One or more VPC subnet IDs to associate with the new proxy.</p>
    public let vpcSubnetIds: [String]?

    public init (
        auth: [UserAuthConfig]? = nil,
        dBProxyName: String? = nil,
        debugLogging: Bool = false,
        engineFamily: EngineFamily? = nil,
        idleClientTimeout: Int? = nil,
        requireTLS: Bool = false,
        roleArn: String? = nil,
        tags: [Tag]? = nil,
        vpcSecurityGroupIds: [String]? = nil,
        vpcSubnetIds: [String]? = nil
    )
    {
        self.auth = auth
        self.dBProxyName = dBProxyName
        self.debugLogging = debugLogging
        self.engineFamily = engineFamily
        self.idleClientTimeout = idleClientTimeout
        self.requireTLS = requireTLS
        self.roleArn = roleArn
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

extension CreateDBProxyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBProxyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyAlreadyExistsFault" : self = .dBProxyAlreadyExistsFault(try DBProxyAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyQuotaExceededFault" : self = .dBProxyQuotaExceededFault(try DBProxyQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBProxyOutputError: Equatable {
    case dBProxyAlreadyExistsFault(DBProxyAlreadyExistsFault)
    case dBProxyQuotaExceededFault(DBProxyQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBProxyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBProxyOutputResponse(dBProxy: \(String(describing: dBProxy)))"}
}

extension CreateDBProxyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBProxyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBProxy = output.dBProxy
        } else {
            self.dBProxy = nil
        }
    }
}

public struct CreateDBProxyOutputResponse: Equatable {
    /// <p>The <code>DBProxy</code> structure corresponding to the new proxy.</p>
    public let dBProxy: DBProxy?

    public init (
        dBProxy: DBProxy? = nil
    )
    {
        self.dBProxy = dBProxy
    }
}

struct CreateDBProxyOutputResponseBody: Equatable {
    public let dBProxy: DBProxy?
}

extension CreateDBProxyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBProxy = "DBProxy"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBProxyResult"))
        let dBProxyDecoded = try containerValues.decodeIfPresent(DBProxy.self, forKey: .dBProxy)
        dBProxy = dBProxyDecoded
    }
}

public struct CreateDBSecurityGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBSecurityGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSecurityGroupInput>
    public typealias MOutput = OperationOutput<CreateDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSecurityGroupOutputError>
}

extension CreateDBSecurityGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBSecurityGroupInput(dBSecurityGroupDescription: \(String(describing: dBSecurityGroupDescription)), dBSecurityGroupName: \(String(describing: dBSecurityGroupName)), tags: \(String(describing: tags)))"}
}

extension CreateDBSecurityGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSecurityGroupDescription = dBSecurityGroupDescription {
            try container.encode(dBSecurityGroupDescription, forKey: Key("DBSecurityGroupDescription"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: Key("DBSecurityGroupName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBSecurityGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBSecurityGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBSecurityGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSecurityGroupInput>
    public typealias MOutput = OperationOutput<CreateDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSecurityGroupOutputError>
}

public struct CreateDBSecurityGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBSecurityGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSecurityGroupInput>
    public typealias MOutput = OperationOutput<CreateDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSecurityGroupOutputError>
}

/// <p></p>
public struct CreateDBSecurityGroupInput: Equatable {
    /// <p>The description for the DB security group.</p>
    public let dBSecurityGroupDescription: String?
    /// <p>The name for the DB security group. This value is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not be "Default"</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>mysecuritygroup</code>
    ///          </p>
    public let dBSecurityGroupName: String?
    /// <p>Tags to assign to the DB security group.</p>
    public let tags: [Tag]?

    public init (
        dBSecurityGroupDescription: String? = nil,
        dBSecurityGroupName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBSecurityGroupDescription = dBSecurityGroupDescription
        self.dBSecurityGroupName = dBSecurityGroupName
        self.tags = tags
    }
}

extension CreateDBSecurityGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBSecurityGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSecurityGroupAlreadyExistsFault" : self = .dBSecurityGroupAlreadyExistsFault(try DBSecurityGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotSupportedFault" : self = .dBSecurityGroupNotSupportedFault(try DBSecurityGroupNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupQuotaExceededFault" : self = .dBSecurityGroupQuotaExceededFault(try DBSecurityGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBSecurityGroupOutputError: Equatable {
    case dBSecurityGroupAlreadyExistsFault(DBSecurityGroupAlreadyExistsFault)
    case dBSecurityGroupNotSupportedFault(DBSecurityGroupNotSupportedFault)
    case dBSecurityGroupQuotaExceededFault(DBSecurityGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBSecurityGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBSecurityGroupOutputResponse(dBSecurityGroup: \(String(describing: dBSecurityGroup)))"}
}

extension CreateDBSecurityGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBSecurityGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSecurityGroup = output.dBSecurityGroup
        } else {
            self.dBSecurityGroup = nil
        }
    }
}

public struct CreateDBSecurityGroupOutputResponse: Equatable {
    /// <p>Contains the details for an Amazon RDS DB security group.
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBSecurityGroups</code> action.
    ///       </p>
    public let dBSecurityGroup: DBSecurityGroup?

    public init (
        dBSecurityGroup: DBSecurityGroup? = nil
    )
    {
        self.dBSecurityGroup = dBSecurityGroup
    }
}

struct CreateDBSecurityGroupOutputResponseBody: Equatable {
    public let dBSecurityGroup: DBSecurityGroup?
}

extension CreateDBSecurityGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSecurityGroup = "DBSecurityGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBSecurityGroupResult"))
        let dBSecurityGroupDecoded = try containerValues.decodeIfPresent(DBSecurityGroup.self, forKey: .dBSecurityGroup)
        dBSecurityGroup = dBSecurityGroupDecoded
    }
}

public struct CreateDBSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSnapshotInput>
    public typealias MOutput = OperationOutput<CreateDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSnapshotOutputError>
}

extension CreateDBSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBSnapshotInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBSnapshotIdentifier: \(String(describing: dBSnapshotIdentifier)), tags: \(String(describing: tags)))"}
}

extension CreateDBSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: Key("DBSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSnapshotInput>
    public typealias MOutput = OperationOutput<CreateDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSnapshotOutputError>
}

public struct CreateDBSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSnapshotInput>
    public typealias MOutput = OperationOutput<CreateDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSnapshotOutputError>
}

/// <p></p>
public struct CreateDBSnapshotInput: Equatable {
    /// <p>The identifier of the DB instance that you want to create the snapshot of.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p>The identifier for the DB snapshot.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Can't be null, empty, or blank</p>
    ///             </li>
    ///             <li>
    ///                <p>Must contain from 1 to 255 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-snapshot-id</code>
    ///          </p>
    public let dBSnapshotIdentifier: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?

    public init (
        dBInstanceIdentifier: String? = nil,
        dBSnapshotIdentifier: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.tags = tags
    }
}

extension CreateDBSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExistsFault" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBSnapshotOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBSnapshotOutputResponse(dBSnapshot: \(String(describing: dBSnapshot)))"}
}

extension CreateDBSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct CreateDBSnapshotOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB snapshot.
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBSnapshots</code> action.
    ///       </p>
    public let dBSnapshot: DBSnapshot?

    public init (
        dBSnapshot: DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct CreateDBSnapshotOutputResponseBody: Equatable {
    public let dBSnapshot: DBSnapshot?
}

extension CreateDBSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

public struct CreateDBSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSubnetGroupOutputError>
}

extension CreateDBSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBSubnetGroupInput(dBSubnetGroupDescription: \(String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)))"}
}

extension CreateDBSubnetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBSubnetGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSubnetGroupOutputError>
}

public struct CreateDBSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSubnetGroupOutputError>
}

/// <p></p>
public struct CreateDBSubnetGroupInput: Equatable {
    /// <p>The description for the DB subnet group.</p>
    public let dBSubnetGroupDescription: String?
    /// <p>The name for the DB subnet group. This value is stored as a lowercase string.</p>
    ///          <p>Constraints: Must contain no more than 255 letters, numbers, periods, underscores, spaces, or hyphens. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>The EC2 Subnet IDs for the DB subnet group.</p>
    public let subnetIds: [String]?
    /// <p>Tags to assign to the DB subnet group.</p>
    public let tags: [Tag]?

    public init (
        dBSubnetGroupDescription: String? = nil,
        dBSubnetGroupName: String? = nil,
        subnetIds: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

extension CreateDBSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupAlreadyExistsFault" : self = .dBSubnetGroupAlreadyExistsFault(try DBSubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupQuotaExceededFault" : self = .dBSubnetGroupQuotaExceededFault(try DBSubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetQuotaExceededFault" : self = .dBSubnetQuotaExceededFault(try DBSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBSubnetGroupOutputError: Equatable {
    case dBSubnetGroupAlreadyExistsFault(DBSubnetGroupAlreadyExistsFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupQuotaExceededFault(DBSubnetGroupQuotaExceededFault)
    case dBSubnetQuotaExceededFault(DBSubnetQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBSubnetGroupOutputResponse(dBSubnetGroup: \(String(describing: dBSubnetGroup)))"}
}

extension CreateDBSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSubnetGroup = output.dBSubnetGroup
        } else {
            self.dBSubnetGroup = nil
        }
    }
}

public struct CreateDBSubnetGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB subnet group.
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBSubnetGroups</code> action.
    ///       </p>
    public let dBSubnetGroup: DBSubnetGroup?

    public init (
        dBSubnetGroup: DBSubnetGroup? = nil
    )
    {
        self.dBSubnetGroup = dBSubnetGroup
    }
}

struct CreateDBSubnetGroupOutputResponseBody: Equatable {
    public let dBSubnetGroup: DBSubnetGroup?
}

extension CreateDBSubnetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSubnetGroup = "DBSubnetGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBSubnetGroupResult"))
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
    }
}

public struct CreateEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

extension CreateEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventSubscriptionInput(enabled: \(String(describing: enabled)), eventCategories: \(String(describing: eventCategories)), snsTopicArn: \(String(describing: snsTopicArn)), sourceIds: \(String(describing: sourceIds)), sourceType: \(String(describing: sourceType)), subscriptionName: \(String(describing: subscriptionName)), tags: \(String(describing: tags)))"}
}

extension CreateEventSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: Key("SnsTopicArn"))
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SourceIds"))
            for (index0, string0) in sourceIds.enumerated() {
                try sourceIdsContainer.encode(string0, forKey: Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateEventSubscription", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

public struct CreateEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

/// <p></p>
public struct CreateEventSubscriptionInput: Equatable {
    /// <p>
    ///           A value that indicates whether to activate the subscription. If the event notification subscription isn't activated, the subscription is created but not active.
    ///       </p>
    public let enabled: Bool?
    /// <p> A list of event categories for a particular source type (<code>SourceType</code>)
    ///             that you want to subscribe to. You can see a list of the categories for a given source
    ///             type in <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.html">Events</a> in the
    ///                 <i>Amazon RDS User Guide</i> or by using the <code>DescribeEventCategories</code> operation. </p>
    public let eventCategories: [String]?
    /// <p>The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.</p>
    public let snsTopicArn: String?
    /// <p>The list of identifiers of the event sources for which events are returned. If not specified, then all sources are included in the response.
    ///           An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens. It can't end with a hyphen or contain two consecutive hyphens.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If <code>SourceIds</code> are supplied, <code>SourceType</code> must also be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB instance, a <code>DBInstanceIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB cluster, a <code>DBClusterIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB parameter group, a <code>DBParameterGroupName</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB security group, a <code>DBSecurityGroupName</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB snapshot, a <code>DBSnapshotIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB cluster snapshot, a <code>DBClusterSnapshotIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///          </ul>
    public let sourceIds: [String]?
    /// <p>The type of source that is generating the events. For example, if you want to be
    ///             notified of events generated by a DB instance, you set this parameter to
    ///                 <code>db-instance</code>. If this value isn't specified, all events are
    ///             returned.</p>
    ///          <p>Valid values: <code>db-instance</code> | <code>db-cluster</code> | <code>db-parameter-group</code> | <code>db-security-group</code> | <code>db-snapshot</code> | <code>db-cluster-snapshot</code>
    ///          </p>
    public let sourceType: String?
    /// <p>The name of the subscription.</p>
    ///          <p>Constraints: The name must be less than 255 characters.</p>
    public let subscriptionName: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?

    public init (
        enabled: Bool? = nil,
        eventCategories: [String]? = nil,
        snsTopicArn: String? = nil,
        sourceIds: [String]? = nil,
        sourceType: String? = nil,
        subscriptionName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

extension CreateEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceededFault" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFoundFault" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionAlreadyExistFault" : self = .subscriptionAlreadyExistFault(try SubscriptionAlreadyExistFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFoundFault" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSubscriptionOutputError: Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionAlreadyExistFault(SubscriptionAlreadyExistFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension CreateEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct CreateEventSubscriptionOutputResponse: Equatable {
    /// <p>Contains the results of a successful invocation of the <code>DescribeEventSubscriptions</code> action.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct CreateEventSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension CreateEventSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct CreateGlobalClusterInputBodyMiddleware: Middleware {
    public let id: String = "CreateGlobalClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGlobalClusterInput>
    public typealias MOutput = OperationOutput<CreateGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGlobalClusterOutputError>
}

extension CreateGlobalClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGlobalClusterInput(databaseName: \(String(describing: databaseName)), deletionProtection: \(String(describing: deletionProtection)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), globalClusterIdentifier: \(String(describing: globalClusterIdentifier)), sourceDBClusterIdentifier: \(String(describing: sourceDBClusterIdentifier)), storageEncrypted: \(String(describing: storageEncrypted)))"}
}

extension CreateGlobalClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: Key("GlobalClusterIdentifier"))
        }
        if let sourceDBClusterIdentifier = sourceDBClusterIdentifier {
            try container.encode(sourceDBClusterIdentifier, forKey: Key("SourceDBClusterIdentifier"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        try container.encode("CreateGlobalCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateGlobalClusterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGlobalClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGlobalClusterInput>
    public typealias MOutput = OperationOutput<CreateGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGlobalClusterOutputError>
}

public struct CreateGlobalClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGlobalClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGlobalClusterInput>
    public typealias MOutput = OperationOutput<CreateGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGlobalClusterOutputError>
}

public struct CreateGlobalClusterInput: Equatable {
    /// <p>
    ///         The name for your database of up to 64 alpha-numeric characters. If you do not provide a name, Amazon
    ///         Aurora will not create a database in the global database cluster you are creating.
    ///       </p>
    public let databaseName: String?
    /// <p>
    ///         The deletion protection setting for the new global database.
    ///         The global database can't be deleted when deletion protection is enabled.
    ///       </p>
    public let deletionProtection: Bool?
    /// <p>The name of the database engine to be used for this DB cluster.</p>
    public let engine: String?
    /// <p>The engine version of the Aurora global database.</p>
    public let engineVersion: String?
    /// <p>The cluster identifier of the new global database cluster.</p>
    public let globalClusterIdentifier: String?
    /// <p>
    ///         The Amazon Resource Name (ARN) to use as the primary cluster of the global database.
    ///         This parameter is optional.
    ///       </p>
    public let sourceDBClusterIdentifier: String?
    /// <p>
    ///         The storage encryption setting for the new global database cluster.
    ///       </p>
    public let storageEncrypted: Bool?

    public init (
        databaseName: String? = nil,
        deletionProtection: Bool? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        globalClusterIdentifier: String? = nil,
        sourceDBClusterIdentifier: String? = nil,
        storageEncrypted: Bool? = nil
    )
    {
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.engine = engine
        self.engineVersion = engineVersion
        self.globalClusterIdentifier = globalClusterIdentifier
        self.sourceDBClusterIdentifier = sourceDBClusterIdentifier
        self.storageEncrypted = storageEncrypted
    }
}

extension CreateGlobalClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateGlobalClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterAlreadyExistsFault" : self = .globalClusterAlreadyExistsFault(try GlobalClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterQuotaExceededFault" : self = .globalClusterQuotaExceededFault(try GlobalClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGlobalClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case globalClusterAlreadyExistsFault(GlobalClusterAlreadyExistsFault)
    case globalClusterQuotaExceededFault(GlobalClusterQuotaExceededFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGlobalClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGlobalClusterOutputResponse(globalCluster: \(String(describing: globalCluster)))"}
}

extension CreateGlobalClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct CreateGlobalClusterOutputResponse: Equatable {
    /// <p>A data type representing an Aurora global database.</p>
    public let globalCluster: GlobalCluster?

    public init (
        globalCluster: GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct CreateGlobalClusterOutputResponseBody: Equatable {
    public let globalCluster: GlobalCluster?
}

extension CreateGlobalClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

public struct CreateOptionGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateOptionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOptionGroupInput>
    public typealias MOutput = OperationOutput<CreateOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOptionGroupOutputError>
}

extension CreateOptionGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOptionGroupInput(engineName: \(String(describing: engineName)), majorEngineVersion: \(String(describing: majorEngineVersion)), optionGroupDescription: \(String(describing: optionGroupDescription)), optionGroupName: \(String(describing: optionGroupName)), tags: \(String(describing: tags)))"}
}

extension CreateOptionGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let engineName = engineName {
            try container.encode(engineName, forKey: Key("EngineName"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: Key("MajorEngineVersion"))
        }
        if let optionGroupDescription = optionGroupDescription {
            try container.encode(optionGroupDescription, forKey: Key("OptionGroupDescription"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateOptionGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateOptionGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateOptionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOptionGroupInput>
    public typealias MOutput = OperationOutput<CreateOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOptionGroupOutputError>
}

public struct CreateOptionGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateOptionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOptionGroupInput>
    public typealias MOutput = OperationOutput<CreateOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOptionGroupOutputError>
}

/// <p></p>
public struct CreateOptionGroupInput: Equatable {
    /// <p>Specifies the name of the engine that this option group should be associated with.</p>
    ///          <p>Valid Values:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>mariadb</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mysql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se2</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se1</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>postgres</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ex</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-web</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let engineName: String?
    /// <p>Specifies the major version of the engine that this option group should be associated with.</p>
    public let majorEngineVersion: String?
    /// <p>The description of the option group.</p>
    public let optionGroupDescription: String?
    /// <p>Specifies the name of the option group to be created.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>myoptiongroup</code>
    ///          </p>
    public let optionGroupName: String?
    /// <p>Tags to assign to the option group.</p>
    public let tags: [Tag]?

    public init (
        engineName: String? = nil,
        majorEngineVersion: String? = nil,
        optionGroupDescription: String? = nil,
        optionGroupName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.engineName = engineName
        self.majorEngineVersion = majorEngineVersion
        self.optionGroupDescription = optionGroupDescription
        self.optionGroupName = optionGroupName
        self.tags = tags
    }
}

extension CreateOptionGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateOptionGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OptionGroupAlreadyExistsFault" : self = .optionGroupAlreadyExistsFault(try OptionGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupQuotaExceededFault" : self = .optionGroupQuotaExceededFault(try OptionGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOptionGroupOutputError: Equatable {
    case optionGroupAlreadyExistsFault(OptionGroupAlreadyExistsFault)
    case optionGroupQuotaExceededFault(OptionGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOptionGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOptionGroupOutputResponse(optionGroup: \(String(describing: optionGroup)))"}
}

extension CreateOptionGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateOptionGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.optionGroup = output.optionGroup
        } else {
            self.optionGroup = nil
        }
    }
}

public struct CreateOptionGroupOutputResponse: Equatable {
    /// <p></p>
    public let optionGroup: OptionGroup?

    public init (
        optionGroup: OptionGroup? = nil
    )
    {
        self.optionGroup = optionGroup
    }
}

struct CreateOptionGroupOutputResponseBody: Equatable {
    public let optionGroup: OptionGroup?
}

extension CreateOptionGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case optionGroup = "OptionGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateOptionGroupResult"))
        let optionGroupDecoded = try containerValues.decodeIfPresent(OptionGroup.self, forKey: .optionGroup)
        optionGroup = optionGroupDecoded
    }
}

extension CustomAvailabilityZone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case customAvailabilityZoneName = "CustomAvailabilityZoneName"
        case customAvailabilityZoneStatus = "CustomAvailabilityZoneStatus"
        case vpnDetails = "VpnDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: Key("CustomAvailabilityZoneId"))
        }
        if let customAvailabilityZoneName = customAvailabilityZoneName {
            try container.encode(customAvailabilityZoneName, forKey: Key("CustomAvailabilityZoneName"))
        }
        if let customAvailabilityZoneStatus = customAvailabilityZoneStatus {
            try container.encode(customAvailabilityZoneStatus, forKey: Key("CustomAvailabilityZoneStatus"))
        }
        if let vpnDetails = vpnDetails {
            try container.encode(vpnDetails, forKey: Key("VpnDetails"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let customAvailabilityZoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customAvailabilityZoneName)
        customAvailabilityZoneName = customAvailabilityZoneNameDecoded
        let customAvailabilityZoneStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customAvailabilityZoneStatus)
        customAvailabilityZoneStatus = customAvailabilityZoneStatusDecoded
        let vpnDetailsDecoded = try containerValues.decodeIfPresent(VpnDetails.self, forKey: .vpnDetails)
        vpnDetails = vpnDetailsDecoded
    }
}

extension CustomAvailabilityZone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomAvailabilityZone(customAvailabilityZoneId: \(String(describing: customAvailabilityZoneId)), customAvailabilityZoneName: \(String(describing: customAvailabilityZoneName)), customAvailabilityZoneStatus: \(String(describing: customAvailabilityZoneStatus)), vpnDetails: \(String(describing: vpnDetails)))"}
}

/// <p>A custom Availability Zone (AZ) is an on-premises AZ that is integrated with a VMware vSphere cluster.</p>
///         <p>For more information about RDS on VMware, see the
///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html">
///                 RDS on VMware User Guide.</a>
///          </p>
public struct CustomAvailabilityZone: Equatable {
    /// <p>The identifier of the custom AZ.</p>
    ///         <p>Amazon RDS generates a unique identifier when a custom AZ is created.</p>
    public let customAvailabilityZoneId: String?
    /// <p>The name of the custom AZ.</p>
    public let customAvailabilityZoneName: String?
    /// <p>The status of the custom AZ.</p>
    public let customAvailabilityZoneStatus: String?
    /// <p>Information about the virtual private network (VPN) between the VMware vSphere cluster
    ///             and the AWS website.</p>
    public let vpnDetails: VpnDetails?

    public init (
        customAvailabilityZoneId: String? = nil,
        customAvailabilityZoneName: String? = nil,
        customAvailabilityZoneStatus: String? = nil,
        vpnDetails: VpnDetails? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.customAvailabilityZoneName = customAvailabilityZoneName
        self.customAvailabilityZoneStatus = customAvailabilityZoneStatus
        self.vpnDetails = vpnDetails
    }
}

extension CustomAvailabilityZoneAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomAvailabilityZoneAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension CustomAvailabilityZoneAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CustomAvailabilityZoneAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>CustomAvailabilityZoneName</code> is already used by an existing custom
///             Availability Zone.</p>
public struct CustomAvailabilityZoneAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomAvailabilityZoneAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension CustomAvailabilityZoneAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomAvailabilityZoneNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomAvailabilityZoneNotFoundFault(message: \(String(describing: message)))"}
}

extension CustomAvailabilityZoneNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CustomAvailabilityZoneNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>CustomAvailabilityZoneId</code> doesn't refer to an existing custom
///             Availability Zone identifier.</p>
public struct CustomAvailabilityZoneNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomAvailabilityZoneNotFoundFaultBody: Equatable {
    public let message: String?
}

extension CustomAvailabilityZoneNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomAvailabilityZoneQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomAvailabilityZoneQuotaExceededFault(message: \(String(describing: message)))"}
}

extension CustomAvailabilityZoneQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CustomAvailabilityZoneQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of custom Availability Zones.</p>
public struct CustomAvailabilityZoneQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomAvailabilityZoneQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension CustomAvailabilityZoneQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBCluster: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activityStreamKinesisStreamName = "ActivityStreamKinesisStreamName"
        case activityStreamKmsKeyId = "ActivityStreamKmsKeyId"
        case activityStreamMode = "ActivityStreamMode"
        case activityStreamStatus = "ActivityStreamStatus"
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case availabilityZones = "AvailabilityZones"
        case backtrackConsumedChangeRecords = "BacktrackConsumedChangeRecords"
        case backtrackWindow = "BacktrackWindow"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case capacity = "Capacity"
        case characterSetName = "CharacterSetName"
        case cloneGroupId = "CloneGroupId"
        case clusterCreateTime = "ClusterCreateTime"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case crossAccountClone = "CrossAccountClone"
        case customEndpoints = "CustomEndpoints"
        case dBClusterArn = "DBClusterArn"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterMembers = "DBClusterMembers"
        case dBClusterOptionGroupMemberships = "DBClusterOptionGroupMemberships"
        case dBClusterParameterGroup = "DBClusterParameterGroup"
        case dBSubnetGroup = "DBSubnetGroup"
        case databaseName = "DatabaseName"
        case dbClusterResourceId = "DbClusterResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case earliestBacktrackTime = "EarliestBacktrackTime"
        case earliestRestorableTime = "EarliestRestorableTime"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case globalWriteForwardingRequested = "GlobalWriteForwardingRequested"
        case globalWriteForwardingStatus = "GlobalWriteForwardingStatus"
        case hostedZoneId = "HostedZoneId"
        case httpEndpointEnabled = "HttpEndpointEnabled"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case masterUsername = "MasterUsername"
        case multiAZ = "MultiAZ"
        case pendingModifiedValues = "PendingModifiedValues"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case readReplicaIdentifiers = "ReadReplicaIdentifiers"
        case readerEndpoint = "ReaderEndpoint"
        case replicationSourceIdentifier = "ReplicationSourceIdentifier"
        case scalingConfigurationInfo = "ScalingConfigurationInfo"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case tagList = "TagList"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let activityStreamKinesisStreamName = activityStreamKinesisStreamName {
            try container.encode(activityStreamKinesisStreamName, forKey: Key("ActivityStreamKinesisStreamName"))
        }
        if let activityStreamKmsKeyId = activityStreamKmsKeyId {
            try container.encode(activityStreamKmsKeyId, forKey: Key("ActivityStreamKmsKeyId"))
        }
        if let activityStreamMode = activityStreamMode {
            try container.encode(activityStreamMode, forKey: Key("ActivityStreamMode"))
        }
        if let activityStreamStatus = activityStreamStatus {
            try container.encode(activityStreamStatus, forKey: Key("ActivityStreamStatus"))
        }
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AssociatedRoles"))
            for (index0, dbclusterrole0) in associatedRoles.enumerated() {
                try associatedRolesContainer.encode(dbclusterrole0, forKey: Key("DBClusterRole.\(index0.advanced(by: 1))"))
            }
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackConsumedChangeRecords = backtrackConsumedChangeRecords {
            try container.encode(backtrackConsumedChangeRecords, forKey: Key("BacktrackConsumedChangeRecords"))
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let capacity = capacity {
            try container.encode(capacity, forKey: Key("Capacity"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
        if let cloneGroupId = cloneGroupId {
            try container.encode(cloneGroupId, forKey: Key("CloneGroupId"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: Key("clusterCreateTime"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let crossAccountClone = crossAccountClone {
            try container.encode(crossAccountClone, forKey: Key("CrossAccountClone"))
        }
        if let customEndpoints = customEndpoints {
            var customEndpointsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("CustomEndpoints"))
            for (index0, string0) in customEndpoints.enumerated() {
                try customEndpointsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterArn = dBClusterArn {
            try container.encode(dBClusterArn, forKey: Key("DBClusterArn"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterMembers = dBClusterMembers {
            var dBClusterMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBClusterMembers"))
            for (index0, dbclustermember0) in dBClusterMembers.enumerated() {
                try dBClusterMembersContainer.encode(dbclustermember0, forKey: Key("DBClusterMember.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships {
            var dBClusterOptionGroupMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBClusterOptionGroupMemberships"))
            for (index0, dbclusteroptiongroupstatus0) in dBClusterOptionGroupMemberships.enumerated() {
                try dBClusterOptionGroupMembershipsContainer.encode(dbclusteroptiongroupstatus0, forKey: Key("DBClusterOptionGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterParameterGroup = dBClusterParameterGroup {
            try container.encode(dBClusterParameterGroup, forKey: Key("DBClusterParameterGroup"))
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: Key("DBSubnetGroup"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let dbClusterResourceId = dbClusterResourceId {
            try container.encode(dbClusterResourceId, forKey: Key("DbClusterResourceId"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DomainMemberships"))
            for (index0, domainmembership0) in domainMemberships.enumerated() {
                try domainMembershipsContainer.encode(domainmembership0, forKey: Key("DomainMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let earliestBacktrackTime = earliestBacktrackTime {
            try container.encode(TimestampWrapper(earliestBacktrackTime, format: .dateTime), forKey: Key("earliestBacktrackTime"))
        }
        if let earliestRestorableTime = earliestRestorableTime {
            try container.encode(TimestampWrapper(earliestRestorableTime, format: .dateTime), forKey: Key("earliestRestorableTime"))
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let globalWriteForwardingRequested = globalWriteForwardingRequested {
            try container.encode(globalWriteForwardingRequested, forKey: Key("GlobalWriteForwardingRequested"))
        }
        if let globalWriteForwardingStatus = globalWriteForwardingStatus {
            try container.encode(globalWriteForwardingStatus, forKey: Key("GlobalWriteForwardingStatus"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: Key("HostedZoneId"))
        }
        if let httpEndpointEnabled = httpEndpointEnabled {
            try container.encode(httpEndpointEnabled, forKey: Key("HttpEndpointEnabled"))
        }
        if let iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: Key("latestRestorableTime"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: Key("PendingModifiedValues"))
        }
        if let percentProgress = percentProgress {
            try container.encode(percentProgress, forKey: Key("PercentProgress"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let readReplicaIdentifiers = readReplicaIdentifiers {
            var readReplicaIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReadReplicaIdentifiers"))
            for (index0, string0) in readReplicaIdentifiers.enumerated() {
                try readReplicaIdentifiersContainer.encode(string0, forKey: Key("ReadReplicaIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readerEndpoint = readerEndpoint {
            try container.encode(readerEndpoint, forKey: Key("ReaderEndpoint"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: Key("ReplicationSourceIdentifier"))
        }
        if let scalingConfigurationInfo = scalingConfigurationInfo {
            try container.encode(scalingConfigurationInfo, forKey: Key("ScalingConfigurationInfo"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let characterSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let earliestRestorableTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .earliestRestorableTime)
        var earliestRestorableTimeBuffer:Date? = nil
        if let earliestRestorableTimeDecoded = earliestRestorableTimeDecoded {
            earliestRestorableTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(earliestRestorableTimeDecoded, format: .dateTime)
        }
        earliestRestorableTime = earliestRestorableTimeBuffer
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let readerEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readerEndpoint)
        readerEndpoint = readerEndpointDecoded
        if containerValues.contains(.customEndpoints) {
            struct KeyVal0{struct member{}}
            let customEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .customEndpoints)
            if let customEndpointsWrappedContainer = customEndpointsWrappedContainer {
                let customEndpointsContainer = try customEndpointsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var customEndpointsBuffer:[String]? = nil
                if let customEndpointsContainer = customEndpointsContainer {
                    customEndpointsBuffer = [String]()
                    for stringContainer0 in customEndpointsContainer {
                        customEndpointsBuffer?.append(stringContainer0)
                    }
                }
                customEndpoints = customEndpointsBuffer
            } else {
                customEndpoints = []
            }
        } else {
            customEndpoints = nil
        }
        let multiAZDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        if containerValues.contains(.dBClusterOptionGroupMemberships) {
            struct KeyVal0{struct DBClusterOptionGroup{}}
            let dBClusterOptionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterOptionGroup>.CodingKeys.self, forKey: .dBClusterOptionGroupMemberships)
            if let dBClusterOptionGroupMembershipsWrappedContainer = dBClusterOptionGroupMembershipsWrappedContainer {
                let dBClusterOptionGroupMembershipsContainer = try dBClusterOptionGroupMembershipsWrappedContainer.decodeIfPresent([DBClusterOptionGroupStatus].self, forKey: .member)
                var dBClusterOptionGroupMembershipsBuffer:[DBClusterOptionGroupStatus]? = nil
                if let dBClusterOptionGroupMembershipsContainer = dBClusterOptionGroupMembershipsContainer {
                    dBClusterOptionGroupMembershipsBuffer = [DBClusterOptionGroupStatus]()
                    for structureContainer0 in dBClusterOptionGroupMembershipsContainer {
                        dBClusterOptionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterOptionGroupMemberships = dBClusterOptionGroupMembershipsBuffer
            } else {
                dBClusterOptionGroupMemberships = []
            }
        } else {
            dBClusterOptionGroupMemberships = nil
        }
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let replicationSourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationSourceIdentifier)
        replicationSourceIdentifier = replicationSourceIdentifierDecoded
        if containerValues.contains(.readReplicaIdentifiers) {
            struct KeyVal0{struct ReadReplicaIdentifier{}}
            let readReplicaIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaIdentifier>.CodingKeys.self, forKey: .readReplicaIdentifiers)
            if let readReplicaIdentifiersWrappedContainer = readReplicaIdentifiersWrappedContainer {
                let readReplicaIdentifiersContainer = try readReplicaIdentifiersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var readReplicaIdentifiersBuffer:[String]? = nil
                if let readReplicaIdentifiersContainer = readReplicaIdentifiersContainer {
                    readReplicaIdentifiersBuffer = [String]()
                    for stringContainer0 in readReplicaIdentifiersContainer {
                        readReplicaIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaIdentifiers = readReplicaIdentifiersBuffer
            } else {
                readReplicaIdentifiers = []
            }
        } else {
            readReplicaIdentifiers = nil
        }
        if containerValues.contains(.dBClusterMembers) {
            struct KeyVal0{struct DBClusterMember{}}
            let dBClusterMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterMember>.CodingKeys.self, forKey: .dBClusterMembers)
            if let dBClusterMembersWrappedContainer = dBClusterMembersWrappedContainer {
                let dBClusterMembersContainer = try dBClusterMembersWrappedContainer.decodeIfPresent([DBClusterMember].self, forKey: .member)
                var dBClusterMembersBuffer:[DBClusterMember]? = nil
                if let dBClusterMembersContainer = dBClusterMembersContainer {
                    dBClusterMembersBuffer = [DBClusterMember]()
                    for structureContainer0 in dBClusterMembersContainer {
                        dBClusterMembersBuffer?.append(structureContainer0)
                    }
                }
                dBClusterMembers = dBClusterMembersBuffer
            } else {
                dBClusterMembers = []
            }
        } else {
            dBClusterMembers = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let storageEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbClusterResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterResourceId)
        dbClusterResourceId = dbClusterResourceIdDecoded
        let dBClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterArn)
        dBClusterArn = dBClusterArnDecoded
        if containerValues.contains(.associatedRoles) {
            struct KeyVal0{struct DBClusterRole{}}
            let associatedRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterRole>.CodingKeys.self, forKey: .associatedRoles)
            if let associatedRolesWrappedContainer = associatedRolesWrappedContainer {
                let associatedRolesContainer = try associatedRolesWrappedContainer.decodeIfPresent([DBClusterRole].self, forKey: .member)
                var associatedRolesBuffer:[DBClusterRole]? = nil
                if let associatedRolesContainer = associatedRolesContainer {
                    associatedRolesBuffer = [DBClusterRole]()
                    for structureContainer0 in associatedRolesContainer {
                        associatedRolesBuffer?.append(structureContainer0)
                    }
                }
                associatedRoles = associatedRolesBuffer
            } else {
                associatedRoles = []
            }
        } else {
            associatedRoles = nil
        }
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let cloneGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloneGroupId)
        cloneGroupId = cloneGroupIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let earliestBacktrackTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .earliestBacktrackTime)
        var earliestBacktrackTimeBuffer:Date? = nil
        if let earliestBacktrackTimeDecoded = earliestBacktrackTimeDecoded {
            earliestBacktrackTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(earliestBacktrackTimeDecoded, format: .dateTime)
        }
        earliestBacktrackTime = earliestBacktrackTimeBuffer
        let backtrackWindowDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backtrackWindow)
        backtrackWindow = backtrackWindowDecoded
        let backtrackConsumedChangeRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backtrackConsumedChangeRecords)
        backtrackConsumedChangeRecords = backtrackConsumedChangeRecordsDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        let capacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let engineModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let scalingConfigurationInfoDecoded = try containerValues.decodeIfPresent(ScalingConfigurationInfo.self, forKey: .scalingConfigurationInfo)
        scalingConfigurationInfo = scalingConfigurationInfoDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let httpEndpointEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .httpEndpointEnabled)
        httpEndpointEnabled = httpEndpointEnabledDecoded
        let activityStreamModeDecoded = try containerValues.decodeIfPresent(ActivityStreamMode.self, forKey: .activityStreamMode)
        activityStreamMode = activityStreamModeDecoded
        let activityStreamStatusDecoded = try containerValues.decodeIfPresent(ActivityStreamStatus.self, forKey: .activityStreamStatus)
        activityStreamStatus = activityStreamStatusDecoded
        let activityStreamKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityStreamKmsKeyId)
        activityStreamKmsKeyId = activityStreamKmsKeyIdDecoded
        let activityStreamKinesisStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityStreamKinesisStreamName)
        activityStreamKinesisStreamName = activityStreamKinesisStreamNameDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let crossAccountCloneDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .crossAccountClone)
        crossAccountClone = crossAccountCloneDecoded
        if containerValues.contains(.domainMemberships) {
            struct KeyVal0{struct DomainMembership{}}
            let domainMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DomainMembership>.CodingKeys.self, forKey: .domainMemberships)
            if let domainMembershipsWrappedContainer = domainMembershipsWrappedContainer {
                let domainMembershipsContainer = try domainMembershipsWrappedContainer.decodeIfPresent([DomainMembership].self, forKey: .member)
                var domainMembershipsBuffer:[DomainMembership]? = nil
                if let domainMembershipsContainer = domainMembershipsContainer {
                    domainMembershipsBuffer = [DomainMembership]()
                    for structureContainer0 in domainMembershipsContainer {
                        domainMembershipsBuffer?.append(structureContainer0)
                    }
                }
                domainMemberships = domainMembershipsBuffer
            } else {
                domainMemberships = []
            }
        } else {
            domainMemberships = nil
        }
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagListBuffer:[Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        let globalWriteForwardingStatusDecoded = try containerValues.decodeIfPresent(WriteForwardingStatus.self, forKey: .globalWriteForwardingStatus)
        globalWriteForwardingStatus = globalWriteForwardingStatusDecoded
        let globalWriteForwardingRequestedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .globalWriteForwardingRequested)
        globalWriteForwardingRequested = globalWriteForwardingRequestedDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(ClusterPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
    }
}

extension DBCluster: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBCluster(activityStreamKinesisStreamName: \(String(describing: activityStreamKinesisStreamName)), activityStreamKmsKeyId: \(String(describing: activityStreamKmsKeyId)), activityStreamMode: \(String(describing: activityStreamMode)), activityStreamStatus: \(String(describing: activityStreamStatus)), allocatedStorage: \(String(describing: allocatedStorage)), associatedRoles: \(String(describing: associatedRoles)), availabilityZones: \(String(describing: availabilityZones)), backtrackConsumedChangeRecords: \(String(describing: backtrackConsumedChangeRecords)), backtrackWindow: \(String(describing: backtrackWindow)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), capacity: \(String(describing: capacity)), characterSetName: \(String(describing: characterSetName)), cloneGroupId: \(String(describing: cloneGroupId)), clusterCreateTime: \(String(describing: clusterCreateTime)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), crossAccountClone: \(String(describing: crossAccountClone)), customEndpoints: \(String(describing: customEndpoints)), dBClusterArn: \(String(describing: dBClusterArn)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterMembers: \(String(describing: dBClusterMembers)), dBClusterOptionGroupMemberships: \(String(describing: dBClusterOptionGroupMemberships)), dBClusterParameterGroup: \(String(describing: dBClusterParameterGroup)), dBSubnetGroup: \(String(describing: dBSubnetGroup)), databaseName: \(String(describing: databaseName)), dbClusterResourceId: \(String(describing: dbClusterResourceId)), deletionProtection: \(String(describing: deletionProtection)), domainMemberships: \(String(describing: domainMemberships)), earliestBacktrackTime: \(String(describing: earliestBacktrackTime)), earliestRestorableTime: \(String(describing: earliestRestorableTime)), enabledCloudwatchLogsExports: \(String(describing: enabledCloudwatchLogsExports)), endpoint: \(String(describing: endpoint)), engine: \(String(describing: engine)), engineMode: \(String(describing: engineMode)), engineVersion: \(String(describing: engineVersion)), globalWriteForwardingRequested: \(String(describing: globalWriteForwardingRequested)), globalWriteForwardingStatus: \(String(describing: globalWriteForwardingStatus)), hostedZoneId: \(String(describing: hostedZoneId)), httpEndpointEnabled: \(String(describing: httpEndpointEnabled)), iAMDatabaseAuthenticationEnabled: \(String(describing: iAMDatabaseAuthenticationEnabled)), kmsKeyId: \(String(describing: kmsKeyId)), latestRestorableTime: \(String(describing: latestRestorableTime)), masterUsername: \(String(describing: masterUsername)), multiAZ: \(String(describing: multiAZ)), pendingModifiedValues: \(String(describing: pendingModifiedValues)), percentProgress: \(String(describing: percentProgress)), port: \(String(describing: port)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), readReplicaIdentifiers: \(String(describing: readReplicaIdentifiers)), readerEndpoint: \(String(describing: readerEndpoint)), replicationSourceIdentifier: \(String(describing: replicationSourceIdentifier)), scalingConfigurationInfo: \(String(describing: scalingConfigurationInfo)), status: \(String(describing: status)), storageEncrypted: \(String(describing: storageEncrypted)), tagList: \(String(describing: tagList)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

/// <p>Contains the details of an Amazon Aurora DB cluster.
///       </p>
///          <p>This data type is used as a response element in the <code>DescribeDBClusters</code>,
///         <code>StopDBCluster</code>, and <code>StartDBCluster</code> actions.
///       </p>
public struct DBCluster: Equatable {
    /// <p>The name of the Amazon Kinesis data stream used for the database activity stream.</p>
    public let activityStreamKinesisStreamName: String?
    /// <p>The AWS KMS key identifier used for encrypting messages in the database activity stream.</p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    public let activityStreamKmsKeyId: String?
    /// <p>The mode of the database activity stream.
    ///            Database events such as a change or access generate an activity stream event.
    ///            The database session can handle these events either synchronously or asynchronously.
    ///        </p>
    public let activityStreamMode: ActivityStreamMode?
    /// <p>The status of the database activity stream.</p>
    public let activityStreamStatus: ActivityStreamStatus?
    /// <p>For all database engines except Amazon Aurora, <code>AllocatedStorage</code> specifies the allocated storage size in gibibytes (GiB).
    ///           For Aurora, <code>AllocatedStorage</code> always returns 1, because Aurora DB cluster storage size isn't fixed, but instead automatically
    ///       adjusts as needed.</p>
    public let allocatedStorage: Int?
    /// <p>Provides a list of the AWS Identity and Access Management (IAM) roles that are associated with the DB cluster.
    ///           IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other AWS services
    ///           on your behalf.</p>
    public let associatedRoles: [DBClusterRole]?
    /// <p>Provides the list of Availability Zones (AZs) where instances in the DB cluster can be created.</p>
    public let availabilityZones: [String]?
    /// <p>The number of change records stored for Backtrack.</p>
    public let backtrackConsumedChangeRecords: Int?
    /// <p>The target backtrack window, in seconds. If this value is set to 0, backtracking is
    ///             disabled for the DB cluster. Otherwise, backtracking is enabled.</p>
    public let backtrackWindow: Int?
    /// <p>Specifies the number of days for which automatic DB snapshots are retained.</p>
    public let backupRetentionPeriod: Int?
    /// <p>The current capacity of an Aurora Serverless DB cluster. The capacity is 0 (zero)
    ///           when the cluster is paused.</p>
    ///          <p>For more information about Aurora Serverless, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html">Using Amazon Aurora Serverless</a> in the
    ///           <i>Amazon Aurora User Guide</i>.</p>
    public let capacity: Int?
    /// <p>If present, specifies the name of the character set that this cluster is associated with.</p>
    public let characterSetName: String?
    /// <p>Identifies the clone group to which the DB cluster is associated.</p>
    public let cloneGroupId: String?
    /// <p>Specifies the time when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
    public let clusterCreateTime: Date?
    /// <p>Specifies whether tags are copied from the DB cluster to snapshots of the DB cluster.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>Specifies whether the DB cluster is a clone of a DB cluster owned by a different AWS account.</p>
    public let crossAccountClone: Bool?
    /// <p>Identifies all custom endpoints associated with the cluster.</p>
    public let customEndpoints: [String]?
    /// <p>The Amazon Resource Name (ARN) for the DB cluster.</p>
    public let dBClusterArn: String?
    /// <p>Contains a user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.</p>
    public let dBClusterIdentifier: String?
    /// <p>Provides the list of instances that make up the DB cluster.</p>
    public let dBClusterMembers: [DBClusterMember]?
    /// <p>Provides the list of option group memberships for this DB cluster.</p>
    public let dBClusterOptionGroupMemberships: [DBClusterOptionGroupStatus]?
    /// <p>Specifies the name of the DB cluster parameter group for the DB cluster.</p>
    public let dBClusterParameterGroup: String?
    /// <p>Specifies information on the subnet group associated with the DB cluster, including the name, description, and subnets in the subnet group.</p>
    public let dBSubnetGroup: String?
    /// <p>Contains the name of the initial database of this DB cluster that was provided at create time, if one was specified when the DB cluster was created. This same name is returned for the life of the DB cluster.</p>
    public let databaseName: String?
    /// <p>The AWS Region-unique, immutable identifier for the DB cluster. This identifier is found in AWS CloudTrail log entries whenever
    ///           the AWS KMS CMK for the DB cluster is accessed.</p>
    public let dbClusterResourceId: String?
    /// <p>Indicates if the DB cluster has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled.
    ///         </p>
    public let deletionProtection: Bool?
    /// <p>The Active Directory Domain membership records associated with the DB cluster.</p>
    public let domainMemberships: [DomainMembership]?
    /// <p>The earliest time to which a DB cluster can be backtracked.</p>
    public let earliestBacktrackTime: Date?
    /// <p>The earliest time to which a database can be restored with point-in-time
    ///             restore.</p>
    public let earliestRestorableTime: Date?
    /// <p>A list of log types that this DB cluster is configured to export to CloudWatch Logs.</p>
    ///         <p>Log types vary by DB engine. For information about the log types for each DB engine, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html">Amazon RDS Database Log Files</a> in the <i>Amazon Aurora User Guide.</i>
    ///          </p>
    public let enabledCloudwatchLogsExports: [String]?
    /// <p>Specifies the connection endpoint for the primary instance of the DB cluster.</p>
    public let endpoint: String?
    /// <p>The name of the database engine to be used for this DB cluster.</p>
    public let engine: String?
    /// <p>The DB engine mode of the DB cluster, either <code>provisioned</code>, <code>serverless</code>,
    ///             <code>parallelquery</code>, <code>global</code>, or <code>multimaster</code>.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBCluster.html">
    ///             CreateDBCluster</a>.</p>
    public let engineMode: String?
    /// <p>Indicates the database engine version.</p>
    public let engineVersion: String?
    /// <p>Specifies whether you have requested to enable write forwarding for a secondary cluster
    ///       in an Aurora global database. Because write forwarding takes time to enable, check the
    ///       value of <code>GlobalWriteForwardingStatus</code> to confirm that the request has completed
    ///       before using the write forwarding feature for this cluster.</p>
    public let globalWriteForwardingRequested: Bool?
    /// <p>Specifies whether a secondary cluster in an Aurora global database has
    ///         write forwarding enabled, not enabled, or is in the process of enabling it.</p>
    public let globalWriteForwardingStatus: WriteForwardingStatus?
    /// <p>Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.</p>
    public let hostedZoneId: String?
    /// <p>A value that indicates whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.</p>
    ///          <p>When enabled, the HTTP endpoint provides a connectionless web service API for running
    ///           SQL queries on the Aurora Serverless DB cluster. You can also query your database
    ///           from inside the RDS console with the query editor.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html">Using the Data API for Aurora Serverless</a> in the
    ///           <i>Amazon Aurora User Guide</i>.</p>
    public let httpEndpointEnabled: Bool?
    /// <p>A value that indicates whether the mapping of AWS Identity and Access Management (IAM) accounts to database accounts is enabled.</p>
    public let iAMDatabaseAuthenticationEnabled: Bool?
    /// <p>If <code>StorageEncrypted</code> is enabled, the AWS KMS key identifier for the encrypted DB cluster.</p>
    ///          <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    public let kmsKeyId: String?
    /// <p>Specifies the latest time to which a database can be restored with point-in-time restore.</p>
    public let latestRestorableTime: Date?
    /// <p>Contains the master username for the DB cluster.</p>
    public let masterUsername: String?
    /// <p>Specifies whether the DB cluster has instances in multiple Availability Zones.</p>
    public let multiAZ: Bool?
    /// <p>A value that specifies that changes to the DB cluster are pending. This element is only included when changes are pending.
    ///           Specific changes are identified by subelements.</p>
    public let pendingModifiedValues: ClusterPendingModifiedValues?
    /// <p>Specifies the progress of the operation as a percentage.</p>
    public let percentProgress: String?
    /// <p>Specifies the port that the database engine is listening on.</p>
    public let port: Int?
    /// <p>Specifies the daily time range during which automated backups are
    ///             created if automated backups are enabled, as determined
    ///             by the <code>BackupRetentionPeriod</code>.
    ///         </p>
    public let preferredBackupWindow: String?
    /// <p>Specifies the weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
    public let preferredMaintenanceWindow: String?
    /// <p>Contains one or more identifiers of the read replicas associated with this DB
    ///             cluster.</p>
    public let readReplicaIdentifiers: [String]?
    /// <p>The reader endpoint for the DB cluster. The reader endpoint for a DB cluster load-balances
    ///             connections across the Aurora Replicas that are available in a DB cluster. As clients request new connections
    ///             to the reader endpoint, Aurora distributes the connection requests among the Aurora Replicas in the DB cluster.
    ///             This functionality can help balance your read workload across multiple Aurora Replicas in your DB cluster. </p>
    ///         <p>If a failover occurs, and the Aurora Replica that you are connected to is promoted
    ///             to be the primary instance, your connection is dropped. To
    ///             continue sending your read workload to other Aurora Replicas in the cluster,
    ///             you can then reconnect to the reader endpoint.</p>
    public let readerEndpoint: String?
    /// <p>Contains the identifier of the source DB cluster if this DB cluster is a read
    ///             replica.</p>
    public let replicationSourceIdentifier: String?
    /// <p>Shows the scaling configuration for an Aurora DB cluster in <code>serverless</code> DB engine mode.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html">Using Amazon Aurora Serverless</a> in the
    ///             <i>Amazon Aurora User Guide</i>.</p>
    public let scalingConfigurationInfo: ScalingConfigurationInfo?
    /// <p>Specifies the current state of this DB cluster.</p>
    public let status: String?
    /// <p>Specifies whether the DB cluster is encrypted.</p>
    public let storageEncrypted: Bool
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tagList: [Tag]?
    /// <p>Provides a list of VPC security groups that the DB cluster belongs to.</p>
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

    public init (
        activityStreamKinesisStreamName: String? = nil,
        activityStreamKmsKeyId: String? = nil,
        activityStreamMode: ActivityStreamMode? = nil,
        activityStreamStatus: ActivityStreamStatus? = nil,
        allocatedStorage: Int? = nil,
        associatedRoles: [DBClusterRole]? = nil,
        availabilityZones: [String]? = nil,
        backtrackConsumedChangeRecords: Int? = nil,
        backtrackWindow: Int? = nil,
        backupRetentionPeriod: Int? = nil,
        capacity: Int? = nil,
        characterSetName: String? = nil,
        cloneGroupId: String? = nil,
        clusterCreateTime: Date? = nil,
        copyTagsToSnapshot: Bool? = nil,
        crossAccountClone: Bool? = nil,
        customEndpoints: [String]? = nil,
        dBClusterArn: String? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterMembers: [DBClusterMember]? = nil,
        dBClusterOptionGroupMemberships: [DBClusterOptionGroupStatus]? = nil,
        dBClusterParameterGroup: String? = nil,
        dBSubnetGroup: String? = nil,
        databaseName: String? = nil,
        dbClusterResourceId: String? = nil,
        deletionProtection: Bool? = nil,
        domainMemberships: [DomainMembership]? = nil,
        earliestBacktrackTime: Date? = nil,
        earliestRestorableTime: Date? = nil,
        enabledCloudwatchLogsExports: [String]? = nil,
        endpoint: String? = nil,
        engine: String? = nil,
        engineMode: String? = nil,
        engineVersion: String? = nil,
        globalWriteForwardingRequested: Bool? = nil,
        globalWriteForwardingStatus: WriteForwardingStatus? = nil,
        hostedZoneId: String? = nil,
        httpEndpointEnabled: Bool? = nil,
        iAMDatabaseAuthenticationEnabled: Bool? = nil,
        kmsKeyId: String? = nil,
        latestRestorableTime: Date? = nil,
        masterUsername: String? = nil,
        multiAZ: Bool? = nil,
        pendingModifiedValues: ClusterPendingModifiedValues? = nil,
        percentProgress: String? = nil,
        port: Int? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        readReplicaIdentifiers: [String]? = nil,
        readerEndpoint: String? = nil,
        replicationSourceIdentifier: String? = nil,
        scalingConfigurationInfo: ScalingConfigurationInfo? = nil,
        status: String? = nil,
        storageEncrypted: Bool = false,
        tagList: [Tag]? = nil,
        vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil
    )
    {
        self.activityStreamKinesisStreamName = activityStreamKinesisStreamName
        self.activityStreamKmsKeyId = activityStreamKmsKeyId
        self.activityStreamMode = activityStreamMode
        self.activityStreamStatus = activityStreamStatus
        self.allocatedStorage = allocatedStorage
        self.associatedRoles = associatedRoles
        self.availabilityZones = availabilityZones
        self.backtrackConsumedChangeRecords = backtrackConsumedChangeRecords
        self.backtrackWindow = backtrackWindow
        self.backupRetentionPeriod = backupRetentionPeriod
        self.capacity = capacity
        self.characterSetName = characterSetName
        self.cloneGroupId = cloneGroupId
        self.clusterCreateTime = clusterCreateTime
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.crossAccountClone = crossAccountClone
        self.customEndpoints = customEndpoints
        self.dBClusterArn = dBClusterArn
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterMembers = dBClusterMembers
        self.dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships
        self.dBClusterParameterGroup = dBClusterParameterGroup
        self.dBSubnetGroup = dBSubnetGroup
        self.databaseName = databaseName
        self.dbClusterResourceId = dbClusterResourceId
        self.deletionProtection = deletionProtection
        self.domainMemberships = domainMemberships
        self.earliestBacktrackTime = earliestBacktrackTime
        self.earliestRestorableTime = earliestRestorableTime
        self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
        self.endpoint = endpoint
        self.engine = engine
        self.engineMode = engineMode
        self.engineVersion = engineVersion
        self.globalWriteForwardingRequested = globalWriteForwardingRequested
        self.globalWriteForwardingStatus = globalWriteForwardingStatus
        self.hostedZoneId = hostedZoneId
        self.httpEndpointEnabled = httpEndpointEnabled
        self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
        self.kmsKeyId = kmsKeyId
        self.latestRestorableTime = latestRestorableTime
        self.masterUsername = masterUsername
        self.multiAZ = multiAZ
        self.pendingModifiedValues = pendingModifiedValues
        self.percentProgress = percentProgress
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.readReplicaIdentifiers = readReplicaIdentifiers
        self.readerEndpoint = readerEndpoint
        self.replicationSourceIdentifier = replicationSourceIdentifier
        self.scalingConfigurationInfo = scalingConfigurationInfo
        self.status = status
        self.storageEncrypted = storageEncrypted
        self.tagList = tagList
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

extension DBClusterAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBClusterAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user already has a DB cluster with the given identifier.</p>
public struct DBClusterAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBClusterAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterBacktrack: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backtrackIdentifier = "BacktrackIdentifier"
        case backtrackRequestCreationTime = "BacktrackRequestCreationTime"
        case backtrackTo = "BacktrackTo"
        case backtrackedFrom = "BacktrackedFrom"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let backtrackIdentifier = backtrackIdentifier {
            try container.encode(backtrackIdentifier, forKey: Key("BacktrackIdentifier"))
        }
        if let backtrackRequestCreationTime = backtrackRequestCreationTime {
            try container.encode(TimestampWrapper(backtrackRequestCreationTime, format: .dateTime), forKey: Key("backtrackRequestCreationTime"))
        }
        if let backtrackTo = backtrackTo {
            try container.encode(TimestampWrapper(backtrackTo, format: .dateTime), forKey: Key("backtrackTo"))
        }
        if let backtrackedFrom = backtrackedFrom {
            try container.encode(TimestampWrapper(backtrackedFrom, format: .dateTime), forKey: Key("backtrackedFrom"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let backtrackIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backtrackIdentifier)
        backtrackIdentifier = backtrackIdentifierDecoded
        let backtrackToDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backtrackTo)
        var backtrackToBuffer:Date? = nil
        if let backtrackToDecoded = backtrackToDecoded {
            backtrackToBuffer = try TimestampWrapperDecoder.parseDateStringValue(backtrackToDecoded, format: .dateTime)
        }
        backtrackTo = backtrackToBuffer
        let backtrackedFromDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backtrackedFrom)
        var backtrackedFromBuffer:Date? = nil
        if let backtrackedFromDecoded = backtrackedFromDecoded {
            backtrackedFromBuffer = try TimestampWrapperDecoder.parseDateStringValue(backtrackedFromDecoded, format: .dateTime)
        }
        backtrackedFrom = backtrackedFromBuffer
        let backtrackRequestCreationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backtrackRequestCreationTime)
        var backtrackRequestCreationTimeBuffer:Date? = nil
        if let backtrackRequestCreationTimeDecoded = backtrackRequestCreationTimeDecoded {
            backtrackRequestCreationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(backtrackRequestCreationTimeDecoded, format: .dateTime)
        }
        backtrackRequestCreationTime = backtrackRequestCreationTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DBClusterBacktrack: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterBacktrack(backtrackIdentifier: \(String(describing: backtrackIdentifier)), backtrackRequestCreationTime: \(String(describing: backtrackRequestCreationTime)), backtrackTo: \(String(describing: backtrackTo)), backtrackedFrom: \(String(describing: backtrackedFrom)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), status: \(String(describing: status)))"}
}

/// <p>This data type is used as a response element in the <code>DescribeDBClusterBacktracks</code> action.</p>
public struct DBClusterBacktrack: Equatable {
    /// <p>Contains the backtrack identifier.</p>
    public let backtrackIdentifier: String?
    /// <p>The timestamp of the time at which the backtrack was requested.</p>
    public let backtrackRequestCreationTime: Date?
    /// <p>The timestamp of the time to which the DB cluster was backtracked.</p>
    public let backtrackTo: Date?
    /// <p>The timestamp of the time from which the DB cluster was backtracked.</p>
    public let backtrackedFrom: Date?
    /// <p>Contains a user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.</p>
    public let dBClusterIdentifier: String?
    /// <p>The status of the backtrack. This property returns one of the following
    ///             values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>applying</code> - The backtrack is currently being applied to or rolled back from the DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>completed</code> - The backtrack has successfully been applied to or rolled back from the DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>failed</code> - An error occurred while the backtrack was applied to or rolled back from the DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code> - The backtrack is currently pending application to or rollback from the DB cluster.</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        backtrackIdentifier: String? = nil,
        backtrackRequestCreationTime: Date? = nil,
        backtrackTo: Date? = nil,
        backtrackedFrom: Date? = nil,
        dBClusterIdentifier: String? = nil,
        status: String? = nil
    )
    {
        self.backtrackIdentifier = backtrackIdentifier
        self.backtrackRequestCreationTime = backtrackRequestCreationTime
        self.backtrackTo = backtrackTo
        self.backtrackedFrom = backtrackedFrom
        self.dBClusterIdentifier = dBClusterIdentifier
        self.status = status
    }
}

extension DBClusterBacktrackNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterBacktrackNotFoundFault(message: \(String(describing: message)))"}
}

extension DBClusterBacktrackNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterBacktrackNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>BacktrackIdentifier</code> doesn't refer to an existing backtrack. </p>
public struct DBClusterBacktrackNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterBacktrackNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBClusterBacktrackNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customEndpointType = customEndpointType {
            try container.encode(customEndpointType, forKey: Key("CustomEndpointType"))
        }
        if let dBClusterEndpointArn = dBClusterEndpointArn {
            try container.encode(dBClusterEndpointArn, forKey: Key("DBClusterEndpointArn"))
        }
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier {
            try container.encode(dBClusterEndpointResourceIdentifier, forKey: Key("DBClusterEndpointResourceIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var staticMembersBuffer:[String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var excludedMembersBuffer:[String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

extension DBClusterEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterEndpoint(customEndpointType: \(String(describing: customEndpointType)), dBClusterEndpointArn: \(String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), endpoint: \(String(describing: endpoint)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)), status: \(String(describing: status)))"}
}

/// <p>This data type represents the information you need to connect to an Amazon Aurora DB cluster.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBClusterEndpoint</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon RDS DB instance endpoints,
///         see <code>Endpoint</code>.</p>
public struct DBClusterEndpoint: Equatable {
    /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
    ///        <code>WRITER</code>, <code>ANY</code>.</p>
    public let customEndpointType: String?
    /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
    public let dBClusterEndpointArn: String?
    /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
    public let dBClusterEndpointResourceIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///             stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>The DNS address of the endpoint.</p>
    public let endpoint: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///        All other eligible instances are reachable through the custom endpoint.
    ///        Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?
    /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that can't be used for a certain kind of cluster,
    ///      such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
    public let status: String?

    public init (
        customEndpointType: String? = nil,
        dBClusterEndpointArn: String? = nil,
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterEndpointResourceIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        endpoint: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil,
        status: String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

extension DBClusterEndpointAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterEndpointAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBClusterEndpointAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterEndpointAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified custom endpoint can't be created because it already exists.</p>
public struct DBClusterEndpointAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBClusterEndpointAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpointNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterEndpointNotFoundFault(message: \(String(describing: message)))"}
}

extension DBClusterEndpointNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterEndpointNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified custom endpoint doesn't exist.</p>
public struct DBClusterEndpointNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBClusterEndpointNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpointQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterEndpointQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBClusterEndpointQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterEndpointQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster already has the maximum number of custom endpoints.</p>
public struct DBClusterEndpointQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBClusterEndpointQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroupStatus = "DBClusterParameterGroupStatus"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case isClusterWriter = "IsClusterWriter"
        case promotionTier = "PromotionTier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupStatus = dBClusterParameterGroupStatus {
            try container.encode(dBClusterParameterGroupStatus, forKey: Key("DBClusterParameterGroupStatus"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if isClusterWriter != false {
            try container.encode(isClusterWriter, forKey: Key("IsClusterWriter"))
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: Key("PromotionTier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let isClusterWriterDecoded = try containerValues.decode(Bool.self, forKey: .isClusterWriter)
        isClusterWriter = isClusterWriterDecoded
        let dBClusterParameterGroupStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroupStatus)
        dBClusterParameterGroupStatus = dBClusterParameterGroupStatusDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
    }
}

extension DBClusterMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterMember(dBClusterParameterGroupStatus: \(String(describing: dBClusterParameterGroupStatus)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), isClusterWriter: \(String(describing: isClusterWriter)), promotionTier: \(String(describing: promotionTier)))"}
}

/// <p>Contains information about an instance that is part of a DB cluster.</p>
public struct DBClusterMember: Equatable {
    /// <p>Specifies the status of the DB cluster parameter group for this member of the DB cluster.</p>
    public let dBClusterParameterGroupStatus: String?
    /// <p>Specifies the instance identifier for this member of the DB cluster.</p>
    public let dBInstanceIdentifier: String?
    /// <p>Value that is <code>true</code> if the cluster member is the primary instance for the DB cluster and <code>false</code> otherwise.</p>
    public let isClusterWriter: Bool
    /// <p>A value that specifies the order in which an Aurora Replica is promoted to the primary instance
    ///       after a failure of the existing primary instance. For more information,
    ///       see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance">
    ///           Fault Tolerance for an Aurora DB Cluster</a> in the <i>Amazon Aurora User Guide</i>.
    ///     </p>
    public let promotionTier: Int?

    public init (
        dBClusterParameterGroupStatus: String? = nil,
        dBInstanceIdentifier: String? = nil,
        isClusterWriter: Bool = false,
        promotionTier: Int? = nil
    )
    {
        self.dBClusterParameterGroupStatus = dBClusterParameterGroupStatus
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.isClusterWriter = isClusterWriter
        self.promotionTier = promotionTier
    }
}

extension DBClusterNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterNotFoundFault(message: \(String(describing: message)))"}
}

extension DBClusterNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>DBClusterIdentifier</code> doesn't refer to an existing DB cluster.
///         </p>
public struct DBClusterNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBClusterNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterOptionGroupStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBClusterOptionGroupName = "DBClusterOptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterOptionGroupName = dBClusterOptionGroupName {
            try container.encode(dBClusterOptionGroupName, forKey: Key("DBClusterOptionGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterOptionGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterOptionGroupName)
        dBClusterOptionGroupName = dBClusterOptionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DBClusterOptionGroupStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterOptionGroupStatus(dBClusterOptionGroupName: \(String(describing: dBClusterOptionGroupName)), status: \(String(describing: status)))"}
}

/// <p>Contains status information for a DB cluster option group.</p>
public struct DBClusterOptionGroupStatus: Equatable {
    /// <p>Specifies the name of the DB cluster option group.</p>
    public let dBClusterOptionGroupName: String?
    /// <p>Specifies the status of the DB cluster option group.</p>
    public let status: String?

    public init (
        dBClusterOptionGroupName: String? = nil,
        status: String? = nil
    )
    {
        self.dBClusterOptionGroupName = dBClusterOptionGroupName
        self.status = status
    }
}

extension DBClusterParameterGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroupArn = "DBClusterParameterGroupArn"
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupArn = dBClusterParameterGroupArn {
            try container.encode(dBClusterParameterGroupArn, forKey: Key("DBClusterParameterGroupArn"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dBClusterParameterGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroupArn)
        dBClusterParameterGroupArn = dBClusterParameterGroupArnDecoded
    }
}

extension DBClusterParameterGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterParameterGroup(dBClusterParameterGroupArn: \(String(describing: dBClusterParameterGroupArn)), dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), description: \(String(describing: description)))"}
}

/// <p>Contains the details of an Amazon RDS DB cluster parameter group.
///         </p>
///          <p>This data type is used as a response element in the <code>DescribeDBClusterParameterGroups</code> action.
///         </p>
public struct DBClusterParameterGroup: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the DB cluster parameter group.</p>
    public let dBClusterParameterGroupArn: String?
    /// <p>The name of the DB cluster parameter group.</p>
    public let dBClusterParameterGroupName: String?
    /// <p>The name of the DB parameter group family that this DB cluster parameter group is compatible with.</p>
    public let dBParameterGroupFamily: String?
    /// <p>Provides the customer-specified description for this DB cluster parameter group.</p>
    public let description: String?

    public init (
        dBClusterParameterGroupArn: String? = nil,
        dBClusterParameterGroupName: String? = nil,
        dBParameterGroupFamily: String? = nil,
        description: String? = nil
    )
    {
        self.dBClusterParameterGroupArn = dBClusterParameterGroupArn
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.description = description
    }
}

extension DBClusterParameterGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterParameterGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension DBClusterParameterGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>DBClusterParameterGroupName</code> doesn't refer to an existing DB
///             cluster parameter group. </p>
public struct DBClusterParameterGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterParameterGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBClusterParameterGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBClusterQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user attempted to create a new DB cluster and the user has already reached the
///             maximum allowed DB cluster quota.</p>
public struct DBClusterQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBClusterQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRole: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let featureName = featureName {
            try container.encode(featureName, forKey: Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .featureName)
        featureName = featureNameDecoded
    }
}

extension DBClusterRole: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterRole(featureName: \(String(describing: featureName)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

/// <p>Describes an AWS Identity and Access Management (IAM) role that is associated with a DB cluster.</p>
public struct DBClusterRole: Equatable {
    /// <p>The name of the feature associated with the AWS Identity and Access Management (IAM) role.
    ///             For the list of supported feature names, see <a>DBEngineVersion</a>.
    ///         </p>
    public let featureName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.</p>
    public let roleArn: String?
    /// <p>Describes the state of association between the IAM role and the DB cluster. The Status property returns one of the following
    ///         values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - the IAM role ARN is associated with the DB cluster and can be used to
    ///             access other AWS services on your behalf.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code> - the IAM role ARN is being associated with the DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INVALID</code> - the IAM role ARN is associated with the DB cluster, but the DB cluster is unable
    ///                 to assume the IAM role in order to access other AWS services on your behalf.</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        featureName: String? = nil,
        roleArn: String? = nil,
        status: String? = nil
    )
    {
        self.featureName = featureName
        self.roleArn = roleArn
        self.status = status
    }
}

extension DBClusterRoleAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterRoleAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBClusterRoleAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterRoleAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.</p>
public struct DBClusterRoleAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBClusterRoleAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRoleNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterRoleNotFoundFault(message: \(String(describing: message)))"}
}

extension DBClusterRoleNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterRoleNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) isn't associated with the specified DB cluster.</p>
public struct DBClusterRoleNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBClusterRoleNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRoleQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterRoleQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBClusterRoleQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterRoleQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.</p>
public struct DBClusterRoleQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBClusterRoleQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterSnapshot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZones = "AvailabilityZones"
        case clusterCreateTime = "ClusterCreateTime"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterSnapshotArn = "DBClusterSnapshotArn"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotType = "SnapshotType"
        case sourceDBClusterSnapshotArn = "SourceDBClusterSnapshotArn"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case tagList = "TagList"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: Key("clusterCreateTime"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotArn = dBClusterSnapshotArn {
            try container.encode(dBClusterSnapshotArn, forKey: Key("DBClusterSnapshotArn"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if percentProgress != 0 {
            try container.encode(percentProgress, forKey: Key("PercentProgress"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: Key("snapshotCreateTime"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: Key("SnapshotType"))
        }
        if let sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArn {
            try container.encode(sourceDBClusterSnapshotArn, forKey: Key("SourceDBClusterSnapshotArn"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let percentProgressDecoded = try containerValues.decode(Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let storageEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dBClusterSnapshotArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterSnapshotArn)
        dBClusterSnapshotArn = dBClusterSnapshotArnDecoded
        let sourceDBClusterSnapshotArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceDBClusterSnapshotArn)
        sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArnDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagListBuffer:[Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

extension DBClusterSnapshot: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterSnapshot(allocatedStorage: \(String(describing: allocatedStorage)), availabilityZones: \(String(describing: availabilityZones)), clusterCreateTime: \(String(describing: clusterCreateTime)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterSnapshotArn: \(String(describing: dBClusterSnapshotArn)), dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)), engine: \(String(describing: engine)), engineMode: \(String(describing: engineMode)), engineVersion: \(String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(String(describing: iAMDatabaseAuthenticationEnabled)), kmsKeyId: \(String(describing: kmsKeyId)), licenseModel: \(String(describing: licenseModel)), masterUsername: \(String(describing: masterUsername)), percentProgress: \(String(describing: percentProgress)), port: \(String(describing: port)), snapshotCreateTime: \(String(describing: snapshotCreateTime)), snapshotType: \(String(describing: snapshotType)), sourceDBClusterSnapshotArn: \(String(describing: sourceDBClusterSnapshotArn)), status: \(String(describing: status)), storageEncrypted: \(String(describing: storageEncrypted)), tagList: \(String(describing: tagList)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains the details for an Amazon RDS DB cluster snapshot
///       </p>
///          <p>This data type is used as a response element
///           in the <code>DescribeDBClusterSnapshots</code> action.
///       </p>
public struct DBClusterSnapshot: Equatable {
    /// <p>Specifies the allocated storage size in gibibytes (GiB).</p>
    public let allocatedStorage: Int
    /// <p>Provides the list of Availability Zones (AZs) where instances in the DB cluster snapshot can be restored.</p>
    public let availabilityZones: [String]?
    /// <p>Specifies the time when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
    public let clusterCreateTime: Date?
    /// <p>Specifies the DB cluster identifier of the DB cluster that this DB cluster snapshot was created from.</p>
    public let dBClusterIdentifier: String?
    /// <p>The Amazon Resource Name (ARN) for the DB cluster snapshot.</p>
    public let dBClusterSnapshotArn: String?
    /// <p>Specifies the identifier for the DB cluster snapshot.</p>
    public let dBClusterSnapshotIdentifier: String?
    /// <p>Specifies the name of the database engine for this DB cluster snapshot.</p>
    public let engine: String?
    /// <p>Provides the engine mode of the database engine for this DB cluster snapshot.</p>
    public let engineMode: String?
    /// <p>Provides the version of the database engine for this DB cluster snapshot.</p>
    public let engineVersion: String?
    /// <p>True if mapping of AWS Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.</p>
    public let iAMDatabaseAuthenticationEnabled: Bool
    /// <p>If <code>StorageEncrypted</code> is true, the AWS KMS key identifier for the encrypted DB cluster snapshot.</p>
    ///          <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    public let kmsKeyId: String?
    /// <p>Provides the license model information for this DB cluster snapshot.</p>
    public let licenseModel: String?
    /// <p>Provides the master username for this DB cluster snapshot.</p>
    public let masterUsername: String?
    /// <p>Specifies the percentage of the estimated data that has been transferred.</p>
    public let percentProgress: Int
    /// <p>Specifies the port that the DB cluster was listening on at the time of the snapshot.</p>
    public let port: Int
    /// <p>Provides the time when the snapshot was taken, in Universal Coordinated Time (UTC).</p>
    public let snapshotCreateTime: Date?
    /// <p>Provides the type of the DB cluster snapshot.</p>
    public let snapshotType: String?
    /// <p>If the DB cluster snapshot was copied from a source DB cluster snapshot, the Amazon
    ///             Resource Name (ARN) for the source DB cluster snapshot, otherwise, a null value.</p>
    public let sourceDBClusterSnapshotArn: String?
    /// <p>Specifies the status of this DB cluster snapshot.</p>
    public let status: String?
    /// <p>Specifies whether the DB cluster snapshot is encrypted.</p>
    public let storageEncrypted: Bool
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tagList: [Tag]?
    /// <p>Provides the VPC ID associated with the DB cluster snapshot.</p>
    public let vpcId: String?

    public init (
        allocatedStorage: Int = 0,
        availabilityZones: [String]? = nil,
        clusterCreateTime: Date? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterSnapshotArn: String? = nil,
        dBClusterSnapshotIdentifier: String? = nil,
        engine: String? = nil,
        engineMode: String? = nil,
        engineVersion: String? = nil,
        iAMDatabaseAuthenticationEnabled: Bool = false,
        kmsKeyId: String? = nil,
        licenseModel: String? = nil,
        masterUsername: String? = nil,
        percentProgress: Int = 0,
        port: Int = 0,
        snapshotCreateTime: Date? = nil,
        snapshotType: String? = nil,
        sourceDBClusterSnapshotArn: String? = nil,
        status: String? = nil,
        storageEncrypted: Bool = false,
        tagList: [Tag]? = nil,
        vpcId: String? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.availabilityZones = availabilityZones
        self.clusterCreateTime = clusterCreateTime
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotArn = dBClusterSnapshotArn
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.engine = engine
        self.engineMode = engineMode
        self.engineVersion = engineVersion
        self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUsername = masterUsername
        self.percentProgress = percentProgress
        self.port = port
        self.snapshotCreateTime = snapshotCreateTime
        self.snapshotType = snapshotType
        self.sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArn
        self.status = status
        self.storageEncrypted = storageEncrypted
        self.tagList = tagList
        self.vpcId = vpcId
    }
}

extension DBClusterSnapshotAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterSnapshotAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBClusterSnapshotAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user already has a DB cluster snapshot with the given identifier.</p>
public struct DBClusterSnapshotAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterSnapshotAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBClusterSnapshotAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterSnapshotAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case attributeValues = "AttributeValues"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let attributeValues = attributeValues {
            var attributeValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AttributeValues"))
            for (index0, string0) in attributeValues.enumerated() {
                try attributeValuesContainer.encode(string0, forKey: Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.attributeValues) {
            struct KeyVal0{struct AttributeValue{}}
            let attributeValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .attributeValues)
            if let attributeValuesWrappedContainer = attributeValuesWrappedContainer {
                let attributeValuesContainer = try attributeValuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var attributeValuesBuffer:[String]? = nil
                if let attributeValuesContainer = attributeValuesContainer {
                    attributeValuesBuffer = [String]()
                    for stringContainer0 in attributeValuesContainer {
                        attributeValuesBuffer?.append(stringContainer0)
                    }
                }
                attributeValues = attributeValuesBuffer
            } else {
                attributeValues = []
            }
        } else {
            attributeValues = nil
        }
    }
}

extension DBClusterSnapshotAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterSnapshotAttribute(attributeName: \(String(describing: attributeName)), attributeValues: \(String(describing: attributeValues)))"}
}

/// <p>Contains the name and values of a manual DB cluster snapshot attribute.</p>
///         <p>Manual DB cluster snapshot attributes are used to authorize other AWS accounts
///             to restore a manual DB cluster snapshot. For more information, see the <code>ModifyDBClusterSnapshotAttribute</code>
///             API action.</p>
public struct DBClusterSnapshotAttribute: Equatable {
    /// <p>The name of the manual DB cluster snapshot attribute.</p>
    ///         <p>The attribute named <code>restore</code> refers to the list of AWS accounts that
    ///             have permission to copy or restore the manual DB cluster snapshot. For more information,
    ///             see the <code>ModifyDBClusterSnapshotAttribute</code>
    ///             API action.</p>
    public let attributeName: String?
    /// <p>The value(s) for the manual DB cluster snapshot attribute.</p>
    ///         <p>If the <code>AttributeName</code> field is set to <code>restore</code>, then this element
    ///             returns a list of IDs of the AWS accounts that are authorized to copy or restore the manual
    ///             DB cluster snapshot. If a value of <code>all</code> is in the list, then the manual DB cluster snapshot
    ///             is public and available for any AWS account to copy or restore.</p>
    public let attributeValues: [String]?

    public init (
        attributeName: String? = nil,
        attributeValues: [String]? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValues = attributeValues
    }
}

extension DBClusterSnapshotAttributesResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshotAttributes = "DBClusterSnapshotAttributes"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterSnapshotAttributes = dBClusterSnapshotAttributes {
            var dBClusterSnapshotAttributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBClusterSnapshotAttributes"))
            for (index0, dbclustersnapshotattribute0) in dBClusterSnapshotAttributes.enumerated() {
                try dBClusterSnapshotAttributesContainer.encode(dbclustersnapshotattribute0, forKey: Key("DBClusterSnapshotAttribute.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        if containerValues.contains(.dBClusterSnapshotAttributes) {
            struct KeyVal0{struct DBClusterSnapshotAttribute{}}
            let dBClusterSnapshotAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterSnapshotAttribute>.CodingKeys.self, forKey: .dBClusterSnapshotAttributes)
            if let dBClusterSnapshotAttributesWrappedContainer = dBClusterSnapshotAttributesWrappedContainer {
                let dBClusterSnapshotAttributesContainer = try dBClusterSnapshotAttributesWrappedContainer.decodeIfPresent([DBClusterSnapshotAttribute].self, forKey: .member)
                var dBClusterSnapshotAttributesBuffer:[DBClusterSnapshotAttribute]? = nil
                if let dBClusterSnapshotAttributesContainer = dBClusterSnapshotAttributesContainer {
                    dBClusterSnapshotAttributesBuffer = [DBClusterSnapshotAttribute]()
                    for structureContainer0 in dBClusterSnapshotAttributesContainer {
                        dBClusterSnapshotAttributesBuffer?.append(structureContainer0)
                    }
                }
                dBClusterSnapshotAttributes = dBClusterSnapshotAttributesBuffer
            } else {
                dBClusterSnapshotAttributes = []
            }
        } else {
            dBClusterSnapshotAttributes = nil
        }
    }
}

extension DBClusterSnapshotAttributesResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterSnapshotAttributesResult(dBClusterSnapshotAttributes: \(String(describing: dBClusterSnapshotAttributes)), dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)))"}
}

/// <p>Contains the results of a successful call to the <code>DescribeDBClusterSnapshotAttributes</code>
///             API action.</p>
///         <p>Manual DB cluster snapshot attributes are used to authorize other AWS accounts
///             to copy or restore a manual DB cluster snapshot. For more information, see the <code>ModifyDBClusterSnapshotAttribute</code>
///             API action.</p>
public struct DBClusterSnapshotAttributesResult: Equatable {
    /// <p>The list of attributes and values for the manual DB cluster snapshot.</p>
    public let dBClusterSnapshotAttributes: [DBClusterSnapshotAttribute]?
    /// <p>The identifier of the manual DB cluster snapshot that the attributes apply to.</p>
    public let dBClusterSnapshotIdentifier: String?

    public init (
        dBClusterSnapshotAttributes: [DBClusterSnapshotAttribute]? = nil,
        dBClusterSnapshotIdentifier: String? = nil
    )
    {
        self.dBClusterSnapshotAttributes = dBClusterSnapshotAttributes
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

extension DBClusterSnapshotNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterSnapshotNotFoundFault(message: \(String(describing: message)))"}
}

extension DBClusterSnapshotNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>DBClusterSnapshotIdentifier</code> doesn't refer to an existing DB cluster snapshot.
///         </p>
public struct DBClusterSnapshotNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterSnapshotNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBClusterSnapshotNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBEngineVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case defaultCharacterSet = "DefaultCharacterSet"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case status = "Status"
        case supportedCharacterSets = "SupportedCharacterSets"
        case supportedEngineModes = "SupportedEngineModes"
        case supportedFeatureNames = "SupportedFeatureNames"
        case supportedNcharCharacterSets = "SupportedNcharCharacterSets"
        case supportedTimezones = "SupportedTimezones"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case supportsParallelQuery = "SupportsParallelQuery"
        case supportsReadReplica = "SupportsReadReplica"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBEngineDescription = dBEngineDescription {
            try container.encode(dBEngineDescription, forKey: Key("DBEngineDescription"))
        }
        if let dBEngineVersionDescription = dBEngineVersionDescription {
            try container.encode(dBEngineVersionDescription, forKey: Key("DBEngineVersionDescription"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let defaultCharacterSet = defaultCharacterSet {
            try container.encode(defaultCharacterSet, forKey: Key("DefaultCharacterSet"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let exportableLogTypes = exportableLogTypes {
            var exportableLogTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExportableLogTypes"))
            for (index0, string0) in exportableLogTypes.enumerated() {
                try exportableLogTypesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let supportedCharacterSets = supportedCharacterSets {
            var supportedCharacterSetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedCharacterSets"))
            for (index0, characterset0) in supportedCharacterSets.enumerated() {
                try supportedCharacterSetsContainer.encode(characterset0, forKey: Key("CharacterSet.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedFeatureNames = supportedFeatureNames {
            var supportedFeatureNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedFeatureNames"))
            for (index0, string0) in supportedFeatureNames.enumerated() {
                try supportedFeatureNamesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedNcharCharacterSets = supportedNcharCharacterSets {
            var supportedNcharCharacterSetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedNcharCharacterSets"))
            for (index0, characterset0) in supportedNcharCharacterSets.enumerated() {
                try supportedNcharCharacterSetsContainer.encode(characterset0, forKey: Key("CharacterSet.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedTimezones = supportedTimezones {
            var supportedTimezonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedTimezones"))
            for (index0, timezone0) in supportedTimezones.enumerated() {
                try supportedTimezonesContainer.encode(timezone0, forKey: Key("Timezone.\(index0.advanced(by: 1))"))
            }
        }
        if supportsGlobalDatabases != false {
            try container.encode(supportsGlobalDatabases, forKey: Key("SupportsGlobalDatabases"))
        }
        if supportsLogExportsToCloudwatchLogs != false {
            try container.encode(supportsLogExportsToCloudwatchLogs, forKey: Key("SupportsLogExportsToCloudwatchLogs"))
        }
        if supportsParallelQuery != false {
            try container.encode(supportsParallelQuery, forKey: Key("SupportsParallelQuery"))
        }
        if supportsReadReplica != false {
            try container.encode(supportsReadReplica, forKey: Key("SupportsReadReplica"))
        }
        if let validUpgradeTarget = validUpgradeTarget {
            var validUpgradeTargetContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValidUpgradeTarget"))
            for (index0, upgradetarget0) in validUpgradeTarget.enumerated() {
                try validUpgradeTargetContainer.encode(upgradetarget0, forKey: Key("UpgradeTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        let defaultCharacterSetDecoded = try containerValues.decodeIfPresent(CharacterSet.self, forKey: .defaultCharacterSet)
        defaultCharacterSet = defaultCharacterSetDecoded
        if containerValues.contains(.supportedCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedCharacterSets)
            if let supportedCharacterSetsWrappedContainer = supportedCharacterSetsWrappedContainer {
                let supportedCharacterSetsContainer = try supportedCharacterSetsWrappedContainer.decodeIfPresent([CharacterSet].self, forKey: .member)
                var supportedCharacterSetsBuffer:[CharacterSet]? = nil
                if let supportedCharacterSetsContainer = supportedCharacterSetsContainer {
                    supportedCharacterSetsBuffer = [CharacterSet]()
                    for structureContainer0 in supportedCharacterSetsContainer {
                        supportedCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedCharacterSets = supportedCharacterSetsBuffer
            } else {
                supportedCharacterSets = []
            }
        } else {
            supportedCharacterSets = nil
        }
        if containerValues.contains(.supportedNcharCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedNcharCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedNcharCharacterSets)
            if let supportedNcharCharacterSetsWrappedContainer = supportedNcharCharacterSetsWrappedContainer {
                let supportedNcharCharacterSetsContainer = try supportedNcharCharacterSetsWrappedContainer.decodeIfPresent([CharacterSet].self, forKey: .member)
                var supportedNcharCharacterSetsBuffer:[CharacterSet]? = nil
                if let supportedNcharCharacterSetsContainer = supportedNcharCharacterSetsContainer {
                    supportedNcharCharacterSetsBuffer = [CharacterSet]()
                    for structureContainer0 in supportedNcharCharacterSetsContainer {
                        supportedNcharCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedNcharCharacterSets = supportedNcharCharacterSetsBuffer
            } else {
                supportedNcharCharacterSets = []
            }
        } else {
            supportedNcharCharacterSets = nil
        }
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.supportedTimezones) {
            struct KeyVal0{struct Timezone{}}
            let supportedTimezonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Timezone>.CodingKeys.self, forKey: .supportedTimezones)
            if let supportedTimezonesWrappedContainer = supportedTimezonesWrappedContainer {
                let supportedTimezonesContainer = try supportedTimezonesWrappedContainer.decodeIfPresent([Timezone].self, forKey: .member)
                var supportedTimezonesBuffer:[Timezone]? = nil
                if let supportedTimezonesContainer = supportedTimezonesContainer {
                    supportedTimezonesBuffer = [Timezone]()
                    for structureContainer0 in supportedTimezonesContainer {
                        supportedTimezonesBuffer?.append(structureContainer0)
                    }
                }
                supportedTimezones = supportedTimezonesBuffer
            } else {
                supportedTimezones = []
            }
        } else {
            supportedTimezones = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var exportableLogTypesBuffer:[String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
        let supportsReadReplicaDecoded = try containerValues.decode(Bool.self, forKey: .supportsReadReplica)
        supportsReadReplica = supportsReadReplicaDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedEngineModesBuffer:[String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        if containerValues.contains(.supportedFeatureNames) {
            struct KeyVal0{struct member{}}
            let supportedFeatureNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedFeatureNames)
            if let supportedFeatureNamesWrappedContainer = supportedFeatureNamesWrappedContainer {
                let supportedFeatureNamesContainer = try supportedFeatureNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedFeatureNamesBuffer:[String]? = nil
                if let supportedFeatureNamesContainer = supportedFeatureNamesContainer {
                    supportedFeatureNamesBuffer = [String]()
                    for stringContainer0 in supportedFeatureNamesContainer {
                        supportedFeatureNamesBuffer?.append(stringContainer0)
                    }
                }
                supportedFeatureNames = supportedFeatureNamesBuffer
            } else {
                supportedFeatureNames = []
            }
        } else {
            supportedFeatureNames = nil
        }
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let supportsParallelQueryDecoded = try containerValues.decode(Bool.self, forKey: .supportsParallelQuery)
        supportsParallelQuery = supportsParallelQueryDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
    }
}

extension DBEngineVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBEngineVersion(dBEngineDescription: \(String(describing: dBEngineDescription)), dBEngineVersionDescription: \(String(describing: dBEngineVersionDescription)), dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), defaultCharacterSet: \(String(describing: defaultCharacterSet)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), exportableLogTypes: \(String(describing: exportableLogTypes)), status: \(String(describing: status)), supportedCharacterSets: \(String(describing: supportedCharacterSets)), supportedEngineModes: \(String(describing: supportedEngineModes)), supportedFeatureNames: \(String(describing: supportedFeatureNames)), supportedNcharCharacterSets: \(String(describing: supportedNcharCharacterSets)), supportedTimezones: \(String(describing: supportedTimezones)), supportsGlobalDatabases: \(String(describing: supportsGlobalDatabases)), supportsLogExportsToCloudwatchLogs: \(String(describing: supportsLogExportsToCloudwatchLogs)), supportsParallelQuery: \(String(describing: supportsParallelQuery)), supportsReadReplica: \(String(describing: supportsReadReplica)), validUpgradeTarget: \(String(describing: validUpgradeTarget)))"}
}

/// <p>
///             This data type is used as a response element in the action <code>DescribeDBEngineVersions</code>.
///         </p>
public struct DBEngineVersion: Equatable {
    /// <p>The description of the database engine.</p>
    public let dBEngineDescription: String?
    /// <p>The description of the database engine version.</p>
    public let dBEngineVersionDescription: String?
    /// <p>The name of the DB parameter group family for the database engine.</p>
    public let dBParameterGroupFamily: String?
    /// <p>
    ///             The default character set for new instances of this engine version,
    ///             if the <code>CharacterSetName</code> parameter of the CreateDBInstance API
    ///             isn't specified.
    ///         </p>
    public let defaultCharacterSet: CharacterSet?
    /// <p>The name of the database engine.</p>
    public let engine: String?
    /// <p>The version number of the database engine.</p>
    public let engineVersion: String?
    /// <p>The types of logs that the database engine has available for export to CloudWatch Logs.</p>
    public let exportableLogTypes: [String]?
    /// <p>The status of the DB engine version, either <code>available</code> or <code>deprecated</code>.</p>
    public let status: String?
    /// <p>A list of the character sets supported by this engine for the <code>CharacterSetName</code> parameter of the <code>CreateDBInstance</code> operation.
    ///       </p>
    public let supportedCharacterSets: [CharacterSet]?
    /// <p>A list of the supported DB engine modes.</p>
    public let supportedEngineModes: [String]?
    /// <p>
    ///         A list of features supported by the DB engine. Supported feature names include the following.
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>s3Import</p>
    ///             </li>
    ///          </ul>
    public let supportedFeatureNames: [String]?
    /// <p>A list of the character sets supported by the Oracle DB engine for the <code>NcharCharacterSetName</code> parameter of the <code>CreateDBInstance</code> operation.
    ///       </p>
    public let supportedNcharCharacterSets: [CharacterSet]?
    /// <p>A list of the time zones supported by this engine for the
    ///             <code>Timezone</code> parameter of the <code>CreateDBInstance</code> action.
    ///         </p>
    public let supportedTimezones: [Timezone]?
    /// <p>A value that indicates whether you can use Aurora global databases with a specific DB engine version.</p>
    public let supportsGlobalDatabases: Bool
    /// <p>A value that indicates whether the engine version supports exporting the log types specified by ExportableLogTypes to CloudWatch Logs.</p>
    public let supportsLogExportsToCloudwatchLogs: Bool
    /// <p>A value that indicates whether you can use Aurora parallel query with a specific DB engine version.</p>
    public let supportsParallelQuery: Bool
    /// <p>Indicates whether the database engine version supports read replicas.</p>
    public let supportsReadReplica: Bool
    /// <p>A list of engine versions that this database engine version can be upgraded to.</p>
    public let validUpgradeTarget: [UpgradeTarget]?

    public init (
        dBEngineDescription: String? = nil,
        dBEngineVersionDescription: String? = nil,
        dBParameterGroupFamily: String? = nil,
        defaultCharacterSet: CharacterSet? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        exportableLogTypes: [String]? = nil,
        status: String? = nil,
        supportedCharacterSets: [CharacterSet]? = nil,
        supportedEngineModes: [String]? = nil,
        supportedFeatureNames: [String]? = nil,
        supportedNcharCharacterSets: [CharacterSet]? = nil,
        supportedTimezones: [Timezone]? = nil,
        supportsGlobalDatabases: Bool = false,
        supportsLogExportsToCloudwatchLogs: Bool = false,
        supportsParallelQuery: Bool = false,
        supportsReadReplica: Bool = false,
        validUpgradeTarget: [UpgradeTarget]? = nil
    )
    {
        self.dBEngineDescription = dBEngineDescription
        self.dBEngineVersionDescription = dBEngineVersionDescription
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.defaultCharacterSet = defaultCharacterSet
        self.engine = engine
        self.engineVersion = engineVersion
        self.exportableLogTypes = exportableLogTypes
        self.status = status
        self.supportedCharacterSets = supportedCharacterSets
        self.supportedEngineModes = supportedEngineModes
        self.supportedFeatureNames = supportedFeatureNames
        self.supportedNcharCharacterSets = supportedNcharCharacterSets
        self.supportedTimezones = supportedTimezones
        self.supportsGlobalDatabases = supportsGlobalDatabases
        self.supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogs
        self.supportsParallelQuery = supportsParallelQuery
        self.supportsReadReplica = supportsReadReplica
        self.validUpgradeTarget = validUpgradeTarget
    }
}

extension DBInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case awsBackupRecoveryPointArn = "AwsBackupRecoveryPointArn"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case characterSetName = "CharacterSetName"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case customerOwnedIpEnabled = "CustomerOwnedIpEnabled"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBInstanceArn = "DBInstanceArn"
        case dBInstanceAutomatedBackupsReplications = "DBInstanceAutomatedBackupsReplications"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBInstanceStatus = "DBInstanceStatus"
        case dBName = "DBName"
        case dBParameterGroups = "DBParameterGroups"
        case dBSecurityGroups = "DBSecurityGroups"
        case dBSubnetGroup = "DBSubnetGroup"
        case dbInstancePort = "DbInstancePort"
        case dbiResourceId = "DbiResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case enhancedMonitoringResourceArn = "EnhancedMonitoringResourceArn"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case licenseModel = "LicenseModel"
        case listenerEndpoint = "ListenerEndpoint"
        case masterUsername = "MasterUsername"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAZ = "MultiAZ"
        case ncharCharacterSetName = "NcharCharacterSetName"
        case optionGroupMemberships = "OptionGroupMemberships"
        case pendingModifiedValues = "PendingModifiedValues"
        case performanceInsightsEnabled = "PerformanceInsightsEnabled"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case processorFeatures = "ProcessorFeatures"
        case promotionTier = "PromotionTier"
        case publiclyAccessible = "PubliclyAccessible"
        case readReplicaDBClusterIdentifiers = "ReadReplicaDBClusterIdentifiers"
        case readReplicaDBInstanceIdentifiers = "ReadReplicaDBInstanceIdentifiers"
        case readReplicaSourceDBInstanceIdentifier = "ReadReplicaSourceDBInstanceIdentifier"
        case replicaMode = "ReplicaMode"
        case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
        case statusInfos = "StatusInfos"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tagList = "TagList"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AssociatedRoles"))
            for (index0, dbinstancerole0) in associatedRoles.enumerated() {
                try associatedRolesContainer.encode(dbinstancerole0, forKey: Key("DBInstanceRole.\(index0.advanced(by: 1))"))
            }
        }
        if autoMinorVersionUpgrade != false {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let awsBackupRecoveryPointArn = awsBackupRecoveryPointArn {
            try container.encode(awsBackupRecoveryPointArn, forKey: Key("AwsBackupRecoveryPointArn"))
        }
        if backupRetentionPeriod != 0 {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: Key("CACertificateIdentifier"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
        if copyTagsToSnapshot != false {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let customerOwnedIpEnabled = customerOwnedIpEnabled {
            try container.encode(customerOwnedIpEnabled, forKey: Key("CustomerOwnedIpEnabled"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBInstanceArn = dBInstanceArn {
            try container.encode(dBInstanceArn, forKey: Key("DBInstanceArn"))
        }
        if let dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications {
            var dBInstanceAutomatedBackupsReplicationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBInstanceAutomatedBackupsReplications"))
            for (index0, dbinstanceautomatedbackupsreplication0) in dBInstanceAutomatedBackupsReplications.enumerated() {
                try dBInstanceAutomatedBackupsReplicationsContainer.encode(dbinstanceautomatedbackupsreplication0, forKey: Key("DBInstanceAutomatedBackupsReplication.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBInstanceStatus = dBInstanceStatus {
            try container.encode(dBInstanceStatus, forKey: Key("DBInstanceStatus"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: Key("DBName"))
        }
        if let dBParameterGroups = dBParameterGroups {
            var dBParameterGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBParameterGroups"))
            for (index0, dbparametergroupstatus0) in dBParameterGroups.enumerated() {
                try dBParameterGroupsContainer.encode(dbparametergroupstatus0, forKey: Key("DBParameterGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBSecurityGroups"))
            for (index0, dbsecuritygroupmembership0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(dbsecuritygroupmembership0, forKey: Key("DBSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: Key("DBSubnetGroup"))
        }
        if dbInstancePort != 0 {
            try container.encode(dbInstancePort, forKey: Key("DbInstancePort"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: Key("DbiResourceId"))
        }
        if deletionProtection != false {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DomainMemberships"))
            for (index0, domainmembership0) in domainMemberships.enumerated() {
                try domainMembershipsContainer.encode(domainmembership0, forKey: Key("DomainMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let enhancedMonitoringResourceArn = enhancedMonitoringResourceArn {
            try container.encode(enhancedMonitoringResourceArn, forKey: Key("EnhancedMonitoringResourceArn"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let instanceCreateTime = instanceCreateTime {
            try container.encode(TimestampWrapper(instanceCreateTime, format: .dateTime), forKey: Key("instanceCreateTime"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: Key("latestRestorableTime"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let listenerEndpoint = listenerEndpoint {
            try container.encode(listenerEndpoint, forKey: Key("ListenerEndpoint"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: Key("MonitoringRoleArn"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let ncharCharacterSetName = ncharCharacterSetName {
            try container.encode(ncharCharacterSetName, forKey: Key("NcharCharacterSetName"))
        }
        if let optionGroupMemberships = optionGroupMemberships {
            var optionGroupMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionGroupMemberships"))
            for (index0, optiongroupmembership0) in optionGroupMemberships.enumerated() {
                try optionGroupMembershipsContainer.encode(optiongroupmembership0, forKey: Key("OptionGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: Key("PendingModifiedValues"))
        }
        if let performanceInsightsEnabled = performanceInsightsEnabled {
            try container.encode(performanceInsightsEnabled, forKey: Key("PerformanceInsightsEnabled"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: Key("PerformanceInsightsRetentionPeriod"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: Key("PromotionTier"))
        }
        if publiclyAccessible != false {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers {
            var readReplicaDBClusterIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReadReplicaDBClusterIdentifiers"))
            for (index0, string0) in readReplicaDBClusterIdentifiers.enumerated() {
                try readReplicaDBClusterIdentifiersContainer.encode(string0, forKey: Key("ReadReplicaDBClusterIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers {
            var readReplicaDBInstanceIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReadReplicaDBInstanceIdentifiers"))
            for (index0, string0) in readReplicaDBInstanceIdentifiers.enumerated() {
                try readReplicaDBInstanceIdentifiersContainer.encode(string0, forKey: Key("ReadReplicaDBInstanceIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier {
            try container.encode(readReplicaSourceDBInstanceIdentifier, forKey: Key("ReadReplicaSourceDBInstanceIdentifier"))
        }
        if let replicaMode = replicaMode {
            try container.encode(replicaMode, forKey: Key("ReplicaMode"))
        }
        if let secondaryAvailabilityZone = secondaryAvailabilityZone {
            try container.encode(secondaryAvailabilityZone, forKey: Key("SecondaryAvailabilityZone"))
        }
        if let statusInfos = statusInfos {
            var statusInfosContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StatusInfos"))
            for (index0, dbinstancestatusinfo0) in statusInfos.enumerated() {
                try statusInfosContainer.encode(dbinstancestatusinfo0, forKey: Key("DBInstanceStatusInfo.\(index0.advanced(by: 1))"))
            }
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: Key("TdeCredentialArn"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: Key("Timezone"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let dBInstanceStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceStatus)
        dBInstanceStatus = dBInstanceStatusDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceCreateTime)
        var instanceCreateTimeBuffer:Date? = nil
        if let instanceCreateTimeDecoded = instanceCreateTimeDecoded {
            instanceCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(instanceCreateTimeDecoded, format: .dateTime)
        }
        instanceCreateTime = instanceCreateTimeBuffer
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let backupRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        if containerValues.contains(.dBSecurityGroups) {
            struct KeyVal0{struct DBSecurityGroup{}}
            let dBSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroup>.CodingKeys.self, forKey: .dBSecurityGroups)
            if let dBSecurityGroupsWrappedContainer = dBSecurityGroupsWrappedContainer {
                let dBSecurityGroupsContainer = try dBSecurityGroupsWrappedContainer.decodeIfPresent([DBSecurityGroupMembership].self, forKey: .member)
                var dBSecurityGroupsBuffer:[DBSecurityGroupMembership]? = nil
                if let dBSecurityGroupsContainer = dBSecurityGroupsContainer {
                    dBSecurityGroupsBuffer = [DBSecurityGroupMembership]()
                    for structureContainer0 in dBSecurityGroupsContainer {
                        dBSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSecurityGroups = dBSecurityGroupsBuffer
            } else {
                dBSecurityGroups = []
            }
        } else {
            dBSecurityGroups = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        if containerValues.contains(.dBParameterGroups) {
            struct KeyVal0{struct DBParameterGroup{}}
            let dBParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBParameterGroup>.CodingKeys.self, forKey: .dBParameterGroups)
            if let dBParameterGroupsWrappedContainer = dBParameterGroupsWrappedContainer {
                let dBParameterGroupsContainer = try dBParameterGroupsWrappedContainer.decodeIfPresent([DBParameterGroupStatus].self, forKey: .member)
                var dBParameterGroupsBuffer:[DBParameterGroupStatus]? = nil
                if let dBParameterGroupsContainer = dBParameterGroupsContainer {
                    dBParameterGroupsBuffer = [DBParameterGroupStatus]()
                    for structureContainer0 in dBParameterGroupsContainer {
                        dBParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBParameterGroups = dBParameterGroupsBuffer
            } else {
                dBParameterGroups = []
            }
        } else {
            dBParameterGroups = nil
        }
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(PendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let multiAZDecoded = try containerValues.decode(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let readReplicaSourceDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readReplicaSourceDBInstanceIdentifier)
        readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifierDecoded
        if containerValues.contains(.readReplicaDBInstanceIdentifiers) {
            struct KeyVal0{struct ReadReplicaDBInstanceIdentifier{}}
            let readReplicaDBInstanceIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaDBInstanceIdentifier>.CodingKeys.self, forKey: .readReplicaDBInstanceIdentifiers)
            if let readReplicaDBInstanceIdentifiersWrappedContainer = readReplicaDBInstanceIdentifiersWrappedContainer {
                let readReplicaDBInstanceIdentifiersContainer = try readReplicaDBInstanceIdentifiersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var readReplicaDBInstanceIdentifiersBuffer:[String]? = nil
                if let readReplicaDBInstanceIdentifiersContainer = readReplicaDBInstanceIdentifiersContainer {
                    readReplicaDBInstanceIdentifiersBuffer = [String]()
                    for stringContainer0 in readReplicaDBInstanceIdentifiersContainer {
                        readReplicaDBInstanceIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiersBuffer
            } else {
                readReplicaDBInstanceIdentifiers = []
            }
        } else {
            readReplicaDBInstanceIdentifiers = nil
        }
        if containerValues.contains(.readReplicaDBClusterIdentifiers) {
            struct KeyVal0{struct ReadReplicaDBClusterIdentifier{}}
            let readReplicaDBClusterIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaDBClusterIdentifier>.CodingKeys.self, forKey: .readReplicaDBClusterIdentifiers)
            if let readReplicaDBClusterIdentifiersWrappedContainer = readReplicaDBClusterIdentifiersWrappedContainer {
                let readReplicaDBClusterIdentifiersContainer = try readReplicaDBClusterIdentifiersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var readReplicaDBClusterIdentifiersBuffer:[String]? = nil
                if let readReplicaDBClusterIdentifiersContainer = readReplicaDBClusterIdentifiersContainer {
                    readReplicaDBClusterIdentifiersBuffer = [String]()
                    for stringContainer0 in readReplicaDBClusterIdentifiersContainer {
                        readReplicaDBClusterIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiersBuffer
            } else {
                readReplicaDBClusterIdentifiers = []
            }
        } else {
            readReplicaDBClusterIdentifiers = nil
        }
        let replicaModeDecoded = try containerValues.decodeIfPresent(ReplicaMode.self, forKey: .replicaMode)
        replicaMode = replicaModeDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
        if containerValues.contains(.optionGroupMemberships) {
            struct KeyVal0{struct OptionGroupMembership{}}
            let optionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupMembership>.CodingKeys.self, forKey: .optionGroupMemberships)
            if let optionGroupMembershipsWrappedContainer = optionGroupMembershipsWrappedContainer {
                let optionGroupMembershipsContainer = try optionGroupMembershipsWrappedContainer.decodeIfPresent([OptionGroupMembership].self, forKey: .member)
                var optionGroupMembershipsBuffer:[OptionGroupMembership]? = nil
                if let optionGroupMembershipsContainer = optionGroupMembershipsContainer {
                    optionGroupMembershipsBuffer = [OptionGroupMembership]()
                    for structureContainer0 in optionGroupMembershipsContainer {
                        optionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupMemberships = optionGroupMembershipsBuffer
            } else {
                optionGroupMemberships = []
            }
        } else {
            optionGroupMemberships = nil
        }
        let characterSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let ncharCharacterSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ncharCharacterSetName)
        ncharCharacterSetName = ncharCharacterSetNameDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        if containerValues.contains(.statusInfos) {
            struct KeyVal0{struct DBInstanceStatusInfo{}}
            let statusInfosWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceStatusInfo>.CodingKeys.self, forKey: .statusInfos)
            if let statusInfosWrappedContainer = statusInfosWrappedContainer {
                let statusInfosContainer = try statusInfosWrappedContainer.decodeIfPresent([DBInstanceStatusInfo].self, forKey: .member)
                var statusInfosBuffer:[DBInstanceStatusInfo]? = nil
                if let statusInfosContainer = statusInfosContainer {
                    statusInfosBuffer = [DBInstanceStatusInfo]()
                    for structureContainer0 in statusInfosContainer {
                        statusInfosBuffer?.append(structureContainer0)
                    }
                }
                statusInfos = statusInfosBuffer
            } else {
                statusInfos = []
            }
        } else {
            statusInfos = nil
        }
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let dbInstancePortDecoded = try containerValues.decode(Int.self, forKey: .dbInstancePort)
        dbInstancePort = dbInstancePortDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let storageEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        if containerValues.contains(.domainMemberships) {
            struct KeyVal0{struct DomainMembership{}}
            let domainMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DomainMembership>.CodingKeys.self, forKey: .domainMemberships)
            if let domainMembershipsWrappedContainer = domainMembershipsWrappedContainer {
                let domainMembershipsContainer = try domainMembershipsWrappedContainer.decodeIfPresent([DomainMembership].self, forKey: .member)
                var domainMembershipsBuffer:[DomainMembership]? = nil
                if let domainMembershipsContainer = domainMembershipsContainer {
                    domainMembershipsBuffer = [DomainMembership]()
                    for structureContainer0 in domainMembershipsContainer {
                        domainMembershipsBuffer?.append(structureContainer0)
                    }
                }
                domainMemberships = domainMembershipsBuffer
            } else {
                domainMemberships = []
            }
        } else {
            domainMemberships = nil
        }
        let copyTagsToSnapshotDecoded = try containerValues.decode(Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let enhancedMonitoringResourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .enhancedMonitoringResourceArn)
        enhancedMonitoringResourceArn = enhancedMonitoringResourceArnDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
        let dBInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceArn)
        dBInstanceArn = dBInstanceArnDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let performanceInsightsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .performanceInsightsEnabled)
        performanceInsightsEnabled = performanceInsightsEnabledDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let deletionProtectionDecoded = try containerValues.decode(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        if containerValues.contains(.associatedRoles) {
            struct KeyVal0{struct DBInstanceRole{}}
            let associatedRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceRole>.CodingKeys.self, forKey: .associatedRoles)
            if let associatedRolesWrappedContainer = associatedRolesWrappedContainer {
                let associatedRolesContainer = try associatedRolesWrappedContainer.decodeIfPresent([DBInstanceRole].self, forKey: .member)
                var associatedRolesBuffer:[DBInstanceRole]? = nil
                if let associatedRolesContainer = associatedRolesContainer {
                    associatedRolesBuffer = [DBInstanceRole]()
                    for structureContainer0 in associatedRolesContainer {
                        associatedRolesBuffer?.append(structureContainer0)
                    }
                }
                associatedRoles = associatedRolesBuffer
            } else {
                associatedRoles = []
            }
        } else {
            associatedRoles = nil
        }
        let listenerEndpointDecoded = try containerValues.decodeIfPresent(Endpoint.self, forKey: .listenerEndpoint)
        listenerEndpoint = listenerEndpointDecoded
        let maxAllocatedStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxAllocatedStorage)
        maxAllocatedStorage = maxAllocatedStorageDecoded
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagListBuffer:[Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        if containerValues.contains(.dBInstanceAutomatedBackupsReplications) {
            struct KeyVal0{struct DBInstanceAutomatedBackupsReplication{}}
            let dBInstanceAutomatedBackupsReplicationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceAutomatedBackupsReplication>.CodingKeys.self, forKey: .dBInstanceAutomatedBackupsReplications)
            if let dBInstanceAutomatedBackupsReplicationsWrappedContainer = dBInstanceAutomatedBackupsReplicationsWrappedContainer {
                let dBInstanceAutomatedBackupsReplicationsContainer = try dBInstanceAutomatedBackupsReplicationsWrappedContainer.decodeIfPresent([DBInstanceAutomatedBackupsReplication].self, forKey: .member)
                var dBInstanceAutomatedBackupsReplicationsBuffer:[DBInstanceAutomatedBackupsReplication]? = nil
                if let dBInstanceAutomatedBackupsReplicationsContainer = dBInstanceAutomatedBackupsReplicationsContainer {
                    dBInstanceAutomatedBackupsReplicationsBuffer = [DBInstanceAutomatedBackupsReplication]()
                    for structureContainer0 in dBInstanceAutomatedBackupsReplicationsContainer {
                        dBInstanceAutomatedBackupsReplicationsBuffer?.append(structureContainer0)
                    }
                }
                dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplicationsBuffer
            } else {
                dBInstanceAutomatedBackupsReplications = []
            }
        } else {
            dBInstanceAutomatedBackupsReplications = nil
        }
        let customerOwnedIpEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .customerOwnedIpEnabled)
        customerOwnedIpEnabled = customerOwnedIpEnabledDecoded
        let awsBackupRecoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsBackupRecoveryPointArn)
        awsBackupRecoveryPointArn = awsBackupRecoveryPointArnDecoded
    }
}

extension DBInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstance(allocatedStorage: \(String(describing: allocatedStorage)), associatedRoles: \(String(describing: associatedRoles)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), availabilityZone: \(String(describing: availabilityZone)), awsBackupRecoveryPointArn: \(String(describing: awsBackupRecoveryPointArn)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(String(describing: cACertificateIdentifier)), characterSetName: \(String(describing: characterSetName)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), customerOwnedIpEnabled: \(String(describing: customerOwnedIpEnabled)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBInstanceArn: \(String(describing: dBInstanceArn)), dBInstanceAutomatedBackupsReplications: \(String(describing: dBInstanceAutomatedBackupsReplications)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBInstanceStatus: \(String(describing: dBInstanceStatus)), dBName: \(String(describing: dBName)), dBParameterGroups: \(String(describing: dBParameterGroups)), dBSecurityGroups: \(String(describing: dBSecurityGroups)), dBSubnetGroup: \(String(describing: dBSubnetGroup)), dbInstancePort: \(String(describing: dbInstancePort)), dbiResourceId: \(String(describing: dbiResourceId)), deletionProtection: \(String(describing: deletionProtection)), domainMemberships: \(String(describing: domainMemberships)), enabledCloudwatchLogsExports: \(String(describing: enabledCloudwatchLogsExports)), endpoint: \(String(describing: endpoint)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), enhancedMonitoringResourceArn: \(String(describing: enhancedMonitoringResourceArn)), iAMDatabaseAuthenticationEnabled: \(String(describing: iAMDatabaseAuthenticationEnabled)), instanceCreateTime: \(String(describing: instanceCreateTime)), iops: \(String(describing: iops)), kmsKeyId: \(String(describing: kmsKeyId)), latestRestorableTime: \(String(describing: latestRestorableTime)), licenseModel: \(String(describing: licenseModel)), listenerEndpoint: \(String(describing: listenerEndpoint)), masterUsername: \(String(describing: masterUsername)), maxAllocatedStorage: \(String(describing: maxAllocatedStorage)), monitoringInterval: \(String(describing: monitoringInterval)), monitoringRoleArn: \(String(describing: monitoringRoleArn)), multiAZ: \(String(describing: multiAZ)), ncharCharacterSetName: \(String(describing: ncharCharacterSetName)), optionGroupMemberships: \(String(describing: optionGroupMemberships)), pendingModifiedValues: \(String(describing: pendingModifiedValues)), performanceInsightsEnabled: \(String(describing: performanceInsightsEnabled)), performanceInsightsKMSKeyId: \(String(describing: performanceInsightsKMSKeyId)), performanceInsightsRetentionPeriod: \(String(describing: performanceInsightsRetentionPeriod)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), processorFeatures: \(String(describing: processorFeatures)), promotionTier: \(String(describing: promotionTier)), publiclyAccessible: \(String(describing: publiclyAccessible)), readReplicaDBClusterIdentifiers: \(String(describing: readReplicaDBClusterIdentifiers)), readReplicaDBInstanceIdentifiers: \(String(describing: readReplicaDBInstanceIdentifiers)), readReplicaSourceDBInstanceIdentifier: \(String(describing: readReplicaSourceDBInstanceIdentifier)), replicaMode: \(String(describing: replicaMode)), secondaryAvailabilityZone: \(String(describing: secondaryAvailabilityZone)), statusInfos: \(String(describing: statusInfos)), storageEncrypted: \(String(describing: storageEncrypted)), storageType: \(String(describing: storageType)), tagList: \(String(describing: tagList)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), timezone: \(String(describing: timezone)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

/// <p>Contains the details of an Amazon RDS DB instance.
///       </p>
///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
///       </p>
public struct DBInstance: Equatable {
    /// <p>Specifies the allocated storage size specified in gibibytes.</p>
    public let allocatedStorage: Int
    /// <p>
    ///             The AWS Identity and Access Management (IAM) roles associated with the DB instance.
    ///         </p>
    public let associatedRoles: [DBInstanceRole]?
    /// <p>A value that indicates that minor version patches are applied automatically.</p>
    public let autoMinorVersionUpgrade: Bool
    /// <p>Specifies the name of the Availability Zone the DB instance is located in.</p>
    public let availabilityZone: String?
    /// <p>The Amazon Resource Name (ARN) of the recovery point in AWS Backup.</p>
    public let awsBackupRecoveryPointArn: String?
    /// <p>Specifies the number of days for which automatic DB snapshots are retained.</p>
    public let backupRetentionPeriod: Int
    /// <p>The identifier of the CA certificate for this DB instance.</p>
    public let cACertificateIdentifier: String?
    /// <p>If present, specifies the name of the character set that this instance is associated with.</p>
    public let characterSetName: String?
    /// <p>Specifies whether tags are copied from the DB instance to snapshots of the DB instance.</p>
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this
    ///             value for an Aurora DB instance has no effect on the DB cluster setting. For more
    ///             information, see <code>DBCluster</code>.</p>
    public let copyTagsToSnapshot: Bool
    /// <p>Specifies whether a customer-owned IP address (CoIP) is enabled for an RDS on Outposts DB instance.</p>
    ///         <p>A <i>CoIP </i>provides local or external connectivity to resources in
    ///             your Outpost subnets through your on-premises network. For some use cases, a CoIP can
    ///             provide lower latency for connections to the DB instance from outside of its virtual
    ///             private cloud (VPC) on your local network.</p>
    ///         <p>For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Working with Amazon RDS on AWS Outposts</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    ///         <p>For more information about CoIPs, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing">Customer-owned IP addresses</a>
    ///             in the <i>AWS Outposts User Guide</i>.</p>
    public let customerOwnedIpEnabled: Bool?
    /// <p>If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.</p>
    public let dBClusterIdentifier: String?
    /// <p>The Amazon Resource Name (ARN) for the DB instance.</p>
    public let dBInstanceArn: String?
    /// <p>The list of replicated automated backups associated with the DB instance.</p>
    public let dBInstanceAutomatedBackupsReplications: [DBInstanceAutomatedBackupsReplication]?
    /// <p>Contains the name of the compute and memory capacity class of the DB instance.</p>
    public let dBInstanceClass: String?
    /// <p>Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.</p>
    public let dBInstanceIdentifier: String?
    /// <p>Specifies the current state of this database.</p>
    ///          <p>For information about DB instance statuses, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/accessing-monitoring.html#Overview.DBInstance.Status">Viewing DB instance status</a>
    ///           in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let dBInstanceStatus: String?
    /// <p>The meaning of this parameter differs according to the database engine you use.</p>
    ///          <p>
    ///             <b>MySQL, MariaDB, SQL Server, PostgreSQL</b>
    ///          </p>
    ///          <p>Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance.</p>
    ///          <p>Type: String</p>
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///          <p>Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters do not apply to an Oracle DB instance.</p>
    public let dBName: String?
    /// <p>Provides the list of DB parameter groups applied to this DB instance.</p>
    public let dBParameterGroups: [DBParameterGroupStatus]?
    /// <p>
    ///         A list of DB security group elements containing
    ///         <code>DBSecurityGroup.Name</code> and <code>DBSecurityGroup.Status</code> subelements.
    ///         </p>
    public let dBSecurityGroups: [DBSecurityGroupMembership]?
    /// <p>Specifies information on the subnet group associated with the DB instance, including the name, description, and subnets in the subnet group.</p>
    public let dBSubnetGroup: DBSubnetGroup?
    /// <p>Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.</p>
    public let dbInstancePort: Int
    /// <p>The AWS Region-unique, immutable identifier for the DB instance. This identifier is found in AWS CloudTrail log
    ///           entries whenever the AWS KMS customer master key (CMK) for the DB instance is accessed.</p>
    public let dbiResourceId: String?
    /// <p>Indicates if the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled.
    ///             For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance</a>.
    ///         </p>
    public let deletionProtection: Bool
    /// <p>The Active Directory Domain membership records associated with the DB instance.</p>
    public let domainMemberships: [DomainMembership]?
    /// <p>A list of log types that this DB instance is configured to export to CloudWatch Logs.</p>
    ///         <p>Log types vary by DB engine. For information about the log types for each DB engine, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html">Amazon RDS Database Log Files</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let enabledCloudwatchLogsExports: [String]?
    /// <p>Specifies the connection endpoint.</p>
    public let endpoint: Endpoint?
    /// <p>The name of the database engine to be used for this DB instance.</p>
    public let engine: String?
    /// <p>Indicates the database engine version.</p>
    public let engineVersion: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log stream that receives the Enhanced Monitoring metrics data for the DB instance.</p>
    public let enhancedMonitoringResourceArn: String?
    /// <p>True if mapping of AWS Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.</p>
    ///
    ///          <p>IAM database authentication can be enabled for the following database engines</p>
    ///          <ul>
    ///             <li>
    ///                <p>For MySQL 5.6, minor version 5.6.34 or higher</p>
    ///             </li>
    ///             <li>
    ///                <p>For MySQL 5.7, minor version 5.7.16 or higher</p>
    ///             </li>
    ///             <li>
    ///                <p>Aurora 5.6 or higher. To enable IAM database authentication for Aurora, see DBCluster Type.</p>
    ///             </li>
    ///          </ul>
    public let iAMDatabaseAuthenticationEnabled: Bool
    /// <p>Provides the date and time the DB instance was created.</p>
    public let instanceCreateTime: Date?
    /// <p>Specifies the Provisioned IOPS (I/O operations per second) value.</p>
    public let iops: Int?
    /// <p>
    ///             If <code>StorageEncrypted</code> is true, the AWS KMS key identifier
    ///             for the encrypted DB instance.
    ///         </p>
    ///          <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    public let kmsKeyId: String?
    /// <p>Specifies the latest time to which a database can be restored with point-in-time restore.</p>
    public let latestRestorableTime: Date?
    /// <p>License model information for this DB instance.</p>
    public let licenseModel: String?
    /// <p>Specifies the listener connection endpoint for SQL Server Always On.</p>
    public let listenerEndpoint: Endpoint?
    /// <p>Contains the master username for the DB instance.</p>
    public let masterUsername: String?
    /// <p>The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.</p>
    public let maxAllocatedStorage: Int?
    /// <p>The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance.</p>
    public let monitoringInterval: Int?
    /// <p>The ARN for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.</p>
    public let monitoringRoleArn: String?
    /// <p>Specifies if the DB instance is a Multi-AZ deployment.</p>
    public let multiAZ: Bool
    /// <p>The name of the NCHAR character set for the Oracle DB instance. This character set specifies the
    ///             Unicode encoding for data stored in table columns of type NCHAR, NCLOB, or NVARCHAR2.
    ///         </p>
    public let ncharCharacterSetName: String?
    /// <p>Provides the list of option group memberships for this DB instance.</p>
    public let optionGroupMemberships: [OptionGroupMembership]?
    /// <p>A value that specifies that changes to the DB instance are pending. This element is only included when changes are pending. Specific changes are identified by subelements.</p>
    public let pendingModifiedValues: PendingModifiedValues?
    /// <p>True if Performance Insights is enabled for the DB instance, and otherwise false.</p>
    public let performanceInsightsEnabled: Bool?
    /// <p>The AWS KMS key identifier for encryption of Performance Insights data.</p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    public let performanceInsightsKMSKeyId: String?
    /// <p>The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years). </p>
    public let performanceInsightsRetentionPeriod: Int?
    /// <p>
    ///         Specifies the daily time range during which automated backups are
    ///         created if automated backups are enabled, as determined
    ///         by the <code>BackupRetentionPeriod</code>.
    ///         </p>
    public let preferredBackupWindow: String?
    /// <p>Specifies the weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    public let processorFeatures: [ProcessorFeature]?
    /// <p>A value that specifies the order in which an Aurora Replica is promoted to the primary instance
    ///       after a failure of the existing primary instance. For more information,
    ///       see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance">
    ///           Fault Tolerance for an Aurora DB Cluster</a> in the <i>Amazon Aurora User Guide</i>.
    ///     </p>
    public let promotionTier: Int?
    /// <p>Specifies the accessibility options for the DB instance.</p>
    ///          <p>When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///           and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///           and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.</p>
    ///          <p>When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.</p>
    ///          <p>For more information, see <a>CreateDBInstance</a>.</p>
    public let publiclyAccessible: Bool
    /// <p>Contains one or more identifiers of Aurora DB clusters to which the RDS DB instance
    ///             is replicated as a read replica. For example, when you create an Aurora read replica of
    ///             an RDS MySQL DB instance, the Aurora MySQL DB cluster for the Aurora read replica is
    ///             shown. This output does not contain information about cross region Aurora read
    ///             replicas.</p>
    ///         <note>
    ///             <p>Currently, each RDS DB instance can have only one Aurora read replica.</p>
    ///         </note>
    public let readReplicaDBClusterIdentifiers: [String]?
    /// <p>Contains one or more identifiers of the read replicas associated with this DB
    ///             instance.</p>
    public let readReplicaDBInstanceIdentifiers: [String]?
    /// <p>Contains the identifier of the source DB instance if this DB instance is a read
    ///             replica.</p>
    public let readReplicaSourceDBInstanceIdentifier: String?
    /// <p>The open mode of an Oracle read replica. The default is <code>open-read-only</code>.
    ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html">Working with Oracle Read Replicas for Amazon RDS</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    ///         <note>
    ///             <p>This attribute is only supported in RDS for Oracle.</p>
    ///         </note>
    public let replicaMode: ReplicaMode?
    /// <p>If present, specifies the name of the secondary Availability Zone for a DB instance with multi-AZ support.</p>
    public let secondaryAvailabilityZone: String?
    /// <p>The status of a read replica. If the instance isn't a read replica, this is
    ///             blank.</p>
    public let statusInfos: [DBInstanceStatusInfo]?
    /// <p>Specifies whether the DB instance is encrypted.</p>
    public let storageEncrypted: Bool
    /// <p>Specifies the storage type associated with DB instance.</p>
    public let storageType: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tagList: [Tag]?
    /// <p>The ARN from the key store with which the instance is associated for TDE encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>The time zone of the DB instance.
    ///             In most cases, the <code>Timezone</code> element is empty.
    ///             <code>Timezone</code> content appears only for
    ///             Microsoft SQL Server DB instances
    ///             that were created with a time zone specified.
    ///         </p>
    public let timezone: String?
    /// <p>Provides a list of VPC security group elements that the DB instance belongs to.</p>
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

    public init (
        allocatedStorage: Int = 0,
        associatedRoles: [DBInstanceRole]? = nil,
        autoMinorVersionUpgrade: Bool = false,
        availabilityZone: String? = nil,
        awsBackupRecoveryPointArn: String? = nil,
        backupRetentionPeriod: Int = 0,
        cACertificateIdentifier: String? = nil,
        characterSetName: String? = nil,
        copyTagsToSnapshot: Bool = false,
        customerOwnedIpEnabled: Bool? = nil,
        dBClusterIdentifier: String? = nil,
        dBInstanceArn: String? = nil,
        dBInstanceAutomatedBackupsReplications: [DBInstanceAutomatedBackupsReplication]? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBInstanceStatus: String? = nil,
        dBName: String? = nil,
        dBParameterGroups: [DBParameterGroupStatus]? = nil,
        dBSecurityGroups: [DBSecurityGroupMembership]? = nil,
        dBSubnetGroup: DBSubnetGroup? = nil,
        dbInstancePort: Int = 0,
        dbiResourceId: String? = nil,
        deletionProtection: Bool = false,
        domainMemberships: [DomainMembership]? = nil,
        enabledCloudwatchLogsExports: [String]? = nil,
        endpoint: Endpoint? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        enhancedMonitoringResourceArn: String? = nil,
        iAMDatabaseAuthenticationEnabled: Bool = false,
        instanceCreateTime: Date? = nil,
        iops: Int? = nil,
        kmsKeyId: String? = nil,
        latestRestorableTime: Date? = nil,
        licenseModel: String? = nil,
        listenerEndpoint: Endpoint? = nil,
        masterUsername: String? = nil,
        maxAllocatedStorage: Int? = nil,
        monitoringInterval: Int? = nil,
        monitoringRoleArn: String? = nil,
        multiAZ: Bool = false,
        ncharCharacterSetName: String? = nil,
        optionGroupMemberships: [OptionGroupMembership]? = nil,
        pendingModifiedValues: PendingModifiedValues? = nil,
        performanceInsightsEnabled: Bool? = nil,
        performanceInsightsKMSKeyId: String? = nil,
        performanceInsightsRetentionPeriod: Int? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        processorFeatures: [ProcessorFeature]? = nil,
        promotionTier: Int? = nil,
        publiclyAccessible: Bool = false,
        readReplicaDBClusterIdentifiers: [String]? = nil,
        readReplicaDBInstanceIdentifiers: [String]? = nil,
        readReplicaSourceDBInstanceIdentifier: String? = nil,
        replicaMode: ReplicaMode? = nil,
        secondaryAvailabilityZone: String? = nil,
        statusInfos: [DBInstanceStatusInfo]? = nil,
        storageEncrypted: Bool = false,
        storageType: String? = nil,
        tagList: [Tag]? = nil,
        tdeCredentialArn: String? = nil,
        timezone: String? = nil,
        vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.associatedRoles = associatedRoles
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cACertificateIdentifier = cACertificateIdentifier
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.customerOwnedIpEnabled = customerOwnedIpEnabled
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBInstanceArn = dBInstanceArn
        self.dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBInstanceStatus = dBInstanceStatus
        self.dBName = dBName
        self.dBParameterGroups = dBParameterGroups
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroup = dBSubnetGroup
        self.dbInstancePort = dbInstancePort
        self.dbiResourceId = dbiResourceId
        self.deletionProtection = deletionProtection
        self.domainMemberships = domainMemberships
        self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
        self.endpoint = endpoint
        self.engine = engine
        self.engineVersion = engineVersion
        self.enhancedMonitoringResourceArn = enhancedMonitoringResourceArn
        self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
        self.instanceCreateTime = instanceCreateTime
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.latestRestorableTime = latestRestorableTime
        self.licenseModel = licenseModel
        self.listenerEndpoint = listenerEndpoint
        self.masterUsername = masterUsername
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.ncharCharacterSetName = ncharCharacterSetName
        self.optionGroupMemberships = optionGroupMemberships
        self.pendingModifiedValues = pendingModifiedValues
        self.performanceInsightsEnabled = performanceInsightsEnabled
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.processorFeatures = processorFeatures
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers
        self.readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers
        self.readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier
        self.replicaMode = replicaMode
        self.secondaryAvailabilityZone = secondaryAvailabilityZone
        self.statusInfos = statusInfos
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tagList = tagList
        self.tdeCredentialArn = tdeCredentialArn
        self.timezone = timezone
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

extension DBInstanceAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBInstanceAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBInstanceAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user already has a DB instance with the given identifier.</p>
public struct DBInstanceAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBInstanceAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceAutomatedBackup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZone = "AvailabilityZone"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case dBInstanceArn = "DBInstanceArn"
        case dBInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
        case dBInstanceAutomatedBackupsReplications = "DBInstanceAutomatedBackupsReplications"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dbiResourceId = "DbiResourceId"
        case encrypted = "Encrypted"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case optionGroupName = "OptionGroupName"
        case port = "Port"
        case region = "Region"
        case restoreWindow = "RestoreWindow"
        case status = "Status"
        case storageType = "StorageType"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let dBInstanceArn = dBInstanceArn {
            try container.encode(dBInstanceArn, forKey: Key("DBInstanceArn"))
        }
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: Key("DBInstanceAutomatedBackupsArn"))
        }
        if let dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications {
            var dBInstanceAutomatedBackupsReplicationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBInstanceAutomatedBackupsReplications"))
            for (index0, dbinstanceautomatedbackupsreplication0) in dBInstanceAutomatedBackupsReplications.enumerated() {
                try dBInstanceAutomatedBackupsReplicationsContainer.encode(dbinstanceautomatedbackupsreplication0, forKey: Key("DBInstanceAutomatedBackupsReplication.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: Key("DbiResourceId"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: Key("Encrypted"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let instanceCreateTime = instanceCreateTime {
            try container.encode(TimestampWrapper(instanceCreateTime, format: .dateTime), forKey: Key("instanceCreateTime"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
        if let region = region {
            try container.encode(region, forKey: Key("Region"))
        }
        if let restoreWindow = restoreWindow {
            try container.encode(restoreWindow, forKey: Key("RestoreWindow"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: Key("TdeCredentialArn"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: Key("Timezone"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceArn)
        dBInstanceArn = dBInstanceArnDecoded
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let restoreWindowDecoded = try containerValues.decodeIfPresent(RestoreWindow.self, forKey: .restoreWindow)
        restoreWindow = restoreWindowDecoded
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceCreateTime)
        var instanceCreateTimeBuffer:Date? = nil
        if let instanceCreateTimeDecoded = instanceCreateTimeDecoded {
            instanceCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(instanceCreateTimeDecoded, format: .dateTime)
        }
        instanceCreateTime = instanceCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let encryptedDecoded = try containerValues.decode(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let dBInstanceAutomatedBackupsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceAutomatedBackupsArn)
        dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArnDecoded
        if containerValues.contains(.dBInstanceAutomatedBackupsReplications) {
            struct KeyVal0{struct DBInstanceAutomatedBackupsReplication{}}
            let dBInstanceAutomatedBackupsReplicationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceAutomatedBackupsReplication>.CodingKeys.self, forKey: .dBInstanceAutomatedBackupsReplications)
            if let dBInstanceAutomatedBackupsReplicationsWrappedContainer = dBInstanceAutomatedBackupsReplicationsWrappedContainer {
                let dBInstanceAutomatedBackupsReplicationsContainer = try dBInstanceAutomatedBackupsReplicationsWrappedContainer.decodeIfPresent([DBInstanceAutomatedBackupsReplication].self, forKey: .member)
                var dBInstanceAutomatedBackupsReplicationsBuffer:[DBInstanceAutomatedBackupsReplication]? = nil
                if let dBInstanceAutomatedBackupsReplicationsContainer = dBInstanceAutomatedBackupsReplicationsContainer {
                    dBInstanceAutomatedBackupsReplicationsBuffer = [DBInstanceAutomatedBackupsReplication]()
                    for structureContainer0 in dBInstanceAutomatedBackupsReplicationsContainer {
                        dBInstanceAutomatedBackupsReplicationsBuffer?.append(structureContainer0)
                    }
                }
                dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplicationsBuffer
            } else {
                dBInstanceAutomatedBackupsReplications = []
            }
        } else {
            dBInstanceAutomatedBackupsReplications = nil
        }
    }
}

extension DBInstanceAutomatedBackup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceAutomatedBackup(allocatedStorage: \(String(describing: allocatedStorage)), availabilityZone: \(String(describing: availabilityZone)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), dBInstanceArn: \(String(describing: dBInstanceArn)), dBInstanceAutomatedBackupsArn: \(String(describing: dBInstanceAutomatedBackupsArn)), dBInstanceAutomatedBackupsReplications: \(String(describing: dBInstanceAutomatedBackupsReplications)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dbiResourceId: \(String(describing: dbiResourceId)), encrypted: \(String(describing: encrypted)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(String(describing: iAMDatabaseAuthenticationEnabled)), instanceCreateTime: \(String(describing: instanceCreateTime)), iops: \(String(describing: iops)), kmsKeyId: \(String(describing: kmsKeyId)), licenseModel: \(String(describing: licenseModel)), masterUsername: \(String(describing: masterUsername)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), region: \(String(describing: region)), restoreWindow: \(String(describing: restoreWindow)), status: \(String(describing: status)), storageType: \(String(describing: storageType)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), timezone: \(String(describing: timezone)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that
///             existed at the time you deleted the source instance.</p>
public struct DBInstanceAutomatedBackup: Equatable {
    /// <p>Specifies the allocated storage size in gibibytes (GiB).</p>
    public let allocatedStorage: Int
    /// <p>The Availability Zone that the automated backup was created in. For information on
    ///             AWS Regions and Availability Zones, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html">Regions
    ///                 and Availability Zones</a>.</p>
    public let availabilityZone: String?
    /// <p>The retention period for the automated backups.</p>
    public let backupRetentionPeriod: Int?
    /// <p>The Amazon Resource Name (ARN) for the automated backups.</p>
    public let dBInstanceArn: String?
    /// <p>The Amazon Resource Name (ARN) for the replicated automated backups.</p>
    public let dBInstanceAutomatedBackupsArn: String?
    /// <p>The list of replications to different AWS Regions associated with the automated backup.</p>
    public let dBInstanceAutomatedBackupsReplications: [DBInstanceAutomatedBackupsReplication]?
    /// <p>The customer id of the instance that is/was associated with the automated backup.
    ///         </p>
    public let dBInstanceIdentifier: String?
    /// <p>The identifier for the source DB instance, which can't be changed and which is unique to an AWS Region.</p>
    public let dbiResourceId: String?
    /// <p>Specifies whether the automated backup is encrypted.</p>
    public let encrypted: Bool
    /// <p>The name of the database engine for this automated backup.</p>
    public let engine: String?
    /// <p>The version of the database engine for the automated backup.</p>
    public let engineVersion: String?
    /// <p>True if mapping of AWS Identity and Access Management (IAM) accounts to database accounts is enabled,
    ///             and otherwise false.</p>
    public let iAMDatabaseAuthenticationEnabled: Bool
    /// <p>Provides the date and time that the DB instance was created.
    ///         </p>
    public let instanceCreateTime: Date?
    /// <p>The IOPS (I/O operations per second) value for the automated backup. </p>
    public let iops: Int?
    /// <p>The AWS KMS key ID for an automated backup.</p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    public let kmsKeyId: String?
    /// <p>License model information for the automated backup.</p>
    public let licenseModel: String?
    /// <p>The license model of an automated backup.</p>
    public let masterUsername: String?
    /// <p>The option group the automated backup is associated with. If omitted, the default option group for the engine specified is used.</p>
    public let optionGroupName: String?
    /// <p>The port number that the automated backup used for connections.</p>
    ///         <p>Default: Inherits from the source DB instance</p>
    ///         <p>Valid Values: <code>1150-65535</code>
    ///          </p>
    public let port: Int
    /// <p>The AWS Region associated with the automated backup.</p>
    public let region: String?
    /// <p>Earliest and latest time an instance can be restored to.</p>
    public let restoreWindow: RestoreWindow?
    /// <p>Provides a list of status information for an automated backup:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>active</code> - automated backups for current instances</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>retained</code> - automated backups for deleted instances</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>creating</code> - automated backups that are waiting
    ///                 for the first automated snapshot to be available.</p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>Specifies the storage type associated with the automated backup.</p>
    public let storageType: String?
    /// <p>The ARN from the key store with which the automated backup is associated for TDE encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>The time zone of the automated backup. In most cases, the <code>Timezone</code> element is empty.
    ///             <code>Timezone</code> content appears only for Microsoft SQL Server DB instances
    ///             that were created with a time zone specified.</p>
    public let timezone: String?
    /// <p>Provides the VPC ID associated with the DB instance</p>
    public let vpcId: String?

    public init (
        allocatedStorage: Int = 0,
        availabilityZone: String? = nil,
        backupRetentionPeriod: Int? = nil,
        dBInstanceArn: String? = nil,
        dBInstanceAutomatedBackupsArn: String? = nil,
        dBInstanceAutomatedBackupsReplications: [DBInstanceAutomatedBackupsReplication]? = nil,
        dBInstanceIdentifier: String? = nil,
        dbiResourceId: String? = nil,
        encrypted: Bool = false,
        engine: String? = nil,
        engineVersion: String? = nil,
        iAMDatabaseAuthenticationEnabled: Bool = false,
        instanceCreateTime: Date? = nil,
        iops: Int? = nil,
        kmsKeyId: String? = nil,
        licenseModel: String? = nil,
        masterUsername: String? = nil,
        optionGroupName: String? = nil,
        port: Int = 0,
        region: String? = nil,
        restoreWindow: RestoreWindow? = nil,
        status: String? = nil,
        storageType: String? = nil,
        tdeCredentialArn: String? = nil,
        timezone: String? = nil,
        vpcId: String? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.availabilityZone = availabilityZone
        self.backupRetentionPeriod = backupRetentionPeriod
        self.dBInstanceArn = dBInstanceArn
        self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
        self.dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dbiResourceId = dbiResourceId
        self.encrypted = encrypted
        self.engine = engine
        self.engineVersion = engineVersion
        self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
        self.instanceCreateTime = instanceCreateTime
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUsername = masterUsername
        self.optionGroupName = optionGroupName
        self.port = port
        self.region = region
        self.restoreWindow = restoreWindow
        self.status = status
        self.storageType = storageType
        self.tdeCredentialArn = tdeCredentialArn
        self.timezone = timezone
        self.vpcId = vpcId
    }
}

extension DBInstanceAutomatedBackupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceAutomatedBackupNotFoundFault(message: \(String(describing: message)))"}
}

extension DBInstanceAutomatedBackupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBInstanceAutomatedBackupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No automated backup for this DB instance was found.</p>
public struct DBInstanceAutomatedBackupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceAutomatedBackupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBInstanceAutomatedBackupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceAutomatedBackupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceAutomatedBackupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBInstanceAutomatedBackupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBInstanceAutomatedBackupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for retained automated backups was exceeded. This prevents you
///             from retaining any additional automated backups. The retained automated backups
///             quota is the same as your DB Instance quota.</p>
public struct DBInstanceAutomatedBackupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceAutomatedBackupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBInstanceAutomatedBackupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceAutomatedBackupsReplication: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: Key("DBInstanceAutomatedBackupsArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceAutomatedBackupsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceAutomatedBackupsArn)
        dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArnDecoded
    }
}

extension DBInstanceAutomatedBackupsReplication: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceAutomatedBackupsReplication(dBInstanceAutomatedBackupsArn: \(String(describing: dBInstanceAutomatedBackupsArn)))"}
}

/// <p>Automated backups of a DB instance replicated to another AWS Region. They consist of system backups, transaction logs, and database instance properties.</p>
public struct DBInstanceAutomatedBackupsReplication: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replicated automated backups.</p>
    public let dBInstanceAutomatedBackupsArn: String?

    public init (
        dBInstanceAutomatedBackupsArn: String? = nil
    )
    {
        self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
    }
}

extension DBInstanceNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceNotFoundFault(message: \(String(describing: message)))"}
}

extension DBInstanceNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBInstanceNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>DBInstanceIdentifier</code> doesn't refer to an existing DB instance.
///         </p>
public struct DBInstanceNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBInstanceNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceRole: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let featureName = featureName {
            try container.encode(featureName, forKey: Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DBInstanceRole: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceRole(featureName: \(String(describing: featureName)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

/// <p>Describes an AWS Identity and Access Management (IAM) role that is associated with a DB instance.</p>
public struct DBInstanceRole: Equatable {
    /// <p>The name of the feature associated with the AWS Identity and Access Management (IAM) role.
    ///             For the list of supported feature names, see <code>DBEngineVersion</code>.
    ///         </p>
    public let featureName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that is associated with the DB
    ///             instance.</p>
    public let roleArn: String?
    /// <p>Describes the state of association between the IAM role and the DB instance. The Status property returns one of the following
    ///             values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - the IAM role ARN is associated with the DB instance and can be used to
    ///                 access other AWS services on your behalf.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code> - the IAM role ARN is being associated with the DB instance.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INVALID</code> - the IAM role ARN is associated with the DB instance, but the DB instance is unable
    ///                 to assume the IAM role in order to access other AWS services on your behalf.</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        featureName: String? = nil,
        roleArn: String? = nil,
        status: String? = nil
    )
    {
        self.featureName = featureName
        self.roleArn = roleArn
        self.status = status
    }
}

extension DBInstanceRoleAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceRoleAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBInstanceRoleAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBInstanceRoleAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified <code>RoleArn</code> or <code>FeatureName</code> value is already associated with the DB instance.</p>
public struct DBInstanceRoleAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceRoleAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBInstanceRoleAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceRoleNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceRoleNotFoundFault(message: \(String(describing: message)))"}
}

extension DBInstanceRoleNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBInstanceRoleNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified <code>RoleArn</code> value doesn't match the specified feature for
///             the DB instance.</p>
public struct DBInstanceRoleNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceRoleNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBInstanceRoleNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceRoleQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceRoleQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBInstanceRoleQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBInstanceRoleQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't associate any more AWS Identity and Access Management (IAM) roles with the DB instance because the quota has been reached.</p>
public struct DBInstanceRoleQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceRoleQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBInstanceRoleQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceStatusInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case normal = "Normal"
        case status = "Status"
        case statusType = "StatusType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if normal != false {
            try container.encode(normal, forKey: Key("Normal"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let statusType = statusType {
            try container.encode(statusType, forKey: Key("StatusType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusType)
        statusType = statusTypeDecoded
        let normalDecoded = try containerValues.decode(Bool.self, forKey: .normal)
        normal = normalDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceStatusInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceStatusInfo(message: \(String(describing: message)), normal: \(String(describing: normal)), status: \(String(describing: status)), statusType: \(String(describing: statusType)))"}
}

/// <p>Provides a list of status information for a DB instance.</p>
public struct DBInstanceStatusInfo: Equatable {
    /// <p>Details of the error if there is an error for the instance. If the instance isn't in an error state, this value is blank.</p>
    public let message: String?
    /// <p>Boolean value that is true if the instance is operating normally, or false if the instance is in an error state.</p>
    public let normal: Bool
    /// <p>Status of the DB instance. For a StatusType of read replica, the values can be
    ///             replicating, replication stop point set, replication stop point reached, error, stopped,
    ///             or terminated.</p>
    public let status: String?
    /// <p>This value is currently "read replication."</p>
    public let statusType: String?

    public init (
        message: String? = nil,
        normal: Bool = false,
        status: String? = nil,
        statusType: String? = nil
    )
    {
        self.message = message
        self.normal = normal
        self.status = status
        self.statusType = statusType
    }
}

extension DBLogFileNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBLogFileNotFoundFault(message: \(String(describing: message)))"}
}

extension DBLogFileNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBLogFileNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>LogFileName</code> doesn't refer to an existing DB log file.</p>
public struct DBLogFileNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBLogFileNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBLogFileNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroupArn = "DBParameterGroupArn"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case dBParameterGroupName = "DBParameterGroupName"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupArn = dBParameterGroupArn {
            try container.encode(dBParameterGroupArn, forKey: Key("DBParameterGroupArn"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dBParameterGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupArn)
        dBParameterGroupArn = dBParameterGroupArnDecoded
    }
}

extension DBParameterGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBParameterGroup(dBParameterGroupArn: \(String(describing: dBParameterGroupArn)), dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), description: \(String(describing: description)))"}
}

/// <p>Contains the details of an Amazon RDS DB parameter group.
///         </p>
///          <p>This data type is used as a response element in the <code>DescribeDBParameterGroups</code> action.
///         </p>
public struct DBParameterGroup: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the DB parameter group.</p>
    public let dBParameterGroupArn: String?
    /// <p>The name of the DB parameter group family that this DB parameter group is compatible with.</p>
    public let dBParameterGroupFamily: String?
    /// <p>The name of the DB parameter group.</p>
    public let dBParameterGroupName: String?
    /// <p>Provides the customer-specified description for this DB parameter group.</p>
    public let description: String?

    public init (
        dBParameterGroupArn: String? = nil,
        dBParameterGroupFamily: String? = nil,
        dBParameterGroupName: String? = nil,
        description: String? = nil
    )
    {
        self.dBParameterGroupArn = dBParameterGroupArn
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.dBParameterGroupName = dBParameterGroupName
        self.description = description
    }
}

extension DBParameterGroupAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBParameterGroupAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBParameterGroupAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBParameterGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A DB parameter group with the same name exists.</p>
public struct DBParameterGroupAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBParameterGroupAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBParameterGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension DBParameterGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>DBParameterGroupName</code> doesn't refer to an
///         existing DB parameter group.
///         </p>
public struct DBParameterGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBParameterGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBParameterGroupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBParameterGroupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBParameterGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB parameter
///             groups.</p>
public struct DBParameterGroupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBParameterGroupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
        case parameterApplyStatus = "ParameterApplyStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try container.encode(parameterApplyStatus, forKey: Key("ParameterApplyStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
    }
}

extension DBParameterGroupStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBParameterGroupStatus(dBParameterGroupName: \(String(describing: dBParameterGroupName)), parameterApplyStatus: \(String(describing: parameterApplyStatus)))"}
}

/// <p>The status of the DB parameter group.</p>
///          <p>This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBInstance</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>CreateDBInstanceReadReplica</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBInstance</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBInstance</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>RebootDBInstance</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>RestoreDBInstanceFromDBSnapshot</code>
///                </p>
///             </li>
///          </ul>
public struct DBParameterGroupStatus: Equatable {
    /// <p>The name of the DB parameter group.</p>
    public let dBParameterGroupName: String?
    /// <p>The status of parameter updates.</p>
    public let parameterApplyStatus: String?

    public init (
        dBParameterGroupName: String? = nil,
        parameterApplyStatus: String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameterApplyStatus = parameterApplyStatus
    }
}

extension DBProxy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auth = "Auth"
        case createdDate = "CreatedDate"
        case dBProxyArn = "DBProxyArn"
        case dBProxyName = "DBProxyName"
        case debugLogging = "DebugLogging"
        case endpoint = "Endpoint"
        case engineFamily = "EngineFamily"
        case idleClientTimeout = "IdleClientTimeout"
        case requireTLS = "RequireTLS"
        case roleArn = "RoleArn"
        case status = "Status"
        case updatedDate = "UpdatedDate"
        case vpcId = "VpcId"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        case vpcSubnetIds = "VpcSubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let auth = auth {
            var authContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Auth"))
            for (index0, userauthconfiginfo0) in auth.enumerated() {
                try authContainer.encode(userauthconfiginfo0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let createdDate = createdDate {
            try container.encode(TimestampWrapper(createdDate, format: .dateTime), forKey: Key("createdDate"))
        }
        if let dBProxyArn = dBProxyArn {
            try container.encode(dBProxyArn, forKey: Key("DBProxyArn"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if debugLogging != false {
            try container.encode(debugLogging, forKey: Key("DebugLogging"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let engineFamily = engineFamily {
            try container.encode(engineFamily, forKey: Key("EngineFamily"))
        }
        if idleClientTimeout != 0 {
            try container.encode(idleClientTimeout, forKey: Key("IdleClientTimeout"))
        }
        if requireTLS != false {
            try container.encode(requireTLS, forKey: Key("RequireTLS"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let updatedDate = updatedDate {
            try container.encode(TimestampWrapper(updatedDate, format: .dateTime), forKey: Key("updatedDate"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let dBProxyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBProxyArn)
        dBProxyArn = dBProxyArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DBProxyStatus.self, forKey: .status)
        status = statusDecoded
        let engineFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineFamily)
        engineFamily = engineFamilyDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct member{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        if containerValues.contains(.vpcSubnetIds) {
            struct KeyVal0{struct member{}}
            let vpcSubnetIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSubnetIds)
            if let vpcSubnetIdsWrappedContainer = vpcSubnetIdsWrappedContainer {
                let vpcSubnetIdsContainer = try vpcSubnetIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var vpcSubnetIdsBuffer:[String]? = nil
                if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
                    vpcSubnetIdsBuffer = [String]()
                    for stringContainer0 in vpcSubnetIdsContainer {
                        vpcSubnetIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSubnetIds = vpcSubnetIdsBuffer
            } else {
                vpcSubnetIds = []
            }
        } else {
            vpcSubnetIds = nil
        }
        if containerValues.contains(.auth) {
            struct KeyVal0{struct member{}}
            let authWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .auth)
            if let authWrappedContainer = authWrappedContainer {
                let authContainer = try authWrappedContainer.decodeIfPresent([UserAuthConfigInfo].self, forKey: .member)
                var authBuffer:[UserAuthConfigInfo]? = nil
                if let authContainer = authContainer {
                    authBuffer = [UserAuthConfigInfo]()
                    for structureContainer0 in authContainer {
                        authBuffer?.append(structureContainer0)
                    }
                }
                auth = authBuffer
            } else {
                auth = []
            }
        } else {
            auth = nil
        }
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let requireTLSDecoded = try containerValues.decode(Bool.self, forKey: .requireTLS)
        requireTLS = requireTLSDecoded
        let idleClientTimeoutDecoded = try containerValues.decode(Int.self, forKey: .idleClientTimeout)
        idleClientTimeout = idleClientTimeoutDecoded
        let debugLoggingDecoded = try containerValues.decode(Bool.self, forKey: .debugLogging)
        debugLogging = debugLoggingDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        var createdDateBuffer:Date? = nil
        if let createdDateDecoded = createdDateDecoded {
            createdDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdDateDecoded, format: .dateTime)
        }
        createdDate = createdDateBuffer
        let updatedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedDate)
        var updatedDateBuffer:Date? = nil
        if let updatedDateDecoded = updatedDateDecoded {
            updatedDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(updatedDateDecoded, format: .dateTime)
        }
        updatedDate = updatedDateBuffer
    }
}

extension DBProxy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxy(auth: \(String(describing: auth)), createdDate: \(String(describing: createdDate)), dBProxyArn: \(String(describing: dBProxyArn)), dBProxyName: \(String(describing: dBProxyName)), debugLogging: \(String(describing: debugLogging)), endpoint: \(String(describing: endpoint)), engineFamily: \(String(describing: engineFamily)), idleClientTimeout: \(String(describing: idleClientTimeout)), requireTLS: \(String(describing: requireTLS)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)), updatedDate: \(String(describing: updatedDate)), vpcId: \(String(describing: vpcId)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)), vpcSubnetIds: \(String(describing: vpcSubnetIds)))"}
}

/// <p>The data structure representing a proxy managed by the RDS Proxy.</p>
///          <p>This data type is used as a response element in the <code>DescribeDBProxies</code> action.</p>
public struct DBProxy: Equatable {
    /// <p>One or more data structures specifying the authorization mechanism to connect to the associated RDS DB instance
    ///         or Aurora DB cluster.</p>
    public let auth: [UserAuthConfigInfo]?
    /// <p>The date and time when the proxy was first created.</p>
    public let createdDate: Date?
    /// <p>The Amazon Resource Name (ARN) for the proxy.</p>
    public let dBProxyArn: String?
    /// <p>The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region.</p>
    public let dBProxyName: String?
    /// <p>Whether the proxy includes detailed information about SQL statements in its logs.
    ///         This information helps you to debug issues involving SQL behavior or the performance
    ///         and scalability of the proxy connections. The debug information includes the text of
    ///         SQL statements that you submit through the proxy. Thus, only enable this setting
    ///         when needed for debugging, and only when you have security measures in place to
    ///         safeguard any sensitive information that appears in the logs.</p>
    public let debugLogging: Bool
    /// <p>The endpoint that you can use to connect to the DB proxy. You include the endpoint value in the
    ///         connection string for a database client application.</p>
    public let endpoint: String?
    /// <p>The engine family applies to MySQL and PostgreSQL for both RDS and Aurora.</p>
    public let engineFamily: String?
    /// <p>The number of seconds a connection to the proxy can have no activity before the proxy drops the client connection.
    ///         The proxy keeps the underlying database connection open and puts it back into the connection pool for reuse by
    ///         later connection requests.</p>
    ///          <p>Default: 1800 (30 minutes)</p>
    ///          <p>Constraints: 1 to 28,800</p>
    public let idleClientTimeout: Int
    /// <p>Indicates whether Transport Layer Security (TLS) encryption is required for connections to the proxy.</p>
    public let requireTLS: Bool
    /// <p>The Amazon Resource Name (ARN) for the IAM role that the proxy uses to access Amazon Secrets Manager.</p>
    public let roleArn: String?
    /// <p>The current status of this proxy. A status of <code>available</code> means the
    ///         proxy is ready to handle requests. Other values indicate that you must wait for
    ///         the proxy to be ready, or take some action to resolve an issue.</p>
    public let status: DBProxyStatus?
    /// <p>The date and time when the proxy was last updated.</p>
    public let updatedDate: Date?
    /// <p>Provides the VPC ID of the DB proxy.</p>
    public let vpcId: String?
    /// <p>Provides a list of VPC security groups that the proxy belongs to.</p>
    public let vpcSecurityGroupIds: [String]?
    /// <p>The EC2 subnet IDs for the proxy.</p>
    public let vpcSubnetIds: [String]?

    public init (
        auth: [UserAuthConfigInfo]? = nil,
        createdDate: Date? = nil,
        dBProxyArn: String? = nil,
        dBProxyName: String? = nil,
        debugLogging: Bool = false,
        endpoint: String? = nil,
        engineFamily: String? = nil,
        idleClientTimeout: Int = 0,
        requireTLS: Bool = false,
        roleArn: String? = nil,
        status: DBProxyStatus? = nil,
        updatedDate: Date? = nil,
        vpcId: String? = nil,
        vpcSecurityGroupIds: [String]? = nil,
        vpcSubnetIds: [String]? = nil
    )
    {
        self.auth = auth
        self.createdDate = createdDate
        self.dBProxyArn = dBProxyArn
        self.dBProxyName = dBProxyName
        self.debugLogging = debugLogging
        self.endpoint = endpoint
        self.engineFamily = engineFamily
        self.idleClientTimeout = idleClientTimeout
        self.requireTLS = requireTLS
        self.roleArn = roleArn
        self.status = status
        self.updatedDate = updatedDate
        self.vpcId = vpcId
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

extension DBProxyAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBProxyAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBProxyAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified proxy name must be unique for all proxies owned by your AWS account in the specified AWS Region.</p>
public struct DBProxyAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBProxyAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "CreatedDate"
        case dBProxyEndpointArn = "DBProxyEndpointArn"
        case dBProxyEndpointName = "DBProxyEndpointName"
        case dBProxyName = "DBProxyName"
        case endpoint = "Endpoint"
        case isDefault = "IsDefault"
        case status = "Status"
        case targetRole = "TargetRole"
        case vpcId = "VpcId"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        case vpcSubnetIds = "VpcSubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let createdDate = createdDate {
            try container.encode(TimestampWrapper(createdDate, format: .dateTime), forKey: Key("createdDate"))
        }
        if let dBProxyEndpointArn = dBProxyEndpointArn {
            try container.encode(dBProxyEndpointArn, forKey: Key("DBProxyEndpointArn"))
        }
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: Key("DBProxyEndpointName"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if isDefault != false {
            try container.encode(isDefault, forKey: Key("IsDefault"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let targetRole = targetRole {
            try container.encode(targetRole, forKey: Key("TargetRole"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyEndpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBProxyEndpointName)
        dBProxyEndpointName = dBProxyEndpointNameDecoded
        let dBProxyEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBProxyEndpointArn)
        dBProxyEndpointArn = dBProxyEndpointArnDecoded
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DBProxyEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct member{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        if containerValues.contains(.vpcSubnetIds) {
            struct KeyVal0{struct member{}}
            let vpcSubnetIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSubnetIds)
            if let vpcSubnetIdsWrappedContainer = vpcSubnetIdsWrappedContainer {
                let vpcSubnetIdsContainer = try vpcSubnetIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var vpcSubnetIdsBuffer:[String]? = nil
                if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
                    vpcSubnetIdsBuffer = [String]()
                    for stringContainer0 in vpcSubnetIdsContainer {
                        vpcSubnetIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSubnetIds = vpcSubnetIdsBuffer
            } else {
                vpcSubnetIds = []
            }
        } else {
            vpcSubnetIds = nil
        }
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        var createdDateBuffer:Date? = nil
        if let createdDateDecoded = createdDateDecoded {
            createdDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdDateDecoded, format: .dateTime)
        }
        createdDate = createdDateBuffer
        let targetRoleDecoded = try containerValues.decodeIfPresent(DBProxyEndpointTargetRole.self, forKey: .targetRole)
        targetRole = targetRoleDecoded
        let isDefaultDecoded = try containerValues.decode(Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
    }
}

extension DBProxyEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyEndpoint(createdDate: \(String(describing: createdDate)), dBProxyEndpointArn: \(String(describing: dBProxyEndpointArn)), dBProxyEndpointName: \(String(describing: dBProxyEndpointName)), dBProxyName: \(String(describing: dBProxyName)), endpoint: \(String(describing: endpoint)), isDefault: \(String(describing: isDefault)), status: \(String(describing: status)), targetRole: \(String(describing: targetRole)), vpcId: \(String(describing: vpcId)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)), vpcSubnetIds: \(String(describing: vpcSubnetIds)))"}
}

/// <p>The data structure representing an endpoint associated with a DB proxy. RDS automatically creates one
///         endpoint for each DB proxy. For Aurora DB clusters, you can associate additional endpoints with the same
///         DB proxy. These endpoints can be read/write or read-only. They can also reside in different VPCs than the
///         associated DB proxy.</p>
///          <p>This data type is used as a response element in the <code>DescribeDBProxyEndpoints</code> operation.</p>
public struct DBProxyEndpoint: Equatable {
    /// <p>The date and time when the DB proxy endpoint was first created.</p>
    public let createdDate: Date?
    /// <p>The Amazon Resource Name (ARN) for the DB proxy endpoint.</p>
    public let dBProxyEndpointArn: String?
    /// <p>The name for the DB proxy endpoint. An identifier must begin with a letter and
    ///         must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen
    ///         or contain two consecutive hyphens.</p>
    public let dBProxyEndpointName: String?
    /// <p>The identifier for the DB proxy that is associated with this DB proxy endpoint.</p>
    public let dBProxyName: String?
    /// <p>The endpoint that you can use to connect to the DB proxy. You include the endpoint value in the
    ///         connection string for a database client application.</p>
    public let endpoint: String?
    /// <p>A value that indicates whether this endpoint is the default endpoint for the associated DB proxy.
    ///         Default DB proxy endpoints always have read/write capability. Other endpoints that you associate with the
    ///         DB proxy can be either read/write or read-only.</p>
    public let isDefault: Bool
    /// <p>The current status of this DB proxy endpoint. A status of <code>available</code> means the
    ///         endpoint is ready to handle requests. Other values indicate that you must wait for
    ///         the endpoint to be ready, or take some action to resolve an issue.</p>
    public let status: DBProxyEndpointStatus?
    /// <p>A value that indicates whether the DB proxy endpoint can be used for read/write or read-only operations.</p>
    public let targetRole: DBProxyEndpointTargetRole?
    /// <p>Provides the VPC ID of the DB proxy endpoint.</p>
    public let vpcId: String?
    /// <p>Provides a list of VPC security groups that the DB proxy endpoint belongs to.</p>
    public let vpcSecurityGroupIds: [String]?
    /// <p>The EC2 subnet IDs for the DB proxy endpoint.</p>
    public let vpcSubnetIds: [String]?

    public init (
        createdDate: Date? = nil,
        dBProxyEndpointArn: String? = nil,
        dBProxyEndpointName: String? = nil,
        dBProxyName: String? = nil,
        endpoint: String? = nil,
        isDefault: Bool = false,
        status: DBProxyEndpointStatus? = nil,
        targetRole: DBProxyEndpointTargetRole? = nil,
        vpcId: String? = nil,
        vpcSecurityGroupIds: [String]? = nil,
        vpcSubnetIds: [String]? = nil
    )
    {
        self.createdDate = createdDate
        self.dBProxyEndpointArn = dBProxyEndpointArn
        self.dBProxyEndpointName = dBProxyEndpointName
        self.dBProxyName = dBProxyName
        self.endpoint = endpoint
        self.isDefault = isDefault
        self.status = status
        self.targetRole = targetRole
        self.vpcId = vpcId
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

extension DBProxyEndpointAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyEndpointAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBProxyEndpointAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBProxyEndpointAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified DB proxy endpoint name must be unique for all DB proxy endpoints owned by your AWS account in the specified AWS Region.</p>
public struct DBProxyEndpointAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyEndpointAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBProxyEndpointAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyEndpointNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyEndpointNotFoundFault(message: \(String(describing: message)))"}
}

extension DBProxyEndpointNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBProxyEndpointNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB proxy endpoint doesn't exist.</p>
public struct DBProxyEndpointNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyEndpointNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBProxyEndpointNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyEndpointQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyEndpointQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBProxyEndpointQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBProxyEndpointQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB proxy already has the maximum number of endpoints.</p>
public struct DBProxyEndpointQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyEndpointQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBProxyEndpointQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum DBProxyEndpointStatus {
    case available
    case creating
    case deleting
    case incompatibleNetwork
    case insufficientResourceLimits
    case modifying
    case sdkUnknown(String)
}

extension DBProxyEndpointStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DBProxyEndpointStatus] {
        return [
            .available,
            .creating,
            .deleting,
            .incompatibleNetwork,
            .insufficientResourceLimits,
            .modifying,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "available"
        case .creating: return "creating"
        case .deleting: return "deleting"
        case .incompatibleNetwork: return "incompatible-network"
        case .insufficientResourceLimits: return "insufficient-resource-limits"
        case .modifying: return "modifying"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DBProxyEndpointStatus(rawValue: rawValue) ?? DBProxyEndpointStatus.sdkUnknown(rawValue)
    }
}

public enum DBProxyEndpointTargetRole {
    case readOnly
    case readWrite
    case sdkUnknown(String)
}

extension DBProxyEndpointTargetRole : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DBProxyEndpointTargetRole] {
        return [
            .readOnly,
            .readWrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .readOnly: return "READ_ONLY"
        case .readWrite: return "READ_WRITE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DBProxyEndpointTargetRole(rawValue: rawValue) ?? DBProxyEndpointTargetRole.sdkUnknown(rawValue)
    }
}

extension DBProxyNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyNotFoundFault(message: \(String(describing: message)))"}
}

extension DBProxyNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBProxyNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified proxy name doesn't correspond to a proxy owned by your AWS account in the specified AWS Region.</p>
public struct DBProxyNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBProxyNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBProxyQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBProxyQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your AWS account already has the maximum number of proxies in the specified AWS Region.</p>
public struct DBProxyQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBProxyQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum DBProxyStatus {
    case available
    case creating
    case deleting
    case incompatibleNetwork
    case insufficientResourceLimits
    case modifying
    case reactivating
    case suspended
    case suspending
    case sdkUnknown(String)
}

extension DBProxyStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DBProxyStatus] {
        return [
            .available,
            .creating,
            .deleting,
            .incompatibleNetwork,
            .insufficientResourceLimits,
            .modifying,
            .reactivating,
            .suspended,
            .suspending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "available"
        case .creating: return "creating"
        case .deleting: return "deleting"
        case .incompatibleNetwork: return "incompatible-network"
        case .insufficientResourceLimits: return "insufficient-resource-limits"
        case .modifying: return "modifying"
        case .reactivating: return "reactivating"
        case .suspended: return "suspended"
        case .suspending: return "suspending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DBProxyStatus(rawValue: rawValue) ?? DBProxyStatus.sdkUnknown(rawValue)
    }
}

extension DBProxyTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoint = "Endpoint"
        case port = "Port"
        case rdsResourceId = "RdsResourceId"
        case role = "Role"
        case targetArn = "TargetArn"
        case targetHealth = "TargetHealth"
        case trackedClusterId = "TrackedClusterId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
        if let rdsResourceId = rdsResourceId {
            try container.encode(rdsResourceId, forKey: Key("RdsResourceId"))
        }
        if let role = role {
            try container.encode(role, forKey: Key("Role"))
        }
        if let targetArn = targetArn {
            try container.encode(targetArn, forKey: Key("TargetArn"))
        }
        if let targetHealth = targetHealth {
            try container.encode(targetHealth, forKey: Key("TargetHealth"))
        }
        if let trackedClusterId = trackedClusterId {
            try container.encode(trackedClusterId, forKey: Key("TrackedClusterId"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let trackedClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trackedClusterId)
        trackedClusterId = trackedClusterIdDecoded
        let rdsResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rdsResourceId)
        rdsResourceId = rdsResourceIdDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TargetType.self, forKey: .type)
        type = typeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(TargetRole.self, forKey: .role)
        role = roleDecoded
        let targetHealthDecoded = try containerValues.decodeIfPresent(TargetHealth.self, forKey: .targetHealth)
        targetHealth = targetHealthDecoded
    }
}

extension DBProxyTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyTarget(endpoint: \(String(describing: endpoint)), port: \(String(describing: port)), rdsResourceId: \(String(describing: rdsResourceId)), role: \(String(describing: role)), targetArn: \(String(describing: targetArn)), targetHealth: \(String(describing: targetHealth)), trackedClusterId: \(String(describing: trackedClusterId)), type: \(String(describing: type)))"}
}

/// <p>Contains the details for an RDS Proxy target. It represents an RDS DB instance or Aurora DB cluster
///         that the proxy can connect to. One or more targets are associated with an RDS Proxy target group.</p>
///          <p>This data type is used as a response element in the <code>DescribeDBProxyTargets</code> action.</p>
public struct DBProxyTarget: Equatable {
    /// <p>The writer endpoint for the RDS DB instance or Aurora DB cluster.</p>
    public let endpoint: String?
    /// <p>The port that the RDS Proxy uses to connect to the target RDS DB instance or Aurora DB cluster.</p>
    public let port: Int
    /// <p>The identifier representing the target. It can be the instance identifier for an RDS DB instance,
    ///         or the cluster identifier for an Aurora DB cluster.</p>
    public let rdsResourceId: String?
    /// <p>A value that indicates whether the target of the proxy can be used for read/write or read-only operations.</p>
    public let role: TargetRole?
    /// <p>The Amazon Resource Name (ARN) for the RDS DB instance or Aurora DB cluster.</p>
    public let targetArn: String?
    /// <p>Information about the connection health of the RDS Proxy target.</p>
    public let targetHealth: TargetHealth?
    /// <p>The DB cluster identifier when the target represents an Aurora DB cluster. This field is blank when the target represents an RDS DB instance.</p>
    public let trackedClusterId: String?
    /// <p>Specifies the kind of database, such as an RDS DB instance or an Aurora DB cluster, that the target represents.</p>
    public let type: TargetType?

    public init (
        endpoint: String? = nil,
        port: Int = 0,
        rdsResourceId: String? = nil,
        role: TargetRole? = nil,
        targetArn: String? = nil,
        targetHealth: TargetHealth? = nil,
        trackedClusterId: String? = nil,
        type: TargetType? = nil
    )
    {
        self.endpoint = endpoint
        self.port = port
        self.rdsResourceId = rdsResourceId
        self.role = role
        self.targetArn = targetArn
        self.targetHealth = targetHealth
        self.trackedClusterId = trackedClusterId
        self.type = type
    }
}

extension DBProxyTargetAlreadyRegisteredFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyTargetAlreadyRegisteredFault(message: \(String(describing: message)))"}
}

extension DBProxyTargetAlreadyRegisteredFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBProxyTargetAlreadyRegisteredFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The proxy is already associated with the specified RDS DB instance or Aurora DB cluster.</p>
public struct DBProxyTargetAlreadyRegisteredFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyTargetAlreadyRegisteredFaultBody: Equatable {
    public let message: String?
}

extension DBProxyTargetAlreadyRegisteredFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyTargetGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionPoolConfig = "ConnectionPoolConfig"
        case createdDate = "CreatedDate"
        case dBProxyName = "DBProxyName"
        case isDefault = "IsDefault"
        case status = "Status"
        case targetGroupArn = "TargetGroupArn"
        case targetGroupName = "TargetGroupName"
        case updatedDate = "UpdatedDate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let connectionPoolConfig = connectionPoolConfig {
            try container.encode(connectionPoolConfig, forKey: Key("ConnectionPoolConfig"))
        }
        if let createdDate = createdDate {
            try container.encode(TimestampWrapper(createdDate, format: .dateTime), forKey: Key("createdDate"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if isDefault != false {
            try container.encode(isDefault, forKey: Key("IsDefault"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: Key("TargetGroupArn"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: Key("TargetGroupName"))
        }
        if let updatedDate = updatedDate {
            try container.encode(TimestampWrapper(updatedDate, format: .dateTime), forKey: Key("updatedDate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let targetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetGroupName)
        targetGroupName = targetGroupNameDecoded
        let targetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetGroupArn)
        targetGroupArn = targetGroupArnDecoded
        let isDefaultDecoded = try containerValues.decode(Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let connectionPoolConfigDecoded = try containerValues.decodeIfPresent(ConnectionPoolConfigurationInfo.self, forKey: .connectionPoolConfig)
        connectionPoolConfig = connectionPoolConfigDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        var createdDateBuffer:Date? = nil
        if let createdDateDecoded = createdDateDecoded {
            createdDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdDateDecoded, format: .dateTime)
        }
        createdDate = createdDateBuffer
        let updatedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedDate)
        var updatedDateBuffer:Date? = nil
        if let updatedDateDecoded = updatedDateDecoded {
            updatedDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(updatedDateDecoded, format: .dateTime)
        }
        updatedDate = updatedDateBuffer
    }
}

extension DBProxyTargetGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyTargetGroup(connectionPoolConfig: \(String(describing: connectionPoolConfig)), createdDate: \(String(describing: createdDate)), dBProxyName: \(String(describing: dBProxyName)), isDefault: \(String(describing: isDefault)), status: \(String(describing: status)), targetGroupArn: \(String(describing: targetGroupArn)), targetGroupName: \(String(describing: targetGroupName)), updatedDate: \(String(describing: updatedDate)))"}
}

/// <p>Represents a set of RDS DB instances, Aurora DB clusters, or both that a proxy can connect to. Currently, each target group
///         is associated with exactly one RDS DB instance or Aurora DB cluster.</p>
///          <p>This data type is used as a response element in the <code>DescribeDBProxyTargetGroups</code> action.</p>
public struct DBProxyTargetGroup: Equatable {
    /// <p>The settings that determine the size and behavior of the connection pool for the target group.</p>
    public let connectionPoolConfig: ConnectionPoolConfigurationInfo?
    /// <p>The date and time when the target group was first created.</p>
    public let createdDate: Date?
    /// <p>The identifier for the RDS proxy associated with this target group.</p>
    public let dBProxyName: String?
    /// <p>Whether this target group is the first one used for connection requests by the associated proxy.
    ///         Because each proxy is currently associated with a single target group, currently this setting
    ///         is always <code>true</code>.</p>
    public let isDefault: Bool
    /// <p>The current status of this target group. A status of <code>available</code> means the
    ///         target group is correctly associated with a database. Other values indicate that you must wait for
    ///         the target group to be ready, or take some action to resolve an issue.</p>
    public let status: String?
    /// <p>The Amazon Resource Name (ARN) representing the target group.</p>
    public let targetGroupArn: String?
    /// <p>The identifier for the target group. This name must be unique for all target groups owned by your AWS account in the specified AWS Region.</p>
    public let targetGroupName: String?
    /// <p>The date and time when the target group was last updated.</p>
    public let updatedDate: Date?

    public init (
        connectionPoolConfig: ConnectionPoolConfigurationInfo? = nil,
        createdDate: Date? = nil,
        dBProxyName: String? = nil,
        isDefault: Bool = false,
        status: String? = nil,
        targetGroupArn: String? = nil,
        targetGroupName: String? = nil,
        updatedDate: Date? = nil
    )
    {
        self.connectionPoolConfig = connectionPoolConfig
        self.createdDate = createdDate
        self.dBProxyName = dBProxyName
        self.isDefault = isDefault
        self.status = status
        self.targetGroupArn = targetGroupArn
        self.targetGroupName = targetGroupName
        self.updatedDate = updatedDate
    }
}

extension DBProxyTargetGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyTargetGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension DBProxyTargetGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBProxyTargetGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified target group isn't available for a proxy owned by your AWS account in the specified AWS Region.</p>
public struct DBProxyTargetGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyTargetGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBProxyTargetGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyTargetNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBProxyTargetNotFoundFault(message: \(String(describing: message)))"}
}

extension DBProxyTargetNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBProxyTargetNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified RDS DB instance or Aurora DB cluster isn't available for a proxy owned by your AWS account in the specified AWS Region.</p>
public struct DBProxyTargetNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyTargetNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBProxyTargetNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBSecurityGroupArn = "DBSecurityGroupArn"
        case dBSecurityGroupDescription = "DBSecurityGroupDescription"
        case dBSecurityGroupName = "DBSecurityGroupName"
        case eC2SecurityGroups = "EC2SecurityGroups"
        case iPRanges = "IPRanges"
        case ownerId = "OwnerId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSecurityGroupArn = dBSecurityGroupArn {
            try container.encode(dBSecurityGroupArn, forKey: Key("DBSecurityGroupArn"))
        }
        if let dBSecurityGroupDescription = dBSecurityGroupDescription {
            try container.encode(dBSecurityGroupDescription, forKey: Key("DBSecurityGroupDescription"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: Key("DBSecurityGroupName"))
        }
        if let eC2SecurityGroups = eC2SecurityGroups {
            var eC2SecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EC2SecurityGroups"))
            for (index0, ec2securitygroup0) in eC2SecurityGroups.enumerated() {
                try eC2SecurityGroupsContainer.encode(ec2securitygroup0, forKey: Key("EC2SecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let iPRanges = iPRanges {
            var iPRangesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("IPRanges"))
            for (index0, iprange0) in iPRanges.enumerated() {
                try iPRangesContainer.encode(iprange0, forKey: Key("IPRange.\(index0.advanced(by: 1))"))
            }
        }
        if let ownerId = ownerId {
            try container.encode(ownerId, forKey: Key("OwnerId"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        let dBSecurityGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSecurityGroupDescription)
        dBSecurityGroupDescription = dBSecurityGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.eC2SecurityGroups) {
            struct KeyVal0{struct EC2SecurityGroup{}}
            let eC2SecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EC2SecurityGroup>.CodingKeys.self, forKey: .eC2SecurityGroups)
            if let eC2SecurityGroupsWrappedContainer = eC2SecurityGroupsWrappedContainer {
                let eC2SecurityGroupsContainer = try eC2SecurityGroupsWrappedContainer.decodeIfPresent([EC2SecurityGroup].self, forKey: .member)
                var eC2SecurityGroupsBuffer:[EC2SecurityGroup]? = nil
                if let eC2SecurityGroupsContainer = eC2SecurityGroupsContainer {
                    eC2SecurityGroupsBuffer = [EC2SecurityGroup]()
                    for structureContainer0 in eC2SecurityGroupsContainer {
                        eC2SecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                eC2SecurityGroups = eC2SecurityGroupsBuffer
            } else {
                eC2SecurityGroups = []
            }
        } else {
            eC2SecurityGroups = nil
        }
        if containerValues.contains(.iPRanges) {
            struct KeyVal0{struct IPRange{}}
            let iPRangesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.IPRange>.CodingKeys.self, forKey: .iPRanges)
            if let iPRangesWrappedContainer = iPRangesWrappedContainer {
                let iPRangesContainer = try iPRangesWrappedContainer.decodeIfPresent([IPRange].self, forKey: .member)
                var iPRangesBuffer:[IPRange]? = nil
                if let iPRangesContainer = iPRangesContainer {
                    iPRangesBuffer = [IPRange]()
                    for structureContainer0 in iPRangesContainer {
                        iPRangesBuffer?.append(structureContainer0)
                    }
                }
                iPRanges = iPRangesBuffer
            } else {
                iPRanges = []
            }
        } else {
            iPRanges = nil
        }
        let dBSecurityGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSecurityGroupArn)
        dBSecurityGroupArn = dBSecurityGroupArnDecoded
    }
}

extension DBSecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSecurityGroup(dBSecurityGroupArn: \(String(describing: dBSecurityGroupArn)), dBSecurityGroupDescription: \(String(describing: dBSecurityGroupDescription)), dBSecurityGroupName: \(String(describing: dBSecurityGroupName)), eC2SecurityGroups: \(String(describing: eC2SecurityGroups)), iPRanges: \(String(describing: iPRanges)), ownerId: \(String(describing: ownerId)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains the details for an Amazon RDS DB security group.
///       </p>
///          <p>This data type is used as a response element
///           in the <code>DescribeDBSecurityGroups</code> action.
///       </p>
public struct DBSecurityGroup: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the DB security group.</p>
    public let dBSecurityGroupArn: String?
    /// <p>Provides the description of the DB security group.</p>
    public let dBSecurityGroupDescription: String?
    /// <p>Specifies the name of the DB security group.</p>
    public let dBSecurityGroupName: String?
    /// <p>
    ///         Contains a list of <code>EC2SecurityGroup</code> elements.
    ///         </p>
    public let eC2SecurityGroups: [EC2SecurityGroup]?
    /// <p>
    ///         Contains a list of <code>IPRange</code> elements.
    ///         </p>
    public let iPRanges: [IPRange]?
    /// <p>Provides the AWS ID of the owner of a specific DB security group.</p>
    public let ownerId: String?
    /// <p>Provides the VpcId of the DB security group.</p>
    public let vpcId: String?

    public init (
        dBSecurityGroupArn: String? = nil,
        dBSecurityGroupDescription: String? = nil,
        dBSecurityGroupName: String? = nil,
        eC2SecurityGroups: [EC2SecurityGroup]? = nil,
        iPRanges: [IPRange]? = nil,
        ownerId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.dBSecurityGroupArn = dBSecurityGroupArn
        self.dBSecurityGroupDescription = dBSecurityGroupDescription
        self.dBSecurityGroupName = dBSecurityGroupName
        self.eC2SecurityGroups = eC2SecurityGroups
        self.iPRanges = iPRanges
        self.ownerId = ownerId
        self.vpcId = vpcId
    }
}

extension DBSecurityGroupAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSecurityGroupAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBSecurityGroupAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSecurityGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///         A DB security group with the name specified in
///         <code>DBSecurityGroupName</code> already exists.
///         </p>
public struct DBSecurityGroupAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBSecurityGroupAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSecurityGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBSecurityGroupName = "DBSecurityGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: Key("DBSecurityGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DBSecurityGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSecurityGroupMembership(dBSecurityGroupName: \(String(describing: dBSecurityGroupName)), status: \(String(describing: status)))"}
}

/// <p>This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>ModifyDBInstance</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>RebootDBInstance</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>RestoreDBInstanceFromDBSnapshot</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>RestoreDBInstanceToPointInTime</code>
///                </p>
///             </li>
///          </ul>
public struct DBSecurityGroupMembership: Equatable {
    /// <p>The name of the DB security group.</p>
    public let dBSecurityGroupName: String?
    /// <p>The status of the DB security group.</p>
    public let status: String?

    public init (
        dBSecurityGroupName: String? = nil,
        status: String? = nil
    )
    {
        self.dBSecurityGroupName = dBSecurityGroupName
        self.status = status
    }
}

extension DBSecurityGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSecurityGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension DBSecurityGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSecurityGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>DBSecurityGroupName</code> doesn't refer to an existing DB security group.
///         </p>
public struct DBSecurityGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBSecurityGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSecurityGroupNotSupportedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSecurityGroupNotSupportedFault(message: \(String(describing: message)))"}
}

extension DBSecurityGroupNotSupportedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSecurityGroupNotSupportedFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A DB security group isn't allowed for this action.</p>
public struct DBSecurityGroupNotSupportedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupNotSupportedFaultBody: Equatable {
    public let message: String?
}

extension DBSecurityGroupNotSupportedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSecurityGroupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSecurityGroupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBSecurityGroupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSecurityGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB security
///             groups.</p>
public struct DBSecurityGroupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBSecurityGroupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSnapshot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZone = "AvailabilityZone"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBSnapshotArn = "DBSnapshotArn"
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
        case dbiResourceId = "DbiResourceId"
        case encrypted = "Encrypted"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case optionGroupName = "OptionGroupName"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotType = "SnapshotType"
        case sourceDBSnapshotIdentifier = "SourceDBSnapshotIdentifier"
        case sourceRegion = "SourceRegion"
        case status = "Status"
        case storageType = "StorageType"
        case tagList = "TagList"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotArn = dBSnapshotArn {
            try container.encode(dBSnapshotArn, forKey: Key("DBSnapshotArn"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: Key("DBSnapshotIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: Key("DbiResourceId"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: Key("Encrypted"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let instanceCreateTime = instanceCreateTime {
            try container.encode(TimestampWrapper(instanceCreateTime, format: .dateTime), forKey: Key("instanceCreateTime"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if percentProgress != 0 {
            try container.encode(percentProgress, forKey: Key("PercentProgress"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: Key("snapshotCreateTime"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: Key("SnapshotType"))
        }
        if let sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier {
            try container.encode(sourceDBSnapshotIdentifier, forKey: Key("SourceDBSnapshotIdentifier"))
        }
        if let sourceRegion = sourceRegion {
            try container.encode(sourceRegion, forKey: Key("SourceRegion"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: Key("TdeCredentialArn"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: Key("Timezone"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceCreateTime)
        var instanceCreateTimeBuffer:Date? = nil
        if let instanceCreateTimeDecoded = instanceCreateTimeDecoded {
            instanceCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(instanceCreateTimeDecoded, format: .dateTime)
        }
        instanceCreateTime = instanceCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let percentProgressDecoded = try containerValues.decode(Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let sourceDBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceDBSnapshotIdentifier)
        sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let encryptedDecoded = try containerValues.decode(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dBSnapshotArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSnapshotArn)
        dBSnapshotArn = dBSnapshotArnDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagListBuffer:[Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

extension DBSnapshot: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSnapshot(allocatedStorage: \(String(describing: allocatedStorage)), availabilityZone: \(String(describing: availabilityZone)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBSnapshotArn: \(String(describing: dBSnapshotArn)), dBSnapshotIdentifier: \(String(describing: dBSnapshotIdentifier)), dbiResourceId: \(String(describing: dbiResourceId)), encrypted: \(String(describing: encrypted)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(String(describing: iAMDatabaseAuthenticationEnabled)), instanceCreateTime: \(String(describing: instanceCreateTime)), iops: \(String(describing: iops)), kmsKeyId: \(String(describing: kmsKeyId)), licenseModel: \(String(describing: licenseModel)), masterUsername: \(String(describing: masterUsername)), optionGroupName: \(String(describing: optionGroupName)), percentProgress: \(String(describing: percentProgress)), port: \(String(describing: port)), processorFeatures: \(String(describing: processorFeatures)), snapshotCreateTime: \(String(describing: snapshotCreateTime)), snapshotType: \(String(describing: snapshotType)), sourceDBSnapshotIdentifier: \(String(describing: sourceDBSnapshotIdentifier)), sourceRegion: \(String(describing: sourceRegion)), status: \(String(describing: status)), storageType: \(String(describing: storageType)), tagList: \(String(describing: tagList)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), timezone: \(String(describing: timezone)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains the details of an Amazon RDS DB snapshot.
///       </p>
///          <p>This data type is used as a response element
///           in the <code>DescribeDBSnapshots</code> action.
///       </p>
public struct DBSnapshot: Equatable {
    /// <p>Specifies the allocated storage size in gibibytes (GiB).</p>
    public let allocatedStorage: Int
    /// <p>Specifies the name of the Availability Zone the DB instance was located in at the time of the DB snapshot.</p>
    public let availabilityZone: String?
    /// <p>Specifies the DB instance identifier of the DB instance this DB snapshot was created from.</p>
    public let dBInstanceIdentifier: String?
    /// <p>The Amazon Resource Name (ARN) for the DB snapshot.</p>
    public let dBSnapshotArn: String?
    /// <p>Specifies the identifier for the DB snapshot.</p>
    public let dBSnapshotIdentifier: String?
    /// <p>The identifier for the source DB instance, which can't be changed and which is unique to an AWS Region.</p>
    public let dbiResourceId: String?
    /// <p>Specifies whether the DB snapshot is encrypted.</p>
    public let encrypted: Bool
    /// <p>Specifies the name of the database engine.</p>
    public let engine: String?
    /// <p>Specifies the version of the database engine.</p>
    public let engineVersion: String?
    /// <p>True if mapping of AWS Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.</p>
    public let iAMDatabaseAuthenticationEnabled: Bool
    /// <p>Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from
    ///             which the snapshot was taken, was created.</p>
    public let instanceCreateTime: Date?
    /// <p>Specifies the Provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.</p>
    public let iops: Int?
    /// <p>
    ///             If <code>Encrypted</code> is true, the AWS KMS key identifier
    ///             for the encrypted DB snapshot.
    ///         </p>
    ///          <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    public let kmsKeyId: String?
    /// <p>License model information for the restored DB instance.</p>
    public let licenseModel: String?
    /// <p>Provides the master username for the DB snapshot.</p>
    public let masterUsername: String?
    /// <p>Provides the option group name for the DB snapshot.</p>
    public let optionGroupName: String?
    /// <p>The percentage of the estimated data that has been transferred.</p>
    public let percentProgress: Int
    /// <p>Specifies the port that the database engine was listening on at the time of the snapshot.</p>
    public let port: Int
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class
    ///             of the DB instance when the DB snapshot was created.</p>
    public let processorFeatures: [ProcessorFeature]?
    /// <p>Specifies when the snapshot was taken in Coordinated Universal Time (UTC).</p>
    public let snapshotCreateTime: Date?
    /// <p>Provides the type of the DB snapshot.</p>
    public let snapshotType: String?
    /// <p>The DB snapshot Amazon Resource Name (ARN) that the DB snapshot was copied from. It only has value in case of cross-customer or cross-region copy.</p>
    public let sourceDBSnapshotIdentifier: String?
    /// <p>The AWS Region that the DB snapshot was created in or copied from.</p>
    public let sourceRegion: String?
    /// <p>Specifies the status of this DB snapshot.</p>
    public let status: String?
    /// <p>Specifies the storage type associated with DB snapshot.</p>
    public let storageType: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tagList: [Tag]?
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>The time zone of the DB snapshot.
    ///             In most cases, the <code>Timezone</code> element is empty.
    ///             <code>Timezone</code> content appears only for
    ///             snapshots taken from
    ///             Microsoft SQL Server DB instances
    ///             that were created with a time zone specified.
    ///         </p>
    public let timezone: String?
    /// <p>Provides the VPC ID associated with the DB snapshot.</p>
    public let vpcId: String?

    public init (
        allocatedStorage: Int = 0,
        availabilityZone: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBSnapshotArn: String? = nil,
        dBSnapshotIdentifier: String? = nil,
        dbiResourceId: String? = nil,
        encrypted: Bool = false,
        engine: String? = nil,
        engineVersion: String? = nil,
        iAMDatabaseAuthenticationEnabled: Bool = false,
        instanceCreateTime: Date? = nil,
        iops: Int? = nil,
        kmsKeyId: String? = nil,
        licenseModel: String? = nil,
        masterUsername: String? = nil,
        optionGroupName: String? = nil,
        percentProgress: Int = 0,
        port: Int = 0,
        processorFeatures: [ProcessorFeature]? = nil,
        snapshotCreateTime: Date? = nil,
        snapshotType: String? = nil,
        sourceDBSnapshotIdentifier: String? = nil,
        sourceRegion: String? = nil,
        status: String? = nil,
        storageType: String? = nil,
        tagList: [Tag]? = nil,
        tdeCredentialArn: String? = nil,
        timezone: String? = nil,
        vpcId: String? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.availabilityZone = availabilityZone
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSnapshotArn = dBSnapshotArn
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.dbiResourceId = dbiResourceId
        self.encrypted = encrypted
        self.engine = engine
        self.engineVersion = engineVersion
        self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
        self.instanceCreateTime = instanceCreateTime
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUsername = masterUsername
        self.optionGroupName = optionGroupName
        self.percentProgress = percentProgress
        self.port = port
        self.processorFeatures = processorFeatures
        self.snapshotCreateTime = snapshotCreateTime
        self.snapshotType = snapshotType
        self.sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier
        self.sourceRegion = sourceRegion
        self.status = status
        self.storageType = storageType
        self.tagList = tagList
        self.tdeCredentialArn = tdeCredentialArn
        self.timezone = timezone
        self.vpcId = vpcId
    }
}

extension DBSnapshotAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSnapshotAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBSnapshotAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>DBSnapshotIdentifier</code> is already used by an existing snapshot.
///         </p>
public struct DBSnapshotAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSnapshotAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBSnapshotAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSnapshotAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case attributeValues = "AttributeValues"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let attributeValues = attributeValues {
            var attributeValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AttributeValues"))
            for (index0, string0) in attributeValues.enumerated() {
                try attributeValuesContainer.encode(string0, forKey: Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.attributeValues) {
            struct KeyVal0{struct AttributeValue{}}
            let attributeValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .attributeValues)
            if let attributeValuesWrappedContainer = attributeValuesWrappedContainer {
                let attributeValuesContainer = try attributeValuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var attributeValuesBuffer:[String]? = nil
                if let attributeValuesContainer = attributeValuesContainer {
                    attributeValuesBuffer = [String]()
                    for stringContainer0 in attributeValuesContainer {
                        attributeValuesBuffer?.append(stringContainer0)
                    }
                }
                attributeValues = attributeValuesBuffer
            } else {
                attributeValues = []
            }
        } else {
            attributeValues = nil
        }
    }
}

extension DBSnapshotAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSnapshotAttribute(attributeName: \(String(describing: attributeName)), attributeValues: \(String(describing: attributeValues)))"}
}

/// <p>Contains the name and values of a manual DB snapshot attribute</p>
///          <p>Manual DB snapshot attributes are used to authorize other AWS accounts
///     to restore a manual DB snapshot. For more information, see the <code>ModifyDBSnapshotAttribute</code>
///     API.</p>
public struct DBSnapshotAttribute: Equatable {
    /// <p>The name of the manual DB snapshot attribute.</p>
    ///          <p>The attribute named <code>restore</code> refers to the list of AWS accounts that
    ///           have permission to copy or restore the manual DB cluster snapshot. For more information,
    ///           see the <code>ModifyDBSnapshotAttribute</code>
    ///           API action.</p>
    public let attributeName: String?
    /// <p>The value or values for the manual DB snapshot attribute.</p>
    ///          <p>If the <code>AttributeName</code> field is set to <code>restore</code>, then this element
    ///       returns a list of IDs of the AWS accounts that are authorized to copy or restore the manual
    ///       DB snapshot. If a value of <code>all</code> is in the list, then the manual DB snapshot
    ///       is public and available for any AWS account to copy or restore.</p>
    public let attributeValues: [String]?

    public init (
        attributeName: String? = nil,
        attributeValues: [String]? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValues = attributeValues
    }
}

extension DBSnapshotAttributesResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBSnapshotAttributes = "DBSnapshotAttributes"
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSnapshotAttributes = dBSnapshotAttributes {
            var dBSnapshotAttributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBSnapshotAttributes"))
            for (index0, dbsnapshotattribute0) in dBSnapshotAttributes.enumerated() {
                try dBSnapshotAttributesContainer.encode(dbsnapshotattribute0, forKey: Key("DBSnapshotAttribute.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: Key("DBSnapshotIdentifier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
        if containerValues.contains(.dBSnapshotAttributes) {
            struct KeyVal0{struct DBSnapshotAttribute{}}
            let dBSnapshotAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSnapshotAttribute>.CodingKeys.self, forKey: .dBSnapshotAttributes)
            if let dBSnapshotAttributesWrappedContainer = dBSnapshotAttributesWrappedContainer {
                let dBSnapshotAttributesContainer = try dBSnapshotAttributesWrappedContainer.decodeIfPresent([DBSnapshotAttribute].self, forKey: .member)
                var dBSnapshotAttributesBuffer:[DBSnapshotAttribute]? = nil
                if let dBSnapshotAttributesContainer = dBSnapshotAttributesContainer {
                    dBSnapshotAttributesBuffer = [DBSnapshotAttribute]()
                    for structureContainer0 in dBSnapshotAttributesContainer {
                        dBSnapshotAttributesBuffer?.append(structureContainer0)
                    }
                }
                dBSnapshotAttributes = dBSnapshotAttributesBuffer
            } else {
                dBSnapshotAttributes = []
            }
        } else {
            dBSnapshotAttributes = nil
        }
    }
}

extension DBSnapshotAttributesResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSnapshotAttributesResult(dBSnapshotAttributes: \(String(describing: dBSnapshotAttributes)), dBSnapshotIdentifier: \(String(describing: dBSnapshotIdentifier)))"}
}

/// <p>Contains the results of a successful call to the <code>DescribeDBSnapshotAttributes</code>
///     API action.</p>
///          <p>Manual DB snapshot attributes are used to authorize other AWS accounts
///       to copy or restore a manual DB snapshot. For more information, see the <code>ModifyDBSnapshotAttribute</code>
///       API action.</p>
public struct DBSnapshotAttributesResult: Equatable {
    /// <p>The list of attributes and values for the manual DB snapshot.</p>
    public let dBSnapshotAttributes: [DBSnapshotAttribute]?
    /// <p>The identifier of the manual DB snapshot that the attributes apply to.</p>
    public let dBSnapshotIdentifier: String?

    public init (
        dBSnapshotAttributes: [DBSnapshotAttribute]? = nil,
        dBSnapshotIdentifier: String? = nil
    )
    {
        self.dBSnapshotAttributes = dBSnapshotAttributes
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
    }
}

extension DBSnapshotNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSnapshotNotFoundFault(message: \(String(describing: message)))"}
}

extension DBSnapshotNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>DBSnapshotIdentifier</code> doesn't refer to an existing DB snapshot.
///         </p>
public struct DBSnapshotNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSnapshotNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBSnapshotNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBSubnetGroupArn = "DBSubnetGroupArn"
        case dBSubnetGroupDescription = "DBSubnetGroupDescription"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSubnetGroupArn = dBSubnetGroupArn {
            try container.encode(dBSubnetGroupArn, forKey: Key("DBSubnetGroupArn"))
        }
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let subnetGroupStatus = subnetGroupStatus {
            try container.encode(subnetGroupStatus, forKey: Key("SubnetGroupStatus"))
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Subnets"))
            for (index0, subnet0) in subnets.enumerated() {
                try subnetsContainer.encode(subnet0, forKey: Key("Subnet.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let dBSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSubnetGroupDescription)
        dBSubnetGroupDescription = dBSubnetGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct Subnet{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Subnet>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([Subnet].self, forKey: .member)
                var subnetsBuffer:[Subnet]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [Subnet]()
                    for structureContainer0 in subnetsContainer {
                        subnetsBuffer?.append(structureContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
        let dBSubnetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSubnetGroupArn)
        dBSubnetGroupArn = dBSubnetGroupArnDecoded
    }
}

extension DBSubnetGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetGroup(dBSubnetGroupArn: \(String(describing: dBSubnetGroupArn)), dBSubnetGroupDescription: \(String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), subnetGroupStatus: \(String(describing: subnetGroupStatus)), subnets: \(String(describing: subnets)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains the details of an Amazon RDS DB subnet group.
///       </p>
///          <p>This data type is used as a response element
///           in the <code>DescribeDBSubnetGroups</code> action.
///       </p>
public struct DBSubnetGroup: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the DB subnet group.</p>
    public let dBSubnetGroupArn: String?
    /// <p>Provides the description of the DB subnet group.</p>
    public let dBSubnetGroupDescription: String?
    /// <p>The name of the DB subnet group.</p>
    public let dBSubnetGroupName: String?
    /// <p>Provides the status of the DB subnet group.</p>
    public let subnetGroupStatus: String?
    /// <p>
    ///         Contains a list of <code>Subnet</code> elements.
    ///         </p>
    public let subnets: [Subnet]?
    /// <p>Provides the VpcId of the DB subnet group.</p>
    public let vpcId: String?

    public init (
        dBSubnetGroupArn: String? = nil,
        dBSubnetGroupDescription: String? = nil,
        dBSubnetGroupName: String? = nil,
        subnetGroupStatus: String? = nil,
        subnets: [Subnet]? = nil,
        vpcId: String? = nil
    )
    {
        self.dBSubnetGroupArn = dBSubnetGroupArn
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetGroupStatus = subnetGroupStatus
        self.subnets = subnets
        self.vpcId = vpcId
    }
}

extension DBSubnetGroupAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetGroupAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBSubnetGroupAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSubnetGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>DBSubnetGroupName</code> is already used by an existing DB subnet group.
///         </p>
public struct DBSubnetGroupAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBSubnetGroupAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupDoesNotCoverEnoughAZs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetGroupDoesNotCoverEnoughAZs(message: \(String(describing: message)))"}
}

extension DBSubnetGroupDoesNotCoverEnoughAZs: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSubnetGroupDoesNotCoverEnoughAZsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.</p>
public struct DBSubnetGroupDoesNotCoverEnoughAZs: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupDoesNotCoverEnoughAZsBody: Equatable {
    public let message: String?
}

extension DBSubnetGroupDoesNotCoverEnoughAZsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupNotAllowedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetGroupNotAllowedFault(message: \(String(describing: message)))"}
}

extension DBSubnetGroupNotAllowedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSubnetGroupNotAllowedFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DBSubnetGroup shouldn't be specified while creating read replicas that lie
///             in the same region as the source instance.</p>
public struct DBSubnetGroupNotAllowedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupNotAllowedFaultBody: Equatable {
    public let message: String?
}

extension DBSubnetGroupNotAllowedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension DBSubnetGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSubnetGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>DBSubnetGroupName</code> doesn't refer to an existing DB subnet group.
///         </p>
public struct DBSubnetGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBSubnetGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetGroupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBSubnetGroupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSubnetGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB subnet
///             groups.</p>
public struct DBSubnetGroupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBSubnetGroupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBSubnetQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSubnetQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of subnets in a
///             DB subnet groups.</p>
public struct DBSubnetQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBSubnetQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBUpgradeDependencyFailureFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBUpgradeDependencyFailureFault(message: \(String(describing: message)))"}
}

extension DBUpgradeDependencyFailureFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBUpgradeDependencyFailureFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB upgrade failed because a resource the DB depends on can't be
///             modified.</p>
public struct DBUpgradeDependencyFailureFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBUpgradeDependencyFailureFaultBody: Equatable {
    public let message: String?
}

extension DBUpgradeDependencyFailureFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteCustomAvailabilityZoneInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCustomAvailabilityZoneInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomAvailabilityZoneInput>
    public typealias MOutput = OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomAvailabilityZoneOutputError>
}

extension DeleteCustomAvailabilityZoneInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomAvailabilityZoneInput(customAvailabilityZoneId: \(String(describing: customAvailabilityZoneId)))"}
}

extension DeleteCustomAvailabilityZoneInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: Key("CustomAvailabilityZoneId"))
        }
        try container.encode("DeleteCustomAvailabilityZone", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteCustomAvailabilityZoneInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCustomAvailabilityZoneInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomAvailabilityZoneInput>
    public typealias MOutput = OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomAvailabilityZoneOutputError>
}

public struct DeleteCustomAvailabilityZoneInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCustomAvailabilityZoneInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomAvailabilityZoneInput>
    public typealias MOutput = OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomAvailabilityZoneOutputError>
}

public struct DeleteCustomAvailabilityZoneInput: Equatable {
    /// <p>The custom AZ identifier.</p>
    public let customAvailabilityZoneId: String?

    public init (
        customAvailabilityZoneId: String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
    }
}

extension DeleteCustomAvailabilityZoneOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCustomAvailabilityZoneOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFoundFault" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomAvailabilityZoneOutputError: Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomAvailabilityZoneOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomAvailabilityZoneOutputResponse(customAvailabilityZone: \(String(describing: customAvailabilityZone)))"}
}

extension DeleteCustomAvailabilityZoneOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteCustomAvailabilityZoneOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customAvailabilityZone = output.customAvailabilityZone
        } else {
            self.customAvailabilityZone = nil
        }
    }
}

public struct DeleteCustomAvailabilityZoneOutputResponse: Equatable {
    /// <p>A custom Availability Zone (AZ) is an on-premises AZ that is integrated with a VMware vSphere cluster.</p>
    ///         <p>For more information about RDS on VMware, see the
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html">
    ///                 RDS on VMware User Guide.</a>
    ///          </p>
    public let customAvailabilityZone: CustomAvailabilityZone?

    public init (
        customAvailabilityZone: CustomAvailabilityZone? = nil
    )
    {
        self.customAvailabilityZone = customAvailabilityZone
    }
}

struct DeleteCustomAvailabilityZoneOutputResponseBody: Equatable {
    public let customAvailabilityZone: CustomAvailabilityZone?
}

extension DeleteCustomAvailabilityZoneOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customAvailabilityZone = "CustomAvailabilityZone"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteCustomAvailabilityZoneResult"))
        let customAvailabilityZoneDecoded = try containerValues.decodeIfPresent(CustomAvailabilityZone.self, forKey: .customAvailabilityZone)
        customAvailabilityZone = customAvailabilityZoneDecoded
    }
}

public struct DeleteDBClusterEndpointInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterEndpointOutputError>
}

extension DeleteDBClusterEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterEndpointInput(dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)))"}
}

extension DeleteDBClusterEndpointInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: Key("DBClusterEndpointIdentifier"))
        }
        try container.encode("DeleteDBClusterEndpoint", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBClusterEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterEndpointOutputError>
}

public struct DeleteDBClusterEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterEndpointOutputError>
}

public struct DeleteDBClusterEndpointInput: Equatable {
    /// <p>The identifier associated with the custom endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?

    public init (
        dBClusterEndpointIdentifier: String? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
    }
}

extension DeleteDBClusterEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointNotFoundFault" : self = .dBClusterEndpointNotFoundFault(try DBClusterEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterEndpointStateFault" : self = .invalidDBClusterEndpointStateFault(try InvalidDBClusterEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterEndpointOutputError: Equatable {
    case dBClusterEndpointNotFoundFault(DBClusterEndpointNotFoundFault)
    case invalidDBClusterEndpointStateFault(InvalidDBClusterEndpointStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterEndpointOutputResponse(customEndpointType: \(String(describing: customEndpointType)), dBClusterEndpointArn: \(String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), endpoint: \(String(describing: endpoint)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)), status: \(String(describing: status)))"}
}

extension DeleteDBClusterEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// <p>This data type represents the information you need to connect to an Amazon Aurora DB cluster.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBClusterEndpoint</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon RDS DB instance endpoints,
///         see <code>Endpoint</code>.</p>
public struct DeleteDBClusterEndpointOutputResponse: Equatable {
    /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
    ///        <code>WRITER</code>, <code>ANY</code>.</p>
    public let customEndpointType: String?
    /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
    public let dBClusterEndpointArn: String?
    /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
    public let dBClusterEndpointResourceIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///             stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>The DNS address of the endpoint.</p>
    public let endpoint: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///        All other eligible instances are reachable through the custom endpoint.
    ///        Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?
    /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that can't be used for a certain kind of cluster,
    ///      such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
    public let status: String?

    public init (
        customEndpointType: String? = nil,
        dBClusterEndpointArn: String? = nil,
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterEndpointResourceIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        endpoint: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil,
        status: String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct DeleteDBClusterEndpointOutputResponseBody: Equatable {
    public let dBClusterEndpointIdentifier: String?
    public let dBClusterIdentifier: String?
    public let dBClusterEndpointResourceIdentifier: String?
    public let endpoint: String?
    public let status: String?
    public let endpointType: String?
    public let customEndpointType: String?
    public let staticMembers: [String]?
    public let excludedMembers: [String]?
    public let dBClusterEndpointArn: String?
}

extension DeleteDBClusterEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var staticMembersBuffer:[String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var excludedMembersBuffer:[String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct DeleteDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterOutputError>
}

extension DeleteDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), finalDBSnapshotIdentifier: \(String(describing: finalDBSnapshotIdentifier)), skipFinalSnapshot: \(String(describing: skipFinalSnapshot)))"}
}

extension DeleteDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let finalDBSnapshotIdentifier = finalDBSnapshotIdentifier {
            try container.encode(finalDBSnapshotIdentifier, forKey: Key("FinalDBSnapshotIdentifier"))
        }
        if skipFinalSnapshot != false {
            try container.encode(skipFinalSnapshot, forKey: Key("SkipFinalSnapshot"))
        }
        try container.encode("DeleteDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterOutputError>
}

public struct DeleteDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterOutputError>
}

/// <p></p>
public struct DeleteDBClusterInput: Equatable {
    /// <p>The DB cluster identifier for the DB cluster to be deleted. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match an existing DBClusterIdentifier.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>
    ///       The DB cluster snapshot identifier of the new DB cluster snapshot created when <code>SkipFinalSnapshot</code>
    ///       is disabled.
    ///     </p>
    ///          <note>
    ///             <p>
    ///           Specifying this parameter and also skipping the creation of a final DB cluster snapshot
    ///           with the <code>SkipFinalShapshot</code> parameter results in an error.</p>
    ///          </note>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let finalDBSnapshotIdentifier: String?
    /// <p>A value that indicates whether to skip the creation of a final DB cluster snapshot before the DB cluster is deleted.
    ///           If skip is specified, no DB cluster snapshot is created. If skip isn't specified, a DB cluster snapshot
    ///           is created before the DB cluster is deleted. By default, skip isn't specified, and the DB cluster snapshot is created.
    ///           By default, this parameter is disabled.</p>
    ///          <note>
    ///             <p>You must specify a <code>FinalDBSnapshotIdentifier</code> parameter if <code>SkipFinalSnapshot</code> is disabled.</p>
    ///          </note>
    public let skipFinalSnapshot: Bool

    public init (
        dBClusterIdentifier: String? = nil,
        finalDBSnapshotIdentifier: String? = nil,
        skipFinalSnapshot: Bool = false
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
        self.skipFinalSnapshot = skipFinalSnapshot
    }
}

extension DeleteDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension DeleteDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct DeleteDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Aurora DB cluster.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusters</code>,
    ///         <code>StopDBCluster</code>, and <code>StartDBCluster</code> actions.
    ///       </p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct DeleteDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension DeleteDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct DeleteDBClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterParameterGroupOutputError>
}

extension DeleteDBClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterParameterGroupInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)))"}
}

extension DeleteDBClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        try container.encode("DeleteDBClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterParameterGroupOutputError>
}

public struct DeleteDBClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterParameterGroupOutputError>
}

/// <p></p>
public struct DeleteDBClusterParameterGroupInput: Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be the name of an existing DB cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                <p>You can't delete a default DB cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be associated with any DB clusters.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?

    public init (
        dBClusterParameterGroupName: String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

extension DeleteDBClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterParameterGroupOutputResponse()"}
}

extension DeleteDBClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBClusterParameterGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteDBClusterParameterGroupOutputResponseBody: Equatable {
}

extension DeleteDBClusterParameterGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDBClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterSnapshotOutputError>
}

extension DeleteDBClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterSnapshotInput(dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)))"}
}

extension DeleteDBClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        try container.encode("DeleteDBClusterSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterSnapshotOutputError>
}

public struct DeleteDBClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterSnapshotOutputError>
}

/// <p></p>
public struct DeleteDBClusterSnapshotInput: Equatable {
    /// <p>The identifier of the DB cluster snapshot to delete.</p>
    ///          <p>Constraints: Must be the name of an existing DB cluster snapshot in the <code>available</code> state.</p>
    public let dBClusterSnapshotIdentifier: String?

    public init (
        dBClusterSnapshotIdentifier: String? = nil
    )
    {
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

extension DeleteDBClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterSnapshotOutputError: Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(String(describing: dBClusterSnapshot)))"}
}

extension DeleteDBClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct DeleteDBClusterSnapshotOutputResponse: Equatable {
    /// <p>Contains the details for an Amazon RDS DB cluster snapshot
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBClusterSnapshots</code> action.
    ///       </p>
    public let dBClusterSnapshot: DBClusterSnapshot?

    public init (
        dBClusterSnapshot: DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct DeleteDBClusterSnapshotOutputResponseBody: Equatable {
    public let dBClusterSnapshot: DBClusterSnapshot?
}

extension DeleteDBClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct DeleteDBInstanceAutomatedBackupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBInstanceAutomatedBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>
    public typealias MOutput = OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBInstanceAutomatedBackupOutputError>
}

extension DeleteDBInstanceAutomatedBackupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBInstanceAutomatedBackupInput(dBInstanceAutomatedBackupsArn: \(String(describing: dBInstanceAutomatedBackupsArn)), dbiResourceId: \(String(describing: dbiResourceId)))"}
}

extension DeleteDBInstanceAutomatedBackupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: Key("DBInstanceAutomatedBackupsArn"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: Key("DbiResourceId"))
        }
        try container.encode("DeleteDBInstanceAutomatedBackup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBInstanceAutomatedBackupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBInstanceAutomatedBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>
    public typealias MOutput = OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBInstanceAutomatedBackupOutputError>
}

public struct DeleteDBInstanceAutomatedBackupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBInstanceAutomatedBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>
    public typealias MOutput = OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBInstanceAutomatedBackupOutputError>
}

/// <p>Parameter input for the <code>DeleteDBInstanceAutomatedBackup</code> operation.</p>
public struct DeleteDBInstanceAutomatedBackupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the automated backups to delete, for example,
    ///             <code>arn:aws:rds:us-east-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE</code>.</p>
    public let dBInstanceAutomatedBackupsArn: String?
    /// <p>The identifier for the source DB instance, which can't be changed and which is unique to an AWS Region.</p>
    public let dbiResourceId: String?

    public init (
        dBInstanceAutomatedBackupsArn: String? = nil,
        dbiResourceId: String? = nil
    )
    {
        self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
        self.dbiResourceId = dbiResourceId
    }
}

extension DeleteDBInstanceAutomatedBackupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBInstanceAutomatedBackupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupNotFoundFault" : self = .dBInstanceAutomatedBackupNotFoundFault(try DBInstanceAutomatedBackupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceAutomatedBackupStateFault" : self = .invalidDBInstanceAutomatedBackupStateFault(try InvalidDBInstanceAutomatedBackupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBInstanceAutomatedBackupOutputError: Equatable {
    case dBInstanceAutomatedBackupNotFoundFault(DBInstanceAutomatedBackupNotFoundFault)
    case invalidDBInstanceAutomatedBackupStateFault(InvalidDBInstanceAutomatedBackupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBInstanceAutomatedBackupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBInstanceAutomatedBackupOutputResponse(dBInstanceAutomatedBackup: \(String(describing: dBInstanceAutomatedBackup)))"}
}

extension DeleteDBInstanceAutomatedBackupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBInstanceAutomatedBackupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstanceAutomatedBackup = output.dBInstanceAutomatedBackup
        } else {
            self.dBInstanceAutomatedBackup = nil
        }
    }
}

public struct DeleteDBInstanceAutomatedBackupOutputResponse: Equatable {
    /// <p>An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that
    ///             existed at the time you deleted the source instance.</p>
    public let dBInstanceAutomatedBackup: DBInstanceAutomatedBackup?

    public init (
        dBInstanceAutomatedBackup: DBInstanceAutomatedBackup? = nil
    )
    {
        self.dBInstanceAutomatedBackup = dBInstanceAutomatedBackup
    }
}

struct DeleteDBInstanceAutomatedBackupOutputResponseBody: Equatable {
    public let dBInstanceAutomatedBackup: DBInstanceAutomatedBackup?
}

extension DeleteDBInstanceAutomatedBackupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBInstanceAutomatedBackupResult"))
        let dBInstanceAutomatedBackupDecoded = try containerValues.decodeIfPresent(DBInstanceAutomatedBackup.self, forKey: .dBInstanceAutomatedBackup)
        dBInstanceAutomatedBackup = dBInstanceAutomatedBackupDecoded
    }
}

public struct DeleteDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBInstanceOutputError>
}

extension DeleteDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBInstanceInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), deleteAutomatedBackups: \(String(describing: deleteAutomatedBackups)), finalDBSnapshotIdentifier: \(String(describing: finalDBSnapshotIdentifier)), skipFinalSnapshot: \(String(describing: skipFinalSnapshot)))"}
}

extension DeleteDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let deleteAutomatedBackups = deleteAutomatedBackups {
            try container.encode(deleteAutomatedBackups, forKey: Key("DeleteAutomatedBackups"))
        }
        if let finalDBSnapshotIdentifier = finalDBSnapshotIdentifier {
            try container.encode(finalDBSnapshotIdentifier, forKey: Key("FinalDBSnapshotIdentifier"))
        }
        if skipFinalSnapshot != false {
            try container.encode(skipFinalSnapshot, forKey: Key("SkipFinalSnapshot"))
        }
        try container.encode("DeleteDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBInstanceOutputError>
}

public struct DeleteDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBInstanceOutputError>
}

/// <p></p>
public struct DeleteDBInstanceInput: Equatable {
    /// <p>The DB instance identifier for the DB instance to be deleted. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the name of an existing DB instance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p>A value that indicates whether to remove automated backups immediately after the DB
    ///             instance is deleted. This parameter isn't case-sensitive. The default is to remove
    ///             automated backups immediately after the DB instance is deleted.</p>
    public let deleteAutomatedBackups: Bool?
    /// <p>
    ///         The <code>DBSnapshotIdentifier</code> of the new <code>DBSnapshot</code> created when the <code>SkipFinalSnapshot</code>
    ///         parameter is disabled.
    ///         </p>
    ///          <note>
    ///             <p>Specifying this parameter and also specifying to skip final DB snapshot creation in SkipFinalShapshot results in an error.</p>
    ///          </note>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be specified when deleting a read replica.</p>
    ///             </li>
    ///          </ul>
    public let finalDBSnapshotIdentifier: String?
    /// <p>A value that indicates whether to skip the creation of a final DB snapshot before the DB instance is deleted.
    ///           If skip is specified, no DB snapshot is created. If skip isn't specified, a DB snapshot
    ///           is created before the DB instance is deleted. By default, skip isn't specified, and the DB snapshot is created.</p>
    ///          <p>When a DB instance is in a failure state and has a status of 'failed', 'incompatible-restore', or 'incompatible-network', it can only be deleted when skip is specified.</p>
    ///          <p>Specify skip when deleting a read replica.</p>
    ///          <note>
    ///             <p>The FinalDBSnapshotIdentifier parameter must be specified if skip isn't specified.</p>
    ///          </note>
    public let skipFinalSnapshot: Bool

    public init (
        dBInstanceIdentifier: String? = nil,
        deleteAutomatedBackups: Bool? = nil,
        finalDBSnapshotIdentifier: String? = nil,
        skipFinalSnapshot: Bool = false
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.deleteAutomatedBackups = deleteAutomatedBackups
        self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
        self.skipFinalSnapshot = skipFinalSnapshot
    }
}

extension DeleteDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupQuotaExceededFault" : self = .dBInstanceAutomatedBackupQuotaExceededFault(try DBInstanceAutomatedBackupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExistsFault" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBInstanceOutputError: Equatable {
    case dBInstanceAutomatedBackupQuotaExceededFault(DBInstanceAutomatedBackupQuotaExceededFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBInstanceOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension DeleteDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct DeleteDBInstanceOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB instance.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
    ///       </p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct DeleteDBInstanceOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension DeleteDBInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct DeleteDBParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBParameterGroupOutputError>
}

extension DeleteDBParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBParameterGroupInput(dBParameterGroupName: \(String(describing: dBParameterGroupName)))"}
}

extension DeleteDBParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        try container.encode("DeleteDBParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBParameterGroupOutputError>
}

public struct DeleteDBParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBParameterGroupOutputError>
}

/// <p></p>
public struct DeleteDBParameterGroupInput: Equatable {
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be the name of an existing DB parameter group</p>
    ///             </li>
    ///             <li>
    ///                <p>You can't delete a default DB parameter group</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be associated with any DB instances</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?

    public init (
        dBParameterGroupName: String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

extension DeleteDBParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBParameterGroupOutputResponse()"}
}

extension DeleteDBParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBParameterGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteDBParameterGroupOutputResponseBody: Equatable {
}

extension DeleteDBParameterGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDBProxyEndpointInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBProxyEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBProxyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBProxyEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBProxyEndpointOutputError>
}

extension DeleteDBProxyEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBProxyEndpointInput(dBProxyEndpointName: \(String(describing: dBProxyEndpointName)))"}
}

extension DeleteDBProxyEndpointInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: Key("DBProxyEndpointName"))
        }
        try container.encode("DeleteDBProxyEndpoint", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBProxyEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBProxyEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBProxyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBProxyEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBProxyEndpointOutputError>
}

public struct DeleteDBProxyEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBProxyEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBProxyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBProxyEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBProxyEndpointOutputError>
}

public struct DeleteDBProxyEndpointInput: Equatable {
    /// <p>The name of the DB proxy endpoint to delete.</p>
    public let dBProxyEndpointName: String?

    public init (
        dBProxyEndpointName: String? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
    }
}

extension DeleteDBProxyEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBProxyEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointNotFoundFault" : self = .dBProxyEndpointNotFoundFault(try DBProxyEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyEndpointStateFault" : self = .invalidDBProxyEndpointStateFault(try InvalidDBProxyEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBProxyEndpointOutputError: Equatable {
    case dBProxyEndpointNotFoundFault(DBProxyEndpointNotFoundFault)
    case invalidDBProxyEndpointStateFault(InvalidDBProxyEndpointStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBProxyEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBProxyEndpointOutputResponse(dBProxyEndpoint: \(String(describing: dBProxyEndpoint)))"}
}

extension DeleteDBProxyEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBProxyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBProxyEndpoint = output.dBProxyEndpoint
        } else {
            self.dBProxyEndpoint = nil
        }
    }
}

public struct DeleteDBProxyEndpointOutputResponse: Equatable {
    /// <p>The data structure representing the details of the DB proxy endpoint that you delete.</p>
    public let dBProxyEndpoint: DBProxyEndpoint?

    public init (
        dBProxyEndpoint: DBProxyEndpoint? = nil
    )
    {
        self.dBProxyEndpoint = dBProxyEndpoint
    }
}

struct DeleteDBProxyEndpointOutputResponseBody: Equatable {
    public let dBProxyEndpoint: DBProxyEndpoint?
}

extension DeleteDBProxyEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBProxyEndpoint = "DBProxyEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBProxyEndpointResult"))
        let dBProxyEndpointDecoded = try containerValues.decodeIfPresent(DBProxyEndpoint.self, forKey: .dBProxyEndpoint)
        dBProxyEndpoint = dBProxyEndpointDecoded
    }
}

public struct DeleteDBProxyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBProxyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBProxyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBProxyInput>
    public typealias MOutput = OperationOutput<DeleteDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBProxyOutputError>
}

extension DeleteDBProxyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBProxyInput(dBProxyName: \(String(describing: dBProxyName)))"}
}

extension DeleteDBProxyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        try container.encode("DeleteDBProxy", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBProxyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBProxyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBProxyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBProxyInput>
    public typealias MOutput = OperationOutput<DeleteDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBProxyOutputError>
}

public struct DeleteDBProxyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBProxyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBProxyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBProxyInput>
    public typealias MOutput = OperationOutput<DeleteDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBProxyOutputError>
}

public struct DeleteDBProxyInput: Equatable {
    /// <p>The name of the DB proxy to delete.</p>
    public let dBProxyName: String?

    public init (
        dBProxyName: String? = nil
    )
    {
        self.dBProxyName = dBProxyName
    }
}

extension DeleteDBProxyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBProxyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBProxyOutputError: Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBProxyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBProxyOutputResponse(dBProxy: \(String(describing: dBProxy)))"}
}

extension DeleteDBProxyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBProxyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBProxy = output.dBProxy
        } else {
            self.dBProxy = nil
        }
    }
}

public struct DeleteDBProxyOutputResponse: Equatable {
    /// <p>The data structure representing the details of the DB proxy that you delete.</p>
    public let dBProxy: DBProxy?

    public init (
        dBProxy: DBProxy? = nil
    )
    {
        self.dBProxy = dBProxy
    }
}

struct DeleteDBProxyOutputResponseBody: Equatable {
    public let dBProxy: DBProxy?
}

extension DeleteDBProxyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBProxy = "DBProxy"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBProxyResult"))
        let dBProxyDecoded = try containerValues.decodeIfPresent(DBProxy.self, forKey: .dBProxy)
        dBProxy = dBProxyDecoded
    }
}

public struct DeleteDBSecurityGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBSecurityGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSecurityGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSecurityGroupOutputError>
}

extension DeleteDBSecurityGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBSecurityGroupInput(dBSecurityGroupName: \(String(describing: dBSecurityGroupName)))"}
}

extension DeleteDBSecurityGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: Key("DBSecurityGroupName"))
        }
        try container.encode("DeleteDBSecurityGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBSecurityGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBSecurityGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSecurityGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSecurityGroupOutputError>
}

public struct DeleteDBSecurityGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBSecurityGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSecurityGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSecurityGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSecurityGroupOutputError>
}

/// <p></p>
public struct DeleteDBSecurityGroupInput: Equatable {
    /// <p>The name of the DB security group to delete.</p>
    ///          <note>
    ///             <p>You can't delete the default DB security group.</p>
    ///          </note>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not be "Default"</p>
    ///             </li>
    ///          </ul>
    public let dBSecurityGroupName: String?

    public init (
        dBSecurityGroupName: String? = nil
    )
    {
        self.dBSecurityGroupName = dBSecurityGroupName
    }
}

extension DeleteDBSecurityGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBSecurityGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupStateFault" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBSecurityGroupOutputError: Equatable {
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBSecurityGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBSecurityGroupOutputResponse()"}
}

extension DeleteDBSecurityGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBSecurityGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteDBSecurityGroupOutputResponseBody: Equatable {
}

extension DeleteDBSecurityGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDBSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSnapshotOutputError>
}

extension DeleteDBSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBSnapshotInput(dBSnapshotIdentifier: \(String(describing: dBSnapshotIdentifier)))"}
}

extension DeleteDBSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: Key("DBSnapshotIdentifier"))
        }
        try container.encode("DeleteDBSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSnapshotOutputError>
}

public struct DeleteDBSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSnapshotOutputError>
}

/// <p></p>
public struct DeleteDBSnapshotInput: Equatable {
    /// <p>The DB snapshot identifier.</p>
    ///          <p>Constraints: Must be the name of an existing DB snapshot in the <code>available</code> state.</p>
    public let dBSnapshotIdentifier: String?

    public init (
        dBSnapshotIdentifier: String? = nil
    )
    {
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
    }
}

extension DeleteDBSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotStateFault" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBSnapshotOutputError: Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBSnapshotOutputResponse(dBSnapshot: \(String(describing: dBSnapshot)))"}
}

extension DeleteDBSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct DeleteDBSnapshotOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB snapshot.
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBSnapshots</code> action.
    ///       </p>
    public let dBSnapshot: DBSnapshot?

    public init (
        dBSnapshot: DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct DeleteDBSnapshotOutputResponseBody: Equatable {
    public let dBSnapshot: DBSnapshot?
}

extension DeleteDBSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

public struct DeleteDBSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSubnetGroupOutputError>
}

extension DeleteDBSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBSubnetGroupInput(dBSubnetGroupName: \(String(describing: dBSubnetGroupName)))"}
}

extension DeleteDBSubnetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        try container.encode("DeleteDBSubnetGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSubnetGroupOutputError>
}

public struct DeleteDBSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSubnetGroupOutputError>
}

/// <p></p>
public struct DeleteDBSubnetGroupInput: Equatable {
    /// <p>The name of the database subnet group to delete.</p>
    ///          <note>
    ///             <p>You can't delete the default subnet group.</p>
    ///          </note>
    ///          <p>Constraints:</p>
    ///          <p>Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?

    public init (
        dBSubnetGroupName: String? = nil
    )
    {
        self.dBSubnetGroupName = dBSubnetGroupName
    }
}

extension DeleteDBSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetStateFault" : self = .invalidDBSubnetStateFault(try InvalidDBSubnetStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBSubnetGroupOutputError: Equatable {
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidDBSubnetStateFault(InvalidDBSubnetStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBSubnetGroupOutputResponse()"}
}

extension DeleteDBSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBSubnetGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteDBSubnetGroupOutputResponseBody: Equatable {
}

extension DeleteDBSubnetGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

extension DeleteEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventSubscriptionInput(subscriptionName: \(String(describing: subscriptionName)))"}
}

extension DeleteEventSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("DeleteEventSubscription", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

public struct DeleteEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

/// <p></p>
public struct DeleteEventSubscriptionInput: Equatable {
    /// <p>The name of the RDS event notification subscription you want to delete.</p>
    public let subscriptionName: String?

    public init (
        subscriptionName: String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

extension DeleteEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidEventSubscriptionStateFault" : self = .invalidEventSubscriptionStateFault(try InvalidEventSubscriptionStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSubscriptionOutputError: Equatable {
    case invalidEventSubscriptionStateFault(InvalidEventSubscriptionStateFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension DeleteEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct DeleteEventSubscriptionOutputResponse: Equatable {
    /// <p>Contains the results of a successful invocation of the <code>DescribeEventSubscriptions</code> action.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct DeleteEventSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension DeleteEventSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct DeleteGlobalClusterInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGlobalClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGlobalClusterInput>
    public typealias MOutput = OperationOutput<DeleteGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGlobalClusterOutputError>
}

extension DeleteGlobalClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGlobalClusterInput(globalClusterIdentifier: \(String(describing: globalClusterIdentifier)))"}
}

extension DeleteGlobalClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: Key("GlobalClusterIdentifier"))
        }
        try container.encode("DeleteGlobalCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteGlobalClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGlobalClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGlobalClusterInput>
    public typealias MOutput = OperationOutput<DeleteGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGlobalClusterOutputError>
}

public struct DeleteGlobalClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGlobalClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGlobalClusterInput>
    public typealias MOutput = OperationOutput<DeleteGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGlobalClusterOutputError>
}

public struct DeleteGlobalClusterInput: Equatable {
    /// <p>
    ///         The cluster identifier of the global database cluster being deleted.
    ///       </p>
    public let globalClusterIdentifier: String?

    public init (
        globalClusterIdentifier: String? = nil
    )
    {
        self.globalClusterIdentifier = globalClusterIdentifier
    }
}

extension DeleteGlobalClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteGlobalClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGlobalClusterOutputError: Equatable {
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGlobalClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGlobalClusterOutputResponse(globalCluster: \(String(describing: globalCluster)))"}
}

extension DeleteGlobalClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct DeleteGlobalClusterOutputResponse: Equatable {
    /// <p>A data type representing an Aurora global database.</p>
    public let globalCluster: GlobalCluster?

    public init (
        globalCluster: GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct DeleteGlobalClusterOutputResponseBody: Equatable {
    public let globalCluster: GlobalCluster?
}

extension DeleteGlobalClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

public struct DeleteInstallationMediaInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInstallationMediaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstallationMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstallationMediaInput>
    public typealias MOutput = OperationOutput<DeleteInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstallationMediaOutputError>
}

extension DeleteInstallationMediaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstallationMediaInput(installationMediaId: \(String(describing: installationMediaId)))"}
}

extension DeleteInstallationMediaInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let installationMediaId = installationMediaId {
            try container.encode(installationMediaId, forKey: Key("InstallationMediaId"))
        }
        try container.encode("DeleteInstallationMedia", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteInstallationMediaInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInstallationMediaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstallationMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstallationMediaInput>
    public typealias MOutput = OperationOutput<DeleteInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstallationMediaOutputError>
}

public struct DeleteInstallationMediaInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInstallationMediaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstallationMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstallationMediaInput>
    public typealias MOutput = OperationOutput<DeleteInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstallationMediaOutputError>
}

public struct DeleteInstallationMediaInput: Equatable {
    /// <p>The installation medium ID.</p>
    public let installationMediaId: String?

    public init (
        installationMediaId: String? = nil
    )
    {
        self.installationMediaId = installationMediaId
    }
}

extension DeleteInstallationMediaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteInstallationMediaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InstallationMediaNotFoundFault" : self = .installationMediaNotFoundFault(try InstallationMediaNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstallationMediaOutputError: Equatable {
    case installationMediaNotFoundFault(InstallationMediaNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstallationMediaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstallationMediaOutputResponse(customAvailabilityZoneId: \(String(describing: customAvailabilityZoneId)), engine: \(String(describing: engine)), engineInstallationMediaPath: \(String(describing: engineInstallationMediaPath)), engineVersion: \(String(describing: engineVersion)), failureCause: \(String(describing: failureCause)), installationMediaId: \(String(describing: installationMediaId)), oSInstallationMediaPath: \(String(describing: oSInstallationMediaPath)), status: \(String(describing: status)))"}
}

extension DeleteInstallationMediaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteInstallationMediaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customAvailabilityZoneId = output.customAvailabilityZoneId
            self.engine = output.engine
            self.engineInstallationMediaPath = output.engineInstallationMediaPath
            self.engineVersion = output.engineVersion
            self.failureCause = output.failureCause
            self.installationMediaId = output.installationMediaId
            self.oSInstallationMediaPath = output.oSInstallationMediaPath
            self.status = output.status
        } else {
            self.customAvailabilityZoneId = nil
            self.engine = nil
            self.engineInstallationMediaPath = nil
            self.engineVersion = nil
            self.failureCause = nil
            self.installationMediaId = nil
            self.oSInstallationMediaPath = nil
            self.status = nil
        }
    }
}

/// <p>Contains the installation media for a DB engine that requires an on-premises
///           customer provided license, such as Microsoft SQL Server.</p>
public struct DeleteInstallationMediaOutputResponse: Equatable {
    /// <p>The custom Availability Zone (AZ) that contains the installation media.</p>
    public let customAvailabilityZoneId: String?
    /// <p>The DB engine.</p>
    public let engine: String?
    /// <p>The path to the installation medium for the DB engine.</p>
    public let engineInstallationMediaPath: String?
    /// <p>The engine version of the DB engine.</p>
    public let engineVersion: String?
    /// <p>If an installation media failure occurred, the cause of the failure.</p>
    public let failureCause: InstallationMediaFailureCause?
    /// <p>The installation medium ID.</p>
    public let installationMediaId: String?
    /// <p>The path to the installation medium for the operating system associated with the DB engine.</p>
    public let oSInstallationMediaPath: String?
    /// <p>The status of the installation medium.</p>
    public let status: String?

    public init (
        customAvailabilityZoneId: String? = nil,
        engine: String? = nil,
        engineInstallationMediaPath: String? = nil,
        engineVersion: String? = nil,
        failureCause: InstallationMediaFailureCause? = nil,
        installationMediaId: String? = nil,
        oSInstallationMediaPath: String? = nil,
        status: String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.engine = engine
        self.engineInstallationMediaPath = engineInstallationMediaPath
        self.engineVersion = engineVersion
        self.failureCause = failureCause
        self.installationMediaId = installationMediaId
        self.oSInstallationMediaPath = oSInstallationMediaPath
        self.status = status
    }
}

struct DeleteInstallationMediaOutputResponseBody: Equatable {
    public let installationMediaId: String?
    public let customAvailabilityZoneId: String?
    public let engine: String?
    public let engineVersion: String?
    public let engineInstallationMediaPath: String?
    public let oSInstallationMediaPath: String?
    public let status: String?
    public let failureCause: InstallationMediaFailureCause?
}

extension DeleteInstallationMediaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case engine = "Engine"
        case engineInstallationMediaPath = "EngineInstallationMediaPath"
        case engineVersion = "EngineVersion"
        case failureCause = "FailureCause"
        case installationMediaId = "InstallationMediaId"
        case oSInstallationMediaPath = "OSInstallationMediaPath"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteInstallationMediaResult"))
        let installationMediaIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .installationMediaId)
        installationMediaId = installationMediaIdDecoded
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineInstallationMediaPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineInstallationMediaPath)
        engineInstallationMediaPath = engineInstallationMediaPathDecoded
        let oSInstallationMediaPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oSInstallationMediaPath)
        oSInstallationMediaPath = oSInstallationMediaPathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(InstallationMediaFailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
    }
}

public struct DeleteOptionGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteOptionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOptionGroupInput>
    public typealias MOutput = OperationOutput<DeleteOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOptionGroupOutputError>
}

extension DeleteOptionGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOptionGroupInput(optionGroupName: \(String(describing: optionGroupName)))"}
}

extension DeleteOptionGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        try container.encode("DeleteOptionGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteOptionGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteOptionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOptionGroupInput>
    public typealias MOutput = OperationOutput<DeleteOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOptionGroupOutputError>
}

public struct DeleteOptionGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteOptionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOptionGroupInput>
    public typealias MOutput = OperationOutput<DeleteOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOptionGroupOutputError>
}

/// <p></p>
public struct DeleteOptionGroupInput: Equatable {
    /// <p>The name of the option group to be deleted.</p>
    ///          <note>
    ///             <p>You can't delete default option groups.</p>
    ///          </note>
    public let optionGroupName: String?

    public init (
        optionGroupName: String? = nil
    )
    {
        self.optionGroupName = optionGroupName
    }
}

extension DeleteOptionGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteOptionGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidOptionGroupStateFault" : self = .invalidOptionGroupStateFault(try InvalidOptionGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOptionGroupOutputError: Equatable {
    case invalidOptionGroupStateFault(InvalidOptionGroupStateFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOptionGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOptionGroupOutputResponse()"}
}

extension DeleteOptionGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOptionGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteOptionGroupOutputResponseBody: Equatable {
}

extension DeleteOptionGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterDBProxyTargetsInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterDBProxyTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterDBProxyTargetsInput>
    public typealias MOutput = OperationOutput<DeregisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterDBProxyTargetsOutputError>
}

extension DeregisterDBProxyTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterDBProxyTargetsInput(dBClusterIdentifiers: \(String(describing: dBClusterIdentifiers)), dBInstanceIdentifiers: \(String(describing: dBInstanceIdentifiers)), dBProxyName: \(String(describing: dBProxyName)), targetGroupName: \(String(describing: targetGroupName)))"}
}

extension DeregisterDBProxyTargetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifiers = dBClusterIdentifiers {
            var dBClusterIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBClusterIdentifiers"))
            for (index0, string0) in dBClusterIdentifiers.enumerated() {
                try dBClusterIdentifiersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceIdentifiers = dBInstanceIdentifiers {
            var dBInstanceIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBInstanceIdentifiers"))
            for (index0, string0) in dBInstanceIdentifiers.enumerated() {
                try dBInstanceIdentifiersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: Key("TargetGroupName"))
        }
        try container.encode("DeregisterDBProxyTargets", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeregisterDBProxyTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterDBProxyTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterDBProxyTargetsInput>
    public typealias MOutput = OperationOutput<DeregisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterDBProxyTargetsOutputError>
}

public struct DeregisterDBProxyTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterDBProxyTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterDBProxyTargetsInput>
    public typealias MOutput = OperationOutput<DeregisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterDBProxyTargetsOutputError>
}

public struct DeregisterDBProxyTargetsInput: Equatable {
    /// <p>One or more DB cluster identifiers.</p>
    public let dBClusterIdentifiers: [String]?
    /// <p>One or more DB instance identifiers.</p>
    public let dBInstanceIdentifiers: [String]?
    /// <p>The identifier of the <code>DBProxy</code> that is associated with the <code>DBProxyTargetGroup</code>.</p>
    public let dBProxyName: String?
    /// <p>The identifier of the <code>DBProxyTargetGroup</code>.</p>
    public let targetGroupName: String?

    public init (
        dBClusterIdentifiers: [String]? = nil,
        dBInstanceIdentifiers: [String]? = nil,
        dBProxyName: String? = nil,
        targetGroupName: String? = nil
    )
    {
        self.dBClusterIdentifiers = dBClusterIdentifiers
        self.dBInstanceIdentifiers = dBInstanceIdentifiers
        self.dBProxyName = dBProxyName
        self.targetGroupName = targetGroupName
    }
}

extension DeregisterDBProxyTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeregisterDBProxyTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetNotFoundFault" : self = .dBProxyTargetNotFoundFault(try DBProxyTargetNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterDBProxyTargetsOutputError: Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBProxyTargetNotFoundFault(DBProxyTargetNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterDBProxyTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterDBProxyTargetsOutputResponse()"}
}

extension DeregisterDBProxyTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterDBProxyTargetsOutputResponse: Equatable {

    public init() {}
}

struct DeregisterDBProxyTargetsOutputResponseBody: Equatable {
}

extension DeregisterDBProxyTargetsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAccountAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

extension DescribeAccountAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAttributesInput()"}
}

extension DescribeAccountAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("DescribeAccountAttributes", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeAccountAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

/// <p></p>
public struct DescribeAccountAttributesInput: Equatable {

    public init() {}
}

extension DescribeAccountAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAccountAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAttributesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAttributesOutputResponse(accountQuotas: \(String(describing: accountQuotas)))"}
}

extension DescribeAccountAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountQuotas = output.accountQuotas
        } else {
            self.accountQuotas = nil
        }
    }
}

/// <p>Data returned by the <b>DescribeAccountAttributes</b> action.</p>
public struct DescribeAccountAttributesOutputResponse: Equatable {
    /// <p>A list of <code>AccountQuota</code> objects. Within this list, each quota has a name,
    ///             a count of usage toward the quota maximum, and a maximum value for the quota.</p>
    public let accountQuotas: [AccountQuota]?

    public init (
        accountQuotas: [AccountQuota]? = nil
    )
    {
        self.accountQuotas = accountQuotas
    }
}

struct DescribeAccountAttributesOutputResponseBody: Equatable {
    public let accountQuotas: [AccountQuota]?
}

extension DescribeAccountAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountQuotas = "AccountQuotas"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeAccountAttributesResult"))
        if containerValues.contains(.accountQuotas) {
            struct KeyVal0{struct AccountQuota{}}
            let accountQuotasWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccountQuota>.CodingKeys.self, forKey: .accountQuotas)
            if let accountQuotasWrappedContainer = accountQuotasWrappedContainer {
                let accountQuotasContainer = try accountQuotasWrappedContainer.decodeIfPresent([AccountQuota].self, forKey: .member)
                var accountQuotasBuffer:[AccountQuota]? = nil
                if let accountQuotasContainer = accountQuotasContainer {
                    accountQuotasBuffer = [AccountQuota]()
                    for structureContainer0 in accountQuotasContainer {
                        accountQuotasBuffer?.append(structureContainer0)
                    }
                }
                accountQuotas = accountQuotasBuffer
            } else {
                accountQuotas = []
            }
        } else {
            accountQuotas = nil
        }
    }
}

public struct DescribeCertificatesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificatesOutputError>
}

extension DescribeCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificatesInput(certificateIdentifier: \(String(describing: certificateIdentifier)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeCertificatesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificateIdentifier = certificateIdentifier {
            try container.encode(certificateIdentifier, forKey: Key("CertificateIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeCertificates", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificatesOutputError>
}

public struct DescribeCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificatesOutputError>
}

/// <p></p>
public struct DescribeCertificatesInput: Equatable {
    /// <p>The user-supplied certificate identifier. If this parameter is specified, information for only the identified certificate is returned. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match an existing CertificateIdentifier.</p>
    ///             </li>
    ///          </ul>
    public let certificateIdentifier: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous
    ///         <code>DescribeCertificates</code> request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///         a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        certificateIdentifier: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.certificateIdentifier = certificateIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateNotFoundFault" : self = .certificateNotFoundFault(try CertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCertificatesOutputError: Equatable {
    case certificateNotFoundFault(CertificateNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificatesOutputResponse(certificates: \(String(describing: certificates)), marker: \(String(describing: marker)))"}
}

extension DescribeCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificates = output.certificates
            self.marker = output.marker
        } else {
            self.certificates = nil
            self.marker = nil
        }
    }
}

/// <p>Data returned by the <b>DescribeCertificates</b> action.</p>
public struct DescribeCertificatesOutputResponse: Equatable {
    /// <p>The list of <code>Certificate</code> objects for the AWS account.</p>
    public let certificates: [Certificate]?
    /// <p>
    ///             An optional pagination token provided by a previous
    ///             <code>DescribeCertificates</code> request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code> .
    ///         </p>
    public let marker: String?

    public init (
        certificates: [Certificate]? = nil,
        marker: String? = nil
    )
    {
        self.certificates = certificates
        self.marker = marker
    }
}

struct DescribeCertificatesOutputResponseBody: Equatable {
    public let certificates: [Certificate]?
    public let marker: String?
}

extension DescribeCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificates = "Certificates"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeCertificatesResult"))
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct Certificate{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Certificate>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([Certificate].self, forKey: .member)
                var certificatesBuffer:[Certificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [Certificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeCustomAvailabilityZonesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCustomAvailabilityZonesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomAvailabilityZonesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomAvailabilityZonesInput>
    public typealias MOutput = OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomAvailabilityZonesOutputError>
}

extension DescribeCustomAvailabilityZonesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomAvailabilityZonesInput(customAvailabilityZoneId: \(String(describing: customAvailabilityZoneId)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeCustomAvailabilityZonesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: Key("CustomAvailabilityZoneId"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeCustomAvailabilityZones", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeCustomAvailabilityZonesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCustomAvailabilityZonesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomAvailabilityZonesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomAvailabilityZonesInput>
    public typealias MOutput = OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomAvailabilityZonesOutputError>
}

public struct DescribeCustomAvailabilityZonesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCustomAvailabilityZonesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomAvailabilityZonesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomAvailabilityZonesInput>
    public typealias MOutput = OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomAvailabilityZonesOutputError>
}

public struct DescribeCustomAvailabilityZonesInput: Equatable {
    /// <p>The custom AZ identifier. If this parameter is specified, information from only the specific custom AZ is returned.</p>
    public let customAvailabilityZoneId: String?
    /// <p>A filter that specifies one or more custom AZs to describe.</p>
    public let filters: [Filter]?
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeCustomAvailabilityZones</code> request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response.
    ///             If more records exist than the specified <code>MaxRecords</code> value,
    ///             a pagination token called a marker is included in the response so you can retrieve the remaining results.</p>
    ///         <p>Default: 100</p>
    ///         <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        customAvailabilityZoneId: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeCustomAvailabilityZonesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeCustomAvailabilityZonesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFoundFault" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomAvailabilityZonesOutputError: Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomAvailabilityZonesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomAvailabilityZonesOutputResponse(customAvailabilityZones: \(String(describing: customAvailabilityZones)), marker: \(String(describing: marker)))"}
}

extension DescribeCustomAvailabilityZonesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCustomAvailabilityZonesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customAvailabilityZones = output.customAvailabilityZones
            self.marker = output.marker
        } else {
            self.customAvailabilityZones = nil
            self.marker = nil
        }
    }
}

public struct DescribeCustomAvailabilityZonesOutputResponse: Equatable {
    /// <p>The list of <a>CustomAvailabilityZone</a> objects for the AWS account.</p>
    public let customAvailabilityZones: [CustomAvailabilityZone]?
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeCustomAvailabilityZones</code> request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?

    public init (
        customAvailabilityZones: [CustomAvailabilityZone]? = nil,
        marker: String? = nil
    )
    {
        self.customAvailabilityZones = customAvailabilityZones
        self.marker = marker
    }
}

struct DescribeCustomAvailabilityZonesOutputResponseBody: Equatable {
    public let marker: String?
    public let customAvailabilityZones: [CustomAvailabilityZone]?
}

extension DescribeCustomAvailabilityZonesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customAvailabilityZones = "CustomAvailabilityZones"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeCustomAvailabilityZonesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.customAvailabilityZones) {
            struct KeyVal0{struct CustomAvailabilityZone{}}
            let customAvailabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CustomAvailabilityZone>.CodingKeys.self, forKey: .customAvailabilityZones)
            if let customAvailabilityZonesWrappedContainer = customAvailabilityZonesWrappedContainer {
                let customAvailabilityZonesContainer = try customAvailabilityZonesWrappedContainer.decodeIfPresent([CustomAvailabilityZone].self, forKey: .member)
                var customAvailabilityZonesBuffer:[CustomAvailabilityZone]? = nil
                if let customAvailabilityZonesContainer = customAvailabilityZonesContainer {
                    customAvailabilityZonesBuffer = [CustomAvailabilityZone]()
                    for structureContainer0 in customAvailabilityZonesContainer {
                        customAvailabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                customAvailabilityZones = customAvailabilityZonesBuffer
            } else {
                customAvailabilityZones = []
            }
        } else {
            customAvailabilityZones = nil
        }
    }
}

public struct DescribeDBClusterBacktracksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClusterBacktracksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterBacktracksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterBacktracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterBacktracksInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterBacktracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterBacktracksOutputError>
}

extension DescribeDBClusterBacktracksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterBacktracksInput(backtrackIdentifier: \(String(describing: backtrackIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBClusterBacktracksInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let backtrackIdentifier = backtrackIdentifier {
            try container.encode(backtrackIdentifier, forKey: Key("BacktrackIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterBacktracks", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClusterBacktracksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClusterBacktracksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterBacktracksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterBacktracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterBacktracksInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterBacktracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterBacktracksOutputError>
}

public struct DescribeDBClusterBacktracksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClusterBacktracksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterBacktracksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterBacktracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterBacktracksInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterBacktracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterBacktracksOutputError>
}

/// <p></p>
public struct DescribeDBClusterBacktracksInput: Equatable {
    /// <p>If specified, this value is the backtrack identifier of the backtrack to be
    ///             described.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must contain a valid universally unique identifier (UUID). For more
    ///                     information about UUIDs, see <a href="http://www.ietf.org/rfc/rfc4122.txt">A Universally Unique Identifier
    ///                         (UUID) URN Namespace</a>.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>123e4567-e89b-12d3-a456-426655440000</code>
    ///         </p>
    public let backtrackIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster to be described. This parameter is
    ///             stored as a lowercase string.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>my-cluster1</code>
    ///         </p>
    public let dBClusterIdentifier: String?
    /// <p>A filter that specifies one or more DB clusters to describe. Supported filters
    ///             include the following:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                     <code>db-cluster-backtrack-id</code> - Accepts backtrack identifiers. The
    ///                     results list includes information about only the backtracks identified by these
    ///                     identifiers.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-backtrack-status</code> - Accepts any of the following backtrack status values:</p>
    ///                 <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>applying</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>completed</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>failed</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>pending</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                 <p>The results list includes information about only the backtracks identified
    ///                     by these values.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous
    ///             <code>DescribeDBClusterBacktracks</code> request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response.
    ///             If more records exist than the specified <code>MaxRecords</code> value,
    ///             a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///         </p>
    ///         <p>Default: 100</p>
    ///         <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        backtrackIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.backtrackIdentifier = backtrackIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClusterBacktracksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterBacktracksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterBacktrackNotFoundFault" : self = .dBClusterBacktrackNotFoundFault(try DBClusterBacktrackNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterBacktracksOutputError: Equatable {
    case dBClusterBacktrackNotFoundFault(DBClusterBacktrackNotFoundFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterBacktracksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterBacktracksOutputResponse(dBClusterBacktracks: \(String(describing: dBClusterBacktracks)), marker: \(String(describing: marker)))"}
}

extension DescribeDBClusterBacktracksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClusterBacktracksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterBacktracks = output.dBClusterBacktracks
            self.marker = output.marker
        } else {
            self.dBClusterBacktracks = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the result of a successful invocation of the <code>DescribeDBClusterBacktracks</code> action.</p>
public struct DescribeDBClusterBacktracksOutputResponse: Equatable {
    /// <p>Contains a list of backtracks for the user.</p>
    public let dBClusterBacktracks: [DBClusterBacktrack]?
    /// <p>A pagination token that can be used in a later <code>DescribeDBClusterBacktracks</code> request.</p>
    public let marker: String?

    public init (
        dBClusterBacktracks: [DBClusterBacktrack]? = nil,
        marker: String? = nil
    )
    {
        self.dBClusterBacktracks = dBClusterBacktracks
        self.marker = marker
    }
}

struct DescribeDBClusterBacktracksOutputResponseBody: Equatable {
    public let marker: String?
    public let dBClusterBacktracks: [DBClusterBacktrack]?
}

extension DescribeDBClusterBacktracksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterBacktracks = "DBClusterBacktracks"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClusterBacktracksResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterBacktracks) {
            struct KeyVal0{struct DBClusterBacktrack{}}
            let dBClusterBacktracksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterBacktrack>.CodingKeys.self, forKey: .dBClusterBacktracks)
            if let dBClusterBacktracksWrappedContainer = dBClusterBacktracksWrappedContainer {
                let dBClusterBacktracksContainer = try dBClusterBacktracksWrappedContainer.decodeIfPresent([DBClusterBacktrack].self, forKey: .member)
                var dBClusterBacktracksBuffer:[DBClusterBacktrack]? = nil
                if let dBClusterBacktracksContainer = dBClusterBacktracksContainer {
                    dBClusterBacktracksBuffer = [DBClusterBacktrack]()
                    for structureContainer0 in dBClusterBacktracksContainer {
                        dBClusterBacktracksBuffer?.append(structureContainer0)
                    }
                }
                dBClusterBacktracks = dBClusterBacktracksBuffer
            } else {
                dBClusterBacktracks = []
            }
        } else {
            dBClusterBacktracks = nil
        }
    }
}

public struct DescribeDBClusterEndpointsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClusterEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterEndpointsOutputError>
}

extension DescribeDBClusterEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterEndpointsInput(dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBClusterEndpointsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterEndpoints", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClusterEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClusterEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterEndpointsOutputError>
}

public struct DescribeDBClusterEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClusterEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterEndpointsOutputError>
}

public struct DescribeDBClusterEndpointsInput: Equatable {
    /// <p>The identifier of the endpoint to describe. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///             stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>A set of name-value pairs that define which endpoints to include in the output.
    ///        The filters are specified as name-value pairs, in the format
    ///        <code>Name=<i>endpoint_type</i>,Values=<i>endpoint_type1</i>,<i>endpoint_type2</i>,...</code>.
    ///        <code>Name</code> can be one of: <code>db-cluster-endpoint-type</code>, <code>db-cluster-endpoint-custom-type</code>, <code>db-cluster-endpoint-id</code>, <code>db-cluster-endpoint-status</code>.
    ///          <code>Values</code> for the <code> db-cluster-endpoint-type</code> filter can be one or more of: <code>reader</code>, <code>writer</code>, <code>custom</code>.
    ///        <code>Values</code> for the <code>db-cluster-endpoint-custom-type</code> filter can be one or more of: <code>reader</code>, <code>any</code>.
    ///        <code>Values</code> for the <code>db-cluster-endpoint-status</code> filter can be one or more of: <code>available</code>, <code>creating</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>.
    ///      </p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous
    ///             <code>DescribeDBClusterEndpoints</code> request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response.
    ///             If more records exist than the specified <code>MaxRecords</code> value,
    ///             a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///         </p>
    ///         <p>Default: 100</p>
    ///         <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClusterEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterEndpointsOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterEndpointsOutputResponse(dBClusterEndpoints: \(String(describing: dBClusterEndpoints)), marker: \(String(describing: marker)))"}
}

extension DescribeDBClusterEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClusterEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterEndpoints = output.dBClusterEndpoints
            self.marker = output.marker
        } else {
            self.dBClusterEndpoints = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBClusterEndpointsOutputResponse: Equatable {
    /// <p>Contains the details of the endpoints associated with the cluster
    ///        and matching any filter conditions.</p>
    public let dBClusterEndpoints: [DBClusterEndpoint]?
    /// <p> An optional pagination token provided by a previous
    ///             <code>DescribeDBClusterEndpoints</code> request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?

    public init (
        dBClusterEndpoints: [DBClusterEndpoint]? = nil,
        marker: String? = nil
    )
    {
        self.dBClusterEndpoints = dBClusterEndpoints
        self.marker = marker
    }
}

struct DescribeDBClusterEndpointsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBClusterEndpoints: [DBClusterEndpoint]?
}

extension DescribeDBClusterEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterEndpoints = "DBClusterEndpoints"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClusterEndpointsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterEndpoints) {
            struct KeyVal0{struct DBClusterEndpointList{}}
            let dBClusterEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterEndpointList>.CodingKeys.self, forKey: .dBClusterEndpoints)
            if let dBClusterEndpointsWrappedContainer = dBClusterEndpointsWrappedContainer {
                let dBClusterEndpointsContainer = try dBClusterEndpointsWrappedContainer.decodeIfPresent([DBClusterEndpoint].self, forKey: .member)
                var dBClusterEndpointsBuffer:[DBClusterEndpoint]? = nil
                if let dBClusterEndpointsContainer = dBClusterEndpointsContainer {
                    dBClusterEndpointsBuffer = [DBClusterEndpoint]()
                    for structureContainer0 in dBClusterEndpointsContainer {
                        dBClusterEndpointsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterEndpoints = dBClusterEndpointsBuffer
            } else {
                dBClusterEndpoints = []
            }
        } else {
            dBClusterEndpoints = nil
        }
    }
}

public struct DescribeDBClusterParameterGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParameterGroupsOutputError>
}

extension DescribeDBClusterParameterGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterParameterGroupsInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBClusterParameterGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterParameterGroups", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClusterParameterGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParameterGroupsOutputError>
}

public struct DescribeDBClusterParameterGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParameterGroupsOutputError>
}

/// <p></p>
public struct DescribeDBClusterParameterGroupsInput: Equatable {
    /// <p>The name of a specific DB cluster parameter group to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous
    ///         <code>DescribeDBClusterParameterGroups</code> request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///       </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBClusterParameterGroupName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClusterParameterGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterParameterGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterParameterGroupsOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterParameterGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterParameterGroupsOutputResponse(dBClusterParameterGroups: \(String(describing: dBClusterParameterGroups)), marker: \(String(describing: marker)))"}
}

extension DescribeDBClusterParameterGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClusterParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterParameterGroups = output.dBClusterParameterGroups
            self.marker = output.marker
        } else {
            self.dBClusterParameterGroups = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeDBClusterParameterGroupsOutputResponse: Equatable {
    /// <p>A list of DB cluster parameter groups.</p>
    public let dBClusterParameterGroups: [DBClusterParameterGroup]?
    /// <p>
    ///             An optional pagination token provided by a previous
    ///             <code>DescribeDBClusterParameterGroups</code> request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?

    public init (
        dBClusterParameterGroups: [DBClusterParameterGroup]? = nil,
        marker: String? = nil
    )
    {
        self.dBClusterParameterGroups = dBClusterParameterGroups
        self.marker = marker
    }
}

struct DescribeDBClusterParameterGroupsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBClusterParameterGroups: [DBClusterParameterGroup]?
}

extension DescribeDBClusterParameterGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroups = "DBClusterParameterGroups"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClusterParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterParameterGroups) {
            struct KeyVal0{struct DBClusterParameterGroup{}}
            let dBClusterParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterParameterGroup>.CodingKeys.self, forKey: .dBClusterParameterGroups)
            if let dBClusterParameterGroupsWrappedContainer = dBClusterParameterGroupsWrappedContainer {
                let dBClusterParameterGroupsContainer = try dBClusterParameterGroupsWrappedContainer.decodeIfPresent([DBClusterParameterGroup].self, forKey: .member)
                var dBClusterParameterGroupsBuffer:[DBClusterParameterGroup]? = nil
                if let dBClusterParameterGroupsContainer = dBClusterParameterGroupsContainer {
                    dBClusterParameterGroupsBuffer = [DBClusterParameterGroup]()
                    for structureContainer0 in dBClusterParameterGroupsContainer {
                        dBClusterParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterParameterGroups = dBClusterParameterGroupsBuffer
            } else {
                dBClusterParameterGroups = []
            }
        } else {
            dBClusterParameterGroups = nil
        }
    }
}

public struct DescribeDBClusterParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParametersOutputError>
}

extension DescribeDBClusterParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterParametersInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), source: \(String(describing: source)))"}
}

extension DescribeDBClusterParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
        try container.encode("DescribeDBClusterParameters", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClusterParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParametersOutputError>
}

public struct DescribeDBClusterParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParametersOutputError>
}

/// <p></p>
public struct DescribeDBClusterParametersInput: Equatable {
    /// <p>The name of a specific DB cluster parameter group to return parameter details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///       An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterParameters</code> request.
    ///       If this parameter is specified, the response includes
    ///       only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: String?
    /// <p>
    ///       The maximum number of records to include in the response.
    ///       If more records exist than the specified <code>MaxRecords</code> value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///     </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>
    ///       A value that indicates to return only parameters for a specific source.
    ///       Parameter sources can be <code>engine</code>, <code>service</code>,
    ///       or <code>customer</code>.
    ///     </p>
    public let source: String?

    public init (
        dBClusterParameterGroupName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        source: String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.source = source
    }
}

extension DescribeDBClusterParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterParametersOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterParametersOutputResponse(marker: \(String(describing: marker)), parameters: \(String(describing: parameters)))"}
}

extension DescribeDBClusterParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

/// <p>Provides details about a DB cluster parameter group including the parameters in the DB cluster parameter group.</p>
public struct DescribeDBClusterParametersOutputResponse: Equatable {
    /// <p>
    ///             An optional pagination token provided by a previous
    ///             DescribeDBClusterParameters request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code> .
    ///         </p>
    public let marker: String?
    /// <p>Provides a list of parameters for the DB cluster parameter group.</p>
    public let parameters: [Parameter]?

    public init (
        marker: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeDBClusterParametersOutputResponseBody: Equatable {
    public let parameters: [Parameter]?
    public let marker: String?
}

extension DescribeDBClusterParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClusterParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBClusterSnapshotAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

extension DescribeDBClusterSnapshotAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterSnapshotAttributesInput(dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)))"}
}

extension DescribeDBClusterSnapshotAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        try container.encode("DescribeDBClusterSnapshotAttributes", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClusterSnapshotAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

public struct DescribeDBClusterSnapshotAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

/// <p></p>
public struct DescribeDBClusterSnapshotAttributesInput: Equatable {
    /// <p>The identifier for the DB cluster snapshot to describe the attributes for.</p>
    public let dBClusterSnapshotIdentifier: String?

    public init (
        dBClusterSnapshotIdentifier: String? = nil
    )
    {
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

extension DescribeDBClusterSnapshotAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterSnapshotAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterSnapshotAttributesOutputError: Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterSnapshotAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterSnapshotAttributesOutputResponse(dBClusterSnapshotAttributesResult: \(String(describing: dBClusterSnapshotAttributesResult)))"}
}

extension DescribeDBClusterSnapshotAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClusterSnapshotAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshotAttributesResult = output.dBClusterSnapshotAttributesResult
        } else {
            self.dBClusterSnapshotAttributesResult = nil
        }
    }
}

public struct DescribeDBClusterSnapshotAttributesOutputResponse: Equatable {
    /// <p>Contains the results of a successful call to the <code>DescribeDBClusterSnapshotAttributes</code>
    ///             API action.</p>
    ///         <p>Manual DB cluster snapshot attributes are used to authorize other AWS accounts
    ///             to copy or restore a manual DB cluster snapshot. For more information, see the <code>ModifyDBClusterSnapshotAttribute</code>
    ///             API action.</p>
    public let dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult?

    public init (
        dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult? = nil
    )
    {
        self.dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResult
    }
}

struct DescribeDBClusterSnapshotAttributesOutputResponseBody: Equatable {
    public let dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult?
}

extension DescribeDBClusterSnapshotAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClusterSnapshotAttributesResult"))
        let dBClusterSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(DBClusterSnapshotAttributesResult.self, forKey: .dBClusterSnapshotAttributesResult)
        dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResultDecoded
    }
}

public struct DescribeDBClusterSnapshotsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotsOutputError>
}

extension DescribeDBClusterSnapshotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterSnapshotsInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)), filters: \(String(describing: filters)), includePublic: \(String(describing: includePublic)), includeShared: \(String(describing: includeShared)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), snapshotType: \(String(describing: snapshotType)))"}
}

extension DescribeDBClusterSnapshotsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if includePublic != false {
            try container.encode(includePublic, forKey: Key("IncludePublic"))
        }
        if includeShared != false {
            try container.encode(includeShared, forKey: Key("IncludeShared"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: Key("SnapshotType"))
        }
        try container.encode("DescribeDBClusterSnapshots", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClusterSnapshotsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotsOutputError>
}

public struct DescribeDBClusterSnapshotsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotsOutputError>
}

/// <p></p>
public struct DescribeDBClusterSnapshotsInput: Equatable {
    /// <p>The ID of the DB cluster to retrieve the list of DB cluster snapshots for.
    ///             This parameter can't be used in conjunction with the
    ///             <code>DBClusterSnapshotIdentifier</code> parameter.
    ///             This parameter isn't case-sensitive.
    ///         </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>A specific DB cluster snapshot identifier to describe.
    ///             This parameter can't be used in conjunction with the
    ///             <code>DBClusterIdentifier</code> parameter.
    ///             This value is stored as a lowercase string.
    ///         </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the identifier of an existing DBClusterSnapshot.</p>
    ///             </li>
    ///             <li>
    ///                <p>If this identifier is for an automated snapshot, the <code>SnapshotType</code> parameter must also be specified.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterSnapshotIdentifier: String?
    /// <p>A filter that specifies one or more DB cluster snapshots to describe.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-id</code> - Accepts DB cluster identifiers and DB
    ///               cluster Amazon Resource Names (ARNs).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-snapshot-id</code> - Accepts DB cluster snapshot identifiers.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>snapshot-type</code> - Accepts types of DB cluster snapshots.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>engine</code> - Accepts names of database engines.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>A value that indicates whether to include manual DB cluster snapshots that are public and can be copied
    ///             or restored by any AWS account. By default, the public snapshots are not included.</p>
    ///         <p>You can share a manual DB cluster snapshot  as public by using the <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
    public let includePublic: Bool
    /// <p>A value that indicates whether to include shared manual DB cluster snapshots
    ///             from other AWS accounts that this AWS account has been given
    ///             permission to copy or restore. By default, these snapshots are not included.</p>
    ///         <p>You can give an AWS account permission to restore a manual DB cluster snapshot from
    ///             another AWS account by the <code>ModifyDBClusterSnapshotAttribute</code> API action.</p>
    public let includeShared: Bool
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeDBClusterSnapshots</code> request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response.
    ///             If more records exist than the specified <code>MaxRecords</code> value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The type of DB cluster snapshots to be returned. You can specify one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>automated</code> - Return all DB cluster snapshots that have been automatically taken by
    ///               Amazon RDS for my AWS account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>manual</code> - Return all DB cluster snapshots that have been taken by my AWS account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>shared</code> - Return all manual DB cluster snapshots that have been shared to my AWS account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>public</code> - Return all DB cluster snapshots that have been marked as public.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify a <code>SnapshotType</code> value, then both automated and manual DB cluster snapshots are
    ///           returned. You can include shared DB cluster snapshots with these results by enabling the <code>IncludeShared</code>
    ///           parameter. You can include public DB cluster snapshots with these results by enabling the
    ///           <code>IncludePublic</code> parameter.</p>
    ///          <p>The <code>IncludeShared</code> and <code>IncludePublic</code> parameters don't apply for <code>SnapshotType</code> values
    ///           of <code>manual</code> or <code>automated</code>. The <code>IncludePublic</code> parameter doesn't apply when <code>SnapshotType</code> is
    ///           set to <code>shared</code>. The <code>IncludeShared</code> parameter doesn't apply when <code>SnapshotType</code> is set to
    ///           <code>public</code>.</p>
    public let snapshotType: String?

    public init (
        dBClusterIdentifier: String? = nil,
        dBClusterSnapshotIdentifier: String? = nil,
        filters: [Filter]? = nil,
        includePublic: Bool = false,
        includeShared: Bool = false,
        marker: String? = nil,
        maxRecords: Int? = nil,
        snapshotType: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.filters = filters
        self.includePublic = includePublic
        self.includeShared = includeShared
        self.marker = marker
        self.maxRecords = maxRecords
        self.snapshotType = snapshotType
    }
}

extension DescribeDBClusterSnapshotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterSnapshotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterSnapshotsOutputError: Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterSnapshotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterSnapshotsOutputResponse(dBClusterSnapshots: \(String(describing: dBClusterSnapshots)), marker: \(String(describing: marker)))"}
}

extension DescribeDBClusterSnapshotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshots = output.dBClusterSnapshots
            self.marker = output.marker
        } else {
            self.dBClusterSnapshots = nil
            self.marker = nil
        }
    }
}

/// <p>
///           Provides a list of DB cluster snapshots for the user as the result of a call to the <code>DescribeDBClusterSnapshots</code> action.
///     </p>
public struct DescribeDBClusterSnapshotsOutputResponse: Equatable {
    /// <p>Provides a list of DB cluster snapshots for the user.</p>
    public let dBClusterSnapshots: [DBClusterSnapshot]?
    /// <p>
    ///       An optional pagination token provided by a previous
    ///           <code>DescribeDBClusterSnapshots</code> request.
    ///       If this parameter is specified, the response includes
    ///       only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: String?

    public init (
        dBClusterSnapshots: [DBClusterSnapshot]? = nil,
        marker: String? = nil
    )
    {
        self.dBClusterSnapshots = dBClusterSnapshots
        self.marker = marker
    }
}

struct DescribeDBClusterSnapshotsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBClusterSnapshots: [DBClusterSnapshot]?
}

extension DescribeDBClusterSnapshotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshots = "DBClusterSnapshots"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClusterSnapshotsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterSnapshots) {
            struct KeyVal0{struct DBClusterSnapshot{}}
            let dBClusterSnapshotsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterSnapshot>.CodingKeys.self, forKey: .dBClusterSnapshots)
            if let dBClusterSnapshotsWrappedContainer = dBClusterSnapshotsWrappedContainer {
                let dBClusterSnapshotsContainer = try dBClusterSnapshotsWrappedContainer.decodeIfPresent([DBClusterSnapshot].self, forKey: .member)
                var dBClusterSnapshotsBuffer:[DBClusterSnapshot]? = nil
                if let dBClusterSnapshotsContainer = dBClusterSnapshotsContainer {
                    dBClusterSnapshotsBuffer = [DBClusterSnapshot]()
                    for structureContainer0 in dBClusterSnapshotsContainer {
                        dBClusterSnapshotsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterSnapshots = dBClusterSnapshotsBuffer
            } else {
                dBClusterSnapshots = []
            }
        } else {
            dBClusterSnapshots = nil
        }
    }
}

public struct DescribeDBClustersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClustersOutputError>
}

extension DescribeDBClustersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClustersInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), filters: \(String(describing: filters)), includeShared: \(String(describing: includeShared)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBClustersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if includeShared != false {
            try container.encode(includeShared, forKey: Key("IncludeShared"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusters", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClustersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClustersOutputError>
}

public struct DescribeDBClustersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClustersOutputError>
}

/// <p></p>
public struct DescribeDBClustersInput: Equatable {
    /// <p>The user-supplied DB cluster identifier. If this parameter is specified, information from only the specific DB cluster is returned. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match an existing DBClusterIdentifier.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>A filter that specifies one or more DB clusters to describe.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-id</code> - Accepts DB cluster identifiers and DB
    ///               cluster Amazon Resource Names (ARNs). The results list will only include information about
    ///               the DB clusters identified by these ARNs.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>Optional Boolean parameter that specifies whether the output includes information about clusters
    ///           shared from other AWS accounts.</p>
    public let includeShared: Bool
    /// <p>An optional pagination token provided by a previous
    ///             <code>DescribeDBClusters</code> request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response.
    ///             If more records exist than the specified <code>MaxRecords</code> value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBClusterIdentifier: String? = nil,
        filters: [Filter]? = nil,
        includeShared: Bool = false,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.includeShared = includeShared
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClustersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClustersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClustersOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClustersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClustersOutputResponse(dBClusters: \(String(describing: dBClusters)), marker: \(String(describing: marker)))"}
}

extension DescribeDBClustersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClustersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusters = output.dBClusters
            self.marker = output.marker
        } else {
            self.dBClusters = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the result of a successful invocation of the <code>DescribeDBClusters</code> action.</p>
public struct DescribeDBClustersOutputResponse: Equatable {
    /// <p>Contains a list of DB clusters for the user.</p>
    public let dBClusters: [DBCluster]?
    /// <p>A pagination token that can be used in a later DescribeDBClusters request.</p>
    public let marker: String?

    public init (
        dBClusters: [DBCluster]? = nil,
        marker: String? = nil
    )
    {
        self.dBClusters = dBClusters
        self.marker = marker
    }
}

struct DescribeDBClustersOutputResponseBody: Equatable {
    public let marker: String?
    public let dBClusters: [DBCluster]?
}

extension DescribeDBClustersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusters = "DBClusters"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClustersResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusters) {
            struct KeyVal0{struct DBCluster{}}
            let dBClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBCluster>.CodingKeys.self, forKey: .dBClusters)
            if let dBClustersWrappedContainer = dBClustersWrappedContainer {
                let dBClustersContainer = try dBClustersWrappedContainer.decodeIfPresent([DBCluster].self, forKey: .member)
                var dBClustersBuffer:[DBCluster]? = nil
                if let dBClustersContainer = dBClustersContainer {
                    dBClustersBuffer = [DBCluster]()
                    for structureContainer0 in dBClustersContainer {
                        dBClustersBuffer?.append(structureContainer0)
                    }
                }
                dBClusters = dBClustersBuffer
            } else {
                dBClusters = []
            }
        } else {
            dBClusters = nil
        }
    }
}

public struct DescribeDBEngineVersionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBEngineVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBEngineVersionsOutputError>
}

extension DescribeDBEngineVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBEngineVersionsInput(dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), defaultOnly: \(String(describing: defaultOnly)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), filters: \(String(describing: filters)), includeAll: \(String(describing: includeAll)), listSupportedCharacterSets: \(String(describing: listSupportedCharacterSets)), listSupportedTimezones: \(String(describing: listSupportedTimezones)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBEngineVersionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if defaultOnly != false {
            try container.encode(defaultOnly, forKey: Key("DefaultOnly"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let includeAll = includeAll {
            try container.encode(includeAll, forKey: Key("IncludeAll"))
        }
        if let listSupportedCharacterSets = listSupportedCharacterSets {
            try container.encode(listSupportedCharacterSets, forKey: Key("ListSupportedCharacterSets"))
        }
        if let listSupportedTimezones = listSupportedTimezones {
            try container.encode(listSupportedTimezones, forKey: Key("ListSupportedTimezones"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBEngineVersions", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBEngineVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBEngineVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBEngineVersionsOutputError>
}

public struct DescribeDBEngineVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBEngineVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBEngineVersionsOutputError>
}

public struct DescribeDBEngineVersionsInput: Equatable {
    /// <p>The name of a specific DB parameter group family to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match an existing DBParameterGroupFamily.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupFamily: String?
    /// <p>A value that indicates whether only the default version of the specified engine or engine and major version combination is returned.</p>
    public let defaultOnly: Bool
    /// <p>The database engine to return.</p>
    ///          <p>Valid Values:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>aurora</code> (for MySQL 5.6-compatible Aurora)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>aurora-postgresql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mariadb</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mysql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se2</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se1</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>postgres</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ex</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-web</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let engine: String?
    /// <p>The database engine version to return.</p>
    ///          <p>Example: <code>5.1.49</code>
    ///          </p>
    public let engineVersion: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>A value that indicates whether to include engine versions that aren't available in the list. The default is to list only available engine versions.</p>
    public let includeAll: Bool?
    /// <p>A value that indicates whether to list the supported character sets for each engine version.</p>
    ///          <p>If this parameter is enabled and the requested engine supports the <code>CharacterSetName</code> parameter for <code>CreateDBInstance</code>,
    ///           the response includes a list of supported character sets for each engine version.
    ///       </p>
    public let listSupportedCharacterSets: Bool?
    /// <p>A value that indicates whether to list the supported time zones for each engine version.</p>
    ///         <p>If this parameter is enabled and the requested engine supports the <code>TimeZone</code> parameter for <code>CreateDBInstance</code>,
    ///             the response includes a list of supported time zones for each engine version.
    ///         </p>
    public let listSupportedTimezones: Bool?
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: String?
    /// <p>
    ///     The maximum number of records to include in the response.
    ///     If more than the <code>MaxRecords</code> value is available, a pagination token called a marker is
    ///     included in the response so you can retrieve the remaining results.
    ///     </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBParameterGroupFamily: String? = nil,
        defaultOnly: Bool = false,
        engine: String? = nil,
        engineVersion: String? = nil,
        filters: [Filter]? = nil,
        includeAll: Bool? = nil,
        listSupportedCharacterSets: Bool? = nil,
        listSupportedTimezones: Bool? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.defaultOnly = defaultOnly
        self.engine = engine
        self.engineVersion = engineVersion
        self.filters = filters
        self.includeAll = includeAll
        self.listSupportedCharacterSets = listSupportedCharacterSets
        self.listSupportedTimezones = listSupportedTimezones
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBEngineVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBEngineVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBEngineVersionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBEngineVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBEngineVersionsOutputResponse(dBEngineVersions: \(String(describing: dBEngineVersions)), marker: \(String(describing: marker)))"}
}

extension DescribeDBEngineVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBEngineVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBEngineVersions = output.dBEngineVersions
            self.marker = output.marker
        } else {
            self.dBEngineVersions = nil
            self.marker = nil
        }
    }
}

/// <p>
///             Contains the result of a successful invocation of the <code>DescribeDBEngineVersions</code> action.
///         </p>
public struct DescribeDBEngineVersionsOutputResponse: Equatable {
    /// <p>
    ///             A list of <code>DBEngineVersion</code> elements.
    ///         </p>
    public let dBEngineVersions: [DBEngineVersion]?
    /// <p>
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?

    public init (
        dBEngineVersions: [DBEngineVersion]? = nil,
        marker: String? = nil
    )
    {
        self.dBEngineVersions = dBEngineVersions
        self.marker = marker
    }
}

struct DescribeDBEngineVersionsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBEngineVersions: [DBEngineVersion]?
}

extension DescribeDBEngineVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBEngineVersions = "DBEngineVersions"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBEngineVersionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBEngineVersions) {
            struct KeyVal0{struct DBEngineVersion{}}
            let dBEngineVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBEngineVersion>.CodingKeys.self, forKey: .dBEngineVersions)
            if let dBEngineVersionsWrappedContainer = dBEngineVersionsWrappedContainer {
                let dBEngineVersionsContainer = try dBEngineVersionsWrappedContainer.decodeIfPresent([DBEngineVersion].self, forKey: .member)
                var dBEngineVersionsBuffer:[DBEngineVersion]? = nil
                if let dBEngineVersionsContainer = dBEngineVersionsContainer {
                    dBEngineVersionsBuffer = [DBEngineVersion]()
                    for structureContainer0 in dBEngineVersionsContainer {
                        dBEngineVersionsBuffer?.append(structureContainer0)
                    }
                }
                dBEngineVersions = dBEngineVersionsBuffer
            } else {
                dBEngineVersions = []
            }
        } else {
            dBEngineVersions = nil
        }
    }
}

public struct DescribeDBInstanceAutomatedBackupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBInstanceAutomatedBackupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>
    public typealias MOutput = OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBInstanceAutomatedBackupsOutputError>
}

extension DescribeDBInstanceAutomatedBackupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBInstanceAutomatedBackupsInput(dBInstanceAutomatedBackupsArn: \(String(describing: dBInstanceAutomatedBackupsArn)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dbiResourceId: \(String(describing: dbiResourceId)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBInstanceAutomatedBackupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: Key("DBInstanceAutomatedBackupsArn"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: Key("DbiResourceId"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBInstanceAutomatedBackups", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBInstanceAutomatedBackupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBInstanceAutomatedBackupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>
    public typealias MOutput = OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBInstanceAutomatedBackupsOutputError>
}

public struct DescribeDBInstanceAutomatedBackupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBInstanceAutomatedBackupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>
    public typealias MOutput = OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBInstanceAutomatedBackupsOutputError>
}

/// <p>Parameter input for DescribeDBInstanceAutomatedBackups. </p>
public struct DescribeDBInstanceAutomatedBackupsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replicated automated backups, for example,
    ///             <code>arn:aws:rds:us-east-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE</code>.</p>
    public let dBInstanceAutomatedBackupsArn: String?
    /// <p>(Optional) The user-supplied instance identifier. If this parameter is specified, it must
    ///             match the identifier of an existing DB instance. It returns information from the
    ///             specific DB instance' automated backup. This parameter isn't case-sensitive. </p>
    public let dBInstanceIdentifier: String?
    /// <p>The resource ID of the DB instance that is the source of
    /// 		    the automated backup. This parameter isn't case-sensitive. </p>
    public let dbiResourceId: String?
    /// <p>A filter that specifies which resources to return based on status.</p>
    /// 		       <p>Supported filters are the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    /// 					             <code>status</code>
    /// 				           </p>
    /// 			            <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>active</code> - automated backups for current instances</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>retained</code> - automated backups for deleted instances and after backup replication is stopped</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>creating</code> - automated backups that are waiting for the first automated snapshot to be available</p>
    ///                   </li>
    ///                </ul>
    /// 			         </li>
    ///             <li>
    ///                <p>
    /// 		                <code>db-instance-id</code> - Accepts DB instance identifiers and Amazon Resource Names (ARNs).
    /// 		        The results list includes only information about the DB instance automated backups identified by these ARNs.</p>
    /// 		          </li>
    ///             <li>
    ///                <p>
    /// 		                <code>dbi-resource-id</code> - Accepts DB resource identifiers and Amazon Resource Names (ARNs).
    /// 		        The results list includes only information about the DB instance resources identified by these ARNs.</p>
    /// 		          </li>
    ///          </ul>
    /// 		       <p>Returns all resources by default. The status for each resource is specified in the response.</p>
    public let filters: [Filter]?
    /// <p>The pagination token provided in the previous request. If this parameter is specified the response
    /// 			includes only records beyond the marker, up to <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist than the specified
    /// 			<code>MaxRecords</code> value, a pagination token called a marker is included in the response so that
    /// 			you can retrieve the remaining results.</p>
    public let maxRecords: Int?

    public init (
        dBInstanceAutomatedBackupsArn: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dbiResourceId: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dbiResourceId = dbiResourceId
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBInstanceAutomatedBackupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBInstanceAutomatedBackupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupNotFoundFault" : self = .dBInstanceAutomatedBackupNotFoundFault(try DBInstanceAutomatedBackupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBInstanceAutomatedBackupsOutputError: Equatable {
    case dBInstanceAutomatedBackupNotFoundFault(DBInstanceAutomatedBackupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBInstanceAutomatedBackupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBInstanceAutomatedBackupsOutputResponse(dBInstanceAutomatedBackups: \(String(describing: dBInstanceAutomatedBackups)), marker: \(String(describing: marker)))"}
}

extension DescribeDBInstanceAutomatedBackupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBInstanceAutomatedBackupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstanceAutomatedBackups = output.dBInstanceAutomatedBackups
            self.marker = output.marker
        } else {
            self.dBInstanceAutomatedBackups = nil
            self.marker = nil
        }
    }
}

/// <p>
///             Contains the result of a successful invocation of the <code>DescribeDBInstanceAutomatedBackups</code> action.
///         </p>
public struct DescribeDBInstanceAutomatedBackupsOutputResponse: Equatable {
    /// <p>
    ///             A list of <code>DBInstanceAutomatedBackup</code> instances.
    ///         </p>
    public let dBInstanceAutomatedBackups: [DBInstanceAutomatedBackup]?
    /// <p>
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code> .
    ///         </p>
    public let marker: String?

    public init (
        dBInstanceAutomatedBackups: [DBInstanceAutomatedBackup]? = nil,
        marker: String? = nil
    )
    {
        self.dBInstanceAutomatedBackups = dBInstanceAutomatedBackups
        self.marker = marker
    }
}

struct DescribeDBInstanceAutomatedBackupsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBInstanceAutomatedBackups: [DBInstanceAutomatedBackup]?
}

extension DescribeDBInstanceAutomatedBackupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstanceAutomatedBackups = "DBInstanceAutomatedBackups"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBInstanceAutomatedBackupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBInstanceAutomatedBackups) {
            struct KeyVal0{struct DBInstanceAutomatedBackup{}}
            let dBInstanceAutomatedBackupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceAutomatedBackup>.CodingKeys.self, forKey: .dBInstanceAutomatedBackups)
            if let dBInstanceAutomatedBackupsWrappedContainer = dBInstanceAutomatedBackupsWrappedContainer {
                let dBInstanceAutomatedBackupsContainer = try dBInstanceAutomatedBackupsWrappedContainer.decodeIfPresent([DBInstanceAutomatedBackup].self, forKey: .member)
                var dBInstanceAutomatedBackupsBuffer:[DBInstanceAutomatedBackup]? = nil
                if let dBInstanceAutomatedBackupsContainer = dBInstanceAutomatedBackupsContainer {
                    dBInstanceAutomatedBackupsBuffer = [DBInstanceAutomatedBackup]()
                    for structureContainer0 in dBInstanceAutomatedBackupsContainer {
                        dBInstanceAutomatedBackupsBuffer?.append(structureContainer0)
                    }
                }
                dBInstanceAutomatedBackups = dBInstanceAutomatedBackupsBuffer
            } else {
                dBInstanceAutomatedBackups = []
            }
        } else {
            dBInstanceAutomatedBackups = nil
        }
    }
}

public struct DescribeDBInstancesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBInstancesOutputError>
}

extension DescribeDBInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBInstancesInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBInstancesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBInstances", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBInstancesOutputError>
}

public struct DescribeDBInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBInstancesOutputError>
}

/// <p></p>
public struct DescribeDBInstancesInput: Equatable {
    /// <p>The user-supplied instance identifier. If this parameter is specified, information from only the specific DB instance is returned. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p>A filter that specifies one or more DB instances to describe.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-id</code> - Accepts DB cluster identifiers and DB
    ///               cluster Amazon Resource Names (ARNs). The results list will only include information about
    ///               the DB instances associated with the DB clusters identified by these ARNs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db-instance-id</code> - Accepts DB instance identifiers and DB
    ///               instance Amazon Resource Names (ARNs). The results list will only include information about
    ///               the DB instances identified by these ARNs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>dbi-resource-id</code> - Accepts DB instance resource identifiers. The results list will
    ///               only include information about the DB instances identified by these DB instance resource identifiers.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>domain</code> - Accepts Active Directory directory IDs. The results list will only
    ///               include information about the DB instances associated with these domains.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>engine</code> - Accepts engine names. The results list will only include information
    ///               about the DB instances for these engines.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous
    ///         <code>DescribeDBInstances</code> request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///         a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBInstanceIdentifier: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBInstancesOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBInstancesOutputResponse(dBInstances: \(String(describing: dBInstances)), marker: \(String(describing: marker)))"}
}

extension DescribeDBInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstances = output.dBInstances
            self.marker = output.marker
        } else {
            self.dBInstances = nil
            self.marker = nil
        }
    }
}

/// <p>
///         Contains the result of a successful invocation of the <code>DescribeDBInstances</code> action.
///         </p>
public struct DescribeDBInstancesOutputResponse: Equatable {
    /// <p>
    ///         A list of <code>DBInstance</code> instances.
    ///         </p>
    public let dBInstances: [DBInstance]?
    /// <p>
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code> .
    ///         </p>
    public let marker: String?

    public init (
        dBInstances: [DBInstance]? = nil,
        marker: String? = nil
    )
    {
        self.dBInstances = dBInstances
        self.marker = marker
    }
}

struct DescribeDBInstancesOutputResponseBody: Equatable {
    public let marker: String?
    public let dBInstances: [DBInstance]?
}

extension DescribeDBInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstances = "DBInstances"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBInstancesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBInstances) {
            struct KeyVal0{struct DBInstance{}}
            let dBInstancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstance>.CodingKeys.self, forKey: .dBInstances)
            if let dBInstancesWrappedContainer = dBInstancesWrappedContainer {
                let dBInstancesContainer = try dBInstancesWrappedContainer.decodeIfPresent([DBInstance].self, forKey: .member)
                var dBInstancesBuffer:[DBInstance]? = nil
                if let dBInstancesContainer = dBInstancesContainer {
                    dBInstancesBuffer = [DBInstance]()
                    for structureContainer0 in dBInstancesContainer {
                        dBInstancesBuffer?.append(structureContainer0)
                    }
                }
                dBInstances = dBInstancesBuffer
            } else {
                dBInstances = []
            }
        } else {
            dBInstances = nil
        }
    }
}

extension DescribeDBLogFilesDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastWritten = "LastWritten"
        case logFileName = "LogFileName"
        case size = "Size"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if lastWritten != 0 {
            try container.encode(lastWritten, forKey: Key("LastWritten"))
        }
        if let logFileName = logFileName {
            try container.encode(logFileName, forKey: Key("LogFileName"))
        }
        if size != 0 {
            try container.encode(size, forKey: Key("Size"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logFileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logFileName)
        logFileName = logFileNameDecoded
        let lastWrittenDecoded = try containerValues.decode(Int.self, forKey: .lastWritten)
        lastWritten = lastWrittenDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension DescribeDBLogFilesDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBLogFilesDetails(lastWritten: \(String(describing: lastWritten)), logFileName: \(String(describing: logFileName)), size: \(String(describing: size)))"}
}

/// <p>This data type is used as a response element to <code>DescribeDBLogFiles</code>.</p>
public struct DescribeDBLogFilesDetails: Equatable {
    /// <p>A POSIX timestamp when the last log entry was written.</p>
    public let lastWritten: Int
    /// <p>The name of the log file for the specified DB instance.</p>
    public let logFileName: String?
    /// <p>The size, in bytes, of the log file for the specified DB instance.</p>
    public let size: Int

    public init (
        lastWritten: Int = 0,
        logFileName: String? = nil,
        size: Int = 0
    )
    {
        self.lastWritten = lastWritten
        self.logFileName = logFileName
        self.size = size
    }
}

public struct DescribeDBLogFilesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBLogFilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBLogFilesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBLogFilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBLogFilesInput>
    public typealias MOutput = OperationOutput<DescribeDBLogFilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBLogFilesOutputError>
}

extension DescribeDBLogFilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBLogFilesInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), fileLastWritten: \(String(describing: fileLastWritten)), fileSize: \(String(describing: fileSize)), filenameContains: \(String(describing: filenameContains)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBLogFilesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if fileLastWritten != 0 {
            try container.encode(fileLastWritten, forKey: Key("FileLastWritten"))
        }
        if fileSize != 0 {
            try container.encode(fileSize, forKey: Key("FileSize"))
        }
        if let filenameContains = filenameContains {
            try container.encode(filenameContains, forKey: Key("FilenameContains"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBLogFiles", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBLogFilesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBLogFilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBLogFilesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBLogFilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBLogFilesInput>
    public typealias MOutput = OperationOutput<DescribeDBLogFilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBLogFilesOutputError>
}

public struct DescribeDBLogFilesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBLogFilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBLogFilesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBLogFilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBLogFilesInput>
    public typealias MOutput = OperationOutput<DescribeDBLogFilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBLogFilesOutputError>
}

/// <p></p>
public struct DescribeDBLogFilesInput: Equatable {
    /// <p>The customer-assigned name of the DB instance that contains the log files you want to list.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p>Filters the available log files for files written since the specified date, in POSIX timestamp format with milliseconds.</p>
    public let fileLastWritten: Int
    /// <p>Filters the available log files for files larger than the specified size.</p>
    public let fileSize: Int
    /// <p>Filters the available log files for log file names that contain the specified string.</p>
    public let filenameContains: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>The pagination token provided in the previous request. If this parameter is specified the response includes only records beyond the marker, up to MaxRecords.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results.</p>
    public let maxRecords: Int?

    public init (
        dBInstanceIdentifier: String? = nil,
        fileLastWritten: Int = 0,
        fileSize: Int = 0,
        filenameContains: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.fileLastWritten = fileLastWritten
        self.fileSize = fileSize
        self.filenameContains = filenameContains
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBLogFilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBLogFilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBLogFilesOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBLogFilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBLogFilesOutputResponse(describeDBLogFiles: \(String(describing: describeDBLogFiles)), marker: \(String(describing: marker)))"}
}

extension DescribeDBLogFilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBLogFilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.describeDBLogFiles = output.describeDBLogFiles
            self.marker = output.marker
        } else {
            self.describeDBLogFiles = nil
            self.marker = nil
        }
    }
}

/// <p>
///             The response from a call to <code>DescribeDBLogFiles</code>.
///         </p>
public struct DescribeDBLogFilesOutputResponse: Equatable {
    /// <p>The DB log files returned.</p>
    public let describeDBLogFiles: [DescribeDBLogFilesDetails]?
    /// <p>A pagination token that can be used in a later DescribeDBLogFiles request.</p>
    public let marker: String?

    public init (
        describeDBLogFiles: [DescribeDBLogFilesDetails]? = nil,
        marker: String? = nil
    )
    {
        self.describeDBLogFiles = describeDBLogFiles
        self.marker = marker
    }
}

struct DescribeDBLogFilesOutputResponseBody: Equatable {
    public let describeDBLogFiles: [DescribeDBLogFilesDetails]?
    public let marker: String?
}

extension DescribeDBLogFilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case describeDBLogFiles = "DescribeDBLogFiles"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBLogFilesResult"))
        if containerValues.contains(.describeDBLogFiles) {
            struct KeyVal0{struct DescribeDBLogFilesDetails{}}
            let describeDBLogFilesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DescribeDBLogFilesDetails>.CodingKeys.self, forKey: .describeDBLogFiles)
            if let describeDBLogFilesWrappedContainer = describeDBLogFilesWrappedContainer {
                let describeDBLogFilesContainer = try describeDBLogFilesWrappedContainer.decodeIfPresent([DescribeDBLogFilesDetails].self, forKey: .member)
                var describeDBLogFilesBuffer:[DescribeDBLogFilesDetails]? = nil
                if let describeDBLogFilesContainer = describeDBLogFilesContainer {
                    describeDBLogFilesBuffer = [DescribeDBLogFilesDetails]()
                    for structureContainer0 in describeDBLogFilesContainer {
                        describeDBLogFilesBuffer?.append(structureContainer0)
                    }
                }
                describeDBLogFiles = describeDBLogFilesBuffer
            } else {
                describeDBLogFiles = []
            }
        } else {
            describeDBLogFiles = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBParameterGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParameterGroupsOutputError>
}

extension DescribeDBParameterGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBParameterGroupsInput(dBParameterGroupName: \(String(describing: dBParameterGroupName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBParameterGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBParameterGroups", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBParameterGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParameterGroupsOutputError>
}

public struct DescribeDBParameterGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParameterGroupsOutputError>
}

/// <p></p>
public struct DescribeDBParameterGroupsInput: Equatable {
    /// <p>The name of a specific DB parameter group to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous
    ///         <code>DescribeDBParameterGroups</code> request.
    ///             If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///             a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBParameterGroupName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBParameterGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBParameterGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBParameterGroupsOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBParameterGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBParameterGroupsOutputResponse(dBParameterGroups: \(String(describing: dBParameterGroups)), marker: \(String(describing: marker)))"}
}

extension DescribeDBParameterGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBParameterGroups = output.dBParameterGroups
            self.marker = output.marker
        } else {
            self.dBParameterGroups = nil
            self.marker = nil
        }
    }
}

/// <p>
///         Contains the result of a successful invocation of the <code>DescribeDBParameterGroups</code> action.
///         </p>
public struct DescribeDBParameterGroupsOutputResponse: Equatable {
    /// <p>
    ///         A list of <code>DBParameterGroup</code> instances.
    ///         </p>
    public let dBParameterGroups: [DBParameterGroup]?
    /// <p>
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?

    public init (
        dBParameterGroups: [DBParameterGroup]? = nil,
        marker: String? = nil
    )
    {
        self.dBParameterGroups = dBParameterGroups
        self.marker = marker
    }
}

struct DescribeDBParameterGroupsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBParameterGroups: [DBParameterGroup]?
}

extension DescribeDBParameterGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroups = "DBParameterGroups"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBParameterGroups) {
            struct KeyVal0{struct DBParameterGroup{}}
            let dBParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBParameterGroup>.CodingKeys.self, forKey: .dBParameterGroups)
            if let dBParameterGroupsWrappedContainer = dBParameterGroupsWrappedContainer {
                let dBParameterGroupsContainer = try dBParameterGroupsWrappedContainer.decodeIfPresent([DBParameterGroup].self, forKey: .member)
                var dBParameterGroupsBuffer:[DBParameterGroup]? = nil
                if let dBParameterGroupsContainer = dBParameterGroupsContainer {
                    dBParameterGroupsBuffer = [DBParameterGroup]()
                    for structureContainer0 in dBParameterGroupsContainer {
                        dBParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBParameterGroups = dBParameterGroupsBuffer
            } else {
                dBParameterGroups = []
            }
        } else {
            dBParameterGroups = nil
        }
    }
}

public struct DescribeDBParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParametersOutputError>
}

extension DescribeDBParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBParametersInput(dBParameterGroupName: \(String(describing: dBParameterGroupName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), source: \(String(describing: source)))"}
}

extension DescribeDBParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
        try container.encode("DescribeDBParameters", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParametersOutputError>
}

public struct DescribeDBParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParametersOutputError>
}

public struct DescribeDBParametersInput: Equatable {
    /// <p>The name of a specific DB parameter group to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous
    ///         <code>DescribeDBParameters</code> request.
    ///             If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///             a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The parameter types to return.</p>
    ///          <p>Default: All parameter types returned</p>
    ///          <p>Valid Values: <code>user | system | engine-default</code>
    ///          </p>
    public let source: String?

    public init (
        dBParameterGroupName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        source: String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.source = source
    }
}

extension DescribeDBParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBParametersOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBParametersOutputResponse(marker: \(String(describing: marker)), parameters: \(String(describing: parameters)))"}
}

extension DescribeDBParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

/// <p>
///         Contains the result of a successful invocation of the <code>DescribeDBParameters</code> action.
///         </p>
public struct DescribeDBParametersOutputResponse: Equatable {
    /// <p>
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///         A list of <code>Parameter</code> values.
    ///         </p>
    public let parameters: [Parameter]?

    public init (
        marker: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeDBParametersOutputResponseBody: Equatable {
    public let parameters: [Parameter]?
    public let marker: String?
}

extension DescribeDBParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBProxiesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBProxiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxiesInput>
    public typealias MOutput = OperationOutput<DescribeDBProxiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxiesOutputError>
}

extension DescribeDBProxiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBProxiesInput(dBProxyName: \(String(describing: dBProxyName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBProxiesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBProxies", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBProxiesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBProxiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxiesInput>
    public typealias MOutput = OperationOutput<DescribeDBProxiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxiesOutputError>
}

public struct DescribeDBProxiesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBProxiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxiesInput>
    public typealias MOutput = OperationOutput<DescribeDBProxiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxiesOutputError>
}

public struct DescribeDBProxiesInput: Equatable {
    /// <p>The name of the DB proxy. If you omit this parameter,
    ///         the output includes information about all DB proxies owned by
    ///         your AWS account ID.</p>
    public let dBProxyName: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist
    ///           than the specified <code>MaxRecords</code> value, a pagination token called a marker is
    ///           included in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBProxyName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBProxiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxiesOutputError: Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBProxiesOutputResponse(dBProxies: \(String(describing: dBProxies)), marker: \(String(describing: marker)))"}
}

extension DescribeDBProxiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBProxiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBProxies = output.dBProxies
            self.marker = output.marker
        } else {
            self.dBProxies = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBProxiesOutputResponse: Equatable {
    /// <p>A return value representing an arbitrary number of <code>DBProxy</code> data structures.</p>
    public let dBProxies: [DBProxy]?
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?

    public init (
        dBProxies: [DBProxy]? = nil,
        marker: String? = nil
    )
    {
        self.dBProxies = dBProxies
        self.marker = marker
    }
}

struct DescribeDBProxiesOutputResponseBody: Equatable {
    public let dBProxies: [DBProxy]?
    public let marker: String?
}

extension DescribeDBProxiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBProxies = "DBProxies"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBProxiesResult"))
        if containerValues.contains(.dBProxies) {
            struct KeyVal0{struct member{}}
            let dBProxiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBProxies)
            if let dBProxiesWrappedContainer = dBProxiesWrappedContainer {
                let dBProxiesContainer = try dBProxiesWrappedContainer.decodeIfPresent([DBProxy].self, forKey: .member)
                var dBProxiesBuffer:[DBProxy]? = nil
                if let dBProxiesContainer = dBProxiesContainer {
                    dBProxiesBuffer = [DBProxy]()
                    for structureContainer0 in dBProxiesContainer {
                        dBProxiesBuffer?.append(structureContainer0)
                    }
                }
                dBProxies = dBProxiesBuffer
            } else {
                dBProxies = []
            }
        } else {
            dBProxies = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBProxyEndpointsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBProxyEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxyEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxyEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxyEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeDBProxyEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxyEndpointsOutputError>
}

extension DescribeDBProxyEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBProxyEndpointsInput(dBProxyEndpointName: \(String(describing: dBProxyEndpointName)), dBProxyName: \(String(describing: dBProxyName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBProxyEndpointsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: Key("DBProxyEndpointName"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBProxyEndpoints", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBProxyEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBProxyEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxyEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxyEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxyEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeDBProxyEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxyEndpointsOutputError>
}

public struct DescribeDBProxyEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBProxyEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxyEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxyEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxyEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeDBProxyEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxyEndpointsOutputError>
}

public struct DescribeDBProxyEndpointsInput: Equatable {
    /// <p>The name of a DB proxy endpoint to describe. If you omit this parameter,
    ///         the output includes information about all DB proxy endpoints associated with
    ///         the specified proxy.</p>
    public let dBProxyEndpointName: String?
    /// <p>The name of the DB proxy whose endpoints you want to describe. If you omit
    ///         this parameter, the output includes information about all DB proxy endpoints
    ///         associated with all your DB proxies.</p>
    public let dBProxyName: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist
    ///           than the specified <code>MaxRecords</code> value, a pagination token called a marker is
    ///           included in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBProxyEndpointName: String? = nil,
        dBProxyName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBProxyEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxyEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointNotFoundFault" : self = .dBProxyEndpointNotFoundFault(try DBProxyEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxyEndpointsOutputError: Equatable {
    case dBProxyEndpointNotFoundFault(DBProxyEndpointNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxyEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBProxyEndpointsOutputResponse(dBProxyEndpoints: \(String(describing: dBProxyEndpoints)), marker: \(String(describing: marker)))"}
}

extension DescribeDBProxyEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBProxyEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBProxyEndpoints = output.dBProxyEndpoints
            self.marker = output.marker
        } else {
            self.dBProxyEndpoints = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBProxyEndpointsOutputResponse: Equatable {
    /// <p>The list of <code>ProxyEndpoint</code> objects returned by the API operation.</p>
    public let dBProxyEndpoints: [DBProxyEndpoint]?
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?

    public init (
        dBProxyEndpoints: [DBProxyEndpoint]? = nil,
        marker: String? = nil
    )
    {
        self.dBProxyEndpoints = dBProxyEndpoints
        self.marker = marker
    }
}

struct DescribeDBProxyEndpointsOutputResponseBody: Equatable {
    public let dBProxyEndpoints: [DBProxyEndpoint]?
    public let marker: String?
}

extension DescribeDBProxyEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBProxyEndpoints = "DBProxyEndpoints"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBProxyEndpointsResult"))
        if containerValues.contains(.dBProxyEndpoints) {
            struct KeyVal0{struct member{}}
            let dBProxyEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBProxyEndpoints)
            if let dBProxyEndpointsWrappedContainer = dBProxyEndpointsWrappedContainer {
                let dBProxyEndpointsContainer = try dBProxyEndpointsWrappedContainer.decodeIfPresent([DBProxyEndpoint].self, forKey: .member)
                var dBProxyEndpointsBuffer:[DBProxyEndpoint]? = nil
                if let dBProxyEndpointsContainer = dBProxyEndpointsContainer {
                    dBProxyEndpointsBuffer = [DBProxyEndpoint]()
                    for structureContainer0 in dBProxyEndpointsContainer {
                        dBProxyEndpointsBuffer?.append(structureContainer0)
                    }
                }
                dBProxyEndpoints = dBProxyEndpointsBuffer
            } else {
                dBProxyEndpoints = []
            }
        } else {
            dBProxyEndpoints = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBProxyTargetGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBProxyTargetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxyTargetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxyTargetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxyTargetGroupsOutputError>
}

extension DescribeDBProxyTargetGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBProxyTargetGroupsInput(dBProxyName: \(String(describing: dBProxyName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), targetGroupName: \(String(describing: targetGroupName)))"}
}

extension DescribeDBProxyTargetGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: Key("TargetGroupName"))
        }
        try container.encode("DescribeDBProxyTargetGroups", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBProxyTargetGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBProxyTargetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxyTargetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxyTargetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxyTargetGroupsOutputError>
}

public struct DescribeDBProxyTargetGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBProxyTargetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxyTargetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxyTargetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxyTargetGroupsOutputError>
}

public struct DescribeDBProxyTargetGroupsInput: Equatable {
    /// <p>The identifier of the <code>DBProxy</code> associated with the target group.</p>
    public let dBProxyName: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///         a pagination token called a marker is included in the response so that the remaining
    ///         results can be retrieved.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The identifier of the <code>DBProxyTargetGroup</code> to describe.</p>
    public let targetGroupName: String?

    public init (
        dBProxyName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        targetGroupName: String? = nil
    )
    {
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.targetGroupName = targetGroupName
    }
}

extension DescribeDBProxyTargetGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxyTargetGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxyTargetGroupsOutputError: Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxyTargetGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBProxyTargetGroupsOutputResponse(marker: \(String(describing: marker)), targetGroups: \(String(describing: targetGroups)))"}
}

extension DescribeDBProxyTargetGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBProxyTargetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.targetGroups = output.targetGroups
        } else {
            self.marker = nil
            self.targetGroups = nil
        }
    }
}

public struct DescribeDBProxyTargetGroupsOutputResponse: Equatable {
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?
    /// <p>An arbitrary number of <code>DBProxyTargetGroup</code> objects, containing details of the corresponding target groups.</p>
    public let targetGroups: [DBProxyTargetGroup]?

    public init (
        marker: String? = nil,
        targetGroups: [DBProxyTargetGroup]? = nil
    )
    {
        self.marker = marker
        self.targetGroups = targetGroups
    }
}

struct DescribeDBProxyTargetGroupsOutputResponseBody: Equatable {
    public let targetGroups: [DBProxyTargetGroup]?
    public let marker: String?
}

extension DescribeDBProxyTargetGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case targetGroups = "TargetGroups"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBProxyTargetGroupsResult"))
        if containerValues.contains(.targetGroups) {
            struct KeyVal0{struct member{}}
            let targetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroups)
            if let targetGroupsWrappedContainer = targetGroupsWrappedContainer {
                let targetGroupsContainer = try targetGroupsWrappedContainer.decodeIfPresent([DBProxyTargetGroup].self, forKey: .member)
                var targetGroupsBuffer:[DBProxyTargetGroup]? = nil
                if let targetGroupsContainer = targetGroupsContainer {
                    targetGroupsBuffer = [DBProxyTargetGroup]()
                    for structureContainer0 in targetGroupsContainer {
                        targetGroupsBuffer?.append(structureContainer0)
                    }
                }
                targetGroups = targetGroupsBuffer
            } else {
                targetGroups = []
            }
        } else {
            targetGroups = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBProxyTargetsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBProxyTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxyTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxyTargetsInput>
    public typealias MOutput = OperationOutput<DescribeDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxyTargetsOutputError>
}

extension DescribeDBProxyTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBProxyTargetsInput(dBProxyName: \(String(describing: dBProxyName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), targetGroupName: \(String(describing: targetGroupName)))"}
}

extension DescribeDBProxyTargetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: Key("TargetGroupName"))
        }
        try container.encode("DescribeDBProxyTargets", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBProxyTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBProxyTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxyTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxyTargetsInput>
    public typealias MOutput = OperationOutput<DescribeDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxyTargetsOutputError>
}

public struct DescribeDBProxyTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBProxyTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBProxyTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBProxyTargetsInput>
    public typealias MOutput = OperationOutput<DescribeDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBProxyTargetsOutputError>
}

public struct DescribeDBProxyTargetsInput: Equatable {
    /// <p>The identifier of the <code>DBProxyTarget</code> to describe.</p>
    public let dBProxyName: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///         a pagination token called a marker is included in the response so that the remaining
    ///         results can be retrieved.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The identifier of the <code>DBProxyTargetGroup</code> to describe.</p>
    public let targetGroupName: String?

    public init (
        dBProxyName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        targetGroupName: String? = nil
    )
    {
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.targetGroupName = targetGroupName
    }
}

extension DescribeDBProxyTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxyTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetNotFoundFault" : self = .dBProxyTargetNotFoundFault(try DBProxyTargetNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxyTargetsOutputError: Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBProxyTargetNotFoundFault(DBProxyTargetNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxyTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBProxyTargetsOutputResponse(marker: \(String(describing: marker)), targets: \(String(describing: targets)))"}
}

extension DescribeDBProxyTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBProxyTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.targets = output.targets
        } else {
            self.marker = nil
            self.targets = nil
        }
    }
}

public struct DescribeDBProxyTargetsOutputResponse: Equatable {
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?
    /// <p>An arbitrary number of <code>DBProxyTarget</code> objects, containing details of the corresponding targets.</p>
    public let targets: [DBProxyTarget]?

    public init (
        marker: String? = nil,
        targets: [DBProxyTarget]? = nil
    )
    {
        self.marker = marker
        self.targets = targets
    }
}

struct DescribeDBProxyTargetsOutputResponseBody: Equatable {
    public let targets: [DBProxyTarget]?
    public let marker: String?
}

extension DescribeDBProxyTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBProxyTargetsResult"))
        if containerValues.contains(.targets) {
            struct KeyVal0{struct member{}}
            let targetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targets)
            if let targetsWrappedContainer = targetsWrappedContainer {
                let targetsContainer = try targetsWrappedContainer.decodeIfPresent([DBProxyTarget].self, forKey: .member)
                var targetsBuffer:[DBProxyTarget]? = nil
                if let targetsContainer = targetsContainer {
                    targetsBuffer = [DBProxyTarget]()
                    for structureContainer0 in targetsContainer {
                        targetsBuffer?.append(structureContainer0)
                    }
                }
                targets = targetsBuffer
            } else {
                targets = []
            }
        } else {
            targets = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBSecurityGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBSecurityGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSecurityGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSecurityGroupsOutputError>
}

extension DescribeDBSecurityGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBSecurityGroupsInput(dBSecurityGroupName: \(String(describing: dBSecurityGroupName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBSecurityGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: Key("DBSecurityGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBSecurityGroups", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBSecurityGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBSecurityGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSecurityGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSecurityGroupsOutputError>
}

public struct DescribeDBSecurityGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBSecurityGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSecurityGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSecurityGroupsOutputError>
}

/// <p></p>
public struct DescribeDBSecurityGroupsInput: Equatable {
    /// <p>The name of the DB security group to return details for.</p>
    public let dBSecurityGroupName: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous
    ///         <code>DescribeDBSecurityGroups</code> request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///         a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBSecurityGroupName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBSecurityGroupName = dBSecurityGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBSecurityGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSecurityGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSecurityGroupsOutputError: Equatable {
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSecurityGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBSecurityGroupsOutputResponse(dBSecurityGroups: \(String(describing: dBSecurityGroups)), marker: \(String(describing: marker)))"}
}

extension DescribeDBSecurityGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBSecurityGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSecurityGroups = output.dBSecurityGroups
            self.marker = output.marker
        } else {
            self.dBSecurityGroups = nil
            self.marker = nil
        }
    }
}

/// <p>
///         Contains the result of a successful invocation of the <code>DescribeDBSecurityGroups</code> action.
///         </p>
public struct DescribeDBSecurityGroupsOutputResponse: Equatable {
    /// <p>
    ///         A list of <code>DBSecurityGroup</code> instances.
    ///         </p>
    public let dBSecurityGroups: [DBSecurityGroup]?
    /// <p>
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?

    public init (
        dBSecurityGroups: [DBSecurityGroup]? = nil,
        marker: String? = nil
    )
    {
        self.dBSecurityGroups = dBSecurityGroups
        self.marker = marker
    }
}

struct DescribeDBSecurityGroupsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBSecurityGroups: [DBSecurityGroup]?
}

extension DescribeDBSecurityGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSecurityGroups = "DBSecurityGroups"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBSecurityGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBSecurityGroups) {
            struct KeyVal0{struct DBSecurityGroup{}}
            let dBSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroup>.CodingKeys.self, forKey: .dBSecurityGroups)
            if let dBSecurityGroupsWrappedContainer = dBSecurityGroupsWrappedContainer {
                let dBSecurityGroupsContainer = try dBSecurityGroupsWrappedContainer.decodeIfPresent([DBSecurityGroup].self, forKey: .member)
                var dBSecurityGroupsBuffer:[DBSecurityGroup]? = nil
                if let dBSecurityGroupsContainer = dBSecurityGroupsContainer {
                    dBSecurityGroupsBuffer = [DBSecurityGroup]()
                    for structureContainer0 in dBSecurityGroupsContainer {
                        dBSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSecurityGroups = dBSecurityGroupsBuffer
            } else {
                dBSecurityGroups = []
            }
        } else {
            dBSecurityGroups = nil
        }
    }
}

public struct DescribeDBSnapshotAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBSnapshotAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSnapshotAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSnapshotAttributesInput>
    public typealias MOutput = OperationOutput<DescribeDBSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSnapshotAttributesOutputError>
}

extension DescribeDBSnapshotAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBSnapshotAttributesInput(dBSnapshotIdentifier: \(String(describing: dBSnapshotIdentifier)))"}
}

extension DescribeDBSnapshotAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: Key("DBSnapshotIdentifier"))
        }
        try container.encode("DescribeDBSnapshotAttributes", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBSnapshotAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBSnapshotAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSnapshotAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSnapshotAttributesInput>
    public typealias MOutput = OperationOutput<DescribeDBSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSnapshotAttributesOutputError>
}

public struct DescribeDBSnapshotAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBSnapshotAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSnapshotAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSnapshotAttributesInput>
    public typealias MOutput = OperationOutput<DescribeDBSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSnapshotAttributesOutputError>
}

/// <p></p>
public struct DescribeDBSnapshotAttributesInput: Equatable {
    /// <p>The identifier for the DB snapshot to describe the attributes for.</p>
    public let dBSnapshotIdentifier: String?

    public init (
        dBSnapshotIdentifier: String? = nil
    )
    {
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
    }
}

extension DescribeDBSnapshotAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSnapshotAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSnapshotAttributesOutputError: Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSnapshotAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBSnapshotAttributesOutputResponse(dBSnapshotAttributesResult: \(String(describing: dBSnapshotAttributesResult)))"}
}

extension DescribeDBSnapshotAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBSnapshotAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSnapshotAttributesResult = output.dBSnapshotAttributesResult
        } else {
            self.dBSnapshotAttributesResult = nil
        }
    }
}

public struct DescribeDBSnapshotAttributesOutputResponse: Equatable {
    /// <p>Contains the results of a successful call to the <code>DescribeDBSnapshotAttributes</code>
    ///     API action.</p>
    ///          <p>Manual DB snapshot attributes are used to authorize other AWS accounts
    ///       to copy or restore a manual DB snapshot. For more information, see the <code>ModifyDBSnapshotAttribute</code>
    ///       API action.</p>
    public let dBSnapshotAttributesResult: DBSnapshotAttributesResult?

    public init (
        dBSnapshotAttributesResult: DBSnapshotAttributesResult? = nil
    )
    {
        self.dBSnapshotAttributesResult = dBSnapshotAttributesResult
    }
}

struct DescribeDBSnapshotAttributesOutputResponseBody: Equatable {
    public let dBSnapshotAttributesResult: DBSnapshotAttributesResult?
}

extension DescribeDBSnapshotAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSnapshotAttributesResult = "DBSnapshotAttributesResult"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBSnapshotAttributesResult"))
        let dBSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(DBSnapshotAttributesResult.self, forKey: .dBSnapshotAttributesResult)
        dBSnapshotAttributesResult = dBSnapshotAttributesResultDecoded
    }
}

public struct DescribeDBSnapshotsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeDBSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSnapshotsOutputError>
}

extension DescribeDBSnapshotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBSnapshotsInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBSnapshotIdentifier: \(String(describing: dBSnapshotIdentifier)), dbiResourceId: \(String(describing: dbiResourceId)), filters: \(String(describing: filters)), includePublic: \(String(describing: includePublic)), includeShared: \(String(describing: includeShared)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), snapshotType: \(String(describing: snapshotType)))"}
}

extension DescribeDBSnapshotsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: Key("DBSnapshotIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: Key("DbiResourceId"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if includePublic != false {
            try container.encode(includePublic, forKey: Key("IncludePublic"))
        }
        if includeShared != false {
            try container.encode(includeShared, forKey: Key("IncludeShared"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: Key("SnapshotType"))
        }
        try container.encode("DescribeDBSnapshots", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBSnapshotsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeDBSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSnapshotsOutputError>
}

public struct DescribeDBSnapshotsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeDBSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSnapshotsOutputError>
}

/// <p></p>
public struct DescribeDBSnapshotsInput: Equatable {
    /// <p>The ID of the DB instance to retrieve the list of DB snapshots for.
    ///         This parameter can't be used in conjunction with <code>DBSnapshotIdentifier</code>.
    ///         This parameter isn't case-sensitive.
    ///         </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p>
    ///         A specific DB snapshot identifier to describe. This parameter can't be used in conjunction with <code>DBInstanceIdentifier</code>.
    ///             This value is stored as a lowercase string.
    ///         </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the identifier of an existing DBSnapshot.</p>
    ///             </li>
    ///             <li>
    ///                <p>If this identifier is for an automated snapshot, the <code>SnapshotType</code> parameter must also be specified.</p>
    ///             </li>
    ///          </ul>
    public let dBSnapshotIdentifier: String?
    /// <p>A specific DB resource ID to describe.</p>
    public let dbiResourceId: String?
    /// <p>A filter that specifies one or more DB snapshots to describe.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-instance-id</code> - Accepts DB instance identifiers and DB
    ///               instance Amazon Resource Names (ARNs).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db-snapshot-id</code> - Accepts DB snapshot identifiers.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>dbi-resource-id</code> - Accepts identifiers of source DB instances.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>snapshot-type</code> - Accepts types of DB snapshots.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>engine</code> - Accepts names of database engines.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>A value that indicates whether to include manual DB cluster snapshots that are public and can be copied
    ///           or restored by any AWS account. By default, the public snapshots are not included.</p>
    ///          <p>You can share a manual DB snapshot as public by using the <a>ModifyDBSnapshotAttribute</a> API.</p>
    public let includePublic: Bool
    /// <p>A value that indicates whether to include shared manual DB cluster snapshots
    ///           from other AWS accounts that this AWS account has been given
    ///           permission to copy or restore. By default, these snapshots are not included.</p>
    ///          <p>You can give an AWS account permission to restore a manual DB snapshot from
    ///     another AWS account by using the <code>ModifyDBSnapshotAttribute</code> API action.</p>
    public let includeShared: Bool
    /// <p>
    ///         An optional pagination token provided by a previous
    ///         <code>DescribeDBSnapshots</code> request.
    ///             If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///         a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The type of snapshots to be returned. You can specify one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>automated</code> - Return all DB snapshots that have been automatically taken by
    ///       Amazon RDS for my AWS account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>manual</code> - Return all DB snapshots that have been taken by my AWS account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>shared</code> - Return all manual DB snapshots that have been shared to my AWS account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>public</code> - Return all DB snapshots that have been marked as public.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>awsbackup</code> - Return the DB snapshots managed by the AWS Backup service.</p>
    ///               <p>For information about AWS Backup, see the
    ///                   <a href="https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html">
    ///                       <i>AWS Backup Developer Guide.</i>
    ///                   </a>
    ///                </p>
    ///               <p>The <code>awsbackup</code> type does not apply to Aurora.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify a <code>SnapshotType</code> value, then both automated and manual snapshots are
    ///       returned. Shared and public DB snapshots are not included in the returned results by default.
    ///       You can include shared snapshots with these results by enabling the <code>IncludeShared</code>
    ///       parameter. You can include public snapshots with these results by enabling the
    ///       <code>IncludePublic</code> parameter.</p>
    ///          <p>The <code>IncludeShared</code> and <code>IncludePublic</code> parameters don't apply for <code>SnapshotType</code> values
    ///       of <code>manual</code> or <code>automated</code>. The <code>IncludePublic</code> parameter doesn't apply when <code>SnapshotType</code> is
    ///       set to <code>shared</code>. The <code>IncludeShared</code> parameter doesn't apply when <code>SnapshotType</code> is set to
    ///       <code>public</code>.</p>
    public let snapshotType: String?

    public init (
        dBInstanceIdentifier: String? = nil,
        dBSnapshotIdentifier: String? = nil,
        dbiResourceId: String? = nil,
        filters: [Filter]? = nil,
        includePublic: Bool = false,
        includeShared: Bool = false,
        marker: String? = nil,
        maxRecords: Int? = nil,
        snapshotType: String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.dbiResourceId = dbiResourceId
        self.filters = filters
        self.includePublic = includePublic
        self.includeShared = includeShared
        self.marker = marker
        self.maxRecords = maxRecords
        self.snapshotType = snapshotType
    }
}

extension DescribeDBSnapshotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSnapshotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSnapshotsOutputError: Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSnapshotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBSnapshotsOutputResponse(dBSnapshots: \(String(describing: dBSnapshots)), marker: \(String(describing: marker)))"}
}

extension DescribeDBSnapshotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSnapshots = output.dBSnapshots
            self.marker = output.marker
        } else {
            self.dBSnapshots = nil
            self.marker = nil
        }
    }
}

/// <p>
///         Contains the result of a successful invocation of the <code>DescribeDBSnapshots</code> action.
///         </p>
public struct DescribeDBSnapshotsOutputResponse: Equatable {
    /// <p>
    ///         A list of <code>DBSnapshot</code> instances.
    ///         </p>
    public let dBSnapshots: [DBSnapshot]?
    /// <p>
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?

    public init (
        dBSnapshots: [DBSnapshot]? = nil,
        marker: String? = nil
    )
    {
        self.dBSnapshots = dBSnapshots
        self.marker = marker
    }
}

struct DescribeDBSnapshotsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBSnapshots: [DBSnapshot]?
}

extension DescribeDBSnapshotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSnapshots = "DBSnapshots"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBSnapshotsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBSnapshots) {
            struct KeyVal0{struct DBSnapshot{}}
            let dBSnapshotsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSnapshot>.CodingKeys.self, forKey: .dBSnapshots)
            if let dBSnapshotsWrappedContainer = dBSnapshotsWrappedContainer {
                let dBSnapshotsContainer = try dBSnapshotsWrappedContainer.decodeIfPresent([DBSnapshot].self, forKey: .member)
                var dBSnapshotsBuffer:[DBSnapshot]? = nil
                if let dBSnapshotsContainer = dBSnapshotsContainer {
                    dBSnapshotsBuffer = [DBSnapshot]()
                    for structureContainer0 in dBSnapshotsContainer {
                        dBSnapshotsBuffer?.append(structureContainer0)
                    }
                }
                dBSnapshots = dBSnapshotsBuffer
            } else {
                dBSnapshots = []
            }
        } else {
            dBSnapshots = nil
        }
    }
}

public struct DescribeDBSubnetGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBSubnetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSubnetGroupsOutputError>
}

extension DescribeDBSubnetGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBSubnetGroupsInput(dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBSubnetGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBSubnetGroups", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBSubnetGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBSubnetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSubnetGroupsOutputError>
}

public struct DescribeDBSubnetGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBSubnetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSubnetGroupsOutputError>
}

/// <p></p>
public struct DescribeDBSubnetGroupsInput: Equatable {
    /// <p>The name of the DB subnet group to return details for.</p>
    public let dBSubnetGroupName: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///             An optional pagination token provided by a previous DescribeDBSubnetGroups request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///         a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBSubnetGroupName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBSubnetGroupName = dBSubnetGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBSubnetGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSubnetGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSubnetGroupsOutputError: Equatable {
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSubnetGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBSubnetGroupsOutputResponse(dBSubnetGroups: \(String(describing: dBSubnetGroups)), marker: \(String(describing: marker)))"}
}

extension DescribeDBSubnetGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSubnetGroups = output.dBSubnetGroups
            self.marker = output.marker
        } else {
            self.dBSubnetGroups = nil
            self.marker = nil
        }
    }
}

/// <p>
///         Contains the result of a successful invocation of the <code>DescribeDBSubnetGroups</code> action.
///         </p>
public struct DescribeDBSubnetGroupsOutputResponse: Equatable {
    /// <p>
    ///         A list of <code>DBSubnetGroup</code> instances.
    ///         </p>
    public let dBSubnetGroups: [DBSubnetGroup]?
    /// <p>
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?

    public init (
        dBSubnetGroups: [DBSubnetGroup]? = nil,
        marker: String? = nil
    )
    {
        self.dBSubnetGroups = dBSubnetGroups
        self.marker = marker
    }
}

struct DescribeDBSubnetGroupsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBSubnetGroups: [DBSubnetGroup]?
}

extension DescribeDBSubnetGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSubnetGroups = "DBSubnetGroups"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBSubnetGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBSubnetGroups) {
            struct KeyVal0{struct DBSubnetGroup{}}
            let dBSubnetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSubnetGroup>.CodingKeys.self, forKey: .dBSubnetGroups)
            if let dBSubnetGroupsWrappedContainer = dBSubnetGroupsWrappedContainer {
                let dBSubnetGroupsContainer = try dBSubnetGroupsWrappedContainer.decodeIfPresent([DBSubnetGroup].self, forKey: .member)
                var dBSubnetGroupsBuffer:[DBSubnetGroup]? = nil
                if let dBSubnetGroupsContainer = dBSubnetGroupsContainer {
                    dBSubnetGroupsBuffer = [DBSubnetGroup]()
                    for structureContainer0 in dBSubnetGroupsContainer {
                        dBSubnetGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSubnetGroups = dBSubnetGroupsBuffer
            } else {
                dBSubnetGroups = []
            }
        } else {
            dBSubnetGroups = nil
        }
    }
}

public struct DescribeEngineDefaultClusterParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

extension DescribeEngineDefaultClusterParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEngineDefaultClusterParametersInput(dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeEngineDefaultClusterParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeEngineDefaultClusterParameters", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeEngineDefaultClusterParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

public struct DescribeEngineDefaultClusterParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

/// <p></p>
public struct DescribeEngineDefaultClusterParametersInput: Equatable {
    /// <p>The name of the DB cluster parameter group family to return engine parameter information for.</p>
    public let dBParameterGroupFamily: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///       An optional pagination token provided by a previous
    ///       <code>DescribeEngineDefaultClusterParameters</code> request.
    ///       If this parameter is specified, the response includes
    ///       only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: String?
    /// <p>
    ///       The maximum number of records to include in the response.
    ///       If more records exist than the specified <code>MaxRecords</code> value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///     </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBParameterGroupFamily: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeEngineDefaultClusterParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEngineDefaultClusterParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngineDefaultClusterParametersOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngineDefaultClusterParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEngineDefaultClusterParametersOutputResponse(engineDefaults: \(String(describing: engineDefaults)))"}
}

extension DescribeEngineDefaultClusterParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEngineDefaultClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.engineDefaults = output.engineDefaults
        } else {
            self.engineDefaults = nil
        }
    }
}

public struct DescribeEngineDefaultClusterParametersOutputResponse: Equatable {
    /// <p>
    ///             Contains the result of a successful invocation of the <code>DescribeEngineDefaultParameters</code> action.
    ///         </p>
    public let engineDefaults: EngineDefaults?

    public init (
        engineDefaults: EngineDefaults? = nil
    )
    {
        self.engineDefaults = engineDefaults
    }
}

struct DescribeEngineDefaultClusterParametersOutputResponseBody: Equatable {
    public let engineDefaults: EngineDefaults?
}

extension DescribeEngineDefaultClusterParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engineDefaults = "EngineDefaults"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEngineDefaultClusterParametersResult"))
        let engineDefaultsDecoded = try containerValues.decodeIfPresent(EngineDefaults.self, forKey: .engineDefaults)
        engineDefaults = engineDefaultsDecoded
    }
}

public struct DescribeEngineDefaultParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultParametersOutputError>
}

extension DescribeEngineDefaultParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEngineDefaultParametersInput(dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeEngineDefaultParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeEngineDefaultParameters", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeEngineDefaultParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultParametersOutputError>
}

public struct DescribeEngineDefaultParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultParametersOutputError>
}

/// <p></p>
public struct DescribeEngineDefaultParametersInput: Equatable {
    /// <p>The name of the DB parameter group family.</p>
    public let dBParameterGroupFamily: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous
    ///         <code>DescribeEngineDefaultParameters</code> request.
    ///             If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBParameterGroupFamily: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeEngineDefaultParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEngineDefaultParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngineDefaultParametersOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngineDefaultParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEngineDefaultParametersOutputResponse(engineDefaults: \(String(describing: engineDefaults)))"}
}

extension DescribeEngineDefaultParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEngineDefaultParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.engineDefaults = output.engineDefaults
        } else {
            self.engineDefaults = nil
        }
    }
}

public struct DescribeEngineDefaultParametersOutputResponse: Equatable {
    /// <p>
    ///             Contains the result of a successful invocation of the <code>DescribeEngineDefaultParameters</code> action.
    ///         </p>
    public let engineDefaults: EngineDefaults?

    public init (
        engineDefaults: EngineDefaults? = nil
    )
    {
        self.engineDefaults = engineDefaults
    }
}

struct DescribeEngineDefaultParametersOutputResponseBody: Equatable {
    public let engineDefaults: EngineDefaults?
}

extension DescribeEngineDefaultParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engineDefaults = "EngineDefaults"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEngineDefaultParametersResult"))
        let engineDefaultsDecoded = try containerValues.decodeIfPresent(EngineDefaults.self, forKey: .engineDefaults)
        engineDefaults = engineDefaultsDecoded
    }
}

public struct DescribeEventCategoriesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

extension DescribeEventCategoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventCategoriesInput(filters: \(String(describing: filters)), sourceType: \(String(describing: sourceType)))"}
}

extension DescribeEventCategoriesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        try container.encode("DescribeEventCategories", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeEventCategoriesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

public struct DescribeEventCategoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

/// <p></p>
public struct DescribeEventCategoriesInput: Equatable {
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>The type of source that is generating the events.</p>
    ///          <p>Valid values: <code>db-instance</code> | <code>db-cluster</code> | <code>db-parameter-group</code> | <code>db-security-group</code> | <code>db-snapshot</code> | <code>db-cluster-snapshot</code>
    ///          </p>
    public let sourceType: String?

    public init (
        filters: [Filter]? = nil,
        sourceType: String? = nil
    )
    {
        self.filters = filters
        self.sourceType = sourceType
    }
}

extension DescribeEventCategoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventCategoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventCategoriesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventCategoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventCategoriesOutputResponse(eventCategoriesMapList: \(String(describing: eventCategoriesMapList)))"}
}

extension DescribeEventCategoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventCategoriesMapList = output.eventCategoriesMapList
        } else {
            self.eventCategoriesMapList = nil
        }
    }
}

/// <p>Data returned from the <code>DescribeEventCategories</code> operation.</p>
public struct DescribeEventCategoriesOutputResponse: Equatable {
    /// <p>A list of EventCategoriesMap data types.</p>
    public let eventCategoriesMapList: [EventCategoriesMap]?

    public init (
        eventCategoriesMapList: [EventCategoriesMap]? = nil
    )
    {
        self.eventCategoriesMapList = eventCategoriesMapList
    }
}

struct DescribeEventCategoriesOutputResponseBody: Equatable {
    public let eventCategoriesMapList: [EventCategoriesMap]?
}

extension DescribeEventCategoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventCategoriesMapList = "EventCategoriesMapList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEventCategoriesResult"))
        if containerValues.contains(.eventCategoriesMapList) {
            struct KeyVal0{struct EventCategoriesMap{}}
            let eventCategoriesMapListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategoriesMap>.CodingKeys.self, forKey: .eventCategoriesMapList)
            if let eventCategoriesMapListWrappedContainer = eventCategoriesMapListWrappedContainer {
                let eventCategoriesMapListContainer = try eventCategoriesMapListWrappedContainer.decodeIfPresent([EventCategoriesMap].self, forKey: .member)
                var eventCategoriesMapListBuffer:[EventCategoriesMap]? = nil
                if let eventCategoriesMapListContainer = eventCategoriesMapListContainer {
                    eventCategoriesMapListBuffer = [EventCategoriesMap]()
                    for structureContainer0 in eventCategoriesMapListContainer {
                        eventCategoriesMapListBuffer?.append(structureContainer0)
                    }
                }
                eventCategoriesMapList = eventCategoriesMapListBuffer
            } else {
                eventCategoriesMapList = []
            }
        } else {
            eventCategoriesMapList = nil
        }
    }
}

public struct DescribeEventSubscriptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

extension DescribeEventSubscriptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventSubscriptionsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), subscriptionName: \(String(describing: subscriptionName)))"}
}

extension DescribeEventSubscriptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("DescribeEventSubscriptions", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeEventSubscriptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

public struct DescribeEventSubscriptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

/// <p></p>
public struct DescribeEventSubscriptionsInput: Equatable {
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///             An optional pagination token provided by a previous
    ///             DescribeOrderableDBInstanceOptions request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code> .
    ///         </p>
    public let marker: String?
    /// <p>
    ///             The maximum number of records to include in the response.
    ///             If more records exist than the specified <code>MaxRecords</code> value,
    ///             a pagination token called a marker is included in the response so that
    ///             you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The name of the RDS event notification subscription you want to describe.</p>
    public let subscriptionName: String?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        subscriptionName: String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
    }
}

extension DescribeEventSubscriptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventSubscriptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventSubscriptionsOutputError: Equatable {
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSubscriptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventSubscriptionsOutputResponse(eventSubscriptionsList: \(String(describing: eventSubscriptionsList)), marker: \(String(describing: marker)))"}
}

extension DescribeEventSubscriptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscriptionsList = output.eventSubscriptionsList
            self.marker = output.marker
        } else {
            self.eventSubscriptionsList = nil
            self.marker = nil
        }
    }
}

/// <p>Data returned by the <b>DescribeEventSubscriptions</b> action.</p>
public struct DescribeEventSubscriptionsOutputResponse: Equatable {
    /// <p>A list of EventSubscriptions data types.</p>
    public let eventSubscriptionsList: [EventSubscription]?
    /// <p>
    ///             An optional pagination token provided by a previous
    ///             DescribeOrderableDBInstanceOptions request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?

    public init (
        eventSubscriptionsList: [EventSubscription]? = nil,
        marker: String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

struct DescribeEventSubscriptionsOutputResponseBody: Equatable {
    public let marker: String?
    public let eventSubscriptionsList: [EventSubscription]?
}

extension DescribeEventSubscriptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscriptionsList = "EventSubscriptionsList"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEventSubscriptionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.eventSubscriptionsList) {
            struct KeyVal0{struct EventSubscription{}}
            let eventSubscriptionsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventSubscription>.CodingKeys.self, forKey: .eventSubscriptionsList)
            if let eventSubscriptionsListWrappedContainer = eventSubscriptionsListWrappedContainer {
                let eventSubscriptionsListContainer = try eventSubscriptionsListWrappedContainer.decodeIfPresent([EventSubscription].self, forKey: .member)
                var eventSubscriptionsListBuffer:[EventSubscription]? = nil
                if let eventSubscriptionsListContainer = eventSubscriptionsListContainer {
                    eventSubscriptionsListBuffer = [EventSubscription]()
                    for structureContainer0 in eventSubscriptionsListContainer {
                        eventSubscriptionsListBuffer?.append(structureContainer0)
                    }
                }
                eventSubscriptionsList = eventSubscriptionsListBuffer
            } else {
                eventSubscriptionsList = []
            }
        } else {
            eventSubscriptionsList = nil
        }
    }
}

public struct DescribeEventsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsInput(duration: \(String(describing: duration)), endTime: \(String(describing: endTime)), eventCategories: \(String(describing: eventCategories)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), sourceIdentifier: \(String(describing: sourceIdentifier)), sourceType: \(String(describing: sourceType)), startTime: \(String(describing: startTime)))"}
}

extension DescribeEventsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let duration = duration {
            try container.encode(duration, forKey: Key("Duration"))
        }
        if let endTime = endTime {
            try container.encode(TimestampWrapper(endTime, format: .dateTime), forKey: Key("endTime"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        try container.encode("DescribeEvents", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeEventsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

/// <p></p>
public struct DescribeEventsInput: Equatable {
    /// <p>The number of minutes to retrieve events for.</p>
    ///          <p>Default: 60</p>
    public let duration: Int?
    /// <p>
    ///         The end of the time interval for which to retrieve events,
    ///         specified in ISO 8601 format. For more information about ISO 8601,
    ///         go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///          </p>
    ///          <p>Example: 2009-07-08T18:00Z</p>
    public let endTime: Date?
    /// <p>A list of event categories that trigger notifications for a event notification subscription.</p>
    public let eventCategories: [String]?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous
    ///         DescribeEvents request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified <code>MaxRecords</code> value,
    ///             a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The identifier of the event source for which events are returned. If not specified, then all sources are included in the response.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If <code>SourceIdentifier</code> is supplied, <code>SourceType</code> must also be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB instance, a <code>DBInstanceIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB cluster, a <code>DBClusterIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB parameter group, a <code>DBParameterGroupName</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB security group, a <code>DBSecurityGroupName</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB snapshot, a <code>DBSnapshotIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB cluster snapshot, a <code>DBClusterSnapshotIdentifier</code> value must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let sourceIdentifier: String?
    /// <p>The event source to retrieve events for. If no value is specified, all events are returned.</p>
    public let sourceType: SourceType?
    /// <p>
    ///         The beginning of the time interval to retrieve events for,
    ///         specified in ISO 8601 format. For more information about ISO 8601,
    ///         go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///          </p>
    ///          <p>Example: 2009-07-08T18:00Z</p>
    public let startTime: Date?

    public init (
        duration: Int? = nil,
        endTime: Date? = nil,
        eventCategories: [String]? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        sourceIdentifier: String? = nil,
        sourceType: SourceType? = nil,
        startTime: Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.eventCategories = eventCategories
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

extension DescribeEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsOutputResponse(events: \(String(describing: events)), marker: \(String(describing: marker)))"}
}

extension DescribeEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
            self.marker = output.marker
        } else {
            self.events = nil
            self.marker = nil
        }
    }
}

/// <p>
///         Contains the result of a successful invocation of the <code>DescribeEvents</code> action.
///         </p>
public struct DescribeEventsOutputResponse: Equatable {
    /// <p>
    ///         A list of <code>Event</code> instances.
    ///         </p>
    public let events: [Event]?
    /// <p>
    ///             An optional pagination token provided by a previous
    ///             Events request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code> .
    ///         </p>
    public let marker: String?

    public init (
        events: [Event]? = nil,
        marker: String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

struct DescribeEventsOutputResponseBody: Equatable {
    public let marker: String?
    public let events: [Event]?
}

extension DescribeEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEventsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.events) {
            struct KeyVal0{struct Event{}}
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Event>.CodingKeys.self, forKey: .events)
            if let eventsWrappedContainer = eventsWrappedContainer {
                let eventsContainer = try eventsWrappedContainer.decodeIfPresent([Event].self, forKey: .member)
                var eventsBuffer:[Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [Event]()
                    for structureContainer0 in eventsContainer {
                        eventsBuffer?.append(structureContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
    }
}

public struct DescribeExportTasksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeExportTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExportTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExportTasksInput>
    public typealias MOutput = OperationOutput<DescribeExportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExportTasksOutputError>
}

extension DescribeExportTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExportTasksInput(exportTaskIdentifier: \(String(describing: exportTaskIdentifier)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), sourceArn: \(String(describing: sourceArn)))"}
}

extension DescribeExportTasksInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: Key("ExportTaskIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: Key("SourceArn"))
        }
        try container.encode("DescribeExportTasks", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeExportTasksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeExportTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExportTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExportTasksInput>
    public typealias MOutput = OperationOutput<DescribeExportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExportTasksOutputError>
}

public struct DescribeExportTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeExportTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExportTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExportTasksInput>
    public typealias MOutput = OperationOutput<DescribeExportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExportTasksOutputError>
}

public struct DescribeExportTasksInput: Equatable {
    /// <p>The identifier of the snapshot export task to be described.</p>
    public let exportTaskIdentifier: String?
    /// <p>Filters specify one or more snapshot exports to describe. The filters are specified as name-value pairs that define what to
    ///             include in the output. Filter names and values are case-sensitive.</p>
    ///         <p>Supported filters include the following: </p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>export-task-identifier</code> - An identifier for the snapshot export task.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3-bucket</code> - The Amazon S3 bucket the snapshot is exported to.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>source-arn</code> - The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                     <code>status</code> - The status of the export task. Must be lowercase, for example, <code>complete</code>.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>
    ///             An optional pagination token provided by a previous <code>DescribeExportTasks</code> request.
    ///             If you specify this parameter, the response includes only records beyond the marker,
    ///             up to the value specified by the <code>MaxRecords</code> parameter.
    ///         </p>
    public let marker: String?
    /// <p>
    ///             The maximum number of records to include in the response. If more records exist than the
    ///             specified value, a pagination token called a marker is included in the response.
    ///             You can use the marker in a later <code>DescribeExportTasks</code> request
    ///             to retrieve the remaining results.
    ///         </p>
    ///         <p>Default: 100</p>
    ///         <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.</p>
    public let sourceArn: String?

    public init (
        exportTaskIdentifier: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        sourceArn: String? = nil
    )
    {
        self.exportTaskIdentifier = exportTaskIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceArn = sourceArn
    }
}

extension DescribeExportTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeExportTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExportTaskNotFoundFault" : self = .exportTaskNotFoundFault(try ExportTaskNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExportTasksOutputError: Equatable {
    case exportTaskNotFoundFault(ExportTaskNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExportTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExportTasksOutputResponse(exportTasks: \(String(describing: exportTasks)), marker: \(String(describing: marker)))"}
}

extension DescribeExportTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeExportTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exportTasks = output.exportTasks
            self.marker = output.marker
        } else {
            self.exportTasks = nil
            self.marker = nil
        }
    }
}

public struct DescribeExportTasksOutputResponse: Equatable {
    /// <p>Information about an export of a snapshot to Amazon S3.</p>
    public let exportTasks: [ExportTask]?
    /// <p>A pagination token that can be used in a later <code>DescribeExportTasks</code>
    ///             request. A marker is used for pagination to identify the location to begin output for
    ///             the next response of <code>DescribeExportTasks</code>.</p>
    public let marker: String?

    public init (
        exportTasks: [ExportTask]? = nil,
        marker: String? = nil
    )
    {
        self.exportTasks = exportTasks
        self.marker = marker
    }
}

struct DescribeExportTasksOutputResponseBody: Equatable {
    public let marker: String?
    public let exportTasks: [ExportTask]?
}

extension DescribeExportTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportTasks = "ExportTasks"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeExportTasksResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.exportTasks) {
            struct KeyVal0{struct ExportTask{}}
            let exportTasksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ExportTask>.CodingKeys.self, forKey: .exportTasks)
            if let exportTasksWrappedContainer = exportTasksWrappedContainer {
                let exportTasksContainer = try exportTasksWrappedContainer.decodeIfPresent([ExportTask].self, forKey: .member)
                var exportTasksBuffer:[ExportTask]? = nil
                if let exportTasksContainer = exportTasksContainer {
                    exportTasksBuffer = [ExportTask]()
                    for structureContainer0 in exportTasksContainer {
                        exportTasksBuffer?.append(structureContainer0)
                    }
                }
                exportTasks = exportTasksBuffer
            } else {
                exportTasks = []
            }
        } else {
            exportTasks = nil
        }
    }
}

public struct DescribeGlobalClustersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeGlobalClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGlobalClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGlobalClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGlobalClustersInput>
    public typealias MOutput = OperationOutput<DescribeGlobalClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGlobalClustersOutputError>
}

extension DescribeGlobalClustersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGlobalClustersInput(filters: \(String(describing: filters)), globalClusterIdentifier: \(String(describing: globalClusterIdentifier)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeGlobalClustersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: Key("GlobalClusterIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeGlobalClusters", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeGlobalClustersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeGlobalClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGlobalClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGlobalClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGlobalClustersInput>
    public typealias MOutput = OperationOutput<DescribeGlobalClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGlobalClustersOutputError>
}

public struct DescribeGlobalClustersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeGlobalClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGlobalClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGlobalClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGlobalClustersInput>
    public typealias MOutput = OperationOutput<DescribeGlobalClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGlobalClustersOutputError>
}

public struct DescribeGlobalClustersInput: Equatable {
    /// <p>A filter that specifies one or more global DB clusters to describe.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-id</code> - Accepts DB cluster identifiers and DB
    ///               cluster Amazon Resource Names (ARNs). The results list will only include information about
    ///               the DB clusters identified by these ARNs.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>
    ///         The user-supplied DB cluster identifier. If this parameter is specified, information from only the specific DB cluster is returned. This parameter isn't case-sensitive.
    ///       </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match an existing DBClusterIdentifier.</p>
    ///             </li>
    ///          </ul>
    public let globalClusterIdentifier: String?
    /// <p>
    ///         An optional pagination token provided by a previous <code>DescribeGlobalClusters</code> request. If
    ///         this parameter is specified, the response includes only records beyond the marker, up to the value
    ///         specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?
    /// <p>
    ///         The maximum number of records to include in the response. If more records exist than the specified
    ///         <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that
    ///        you can retrieve the remaining results.
    ///       </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        filters: [Filter]? = nil,
        globalClusterIdentifier: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.filters = filters
        self.globalClusterIdentifier = globalClusterIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeGlobalClustersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeGlobalClustersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGlobalClustersOutputError: Equatable {
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGlobalClustersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGlobalClustersOutputResponse(globalClusters: \(String(describing: globalClusters)), marker: \(String(describing: marker)))"}
}

extension DescribeGlobalClustersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeGlobalClustersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.globalClusters = output.globalClusters
            self.marker = output.marker
        } else {
            self.globalClusters = nil
            self.marker = nil
        }
    }
}

public struct DescribeGlobalClustersOutputResponse: Equatable {
    /// <p>
    ///         The list of global clusters returned by this request.
    ///       </p>
    public let globalClusters: [GlobalCluster]?
    /// <p>
    ///         An optional pagination token provided by a previous <code>DescribeGlobalClusters</code> request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker, up to the value specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?

    public init (
        globalClusters: [GlobalCluster]? = nil,
        marker: String? = nil
    )
    {
        self.globalClusters = globalClusters
        self.marker = marker
    }
}

struct DescribeGlobalClustersOutputResponseBody: Equatable {
    public let marker: String?
    public let globalClusters: [GlobalCluster]?
}

extension DescribeGlobalClustersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalClusters = "GlobalClusters"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeGlobalClustersResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.globalClusters) {
            struct KeyVal0{struct GlobalClusterMember{}}
            let globalClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.GlobalClusterMember>.CodingKeys.self, forKey: .globalClusters)
            if let globalClustersWrappedContainer = globalClustersWrappedContainer {
                let globalClustersContainer = try globalClustersWrappedContainer.decodeIfPresent([GlobalCluster].self, forKey: .member)
                var globalClustersBuffer:[GlobalCluster]? = nil
                if let globalClustersContainer = globalClustersContainer {
                    globalClustersBuffer = [GlobalCluster]()
                    for structureContainer0 in globalClustersContainer {
                        globalClustersBuffer?.append(structureContainer0)
                    }
                }
                globalClusters = globalClustersBuffer
            } else {
                globalClusters = []
            }
        } else {
            globalClusters = nil
        }
    }
}

public struct DescribeInstallationMediaInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInstallationMediaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstallationMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstallationMediaInput>
    public typealias MOutput = OperationOutput<DescribeInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstallationMediaOutputError>
}

extension DescribeInstallationMediaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstallationMediaInput(filters: \(String(describing: filters)), installationMediaId: \(String(describing: installationMediaId)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeInstallationMediaInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let installationMediaId = installationMediaId {
            try container.encode(installationMediaId, forKey: Key("InstallationMediaId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeInstallationMedia", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeInstallationMediaInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstallationMediaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstallationMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstallationMediaInput>
    public typealias MOutput = OperationOutput<DescribeInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstallationMediaOutputError>
}

public struct DescribeInstallationMediaInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstallationMediaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstallationMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstallationMediaInput>
    public typealias MOutput = OperationOutput<DescribeInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstallationMediaOutputError>
}

public struct DescribeInstallationMediaInput: Equatable {
    /// <p>A filter that specifies one or more installation media to describe. Supported filters
    ///           include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                     <code>custom-availability-zone-id</code> - Accepts custom Availability Zone (AZ)
    ///                     identifiers. The results list includes information about only the custom AZs
    ///                     identified by these identifiers.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>engine</code> - Accepts database engines. The results list includes information about
    ///               only the database engines identified by these identifiers.</p>
    ///               <p>For more information about the valid engines for installation media, see <a>ImportInstallationMedia</a>.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>The installation medium ID.</p>
    public let installationMediaId: String?
    /// <p>An optional pagination token provided by a previous request.
    ///           If this parameter is specified, the response includes
    ///           only records beyond the marker,
    ///           up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>An optional pagination token provided by a previous DescribeInstallationMedia request.
    ///           If this parameter is specified, the response includes
    ///           only records beyond the marker, up to the value specified by <code>MaxRecords</code>.</p>
    public let maxRecords: Int?

    public init (
        filters: [Filter]? = nil,
        installationMediaId: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.filters = filters
        self.installationMediaId = installationMediaId
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeInstallationMediaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeInstallationMediaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InstallationMediaNotFoundFault" : self = .installationMediaNotFoundFault(try InstallationMediaNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstallationMediaOutputError: Equatable {
    case installationMediaNotFoundFault(InstallationMediaNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstallationMediaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstallationMediaOutputResponse(installationMedia: \(String(describing: installationMedia)), marker: \(String(describing: marker)))"}
}

extension DescribeInstallationMediaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstallationMediaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.installationMedia = output.installationMedia
            self.marker = output.marker
        } else {
            self.installationMedia = nil
            self.marker = nil
        }
    }
}

public struct DescribeInstallationMediaOutputResponse: Equatable {
    /// <p>The list of <a>InstallationMedia</a> objects for the AWS account.</p>
    public let installationMedia: [InstallationMedia]?
    /// <p>An optional pagination token provided by a previous
    ///           <a>DescribeInstallationMedia</a> request.
    ///           If this parameter is specified, the response includes
    ///           only records beyond the marker,
    ///           up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?

    public init (
        installationMedia: [InstallationMedia]? = nil,
        marker: String? = nil
    )
    {
        self.installationMedia = installationMedia
        self.marker = marker
    }
}

struct DescribeInstallationMediaOutputResponseBody: Equatable {
    public let marker: String?
    public let installationMedia: [InstallationMedia]?
}

extension DescribeInstallationMediaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case installationMedia = "InstallationMedia"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeInstallationMediaResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.installationMedia) {
            struct KeyVal0{struct InstallationMedia{}}
            let installationMediaWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.InstallationMedia>.CodingKeys.self, forKey: .installationMedia)
            if let installationMediaWrappedContainer = installationMediaWrappedContainer {
                let installationMediaContainer = try installationMediaWrappedContainer.decodeIfPresent([InstallationMedia].self, forKey: .member)
                var installationMediaBuffer:[InstallationMedia]? = nil
                if let installationMediaContainer = installationMediaContainer {
                    installationMediaBuffer = [InstallationMedia]()
                    for structureContainer0 in installationMediaContainer {
                        installationMediaBuffer?.append(structureContainer0)
                    }
                }
                installationMedia = installationMediaBuffer
            } else {
                installationMedia = []
            }
        } else {
            installationMedia = nil
        }
    }
}

public struct DescribeOptionGroupOptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOptionGroupOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOptionGroupOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOptionGroupOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOptionGroupOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOptionGroupOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOptionGroupOptionsOutputError>
}

extension DescribeOptionGroupOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOptionGroupOptionsInput(engineName: \(String(describing: engineName)), filters: \(String(describing: filters)), majorEngineVersion: \(String(describing: majorEngineVersion)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeOptionGroupOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let engineName = engineName {
            try container.encode(engineName, forKey: Key("EngineName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: Key("MajorEngineVersion"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeOptionGroupOptions", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeOptionGroupOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOptionGroupOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOptionGroupOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOptionGroupOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOptionGroupOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOptionGroupOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOptionGroupOptionsOutputError>
}

public struct DescribeOptionGroupOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOptionGroupOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOptionGroupOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOptionGroupOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOptionGroupOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOptionGroupOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOptionGroupOptionsOutputError>
}

/// <p></p>
public struct DescribeOptionGroupOptionsInput: Equatable {
    /// <p>A required parameter. Options available for the given engine name are described.</p>
    ///          <p>Valid Values:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>mariadb</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mysql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se2</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se1</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>postgres</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ex</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-web</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let engineName: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>If specified, filters the results to include only options for the specified major engine version.</p>
    public let majorEngineVersion: String?
    /// <p>An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>
    ///             The maximum number of records to include in the response.
    ///             If more records exist than the specified <code>MaxRecords</code> value,
    ///             a pagination token called a marker is included in the response so that
    ///             you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        engineName: String? = nil,
        filters: [Filter]? = nil,
        majorEngineVersion: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.engineName = engineName
        self.filters = filters
        self.majorEngineVersion = majorEngineVersion
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeOptionGroupOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOptionGroupOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOptionGroupOptionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOptionGroupOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOptionGroupOptionsOutputResponse(marker: \(String(describing: marker)), optionGroupOptions: \(String(describing: optionGroupOptions)))"}
}

extension DescribeOptionGroupOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOptionGroupOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.optionGroupOptions = output.optionGroupOptions
        } else {
            self.marker = nil
            self.optionGroupOptions = nil
        }
    }
}

/// <p></p>
public struct DescribeOptionGroupOptionsOutputResponse: Equatable {
    /// <p>An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>List of available option group options.</p>
    public let optionGroupOptions: [OptionGroupOption]?

    public init (
        marker: String? = nil,
        optionGroupOptions: [OptionGroupOption]? = nil
    )
    {
        self.marker = marker
        self.optionGroupOptions = optionGroupOptions
    }
}

struct DescribeOptionGroupOptionsOutputResponseBody: Equatable {
    public let optionGroupOptions: [OptionGroupOption]?
    public let marker: String?
}

extension DescribeOptionGroupOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case optionGroupOptions = "OptionGroupOptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeOptionGroupOptionsResult"))
        if containerValues.contains(.optionGroupOptions) {
            struct KeyVal0{struct OptionGroupOption{}}
            let optionGroupOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupOption>.CodingKeys.self, forKey: .optionGroupOptions)
            if let optionGroupOptionsWrappedContainer = optionGroupOptionsWrappedContainer {
                let optionGroupOptionsContainer = try optionGroupOptionsWrappedContainer.decodeIfPresent([OptionGroupOption].self, forKey: .member)
                var optionGroupOptionsBuffer:[OptionGroupOption]? = nil
                if let optionGroupOptionsContainer = optionGroupOptionsContainer {
                    optionGroupOptionsBuffer = [OptionGroupOption]()
                    for structureContainer0 in optionGroupOptionsContainer {
                        optionGroupOptionsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupOptions = optionGroupOptionsBuffer
            } else {
                optionGroupOptions = []
            }
        } else {
            optionGroupOptions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeOptionGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOptionGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOptionGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOptionGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOptionGroupsInput>
    public typealias MOutput = OperationOutput<DescribeOptionGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOptionGroupsOutputError>
}

extension DescribeOptionGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOptionGroupsInput(engineName: \(String(describing: engineName)), filters: \(String(describing: filters)), majorEngineVersion: \(String(describing: majorEngineVersion)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), optionGroupName: \(String(describing: optionGroupName)))"}
}

extension DescribeOptionGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let engineName = engineName {
            try container.encode(engineName, forKey: Key("EngineName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: Key("MajorEngineVersion"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        try container.encode("DescribeOptionGroups", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeOptionGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOptionGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOptionGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOptionGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOptionGroupsInput>
    public typealias MOutput = OperationOutput<DescribeOptionGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOptionGroupsOutputError>
}

public struct DescribeOptionGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOptionGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOptionGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOptionGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOptionGroupsInput>
    public typealias MOutput = OperationOutput<DescribeOptionGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOptionGroupsOutputError>
}

/// <p></p>
public struct DescribeOptionGroupsInput: Equatable {
    /// <p>Filters the list of option groups to only include groups associated with a specific database engine.</p>
    ///          <p>Valid Values:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>mariadb</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mysql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se2</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se1</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>postgres</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ex</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-web</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let engineName: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>Filters the list of option groups to only include groups associated with a specific database engine version. If specified, then EngineName must also be specified.</p>
    public let majorEngineVersion: String?
    /// <p>
    ///             An optional pagination token provided by a previous DescribeOptionGroups request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///             The maximum number of records to include in the response.
    ///             If more records exist than the specified <code>MaxRecords</code> value,
    ///             a pagination token called a marker is included in the response so that
    ///             you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The name of the option group to describe. Can't be supplied together with EngineName or MajorEngineVersion.</p>
    public let optionGroupName: String?

    public init (
        engineName: String? = nil,
        filters: [Filter]? = nil,
        majorEngineVersion: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        optionGroupName: String? = nil
    )
    {
        self.engineName = engineName
        self.filters = filters
        self.majorEngineVersion = majorEngineVersion
        self.marker = marker
        self.maxRecords = maxRecords
        self.optionGroupName = optionGroupName
    }
}

extension DescribeOptionGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOptionGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOptionGroupsOutputError: Equatable {
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOptionGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOptionGroupsOutputResponse(marker: \(String(describing: marker)), optionGroupsList: \(String(describing: optionGroupsList)))"}
}

extension DescribeOptionGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOptionGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.optionGroupsList = output.optionGroupsList
        } else {
            self.marker = nil
            self.optionGroupsList = nil
        }
    }
}

/// <p>List of option groups.</p>
public struct DescribeOptionGroupsOutputResponse: Equatable {
    /// <p>An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>List of option groups.</p>
    public let optionGroupsList: [OptionGroup]?

    public init (
        marker: String? = nil,
        optionGroupsList: [OptionGroup]? = nil
    )
    {
        self.marker = marker
        self.optionGroupsList = optionGroupsList
    }
}

struct DescribeOptionGroupsOutputResponseBody: Equatable {
    public let optionGroupsList: [OptionGroup]?
    public let marker: String?
}

extension DescribeOptionGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case optionGroupsList = "OptionGroupsList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeOptionGroupsResult"))
        if containerValues.contains(.optionGroupsList) {
            struct KeyVal0{struct OptionGroup{}}
            let optionGroupsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroup>.CodingKeys.self, forKey: .optionGroupsList)
            if let optionGroupsListWrappedContainer = optionGroupsListWrappedContainer {
                let optionGroupsListContainer = try optionGroupsListWrappedContainer.decodeIfPresent([OptionGroup].self, forKey: .member)
                var optionGroupsListBuffer:[OptionGroup]? = nil
                if let optionGroupsListContainer = optionGroupsListContainer {
                    optionGroupsListBuffer = [OptionGroup]()
                    for structureContainer0 in optionGroupsListContainer {
                        optionGroupsListBuffer?.append(structureContainer0)
                    }
                }
                optionGroupsList = optionGroupsListBuffer
            } else {
                optionGroupsList = []
            }
        } else {
            optionGroupsList = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeOrderableDBInstanceOptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOrderableDBInstanceOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

extension DescribeOrderableDBInstanceOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrderableDBInstanceOptionsInput(availabilityZoneGroup: \(String(describing: availabilityZoneGroup)), dBInstanceClass: \(String(describing: dBInstanceClass)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), filters: \(String(describing: filters)), licenseModel: \(String(describing: licenseModel)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), vpc: \(String(describing: vpc)))"}
}

extension DescribeOrderableDBInstanceOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZoneGroup = availabilityZoneGroup {
            try container.encode(availabilityZoneGroup, forKey: Key("AvailabilityZoneGroup"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let vpc = vpc {
            try container.encode(vpc, forKey: Key("Vpc"))
        }
        try container.encode("DescribeOrderableDBInstanceOptions", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeOrderableDBInstanceOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrderableDBInstanceOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

public struct DescribeOrderableDBInstanceOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrderableDBInstanceOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

/// <p></p>
public struct DescribeOrderableDBInstanceOptionsInput: Equatable {
    /// <p>The Availability Zone group associated with a Local Zone. Specify this parameter to retrieve available offerings for the Local Zones in the group.</p>
    ///         <p>Omit this parameter to show the available offerings in the specified AWS Region.</p>
    public let availabilityZoneGroup: String?
    /// <p>The DB instance class filter value. Specify this parameter to show only the available offerings matching the specified DB instance class.</p>
    public let dBInstanceClass: String?
    /// <p>The name of the engine to retrieve DB instance options for.</p>
    ///          <p>Valid Values:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>aurora</code> (for MySQL 5.6-compatible Aurora)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>aurora-postgresql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mariadb</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mysql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se2</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se1</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>postgres</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ex</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-web</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let engine: String?
    /// <p>The engine version filter value. Specify this parameter to show only the available offerings matching the specified engine version.</p>
    public let engineVersion: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>The license model filter value. Specify this parameter to show only the available offerings matching the specified license model.</p>
    public let licenseModel: String?
    /// <p>
    ///             An optional pagination token provided by a previous
    ///             DescribeOrderableDBInstanceOptions request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code> .
    ///         </p>
    public let marker: String?
    /// <p>
    ///             The maximum number of records to include in the response.
    ///             If more records exist than the specified <code>MaxRecords</code> value,
    ///             a pagination token called a marker is included in the response so that
    ///             you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>A value that indicates whether to show only VPC or non-VPC offerings.</p>
    public let vpc: Bool?

    public init (
        availabilityZoneGroup: String? = nil,
        dBInstanceClass: String? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        filters: [Filter]? = nil,
        licenseModel: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        vpc: Bool? = nil
    )
    {
        self.availabilityZoneGroup = availabilityZoneGroup
        self.dBInstanceClass = dBInstanceClass
        self.engine = engine
        self.engineVersion = engineVersion
        self.filters = filters
        self.licenseModel = licenseModel
        self.marker = marker
        self.maxRecords = maxRecords
        self.vpc = vpc
    }
}

extension DescribeOrderableDBInstanceOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOrderableDBInstanceOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrderableDBInstanceOptionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrderableDBInstanceOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrderableDBInstanceOptionsOutputResponse(marker: \(String(describing: marker)), orderableDBInstanceOptions: \(String(describing: orderableDBInstanceOptions)))"}
}

extension DescribeOrderableDBInstanceOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOrderableDBInstanceOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.orderableDBInstanceOptions = output.orderableDBInstanceOptions
        } else {
            self.marker = nil
            self.orderableDBInstanceOptions = nil
        }
    }
}

/// <p>
///             Contains the result of a successful invocation of the <code>DescribeOrderableDBInstanceOptions</code> action.
///         </p>
public struct DescribeOrderableDBInstanceOptionsOutputResponse: Equatable {
    /// <p>
    ///             An optional pagination token provided by a previous
    ///             OrderableDBInstanceOptions request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code> .
    ///         </p>
    public let marker: String?
    /// <p>An <code>OrderableDBInstanceOption</code> structure containing information about orderable options for the DB instance.</p>
    public let orderableDBInstanceOptions: [OrderableDBInstanceOption]?

    public init (
        marker: String? = nil,
        orderableDBInstanceOptions: [OrderableDBInstanceOption]? = nil
    )
    {
        self.marker = marker
        self.orderableDBInstanceOptions = orderableDBInstanceOptions
    }
}

struct DescribeOrderableDBInstanceOptionsOutputResponseBody: Equatable {
    public let orderableDBInstanceOptions: [OrderableDBInstanceOption]?
    public let marker: String?
}

extension DescribeOrderableDBInstanceOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case orderableDBInstanceOptions = "OrderableDBInstanceOptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeOrderableDBInstanceOptionsResult"))
        if containerValues.contains(.orderableDBInstanceOptions) {
            struct KeyVal0{struct OrderableDBInstanceOption{}}
            let orderableDBInstanceOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OrderableDBInstanceOption>.CodingKeys.self, forKey: .orderableDBInstanceOptions)
            if let orderableDBInstanceOptionsWrappedContainer = orderableDBInstanceOptionsWrappedContainer {
                let orderableDBInstanceOptionsContainer = try orderableDBInstanceOptionsWrappedContainer.decodeIfPresent([OrderableDBInstanceOption].self, forKey: .member)
                var orderableDBInstanceOptionsBuffer:[OrderableDBInstanceOption]? = nil
                if let orderableDBInstanceOptionsContainer = orderableDBInstanceOptionsContainer {
                    orderableDBInstanceOptionsBuffer = [OrderableDBInstanceOption]()
                    for structureContainer0 in orderableDBInstanceOptionsContainer {
                        orderableDBInstanceOptionsBuffer?.append(structureContainer0)
                    }
                }
                orderableDBInstanceOptions = orderableDBInstanceOptionsBuffer
            } else {
                orderableDBInstanceOptions = []
            }
        } else {
            orderableDBInstanceOptions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribePendingMaintenanceActionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribePendingMaintenanceActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingMaintenanceActionsOutputError>
}

extension DescribePendingMaintenanceActionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePendingMaintenanceActionsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

extension DescribePendingMaintenanceActionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: Key("ResourceIdentifier"))
        }
        try container.encode("DescribePendingMaintenanceActions", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribePendingMaintenanceActionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePendingMaintenanceActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingMaintenanceActionsOutputError>
}

public struct DescribePendingMaintenanceActionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePendingMaintenanceActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingMaintenanceActionsOutputError>
}

/// <p></p>
public struct DescribePendingMaintenanceActionsInput: Equatable {
    /// <p>A filter that specifies one or more resources to return pending maintenance actions for.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-id</code> - Accepts DB cluster identifiers and DB
    ///               cluster Amazon Resource Names (ARNs). The results list will only include pending maintenance
    ///               actions for the DB clusters identified by these ARNs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db-instance-id</code> - Accepts DB instance identifiers and DB
    ///             instance ARNs. The results list will only include pending maintenance
    ///             actions for the DB instances identified by these ARNs.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>
    ///             An optional pagination token provided by a previous
    ///             <code>DescribePendingMaintenanceActions</code> request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to a number of records specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>
    ///             The maximum number of records to include in the response.
    ///             If more records exist than the specified <code>MaxRecords</code> value,
    ///             a pagination token called a marker is included in the response so that
    ///             you can retrieve the remaining results.
    ///         </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The ARN of a resource to return pending maintenance actions for.</p>
    public let resourceIdentifier: String?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        resourceIdentifier: String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.resourceIdentifier = resourceIdentifier
    }
}

extension DescribePendingMaintenanceActionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribePendingMaintenanceActionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePendingMaintenanceActionsOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePendingMaintenanceActionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePendingMaintenanceActionsOutputResponse(marker: \(String(describing: marker)), pendingMaintenanceActions: \(String(describing: pendingMaintenanceActions)))"}
}

extension DescribePendingMaintenanceActionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePendingMaintenanceActionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.pendingMaintenanceActions = output.pendingMaintenanceActions
        } else {
            self.marker = nil
            self.pendingMaintenanceActions = nil
        }
    }
}

/// <p>Data returned from the <b>DescribePendingMaintenanceActions</b> action.</p>
public struct DescribePendingMaintenanceActionsOutputResponse: Equatable {
    /// <p>
    ///             An optional pagination token provided by a previous
    ///             <code>DescribePendingMaintenanceActions</code> request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to a number of records specified by <code>MaxRecords</code>.
    ///         </p>
    public let marker: String?
    /// <p>A list of the pending maintenance actions for the resource.</p>
    public let pendingMaintenanceActions: [ResourcePendingMaintenanceActions]?

    public init (
        marker: String? = nil,
        pendingMaintenanceActions: [ResourcePendingMaintenanceActions]? = nil
    )
    {
        self.marker = marker
        self.pendingMaintenanceActions = pendingMaintenanceActions
    }
}

struct DescribePendingMaintenanceActionsOutputResponseBody: Equatable {
    public let pendingMaintenanceActions: [ResourcePendingMaintenanceActions]?
    public let marker: String?
}

extension DescribePendingMaintenanceActionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case pendingMaintenanceActions = "PendingMaintenanceActions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribePendingMaintenanceActionsResult"))
        if containerValues.contains(.pendingMaintenanceActions) {
            struct KeyVal0{struct ResourcePendingMaintenanceActions{}}
            let pendingMaintenanceActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ResourcePendingMaintenanceActions>.CodingKeys.self, forKey: .pendingMaintenanceActions)
            if let pendingMaintenanceActionsWrappedContainer = pendingMaintenanceActionsWrappedContainer {
                let pendingMaintenanceActionsContainer = try pendingMaintenanceActionsWrappedContainer.decodeIfPresent([ResourcePendingMaintenanceActions].self, forKey: .member)
                var pendingMaintenanceActionsBuffer:[ResourcePendingMaintenanceActions]? = nil
                if let pendingMaintenanceActionsContainer = pendingMaintenanceActionsContainer {
                    pendingMaintenanceActionsBuffer = [ResourcePendingMaintenanceActions]()
                    for structureContainer0 in pendingMaintenanceActionsContainer {
                        pendingMaintenanceActionsBuffer?.append(structureContainer0)
                    }
                }
                pendingMaintenanceActions = pendingMaintenanceActionsBuffer
            } else {
                pendingMaintenanceActions = []
            }
        } else {
            pendingMaintenanceActions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeReservedDBInstancesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReservedDBInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedDBInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedDBInstancesInput>
    public typealias MOutput = OperationOutput<DescribeReservedDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedDBInstancesOutputError>
}

extension DescribeReservedDBInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReservedDBInstancesInput(dBInstanceClass: \(String(describing: dBInstanceClass)), duration: \(String(describing: duration)), filters: \(String(describing: filters)), leaseId: \(String(describing: leaseId)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), multiAZ: \(String(describing: multiAZ)), offeringType: \(String(describing: offeringType)), productDescription: \(String(describing: productDescription)), reservedDBInstanceId: \(String(describing: reservedDBInstanceId)), reservedDBInstancesOfferingId: \(String(describing: reservedDBInstancesOfferingId)))"}
}

extension DescribeReservedDBInstancesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let duration = duration {
            try container.encode(duration, forKey: Key("Duration"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let leaseId = leaseId {
            try container.encode(leaseId, forKey: Key("LeaseId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: Key("ProductDescription"))
        }
        if let reservedDBInstanceId = reservedDBInstanceId {
            try container.encode(reservedDBInstanceId, forKey: Key("ReservedDBInstanceId"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: Key("ReservedDBInstancesOfferingId"))
        }
        try container.encode("DescribeReservedDBInstances", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeReservedDBInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReservedDBInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedDBInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedDBInstancesInput>
    public typealias MOutput = OperationOutput<DescribeReservedDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedDBInstancesOutputError>
}

public struct DescribeReservedDBInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReservedDBInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedDBInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedDBInstancesInput>
    public typealias MOutput = OperationOutput<DescribeReservedDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedDBInstancesOutputError>
}

/// <p></p>
public struct DescribeReservedDBInstancesInput: Equatable {
    /// <p>The DB instance class filter value. Specify this parameter to show only those reservations matching the specified DB instances class.</p>
    public let dBInstanceClass: String?
    /// <p>The duration filter value, specified in years or seconds. Specify this parameter to show only reservations for this duration.</p>
    ///          <p>Valid Values: <code>1 | 3 | 31536000 | 94608000</code>
    ///          </p>
    public let duration: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>The lease identifier filter value. Specify this parameter to show only the reservation that matches the specified lease ID.</p>
    ///          <note>
    ///             <p>AWS Support might request the lease ID for an issue related to a reserved DB instance.</p>
    ///          </note>
    public let leaseId: String?
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: String?
    /// <p>
    ///     The maximum number of records to include in the response.
    ///     If more than the <code>MaxRecords</code> value is available, a pagination token called a marker is
    ///           included in the response so you can retrieve the remaining results.
    ///     </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>A value that indicates whether to show only those reservations that support Multi-AZ.</p>
    public let multiAZ: Bool?
    /// <p>The offering type filter value. Specify this parameter to show only the available offerings matching the specified offering type.</p>
    ///          <p>Valid Values: <code>"Partial Upfront" | "All Upfront" | "No Upfront" </code>
    ///          </p>
    public let offeringType: String?
    /// <p>The product description filter value. Specify this parameter to show only those reservations matching the specified product description.</p>
    public let productDescription: String?
    /// <p>The reserved DB instance identifier filter value. Specify this parameter to show only the reservation that matches the specified reservation ID.</p>
    public let reservedDBInstanceId: String?
    /// <p>The offering identifier filter value. Specify this parameter to show only purchased reservations matching the specified offering identifier.</p>
    public let reservedDBInstancesOfferingId: String?

    public init (
        dBInstanceClass: String? = nil,
        duration: String? = nil,
        filters: [Filter]? = nil,
        leaseId: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        multiAZ: Bool? = nil,
        offeringType: String? = nil,
        productDescription: String? = nil,
        reservedDBInstanceId: String? = nil,
        reservedDBInstancesOfferingId: String? = nil
    )
    {
        self.dBInstanceClass = dBInstanceClass
        self.duration = duration
        self.filters = filters
        self.leaseId = leaseId
        self.marker = marker
        self.maxRecords = maxRecords
        self.multiAZ = multiAZ
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.reservedDBInstanceId = reservedDBInstanceId
        self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
    }
}

public struct DescribeReservedDBInstancesOfferingsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReservedDBInstancesOfferingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedDBInstancesOfferingsOutputError>
}

extension DescribeReservedDBInstancesOfferingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReservedDBInstancesOfferingsInput(dBInstanceClass: \(String(describing: dBInstanceClass)), duration: \(String(describing: duration)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), multiAZ: \(String(describing: multiAZ)), offeringType: \(String(describing: offeringType)), productDescription: \(String(describing: productDescription)), reservedDBInstancesOfferingId: \(String(describing: reservedDBInstancesOfferingId)))"}
}

extension DescribeReservedDBInstancesOfferingsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let duration = duration {
            try container.encode(duration, forKey: Key("Duration"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: Key("ProductDescription"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: Key("ReservedDBInstancesOfferingId"))
        }
        try container.encode("DescribeReservedDBInstancesOfferings", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeReservedDBInstancesOfferingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReservedDBInstancesOfferingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedDBInstancesOfferingsOutputError>
}

public struct DescribeReservedDBInstancesOfferingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReservedDBInstancesOfferingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservedDBInstancesOfferingsOutputError>
}

/// <p></p>
public struct DescribeReservedDBInstancesOfferingsInput: Equatable {
    /// <p>The DB instance class filter value. Specify this parameter to show only the available offerings matching the specified DB instance class.</p>
    public let dBInstanceClass: String?
    /// <p>Duration filter value, specified in years or seconds. Specify this parameter to show only reservations for this duration.</p>
    ///          <p>Valid Values: <code>1 | 3 | 31536000 | 94608000</code>
    ///          </p>
    public let duration: String?
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: String?
    /// <p>
    ///     The maximum number of records to include in the response.
    ///     If more than the <code>MaxRecords</code> value is available, a pagination token called a marker is
    ///     included in the response so you can retrieve the remaining results.
    ///     </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>A value that indicates whether to show only those reservations that support Multi-AZ.</p>
    public let multiAZ: Bool?
    /// <p>The offering type filter value. Specify this parameter to show only the available offerings matching the specified offering type.</p>
    ///          <p>Valid Values: <code>"Partial Upfront" | "All Upfront" | "No Upfront" </code>
    ///          </p>
    public let offeringType: String?
    /// <p>Product description filter value. Specify this parameter to show only the available offerings that contain the specified product description.</p>
    ///          <note>
    ///             <p>The results show offerings that partially match the filter value.</p>
    ///          </note>
    public let productDescription: String?
    /// <p>The offering identifier filter value. Specify this parameter to show only the available offering that matches the specified reservation identifier.</p>
    ///          <p>Example: <code>438012d3-4052-4cc7-b2e3-8d3372e0e706</code>
    ///          </p>
    public let reservedDBInstancesOfferingId: String?

    public init (
        dBInstanceClass: String? = nil,
        duration: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        multiAZ: Bool? = nil,
        offeringType: String? = nil,
        productDescription: String? = nil,
        reservedDBInstancesOfferingId: String? = nil
    )
    {
        self.dBInstanceClass = dBInstanceClass
        self.duration = duration
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.multiAZ = multiAZ
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
    }
}

extension DescribeReservedDBInstancesOfferingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReservedDBInstancesOfferingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ReservedDBInstancesOfferingNotFoundFault" : self = .reservedDBInstancesOfferingNotFoundFault(try ReservedDBInstancesOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedDBInstancesOfferingsOutputError: Equatable {
    case reservedDBInstancesOfferingNotFoundFault(ReservedDBInstancesOfferingNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedDBInstancesOfferingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReservedDBInstancesOfferingsOutputResponse(marker: \(String(describing: marker)), reservedDBInstancesOfferings: \(String(describing: reservedDBInstancesOfferings)))"}
}

extension DescribeReservedDBInstancesOfferingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReservedDBInstancesOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.reservedDBInstancesOfferings = output.reservedDBInstancesOfferings
        } else {
            self.marker = nil
            self.reservedDBInstancesOfferings = nil
        }
    }
}

/// <p>
///         Contains the result of a successful invocation of the <code>DescribeReservedDBInstancesOfferings</code> action.
///         </p>
public struct DescribeReservedDBInstancesOfferingsOutputResponse: Equatable {
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: String?
    /// <p>A list of reserved DB instance offerings.</p>
    public let reservedDBInstancesOfferings: [ReservedDBInstancesOffering]?

    public init (
        marker: String? = nil,
        reservedDBInstancesOfferings: [ReservedDBInstancesOffering]? = nil
    )
    {
        self.marker = marker
        self.reservedDBInstancesOfferings = reservedDBInstancesOfferings
    }
}

struct DescribeReservedDBInstancesOfferingsOutputResponseBody: Equatable {
    public let marker: String?
    public let reservedDBInstancesOfferings: [ReservedDBInstancesOffering]?
}

extension DescribeReservedDBInstancesOfferingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case reservedDBInstancesOfferings = "ReservedDBInstancesOfferings"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeReservedDBInstancesOfferingsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedDBInstancesOfferings) {
            struct KeyVal0{struct ReservedDBInstancesOffering{}}
            let reservedDBInstancesOfferingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedDBInstancesOffering>.CodingKeys.self, forKey: .reservedDBInstancesOfferings)
            if let reservedDBInstancesOfferingsWrappedContainer = reservedDBInstancesOfferingsWrappedContainer {
                let reservedDBInstancesOfferingsContainer = try reservedDBInstancesOfferingsWrappedContainer.decodeIfPresent([ReservedDBInstancesOffering].self, forKey: .member)
                var reservedDBInstancesOfferingsBuffer:[ReservedDBInstancesOffering]? = nil
                if let reservedDBInstancesOfferingsContainer = reservedDBInstancesOfferingsContainer {
                    reservedDBInstancesOfferingsBuffer = [ReservedDBInstancesOffering]()
                    for structureContainer0 in reservedDBInstancesOfferingsContainer {
                        reservedDBInstancesOfferingsBuffer?.append(structureContainer0)
                    }
                }
                reservedDBInstancesOfferings = reservedDBInstancesOfferingsBuffer
            } else {
                reservedDBInstancesOfferings = []
            }
        } else {
            reservedDBInstancesOfferings = nil
        }
    }
}

extension DescribeReservedDBInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReservedDBInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ReservedDBInstanceNotFoundFault" : self = .reservedDBInstanceNotFoundFault(try ReservedDBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedDBInstancesOutputError: Equatable {
    case reservedDBInstanceNotFoundFault(ReservedDBInstanceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedDBInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReservedDBInstancesOutputResponse(marker: \(String(describing: marker)), reservedDBInstances: \(String(describing: reservedDBInstances)))"}
}

extension DescribeReservedDBInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReservedDBInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.reservedDBInstances = output.reservedDBInstances
        } else {
            self.marker = nil
            self.reservedDBInstances = nil
        }
    }
}

/// <p>
///         Contains the result of a successful invocation of the <code>DescribeReservedDBInstances</code> action.
///         </p>
public struct DescribeReservedDBInstancesOutputResponse: Equatable {
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: String?
    /// <p>A list of reserved DB instances.</p>
    public let reservedDBInstances: [ReservedDBInstance]?

    public init (
        marker: String? = nil,
        reservedDBInstances: [ReservedDBInstance]? = nil
    )
    {
        self.marker = marker
        self.reservedDBInstances = reservedDBInstances
    }
}

struct DescribeReservedDBInstancesOutputResponseBody: Equatable {
    public let marker: String?
    public let reservedDBInstances: [ReservedDBInstance]?
}

extension DescribeReservedDBInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case reservedDBInstances = "ReservedDBInstances"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeReservedDBInstancesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedDBInstances) {
            struct KeyVal0{struct ReservedDBInstance{}}
            let reservedDBInstancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedDBInstance>.CodingKeys.self, forKey: .reservedDBInstances)
            if let reservedDBInstancesWrappedContainer = reservedDBInstancesWrappedContainer {
                let reservedDBInstancesContainer = try reservedDBInstancesWrappedContainer.decodeIfPresent([ReservedDBInstance].self, forKey: .member)
                var reservedDBInstancesBuffer:[ReservedDBInstance]? = nil
                if let reservedDBInstancesContainer = reservedDBInstancesContainer {
                    reservedDBInstancesBuffer = [ReservedDBInstance]()
                    for structureContainer0 in reservedDBInstancesContainer {
                        reservedDBInstancesBuffer?.append(structureContainer0)
                    }
                }
                reservedDBInstances = reservedDBInstancesBuffer
            } else {
                reservedDBInstances = []
            }
        } else {
            reservedDBInstances = nil
        }
    }
}

public struct DescribeSourceRegionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSourceRegionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSourceRegionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSourceRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSourceRegionsInput>
    public typealias MOutput = OperationOutput<DescribeSourceRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSourceRegionsOutputError>
}

extension DescribeSourceRegionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSourceRegionsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), regionName: \(String(describing: regionName)))"}
}

extension DescribeSourceRegionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let regionName = regionName {
            try container.encode(regionName, forKey: Key("RegionName"))
        }
        try container.encode("DescribeSourceRegions", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeSourceRegionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSourceRegionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSourceRegionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSourceRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSourceRegionsInput>
    public typealias MOutput = OperationOutput<DescribeSourceRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSourceRegionsOutputError>
}

public struct DescribeSourceRegionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSourceRegionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSourceRegionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSourceRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSourceRegionsInput>
    public typealias MOutput = OperationOutput<DescribeSourceRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSourceRegionsOutputError>
}

/// <p></p>
public struct DescribeSourceRegionsInput: Equatable {
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>An optional pagination token provided by a previous <code>DescribeSourceRegions</code> request. If this parameter is specified, the response
    ///             includes only records beyond the marker, up to the value specified by
    ///             <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist
    ///             than the specified <code>MaxRecords</code> value, a pagination token called a marker is
    ///             included in the response so you can retrieve the remaining results. </p>
    ///         <p>Default: 100</p>
    ///         <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The source AWS Region name. For example, <code>us-east-1</code>.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must specify a valid AWS Region name.</p>
    ///             </li>
    ///          </ul>
    public let regionName: String?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        regionName: String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.regionName = regionName
    }
}

extension DescribeSourceRegionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSourceRegionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSourceRegionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSourceRegionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSourceRegionsOutputResponse(marker: \(String(describing: marker)), sourceRegions: \(String(describing: sourceRegions)))"}
}

extension DescribeSourceRegionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSourceRegionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.sourceRegions = output.sourceRegions
        } else {
            self.marker = nil
            self.sourceRegions = nil
        }
    }
}

/// <p>Contains the result of a successful invocation of the <code>DescribeSourceRegions</code> action.</p>
public struct DescribeSourceRegionsOutputResponse: Equatable {
    /// <p>
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by <code>MaxRecords</code>.
    ///       </p>
    public let marker: String?
    /// <p>A list of SourceRegion instances that contains each source AWS Region that the
    ///             current AWS Region can get a read replica or a DB snapshot from.</p>
    public let sourceRegions: [SourceRegion]?

    public init (
        marker: String? = nil,
        sourceRegions: [SourceRegion]? = nil
    )
    {
        self.marker = marker
        self.sourceRegions = sourceRegions
    }
}

struct DescribeSourceRegionsOutputResponseBody: Equatable {
    public let marker: String?
    public let sourceRegions: [SourceRegion]?
}

extension DescribeSourceRegionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case sourceRegions = "SourceRegions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeSourceRegionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.sourceRegions) {
            struct KeyVal0{struct SourceRegion{}}
            let sourceRegionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SourceRegion>.CodingKeys.self, forKey: .sourceRegions)
            if let sourceRegionsWrappedContainer = sourceRegionsWrappedContainer {
                let sourceRegionsContainer = try sourceRegionsWrappedContainer.decodeIfPresent([SourceRegion].self, forKey: .member)
                var sourceRegionsBuffer:[SourceRegion]? = nil
                if let sourceRegionsContainer = sourceRegionsContainer {
                    sourceRegionsBuffer = [SourceRegion]()
                    for structureContainer0 in sourceRegionsContainer {
                        sourceRegionsBuffer?.append(structureContainer0)
                    }
                }
                sourceRegions = sourceRegionsBuffer
            } else {
                sourceRegions = []
            }
        } else {
            sourceRegions = nil
        }
    }
}

public struct DescribeValidDBInstanceModificationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeValidDBInstanceModificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeValidDBInstanceModificationsOutputError>
}

extension DescribeValidDBInstanceModificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeValidDBInstanceModificationsInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)))"}
}

extension DescribeValidDBInstanceModificationsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        try container.encode("DescribeValidDBInstanceModifications", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeValidDBInstanceModificationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeValidDBInstanceModificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeValidDBInstanceModificationsOutputError>
}

public struct DescribeValidDBInstanceModificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeValidDBInstanceModificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeValidDBInstanceModificationsOutputError>
}

/// <p></p>
public struct DescribeValidDBInstanceModificationsInput: Equatable {
    /// <p>The customer identifier or the ARN of your DB instance.
    ///         </p>
    public let dBInstanceIdentifier: String?

    public init (
        dBInstanceIdentifier: String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
    }
}

extension DescribeValidDBInstanceModificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeValidDBInstanceModificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeValidDBInstanceModificationsOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeValidDBInstanceModificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeValidDBInstanceModificationsOutputResponse(validDBInstanceModificationsMessage: \(String(describing: validDBInstanceModificationsMessage)))"}
}

extension DescribeValidDBInstanceModificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeValidDBInstanceModificationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.validDBInstanceModificationsMessage = output.validDBInstanceModificationsMessage
        } else {
            self.validDBInstanceModificationsMessage = nil
        }
    }
}

public struct DescribeValidDBInstanceModificationsOutputResponse: Equatable {
    /// <p>Information about valid modifications that you can make to your DB instance.
    ///             Contains the result of a successful call to the
    ///             <code>DescribeValidDBInstanceModifications</code> action.
    ///             You can use this information when you call
    ///             <code>ModifyDBInstance</code>.
    ///         </p>
    public let validDBInstanceModificationsMessage: ValidDBInstanceModificationsMessage?

    public init (
        validDBInstanceModificationsMessage: ValidDBInstanceModificationsMessage? = nil
    )
    {
        self.validDBInstanceModificationsMessage = validDBInstanceModificationsMessage
    }
}

struct DescribeValidDBInstanceModificationsOutputResponseBody: Equatable {
    public let validDBInstanceModificationsMessage: ValidDBInstanceModificationsMessage?
}

extension DescribeValidDBInstanceModificationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case validDBInstanceModificationsMessage = "ValidDBInstanceModificationsMessage"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeValidDBInstanceModificationsResult"))
        let validDBInstanceModificationsMessageDecoded = try containerValues.decodeIfPresent(ValidDBInstanceModificationsMessage.self, forKey: .validDBInstanceModificationsMessage)
        validDBInstanceModificationsMessage = validDBInstanceModificationsMessageDecoded
    }
}

extension DomainMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
        case fQDN = "FQDN"
        case iAMRoleName = "IAMRoleName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let fQDN = fQDN {
            try container.encode(fQDN, forKey: Key("FQDN"))
        }
        if let iAMRoleName = iAMRoleName {
            try container.encode(iAMRoleName, forKey: Key("IAMRoleName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let fQDNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fQDN)
        fQDN = fQDNDecoded
        let iAMRoleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iAMRoleName)
        iAMRoleName = iAMRoleNameDecoded
    }
}

extension DomainMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainMembership(domain: \(String(describing: domain)), fQDN: \(String(describing: fQDN)), iAMRoleName: \(String(describing: iAMRoleName)), status: \(String(describing: status)))"}
}

/// <p>An Active Directory Domain membership record associated with the DB instance or cluster.</p>
public struct DomainMembership: Equatable {
    /// <p>The identifier of the Active Directory Domain.</p>
    public let domain: String?
    /// <p>The fully qualified domain name of the Active Directory Domain.</p>
    public let fQDN: String?
    /// <p>The name of the IAM role to be used when making API calls to the Directory Service.</p>
    public let iAMRoleName: String?
    /// <p>The status of the Active Directory Domain membership for the DB instance or cluster. Values include joined, pending-join, failed, and so on.</p>
    public let status: String?

    public init (
        domain: String? = nil,
        fQDN: String? = nil,
        iAMRoleName: String? = nil,
        status: String? = nil
    )
    {
        self.domain = domain
        self.fQDN = fQDN
        self.iAMRoleName = iAMRoleName
        self.status = status
    }
}

extension DomainNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainNotFoundFault(message: \(String(describing: message)))"}
}

extension DomainNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DomainNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>Domain</code> doesn't refer to an existing Active Directory domain.
///         </p>
public struct DomainNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DomainNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DomainNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DoubleRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case from = "From"
        case to = "To"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if from != 0.0 {
            try container.encode(String(from), forKey: Key("From"))
        }
        if to != 0.0 {
            try container.encode(String(to), forKey: Key("To"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decode(Double.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decode(Double.self, forKey: .to)
        to = toDecoded
    }
}

extension DoubleRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DoubleRange(from: \(String(describing: from)), to: \(String(describing: to)))"}
}

/// <p>A range of double values.</p>
public struct DoubleRange: Equatable {
    /// <p>The minimum value in the range.</p>
    public let from: Double
    /// <p>The maximum value in the range.</p>
    public let to: Double

    public init (
        from: Double = 0.0,
        to: Double = 0.0
    )
    {
        self.from = from
        self.to = to
    }
}

public struct DownloadDBLogFilePortionInputBodyMiddleware: Middleware {
    public let id: String = "DownloadDBLogFilePortionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DownloadDBLogFilePortionInput>,
                  next: H) -> Swift.Result<OperationOutput<DownloadDBLogFilePortionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DownloadDBLogFilePortionInput>
    public typealias MOutput = OperationOutput<DownloadDBLogFilePortionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DownloadDBLogFilePortionOutputError>
}

extension DownloadDBLogFilePortionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DownloadDBLogFilePortionInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), logFileName: \(String(describing: logFileName)), marker: \(String(describing: marker)), numberOfLines: \(String(describing: numberOfLines)))"}
}

extension DownloadDBLogFilePortionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let logFileName = logFileName {
            try container.encode(logFileName, forKey: Key("LogFileName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if numberOfLines != 0 {
            try container.encode(numberOfLines, forKey: Key("NumberOfLines"))
        }
        try container.encode("DownloadDBLogFilePortion", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DownloadDBLogFilePortionInputHeadersMiddleware: Middleware {
    public let id: String = "DownloadDBLogFilePortionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DownloadDBLogFilePortionInput>,
                  next: H) -> Swift.Result<OperationOutput<DownloadDBLogFilePortionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DownloadDBLogFilePortionInput>
    public typealias MOutput = OperationOutput<DownloadDBLogFilePortionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DownloadDBLogFilePortionOutputError>
}

public struct DownloadDBLogFilePortionInputQueryItemMiddleware: Middleware {
    public let id: String = "DownloadDBLogFilePortionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DownloadDBLogFilePortionInput>,
                  next: H) -> Swift.Result<OperationOutput<DownloadDBLogFilePortionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DownloadDBLogFilePortionInput>
    public typealias MOutput = OperationOutput<DownloadDBLogFilePortionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DownloadDBLogFilePortionOutputError>
}

/// <p></p>
public struct DownloadDBLogFilePortionInput: Equatable {
    /// <p>The customer-assigned name of the DB instance that contains the log files you want to list.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p>The name of the log file to be downloaded.</p>
    public let logFileName: String?
    /// <p>The pagination token provided in the previous request or "0". If the Marker parameter is specified the response includes only records beyond the marker until the end of the file or up to NumberOfLines.</p>
    public let marker: String?
    /// <p>The number of lines to download. If the number of lines specified results in a file over 1 MB in size, the file is truncated at 1 MB in size.</p>
    ///          <p>If the NumberOfLines parameter is specified, then the block of lines returned can be from the beginning
    ///             or the end of the log file, depending on the value of the Marker parameter.</p>
    ///             <ul>
    ///             <li>
    ///                <p>If neither Marker or NumberOfLines are specified, the entire log file is returned up to a
    ///               maximum of 10000 lines, starting with the most recent log entries first.</p>
    ///             </li>
    ///             <li>
    ///                <p>If
    ///               NumberOfLines is specified and Marker isn't specified, then the most recent lines from the end
    ///                     of the log file are returned.</p>
    ///             </li>
    ///             <li>
    ///                <p>If Marker is specified as "0", then the specified
    ///                       number of lines from the beginning of the log file are returned.</p>
    ///             </li>
    ///             <li>
    ///                <p>You can
    ///                         download the log file in blocks of lines by specifying the size of the block using
    ///                     the NumberOfLines parameter, and by specifying a value of "0" for the Marker parameter in your
    ///                     first request. Include the Marker value returned in the response as the Marker value for the next
    ///                     request, continuing until the AdditionalDataPending response element returns false.</p>
    ///             </li>
    ///          </ul>
    public let numberOfLines: Int

    public init (
        dBInstanceIdentifier: String? = nil,
        logFileName: String? = nil,
        marker: String? = nil,
        numberOfLines: Int = 0
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.logFileName = logFileName
        self.marker = marker
        self.numberOfLines = numberOfLines
    }
}

extension DownloadDBLogFilePortionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DownloadDBLogFilePortionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBLogFileNotFoundFault" : self = .dBLogFileNotFoundFault(try DBLogFileNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DownloadDBLogFilePortionOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBLogFileNotFoundFault(DBLogFileNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DownloadDBLogFilePortionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DownloadDBLogFilePortionOutputResponse(additionalDataPending: \(String(describing: additionalDataPending)), logFileData: \(String(describing: logFileData)), marker: \(String(describing: marker)))"}
}

extension DownloadDBLogFilePortionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DownloadDBLogFilePortionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.additionalDataPending = output.additionalDataPending
            self.logFileData = output.logFileData
            self.marker = output.marker
        } else {
            self.additionalDataPending = false
            self.logFileData = nil
            self.marker = nil
        }
    }
}

/// <p>This data type is used as a response element to <code>DownloadDBLogFilePortion</code>.</p>
public struct DownloadDBLogFilePortionOutputResponse: Equatable {
    /// <p>Boolean value that if true, indicates there is more data to be downloaded.</p>
    public let additionalDataPending: Bool
    /// <p>Entries from the specified log file.</p>
    public let logFileData: String?
    /// <p>A pagination token that can be used in a later DownloadDBLogFilePortion request.</p>
    public let marker: String?

    public init (
        additionalDataPending: Bool = false,
        logFileData: String? = nil,
        marker: String? = nil
    )
    {
        self.additionalDataPending = additionalDataPending
        self.logFileData = logFileData
        self.marker = marker
    }
}

struct DownloadDBLogFilePortionOutputResponseBody: Equatable {
    public let logFileData: String?
    public let marker: String?
    public let additionalDataPending: Bool
}

extension DownloadDBLogFilePortionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case additionalDataPending = "AdditionalDataPending"
        case logFileData = "LogFileData"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DownloadDBLogFilePortionResult"))
        let logFileDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logFileData)
        logFileData = logFileDataDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let additionalDataPendingDecoded = try containerValues.decode(Bool.self, forKey: .additionalDataPending)
        additionalDataPending = additionalDataPendingDecoded
    }
}

extension EC2SecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eC2SecurityGroupId = "EC2SecurityGroupId"
        case eC2SecurityGroupName = "EC2SecurityGroupName"
        case eC2SecurityGroupOwnerId = "EC2SecurityGroupOwnerId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let eC2SecurityGroupId = eC2SecurityGroupId {
            try container.encode(eC2SecurityGroupId, forKey: Key("EC2SecurityGroupId"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: Key("EC2SecurityGroupOwnerId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let eC2SecurityGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eC2SecurityGroupName)
        eC2SecurityGroupName = eC2SecurityGroupNameDecoded
        let eC2SecurityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eC2SecurityGroupId)
        eC2SecurityGroupId = eC2SecurityGroupIdDecoded
        let eC2SecurityGroupOwnerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eC2SecurityGroupOwnerId)
        eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerIdDecoded
    }
}

extension EC2SecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EC2SecurityGroup(eC2SecurityGroupId: \(String(describing: eC2SecurityGroupId)), eC2SecurityGroupName: \(String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(String(describing: eC2SecurityGroupOwnerId)), status: \(String(describing: status)))"}
}

/// <p>This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>AuthorizeDBSecurityGroupIngress</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBSecurityGroups</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>RevokeDBSecurityGroupIngress</code>
///                </p>
///             </li>
///          </ul>
public struct EC2SecurityGroup: Equatable {
    /// <p>Specifies the id of the EC2 security group.</p>
    public let eC2SecurityGroupId: String?
    /// <p>Specifies the name of the EC2 security group.</p>
    public let eC2SecurityGroupName: String?
    /// <p>
    ///         Specifies the AWS ID of the owner of the EC2 security group
    ///         specified in the <code>EC2SecurityGroupName</code> field.
    ///         </p>
    public let eC2SecurityGroupOwnerId: String?
    /// <p>Provides the status of the EC2 security group. Status can be "authorizing", "authorized", "revoking", and "revoked".</p>
    public let status: String?

    public init (
        eC2SecurityGroupId: String? = nil,
        eC2SecurityGroupName: String? = nil,
        eC2SecurityGroupOwnerId: String? = nil,
        status: String? = nil
    )
    {
        self.eC2SecurityGroupId = eC2SecurityGroupId
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
        self.status = status
    }
}

extension Endpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case hostedZoneId = "HostedZoneId"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let address = address {
            try container.encode(address, forKey: Key("Address"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: Key("HostedZoneId"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension Endpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Endpoint(address: \(String(describing: address)), hostedZoneId: \(String(describing: hostedZoneId)), port: \(String(describing: port)))"}
}

/// <p>This data type represents the information you need to connect to an Amazon RDS DB instance.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBInstance</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBInstances</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBInstance</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon Aurora DB cluster endpoints,
///         see <code>DBClusterEndpoint</code>.</p>
public struct Endpoint: Equatable {
    /// <p>Specifies the DNS address of the DB instance.</p>
    public let address: String?
    /// <p>Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.</p>
    public let hostedZoneId: String?
    /// <p>Specifies the port that the database engine is listening on.</p>
    public let port: Int

    public init (
        address: String? = nil,
        hostedZoneId: String? = nil,
        port: Int = 0
    )
    {
        self.address = address
        self.hostedZoneId = hostedZoneId
        self.port = port
    }
}

extension EngineDefaults: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
    }
}

extension EngineDefaults: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EngineDefaults(dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), marker: \(String(describing: marker)), parameters: \(String(describing: parameters)))"}
}

/// <p>
///             Contains the result of a successful invocation of the <code>DescribeEngineDefaultParameters</code> action.
///         </p>
public struct EngineDefaults: Equatable {
    /// <p>Specifies the name of the DB parameter group family that the engine default parameters apply to.</p>
    public let dBParameterGroupFamily: String?
    /// <p>
    ///             An optional pagination token provided by a previous
    ///             EngineDefaults request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by <code>MaxRecords</code> .
    ///         </p>
    public let marker: String?
    /// <p>Contains a list of engine default parameters.</p>
    public let parameters: [Parameter]?

    public init (
        dBParameterGroupFamily: String? = nil,
        marker: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.marker = marker
        self.parameters = parameters
    }
}

public enum EngineFamily {
    case mysql
    case postgresql
    case sdkUnknown(String)
}

extension EngineFamily : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EngineFamily] {
        return [
            .mysql,
            .postgresql,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .mysql: return "MYSQL"
        case .postgresql: return "POSTGRESQL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EngineFamily(rawValue: rawValue) ?? EngineFamily.sdkUnknown(rawValue)
    }
}

extension Event: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case date = "Date"
        case eventCategories = "EventCategories"
        case message = "Message"
        case sourceArn = "SourceArn"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let date = date {
            try container.encode(TimestampWrapper(date, format: .dateTime), forKey: Key("date"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: Key("SourceArn"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var eventCategoriesBuffer:[String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        let dateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .date)
        var dateBuffer:Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
    }
}

extension Event: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Event(date: \(String(describing: date)), eventCategories: \(String(describing: eventCategories)), message: \(String(describing: message)), sourceArn: \(String(describing: sourceArn)), sourceIdentifier: \(String(describing: sourceIdentifier)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>
///         This data type is used as a response element in the <code>DescribeEvents</code> action.
///         </p>
public struct Event: Equatable {
    /// <p>Specifies the date and time of the event.</p>
    public let date: Date?
    /// <p>Specifies the category for the event.</p>
    public let eventCategories: [String]?
    /// <p>Provides the text of this event.</p>
    public let message: String?
    /// <p>The Amazon Resource Name (ARN) for the event.</p>
    public let sourceArn: String?
    /// <p>Provides the identifier for the source of the event.</p>
    public let sourceIdentifier: String?
    /// <p>Specifies the source type for this event.</p>
    public let sourceType: SourceType?

    public init (
        date: Date? = nil,
        eventCategories: [String]? = nil,
        message: String? = nil,
        sourceArn: String? = nil,
        sourceIdentifier: String? = nil,
        sourceType: SourceType? = nil
    )
    {
        self.date = date
        self.eventCategories = eventCategories
        self.message = message
        self.sourceArn = sourceArn
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
    }
}

extension EventCategoriesMap: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventCategories = "EventCategories"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var eventCategoriesBuffer:[String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
    }
}

extension EventCategoriesMap: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventCategoriesMap(eventCategories: \(String(describing: eventCategories)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>Contains the results of a successful invocation of the <code>DescribeEventCategories</code> operation.</p>
public struct EventCategoriesMap: Equatable {
    /// <p>The event categories for the specified source type</p>
    public let eventCategories: [String]?
    /// <p>The source type that the returned categories belong to</p>
    public let sourceType: String?

    public init (
        eventCategories: [String]? = nil,
        sourceType: String? = nil
    )
    {
        self.eventCategories = eventCategories
        self.sourceType = sourceType
    }
}

extension EventSubscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case eventSubscriptionArn = "EventSubscriptionArn"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let custSubscriptionId = custSubscriptionId {
            try container.encode(custSubscriptionId, forKey: Key("CustSubscriptionId"))
        }
        if let customerAwsId = customerAwsId {
            try container.encode(customerAwsId, forKey: Key("CustomerAwsId"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategoriesList"))
            for (index0, string0) in eventCategoriesList.enumerated() {
                try eventCategoriesListContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let eventSubscriptionArn = eventSubscriptionArn {
            try container.encode(eventSubscriptionArn, forKey: Key("EventSubscriptionArn"))
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: Key("SnsTopicArn"))
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SourceIdsList"))
            for (index0, string0) in sourceIdsList.enumerated() {
                try sourceIdsListContainer.encode(string0, forKey: Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let subscriptionCreationTime = subscriptionCreationTime {
            try container.encode(subscriptionCreationTime, forKey: Key("SubscriptionCreationTime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionCreationTime)
        subscriptionCreationTime = subscriptionCreationTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.sourceIdsList) {
            struct KeyVal0{struct SourceId{}}
            let sourceIdsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SourceId>.CodingKeys.self, forKey: .sourceIdsList)
            if let sourceIdsListWrappedContainer = sourceIdsListWrappedContainer {
                let sourceIdsListContainer = try sourceIdsListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var sourceIdsListBuffer:[String]? = nil
                if let sourceIdsListContainer = sourceIdsListContainer {
                    sourceIdsListBuffer = [String]()
                    for stringContainer0 in sourceIdsListContainer {
                        sourceIdsListBuffer?.append(stringContainer0)
                    }
                }
                sourceIdsList = sourceIdsListBuffer
            } else {
                sourceIdsList = []
            }
        } else {
            sourceIdsList = nil
        }
        if containerValues.contains(.eventCategoriesList) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategoriesList)
            if let eventCategoriesListWrappedContainer = eventCategoriesListWrappedContainer {
                let eventCategoriesListContainer = try eventCategoriesListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var eventCategoriesListBuffer:[String]? = nil
                if let eventCategoriesListContainer = eventCategoriesListContainer {
                    eventCategoriesListBuffer = [String]()
                    for stringContainer0 in eventCategoriesListContainer {
                        eventCategoriesListBuffer?.append(stringContainer0)
                    }
                }
                eventCategoriesList = eventCategoriesListBuffer
            } else {
                eventCategoriesList = []
            }
        } else {
            eventCategoriesList = nil
        }
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let eventSubscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSubscriptionArn)
        eventSubscriptionArn = eventSubscriptionArnDecoded
    }
}

extension EventSubscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSubscription(custSubscriptionId: \(String(describing: custSubscriptionId)), customerAwsId: \(String(describing: customerAwsId)), enabled: \(String(describing: enabled)), eventCategoriesList: \(String(describing: eventCategoriesList)), eventSubscriptionArn: \(String(describing: eventSubscriptionArn)), snsTopicArn: \(String(describing: snsTopicArn)), sourceIdsList: \(String(describing: sourceIdsList)), sourceType: \(String(describing: sourceType)), status: \(String(describing: status)), subscriptionCreationTime: \(String(describing: subscriptionCreationTime)))"}
}

/// <p>Contains the results of a successful invocation of the <code>DescribeEventSubscriptions</code> action.</p>
public struct EventSubscription: Equatable {
    /// <p>The RDS event notification subscription Id.</p>
    public let custSubscriptionId: String?
    /// <p>The AWS customer account associated with the RDS event notification subscription.</p>
    public let customerAwsId: String?
    /// <p>A Boolean value indicating if the subscription is enabled. True indicates the subscription is enabled.</p>
    public let enabled: Bool
    /// <p>A list of event categories for the RDS event notification subscription.</p>
    public let eventCategoriesList: [String]?
    /// <p>The Amazon Resource Name (ARN) for the event subscription.</p>
    public let eventSubscriptionArn: String?
    /// <p>The topic ARN of the RDS event notification subscription.</p>
    public let snsTopicArn: String?
    /// <p>A list of source IDs for the RDS event notification subscription.</p>
    public let sourceIdsList: [String]?
    /// <p>The source type for the RDS event notification subscription.</p>
    public let sourceType: String?
    /// <p>The status of the RDS event notification subscription.</p>
    ///          <p>Constraints:</p>
    ///          <p>Can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist</p>
    ///          <p>The status "no-permission" indicates that RDS no longer has permission to post to the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the subscription was created.</p>
    public let status: String?
    /// <p>The time the RDS event notification subscription was created.</p>
    public let subscriptionCreationTime: String?

    public init (
        custSubscriptionId: String? = nil,
        customerAwsId: String? = nil,
        enabled: Bool = false,
        eventCategoriesList: [String]? = nil,
        eventSubscriptionArn: String? = nil,
        snsTopicArn: String? = nil,
        sourceIdsList: [String]? = nil,
        sourceType: String? = nil,
        status: String? = nil,
        subscriptionCreationTime: String? = nil
    )
    {
        self.custSubscriptionId = custSubscriptionId
        self.customerAwsId = customerAwsId
        self.enabled = enabled
        self.eventCategoriesList = eventCategoriesList
        self.eventSubscriptionArn = eventSubscriptionArn
        self.snsTopicArn = snsTopicArn
        self.sourceIdsList = sourceIdsList
        self.sourceType = sourceType
        self.status = status
        self.subscriptionCreationTime = subscriptionCreationTime
    }
}

extension EventSubscriptionQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSubscriptionQuotaExceededFault(message: \(String(describing: message)))"}
}

extension EventSubscriptionQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EventSubscriptionQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of event subscriptions.</p>
public struct EventSubscriptionQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EventSubscriptionQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension EventSubscriptionQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExportTask: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportOnly = "ExportOnly"
        case exportTaskIdentifier = "ExportTaskIdentifier"
        case failureCause = "FailureCause"
        case iamRoleArn = "IamRoleArn"
        case kmsKeyId = "KmsKeyId"
        case percentProgress = "PercentProgress"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case snapshotTime = "SnapshotTime"
        case sourceArn = "SourceArn"
        case status = "Status"
        case taskEndTime = "TaskEndTime"
        case taskStartTime = "TaskStartTime"
        case totalExtractedDataInGB = "TotalExtractedDataInGB"
        case warningMessage = "WarningMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let exportOnly = exportOnly {
            var exportOnlyContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExportOnly"))
            for (index0, string0) in exportOnly.enumerated() {
                try exportOnlyContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: Key("ExportTaskIdentifier"))
        }
        if let failureCause = failureCause {
            try container.encode(failureCause, forKey: Key("FailureCause"))
        }
        if let iamRoleArn = iamRoleArn {
            try container.encode(iamRoleArn, forKey: Key("IamRoleArn"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if percentProgress != 0 {
            try container.encode(percentProgress, forKey: Key("PercentProgress"))
        }
        if let s3Bucket = s3Bucket {
            try container.encode(s3Bucket, forKey: Key("S3Bucket"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: Key("S3Prefix"))
        }
        if let snapshotTime = snapshotTime {
            try container.encode(TimestampWrapper(snapshotTime, format: .dateTime), forKey: Key("snapshotTime"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: Key("SourceArn"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let taskEndTime = taskEndTime {
            try container.encode(TimestampWrapper(taskEndTime, format: .dateTime), forKey: Key("taskEndTime"))
        }
        if let taskStartTime = taskStartTime {
            try container.encode(TimestampWrapper(taskStartTime, format: .dateTime), forKey: Key("taskStartTime"))
        }
        if totalExtractedDataInGB != 0 {
            try container.encode(totalExtractedDataInGB, forKey: Key("TotalExtractedDataInGB"))
        }
        if let warningMessage = warningMessage {
            try container.encode(warningMessage, forKey: Key("WarningMessage"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        if containerValues.contains(.exportOnly) {
            struct KeyVal0{struct member{}}
            let exportOnlyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportOnly)
            if let exportOnlyWrappedContainer = exportOnlyWrappedContainer {
                let exportOnlyContainer = try exportOnlyWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var exportOnlyBuffer:[String]? = nil
                if let exportOnlyContainer = exportOnlyContainer {
                    exportOnlyBuffer = [String]()
                    for stringContainer0 in exportOnlyContainer {
                        exportOnlyBuffer?.append(stringContainer0)
                    }
                }
                exportOnly = exportOnlyBuffer
            } else {
                exportOnly = []
            }
        } else {
            exportOnly = nil
        }
        let snapshotTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotTime)
        var snapshotTimeBuffer:Date? = nil
        if let snapshotTimeDecoded = snapshotTimeDecoded {
            snapshotTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(snapshotTimeDecoded, format: .dateTime)
        }
        snapshotTime = snapshotTimeBuffer
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskStartTime)
        var taskStartTimeBuffer:Date? = nil
        if let taskStartTimeDecoded = taskStartTimeDecoded {
            taskStartTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(taskStartTimeDecoded, format: .dateTime)
        }
        taskStartTime = taskStartTimeBuffer
        let taskEndTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskEndTime)
        var taskEndTimeBuffer:Date? = nil
        if let taskEndTimeDecoded = taskEndTimeDecoded {
            taskEndTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(taskEndTimeDecoded, format: .dateTime)
        }
        taskEndTime = taskEndTimeBuffer
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decode(Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let totalExtractedDataInGBDecoded = try containerValues.decode(Int.self, forKey: .totalExtractedDataInGB)
        totalExtractedDataInGB = totalExtractedDataInGBDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
        let warningMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .warningMessage)
        warningMessage = warningMessageDecoded
    }
}

extension ExportTask: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportTask(exportOnly: \(String(describing: exportOnly)), exportTaskIdentifier: \(String(describing: exportTaskIdentifier)), failureCause: \(String(describing: failureCause)), iamRoleArn: \(String(describing: iamRoleArn)), kmsKeyId: \(String(describing: kmsKeyId)), percentProgress: \(String(describing: percentProgress)), s3Bucket: \(String(describing: s3Bucket)), s3Prefix: \(String(describing: s3Prefix)), snapshotTime: \(String(describing: snapshotTime)), sourceArn: \(String(describing: sourceArn)), status: \(String(describing: status)), taskEndTime: \(String(describing: taskEndTime)), taskStartTime: \(String(describing: taskStartTime)), totalExtractedDataInGB: \(String(describing: totalExtractedDataInGB)), warningMessage: \(String(describing: warningMessage)))"}
}

/// <p>Contains the details of a snapshot export to Amazon S3.
///         </p>
///         <p>This data type is used as a response element in the <code>DescribeExportTasks</code> action.
///         </p>
public struct ExportTask: Equatable {
    /// <p>The data exported from the snapshot. Valid values are the following:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>database</code> - Export all the data from a specified database.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.table</code>
    ///                   <i>table-name</i> -
    ///                 Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.schema</code>
    ///                   <i>schema-name</i> - Export a database schema of the snapshot.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.schema.table</code>
    ///                   <i>table-name</i> - Export a table of the database schema.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p>
    ///             </li>
    ///          </ul>
    public let exportOnly: [String]?
    /// <p>A unique identifier for the snapshot export task. This ID isn't an identifier for
    ///             the Amazon S3 bucket where the snapshot is exported to. </p>
    public let exportTaskIdentifier: String?
    /// <p>The reason the export failed, if it failed.</p>
    public let failureCause: String?
    /// <p>The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot. </p>
    public let iamRoleArn: String?
    /// <p>The key identifier of the AWS KMS customer master key (CMK) that is used to encrypt the snapshot when it's exported to
    ///             Amazon S3. The AWS KMS CMK identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the snapshot export
    ///             must have encryption and decryption permissions to use this AWS KMS CMK. </p>
    public let kmsKeyId: String?
    /// <p>The progress of the snapshot export task as a percentage.</p>
    public let percentProgress: Int
    /// <p>The Amazon S3 bucket that the snapshot is exported to.</p>
    public let s3Bucket: String?
    /// <p>The Amazon S3 bucket prefix that is the file name and path of the exported snapshot.</p>
    public let s3Prefix: String?
    /// <p>The time that the snapshot was created.</p>
    public let snapshotTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.</p>
    public let sourceArn: String?
    /// <p>The progress status of the export task.</p>
    public let status: String?
    /// <p>The time that the snapshot export task completed.</p>
    public let taskEndTime: Date?
    /// <p>The time that the snapshot export task started.</p>
    public let taskStartTime: Date?
    /// <p>The total amount of data exported, in gigabytes.</p>
    public let totalExtractedDataInGB: Int
    /// <p>A warning about the snapshot export task.</p>
    public let warningMessage: String?

    public init (
        exportOnly: [String]? = nil,
        exportTaskIdentifier: String? = nil,
        failureCause: String? = nil,
        iamRoleArn: String? = nil,
        kmsKeyId: String? = nil,
        percentProgress: Int = 0,
        s3Bucket: String? = nil,
        s3Prefix: String? = nil,
        snapshotTime: Date? = nil,
        sourceArn: String? = nil,
        status: String? = nil,
        taskEndTime: Date? = nil,
        taskStartTime: Date? = nil,
        totalExtractedDataInGB: Int = 0,
        warningMessage: String? = nil
    )
    {
        self.exportOnly = exportOnly
        self.exportTaskIdentifier = exportTaskIdentifier
        self.failureCause = failureCause
        self.iamRoleArn = iamRoleArn
        self.kmsKeyId = kmsKeyId
        self.percentProgress = percentProgress
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
        self.snapshotTime = snapshotTime
        self.sourceArn = sourceArn
        self.status = status
        self.taskEndTime = taskEndTime
        self.taskStartTime = taskStartTime
        self.totalExtractedDataInGB = totalExtractedDataInGB
        self.warningMessage = warningMessage
    }
}

extension ExportTaskAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportTaskAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension ExportTaskAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ExportTaskAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't start an export task that's already running.</p>
public struct ExportTaskAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExportTaskAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension ExportTaskAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExportTaskNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportTaskNotFoundFault(message: \(String(describing: message)))"}
}

extension ExportTaskNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ExportTaskNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The export task doesn't exist.</p>
public struct ExportTaskNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExportTaskNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ExportTaskNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct FailoverDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "FailoverDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FailoverDBClusterOutputError>
}

extension FailoverDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailoverDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), targetDBInstanceIdentifier: \(String(describing: targetDBInstanceIdentifier)))"}
}

extension FailoverDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let targetDBInstanceIdentifier = targetDBInstanceIdentifier {
            try container.encode(targetDBInstanceIdentifier, forKey: Key("TargetDBInstanceIdentifier"))
        }
        try container.encode("FailoverDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct FailoverDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "FailoverDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FailoverDBClusterOutputError>
}

public struct FailoverDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "FailoverDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FailoverDBClusterOutputError>
}

/// <p></p>
public struct FailoverDBClusterInput: Equatable {
    /// <p>A DB cluster identifier to force a failover for. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>The name of the instance to promote to the primary instance.</p>
    ///         <p>You must specify the instance identifier for an Aurora Replica in the DB cluster.
    ///         For example, <code>mydbcluster-replica1</code>.</p>
    public let targetDBInstanceIdentifier: String?

    public init (
        dBClusterIdentifier: String? = nil,
        targetDBInstanceIdentifier: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.targetDBInstanceIdentifier = targetDBInstanceIdentifier
    }
}

extension FailoverDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension FailoverDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FailoverDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension FailoverDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailoverDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension FailoverDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FailoverDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct FailoverDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Aurora DB cluster.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusters</code>,
    ///         <code>StopDBCluster</code>, and <code>StartDBCluster</code> actions.
    ///       </p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct FailoverDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension FailoverDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("FailoverDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct FailoverGlobalClusterInputBodyMiddleware: Middleware {
    public let id: String = "FailoverGlobalClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FailoverGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<FailoverGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FailoverGlobalClusterInput>
    public typealias MOutput = OperationOutput<FailoverGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FailoverGlobalClusterOutputError>
}

extension FailoverGlobalClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailoverGlobalClusterInput(globalClusterIdentifier: \(String(describing: globalClusterIdentifier)), targetDbClusterIdentifier: \(String(describing: targetDbClusterIdentifier)))"}
}

extension FailoverGlobalClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: Key("GlobalClusterIdentifier"))
        }
        if let targetDbClusterIdentifier = targetDbClusterIdentifier {
            try container.encode(targetDbClusterIdentifier, forKey: Key("TargetDbClusterIdentifier"))
        }
        try container.encode("FailoverGlobalCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct FailoverGlobalClusterInputHeadersMiddleware: Middleware {
    public let id: String = "FailoverGlobalClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FailoverGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<FailoverGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FailoverGlobalClusterInput>
    public typealias MOutput = OperationOutput<FailoverGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FailoverGlobalClusterOutputError>
}

public struct FailoverGlobalClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "FailoverGlobalClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FailoverGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<FailoverGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FailoverGlobalClusterInput>
    public typealias MOutput = OperationOutput<FailoverGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FailoverGlobalClusterOutputError>
}

public struct FailoverGlobalClusterInput: Equatable {
    /// <p>Identifier of the Aurora global database (<a>GlobalCluster</a>)
    ///     that should be failed over. The identifier is the unique key assigned by
    ///     the user when the Aurora global database was created. In other words,
    ///     it's the name of the Aurora global database that you want to fail over. </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing
    ///       <a>GlobalCluster</a> (Aurora global database).</p>
    ///             </li>
    ///          </ul>
    public let globalClusterIdentifier: String?
    /// <p>Identifier of the secondary Aurora DB cluster that you want to promote to primary for the Aurora
    ///        global database (<a>GlobalCluster</a>.) Use the Amazon Resource Name (ARN) for the identifier so that
    ///        Aurora can locate the cluster in its AWS Region.
    ///  </p>
    public let targetDbClusterIdentifier: String?

    public init (
        globalClusterIdentifier: String? = nil,
        targetDbClusterIdentifier: String? = nil
    )
    {
        self.globalClusterIdentifier = globalClusterIdentifier
        self.targetDbClusterIdentifier = targetDbClusterIdentifier
    }
}

extension FailoverGlobalClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension FailoverGlobalClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FailoverGlobalClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension FailoverGlobalClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailoverGlobalClusterOutputResponse(globalCluster: \(String(describing: globalCluster)))"}
}

extension FailoverGlobalClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FailoverGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct FailoverGlobalClusterOutputResponse: Equatable {
    /// <p>A data type representing an Aurora global database.</p>
    public let globalCluster: GlobalCluster?

    public init (
        globalCluster: GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct FailoverGlobalClusterOutputResponseBody: Equatable {
    public let globalCluster: GlobalCluster?
}

extension FailoverGlobalClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("FailoverGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

extension FailoverState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromDbClusterArn = "FromDbClusterArn"
        case status = "Status"
        case toDbClusterArn = "ToDbClusterArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let fromDbClusterArn = fromDbClusterArn {
            try container.encode(fromDbClusterArn, forKey: Key("FromDbClusterArn"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let toDbClusterArn = toDbClusterArn {
            try container.encode(toDbClusterArn, forKey: Key("ToDbClusterArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(FailoverStatus.self, forKey: .status)
        status = statusDecoded
        let fromDbClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromDbClusterArn)
        fromDbClusterArn = fromDbClusterArnDecoded
        let toDbClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .toDbClusterArn)
        toDbClusterArn = toDbClusterArnDecoded
    }
}

extension FailoverState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailoverState(fromDbClusterArn: \(String(describing: fromDbClusterArn)), status: \(String(describing: status)), toDbClusterArn: \(String(describing: toDbClusterArn)))"}
}

/// <p>Contains the state of scheduled or in-process failover operations on an
///       Aurora global database (<a>GlobalCluster</a>). This Data type is empty unless a failover
///       operation is scheduled or is currently underway on the Aurora global database. </p>
public struct FailoverState: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Aurora DB cluster that is currently being demoted, and which is associated with this
    ///        state. </p>
    public let fromDbClusterArn: String?
    /// <p>The current status of the Aurora global database (<a>GlobalCluster</a>). Possible values are as follows:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>pending  A request to fail over the Aurora global database (<a>GlobalCluster</a>) has been received by the service. The
    ///         <code>GlobalCluster</code>'s primary DB cluster and the specified secondary DB cluster are being verified before the failover
    ///         process can start.</p>
    ///             </li>
    ///             <li>
    ///                <p>failing-over  This status covers the range of Aurora internal operations that take place during the failover process, such
    ///         as demoting the primary Aurora DB cluster, promoting the secondary Aurora DB, and synchronizing replicas. </p>
    ///             </li>
    ///             <li>
    ///                <p>cancelling  The request to fail over the Aurora global database (<a>GlobalCluster</a>) was cancelled and the primary
    ///         Aurora DB cluster and the selected secondary Aurora DB cluster are returning to their previous states.
    ///       </p>
    ///             </li>
    ///          </ul>
    public let status: FailoverStatus?
    /// <p>The Amazon Resource Name (ARN) of the Aurora DB cluster that is currently being promoted, and which is associated
    ///      with this state.</p>
    public let toDbClusterArn: String?

    public init (
        fromDbClusterArn: String? = nil,
        status: FailoverStatus? = nil,
        toDbClusterArn: String? = nil
    )
    {
        self.fromDbClusterArn = fromDbClusterArn
        self.status = status
        self.toDbClusterArn = toDbClusterArn
    }
}

public enum FailoverStatus {
    case cancelling
    case failingOver
    case pending
    case sdkUnknown(String)
}

extension FailoverStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FailoverStatus] {
        return [
            .cancelling,
            .failingOver,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelling: return "cancelling"
        case .failingOver: return "failing-over"
        case .pending: return "pending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FailoverStatus(rawValue: rawValue) ?? FailoverStatus.sdkUnknown(rawValue)
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, string0) in values.enumerated() {
                try valuesContainer.encode(string0, forKey: Key("Value.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct Value{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Value>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A filter name and value pair that is used to return a more specific list of results
///             from a describe operation. Filters can be used to match a set of resources by specific
///             criteria, such as IDs. The filters supported by a describe operation are documented
///             with the describe operation.</p>
///         <note>
///             <p>Currently, wildcards are not supported in filters.</p>
///         </note>
///         <p>The following actions can be filtered:</p>
///         <ul>
///             <li>
///                <p>
///                   <code>DescribeDBClusterBacktracks</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusters</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBInstances</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribePendingMaintenanceActions</code>
///                </p>
///             </li>
///          </ul>
public struct Filter: Equatable {
    /// <p>The name of the filter. Filter names are case-sensitive.</p>
    public let name: String?
    /// <p>One or more filter values. Filter values are case-sensitive.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension GlobalCluster: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case deletionProtection = "DeletionProtection"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case failoverState = "FailoverState"
        case globalClusterArn = "GlobalClusterArn"
        case globalClusterIdentifier = "GlobalClusterIdentifier"
        case globalClusterMembers = "GlobalClusterMembers"
        case globalClusterResourceId = "GlobalClusterResourceId"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let failoverState = failoverState {
            try container.encode(failoverState, forKey: Key("FailoverState"))
        }
        if let globalClusterArn = globalClusterArn {
            try container.encode(globalClusterArn, forKey: Key("GlobalClusterArn"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: Key("GlobalClusterIdentifier"))
        }
        if let globalClusterMembers = globalClusterMembers {
            var globalClusterMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("GlobalClusterMembers"))
            for (index0, globalclustermember0) in globalClusterMembers.enumerated() {
                try globalClusterMembersContainer.encode(globalclustermember0, forKey: Key("GlobalClusterMember.\(index0.advanced(by: 1))"))
            }
        }
        if let globalClusterResourceId = globalClusterResourceId {
            try container.encode(globalClusterResourceId, forKey: Key("GlobalClusterResourceId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalClusterIdentifier)
        globalClusterIdentifier = globalClusterIdentifierDecoded
        let globalClusterResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalClusterResourceId)
        globalClusterResourceId = globalClusterResourceIdDecoded
        let globalClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalClusterArn)
        globalClusterArn = globalClusterArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        if containerValues.contains(.globalClusterMembers) {
            struct KeyVal0{struct GlobalClusterMember{}}
            let globalClusterMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.GlobalClusterMember>.CodingKeys.self, forKey: .globalClusterMembers)
            if let globalClusterMembersWrappedContainer = globalClusterMembersWrappedContainer {
                let globalClusterMembersContainer = try globalClusterMembersWrappedContainer.decodeIfPresent([GlobalClusterMember].self, forKey: .member)
                var globalClusterMembersBuffer:[GlobalClusterMember]? = nil
                if let globalClusterMembersContainer = globalClusterMembersContainer {
                    globalClusterMembersBuffer = [GlobalClusterMember]()
                    for structureContainer0 in globalClusterMembersContainer {
                        globalClusterMembersBuffer?.append(structureContainer0)
                    }
                }
                globalClusterMembers = globalClusterMembersBuffer
            } else {
                globalClusterMembers = []
            }
        } else {
            globalClusterMembers = nil
        }
        let failoverStateDecoded = try containerValues.decodeIfPresent(FailoverState.self, forKey: .failoverState)
        failoverState = failoverStateDecoded
    }
}

extension GlobalCluster: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlobalCluster(databaseName: \(String(describing: databaseName)), deletionProtection: \(String(describing: deletionProtection)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), failoverState: \(String(describing: failoverState)), globalClusterArn: \(String(describing: globalClusterArn)), globalClusterIdentifier: \(String(describing: globalClusterIdentifier)), globalClusterMembers: \(String(describing: globalClusterMembers)), globalClusterResourceId: \(String(describing: globalClusterResourceId)), status: \(String(describing: status)), storageEncrypted: \(String(describing: storageEncrypted)))"}
}

/// <p>A data type representing an Aurora global database.</p>
public struct GlobalCluster: Equatable {
    /// <p>
    ///         The default database name within the new global database cluster.
    ///       </p>
    public let databaseName: String?
    /// <p>
    ///         The deletion protection setting for the new global database cluster.
    ///       </p>
    public let deletionProtection: Bool?
    /// <p>
    ///         The Aurora database engine used by the global database cluster.
    ///       </p>
    public let engine: String?
    /// <p>Indicates the database engine version.</p>
    public let engineVersion: String?
    /// <p>A data object containing all properties for the current state of an in-process or pending failover process for this Aurora global database.
    ///       This object is empty unless the <a>FailoverGlobalCluster</a> API operation has been called on this Aurora global database (<a>GlobalCluster</a>).
    ///     </p>
    public let failoverState: FailoverState?
    /// <p>The Amazon Resource Name (ARN) for the global database cluster.</p>
    public let globalClusterArn: String?
    /// <p>
    ///         Contains a user-supplied global database cluster identifier. This identifier is the unique key that
    ///         identifies a global database cluster.
    ///       </p>
    public let globalClusterIdentifier: String?
    /// <p>
    ///         The list of cluster IDs for secondary clusters within the global database cluster. Currently limited to
    ///         1 item.
    ///       </p>
    public let globalClusterMembers: [GlobalClusterMember]?
    /// <p>
    ///         The AWS Region-unique, immutable identifier for the global database cluster. This identifier is found in
    ///         AWS CloudTrail log entries whenever the AWS KMS customer master key (CMK) for the DB cluster is accessed.
    ///       </p>
    public let globalClusterResourceId: String?
    /// <p>Specifies the current state of this global database cluster.</p>
    public let status: String?
    /// <p>
    ///         The storage encryption setting for the global database cluster.
    ///       </p>
    public let storageEncrypted: Bool?

    public init (
        databaseName: String? = nil,
        deletionProtection: Bool? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        failoverState: FailoverState? = nil,
        globalClusterArn: String? = nil,
        globalClusterIdentifier: String? = nil,
        globalClusterMembers: [GlobalClusterMember]? = nil,
        globalClusterResourceId: String? = nil,
        status: String? = nil,
        storageEncrypted: Bool? = nil
    )
    {
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.engine = engine
        self.engineVersion = engineVersion
        self.failoverState = failoverState
        self.globalClusterArn = globalClusterArn
        self.globalClusterIdentifier = globalClusterIdentifier
        self.globalClusterMembers = globalClusterMembers
        self.globalClusterResourceId = globalClusterResourceId
        self.status = status
        self.storageEncrypted = storageEncrypted
    }
}

extension GlobalClusterAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlobalClusterAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension GlobalClusterAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<GlobalClusterAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>GlobalClusterIdentifier</code> already exists. Choose a new global database identifier (unique name) to create a new global database cluster.</p>
public struct GlobalClusterAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct GlobalClusterAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension GlobalClusterAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalClusterMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBClusterArn = "DBClusterArn"
        case globalWriteForwardingStatus = "GlobalWriteForwardingStatus"
        case isWriter = "IsWriter"
        case readers = "Readers"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterArn = dBClusterArn {
            try container.encode(dBClusterArn, forKey: Key("DBClusterArn"))
        }
        if let globalWriteForwardingStatus = globalWriteForwardingStatus {
            try container.encode(globalWriteForwardingStatus, forKey: Key("GlobalWriteForwardingStatus"))
        }
        if isWriter != false {
            try container.encode(isWriter, forKey: Key("IsWriter"))
        }
        if let readers = readers {
            var readersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Readers"))
            for (index0, string0) in readers.enumerated() {
                try readersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterArn)
        dBClusterArn = dBClusterArnDecoded
        if containerValues.contains(.readers) {
            struct KeyVal0{struct member{}}
            let readersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .readers)
            if let readersWrappedContainer = readersWrappedContainer {
                let readersContainer = try readersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var readersBuffer:[String]? = nil
                if let readersContainer = readersContainer {
                    readersBuffer = [String]()
                    for stringContainer0 in readersContainer {
                        readersBuffer?.append(stringContainer0)
                    }
                }
                readers = readersBuffer
            } else {
                readers = []
            }
        } else {
            readers = nil
        }
        let isWriterDecoded = try containerValues.decode(Bool.self, forKey: .isWriter)
        isWriter = isWriterDecoded
        let globalWriteForwardingStatusDecoded = try containerValues.decodeIfPresent(WriteForwardingStatus.self, forKey: .globalWriteForwardingStatus)
        globalWriteForwardingStatus = globalWriteForwardingStatusDecoded
    }
}

extension GlobalClusterMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlobalClusterMember(dBClusterArn: \(String(describing: dBClusterArn)), globalWriteForwardingStatus: \(String(describing: globalWriteForwardingStatus)), isWriter: \(String(describing: isWriter)), readers: \(String(describing: readers)))"}
}

/// <p>
///         A data structure with information about any primary and
///         secondary clusters associated with an Aurora global database.
///       </p>
public struct GlobalClusterMember: Equatable {
    /// <p>
    ///        The Amazon Resource Name (ARN) for each Aurora cluster.
    ///       </p>
    public let dBClusterArn: String?
    /// <p>Specifies whether a secondary cluster in an Aurora global database has
    ///         write forwarding enabled, not enabled, or is in the process of enabling it.</p>
    public let globalWriteForwardingStatus: WriteForwardingStatus?
    /// <p>
    ///         Specifies whether the Aurora cluster is the primary cluster
    ///         (that is, has read-write capability) for the Aurora global
    ///         database with which it is associated.
    ///       </p>
    public let isWriter: Bool
    /// <p>
    ///         The Amazon Resource Name (ARN) for each read-only secondary cluster
    ///         associated with the Aurora global database.
    ///       </p>
    public let readers: [String]?

    public init (
        dBClusterArn: String? = nil,
        globalWriteForwardingStatus: WriteForwardingStatus? = nil,
        isWriter: Bool = false,
        readers: [String]? = nil
    )
    {
        self.dBClusterArn = dBClusterArn
        self.globalWriteForwardingStatus = globalWriteForwardingStatus
        self.isWriter = isWriter
        self.readers = readers
    }
}

extension GlobalClusterNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlobalClusterNotFoundFault(message: \(String(describing: message)))"}
}

extension GlobalClusterNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<GlobalClusterNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>GlobalClusterIdentifier</code> doesn't refer to an existing global database cluster. </p>
public struct GlobalClusterNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct GlobalClusterNotFoundFaultBody: Equatable {
    public let message: String?
}

extension GlobalClusterNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalClusterQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlobalClusterQuotaExceededFault(message: \(String(describing: message)))"}
}

extension GlobalClusterQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<GlobalClusterQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of global database clusters for this account is already at the maximum allowed.</p>
public struct GlobalClusterQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct GlobalClusterQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension GlobalClusterQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum IAMAuthMode {
    case disabled
    case `required`
    case sdkUnknown(String)
}

extension IAMAuthMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IAMAuthMode] {
        return [
            .disabled,
            .required,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .required: return "REQUIRED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IAMAuthMode(rawValue: rawValue) ?? IAMAuthMode.sdkUnknown(rawValue)
    }
}

extension IPRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cIDRIP = "CIDRIP"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: Key("CIDRIP"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let cIDRIPDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cIDRIP)
        cIDRIP = cIDRIPDecoded
    }
}

extension IPRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPRange(cIDRIP: \(String(describing: cIDRIP)), status: \(String(describing: status)))"}
}

/// <p>
///         This data type is used as a response element in the <code>DescribeDBSecurityGroups</code> action.
///         </p>
public struct IPRange: Equatable {
    /// <p>Specifies the IP range.</p>
    public let cIDRIP: String?
    /// <p>Specifies the status of the IP range. Status can be "authorizing", "authorized", "revoking", and "revoked".</p>
    public let status: String?

    public init (
        cIDRIP: String? = nil,
        status: String? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.status = status
    }
}

extension IamRoleMissingPermissionsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IamRoleMissingPermissionsFault(message: \(String(describing: message)))"}
}

extension IamRoleMissingPermissionsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<IamRoleMissingPermissionsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The IAM role requires additional permissions to export to an Amazon S3 bucket.</p>
public struct IamRoleMissingPermissionsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IamRoleMissingPermissionsFaultBody: Equatable {
    public let message: String?
}

extension IamRoleMissingPermissionsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IamRoleNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IamRoleNotFoundFault(message: \(String(describing: message)))"}
}

extension IamRoleNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<IamRoleNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The IAM role is missing for exporting to an Amazon S3 bucket.</p>
public struct IamRoleNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IamRoleNotFoundFaultBody: Equatable {
    public let message: String?
}

extension IamRoleNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ImportInstallationMediaInputBodyMiddleware: Middleware {
    public let id: String = "ImportInstallationMediaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportInstallationMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportInstallationMediaInput>
    public typealias MOutput = OperationOutput<ImportInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportInstallationMediaOutputError>
}

extension ImportInstallationMediaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportInstallationMediaInput(customAvailabilityZoneId: \(String(describing: customAvailabilityZoneId)), engine: \(String(describing: engine)), engineInstallationMediaPath: \(String(describing: engineInstallationMediaPath)), engineVersion: \(String(describing: engineVersion)), oSInstallationMediaPath: \(String(describing: oSInstallationMediaPath)))"}
}

extension ImportInstallationMediaInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: Key("CustomAvailabilityZoneId"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineInstallationMediaPath = engineInstallationMediaPath {
            try container.encode(engineInstallationMediaPath, forKey: Key("EngineInstallationMediaPath"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let oSInstallationMediaPath = oSInstallationMediaPath {
            try container.encode(oSInstallationMediaPath, forKey: Key("OSInstallationMediaPath"))
        }
        try container.encode("ImportInstallationMedia", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ImportInstallationMediaInputHeadersMiddleware: Middleware {
    public let id: String = "ImportInstallationMediaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportInstallationMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportInstallationMediaInput>
    public typealias MOutput = OperationOutput<ImportInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportInstallationMediaOutputError>
}

public struct ImportInstallationMediaInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportInstallationMediaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportInstallationMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportInstallationMediaInput>
    public typealias MOutput = OperationOutput<ImportInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportInstallationMediaOutputError>
}

public struct ImportInstallationMediaInput: Equatable {
    /// <p>The identifier of the custom Availability Zone (AZ) to import the installation media to.</p>
    public let customAvailabilityZoneId: String?
    /// <p>The name of the database engine to be used for this instance.
    ///       </p>
    ///
    ///          <p>The list only includes supported DB engines that require an on-premises
    ///           customer provided license.
    ///       </p>
    ///
    ///          <p>Valid Values:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ex</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-web</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let engine: String?
    /// <p>The path to the installation medium for the specified DB engine.</p>
    ///          <p>Example: <code>SQLServerISO/en_sql_server_2016_enterprise_x64_dvd_8701793.iso</code>
    ///          </p>
    public let engineInstallationMediaPath: String?
    /// <p>The version number of the database engine to use.</p>
    ///          <p>For a list of valid engine versions, call <a>DescribeDBEngineVersions</a>.</p>
    ///          <p>The following are the database engines and links to information about the major and minor
    ///           versions. The list only includes DB engines that require an on-premises
    ///           customer provided license.</p>
    ///
    ///          <p>
    ///             <b>Microsoft SQL Server</b>
    ///          </p>
    ///
    ///          <p>See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport">
    ///           Microsoft SQL Server Versions on Amazon RDS</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let engineVersion: String?
    /// <p>The path to the installation medium for the operating system associated with the specified DB engine.</p>
    ///         <p>Example: <code>WindowsISO/en_windows_server_2016_x64_dvd_9327751.iso</code>
    ///          </p>
    public let oSInstallationMediaPath: String?

    public init (
        customAvailabilityZoneId: String? = nil,
        engine: String? = nil,
        engineInstallationMediaPath: String? = nil,
        engineVersion: String? = nil,
        oSInstallationMediaPath: String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.engine = engine
        self.engineInstallationMediaPath = engineInstallationMediaPath
        self.engineVersion = engineVersion
        self.oSInstallationMediaPath = oSInstallationMediaPath
    }
}

extension ImportInstallationMediaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ImportInstallationMediaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFoundFault" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstallationMediaAlreadyExistsFault" : self = .installationMediaAlreadyExistsFault(try InstallationMediaAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportInstallationMediaOutputError: Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case installationMediaAlreadyExistsFault(InstallationMediaAlreadyExistsFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportInstallationMediaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportInstallationMediaOutputResponse(customAvailabilityZoneId: \(String(describing: customAvailabilityZoneId)), engine: \(String(describing: engine)), engineInstallationMediaPath: \(String(describing: engineInstallationMediaPath)), engineVersion: \(String(describing: engineVersion)), failureCause: \(String(describing: failureCause)), installationMediaId: \(String(describing: installationMediaId)), oSInstallationMediaPath: \(String(describing: oSInstallationMediaPath)), status: \(String(describing: status)))"}
}

extension ImportInstallationMediaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportInstallationMediaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customAvailabilityZoneId = output.customAvailabilityZoneId
            self.engine = output.engine
            self.engineInstallationMediaPath = output.engineInstallationMediaPath
            self.engineVersion = output.engineVersion
            self.failureCause = output.failureCause
            self.installationMediaId = output.installationMediaId
            self.oSInstallationMediaPath = output.oSInstallationMediaPath
            self.status = output.status
        } else {
            self.customAvailabilityZoneId = nil
            self.engine = nil
            self.engineInstallationMediaPath = nil
            self.engineVersion = nil
            self.failureCause = nil
            self.installationMediaId = nil
            self.oSInstallationMediaPath = nil
            self.status = nil
        }
    }
}

/// <p>Contains the installation media for a DB engine that requires an on-premises
///           customer provided license, such as Microsoft SQL Server.</p>
public struct ImportInstallationMediaOutputResponse: Equatable {
    /// <p>The custom Availability Zone (AZ) that contains the installation media.</p>
    public let customAvailabilityZoneId: String?
    /// <p>The DB engine.</p>
    public let engine: String?
    /// <p>The path to the installation medium for the DB engine.</p>
    public let engineInstallationMediaPath: String?
    /// <p>The engine version of the DB engine.</p>
    public let engineVersion: String?
    /// <p>If an installation media failure occurred, the cause of the failure.</p>
    public let failureCause: InstallationMediaFailureCause?
    /// <p>The installation medium ID.</p>
    public let installationMediaId: String?
    /// <p>The path to the installation medium for the operating system associated with the DB engine.</p>
    public let oSInstallationMediaPath: String?
    /// <p>The status of the installation medium.</p>
    public let status: String?

    public init (
        customAvailabilityZoneId: String? = nil,
        engine: String? = nil,
        engineInstallationMediaPath: String? = nil,
        engineVersion: String? = nil,
        failureCause: InstallationMediaFailureCause? = nil,
        installationMediaId: String? = nil,
        oSInstallationMediaPath: String? = nil,
        status: String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.engine = engine
        self.engineInstallationMediaPath = engineInstallationMediaPath
        self.engineVersion = engineVersion
        self.failureCause = failureCause
        self.installationMediaId = installationMediaId
        self.oSInstallationMediaPath = oSInstallationMediaPath
        self.status = status
    }
}

struct ImportInstallationMediaOutputResponseBody: Equatable {
    public let installationMediaId: String?
    public let customAvailabilityZoneId: String?
    public let engine: String?
    public let engineVersion: String?
    public let engineInstallationMediaPath: String?
    public let oSInstallationMediaPath: String?
    public let status: String?
    public let failureCause: InstallationMediaFailureCause?
}

extension ImportInstallationMediaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case engine = "Engine"
        case engineInstallationMediaPath = "EngineInstallationMediaPath"
        case engineVersion = "EngineVersion"
        case failureCause = "FailureCause"
        case installationMediaId = "InstallationMediaId"
        case oSInstallationMediaPath = "OSInstallationMediaPath"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ImportInstallationMediaResult"))
        let installationMediaIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .installationMediaId)
        installationMediaId = installationMediaIdDecoded
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineInstallationMediaPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineInstallationMediaPath)
        engineInstallationMediaPath = engineInstallationMediaPathDecoded
        let oSInstallationMediaPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oSInstallationMediaPath)
        oSInstallationMediaPath = oSInstallationMediaPathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(InstallationMediaFailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
    }
}

extension InstallationMedia: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case engine = "Engine"
        case engineInstallationMediaPath = "EngineInstallationMediaPath"
        case engineVersion = "EngineVersion"
        case failureCause = "FailureCause"
        case installationMediaId = "InstallationMediaId"
        case oSInstallationMediaPath = "OSInstallationMediaPath"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: Key("CustomAvailabilityZoneId"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineInstallationMediaPath = engineInstallationMediaPath {
            try container.encode(engineInstallationMediaPath, forKey: Key("EngineInstallationMediaPath"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let failureCause = failureCause {
            try container.encode(failureCause, forKey: Key("FailureCause"))
        }
        if let installationMediaId = installationMediaId {
            try container.encode(installationMediaId, forKey: Key("InstallationMediaId"))
        }
        if let oSInstallationMediaPath = oSInstallationMediaPath {
            try container.encode(oSInstallationMediaPath, forKey: Key("OSInstallationMediaPath"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let installationMediaIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .installationMediaId)
        installationMediaId = installationMediaIdDecoded
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineInstallationMediaPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineInstallationMediaPath)
        engineInstallationMediaPath = engineInstallationMediaPathDecoded
        let oSInstallationMediaPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oSInstallationMediaPath)
        oSInstallationMediaPath = oSInstallationMediaPathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(InstallationMediaFailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
    }
}

extension InstallationMedia: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstallationMedia(customAvailabilityZoneId: \(String(describing: customAvailabilityZoneId)), engine: \(String(describing: engine)), engineInstallationMediaPath: \(String(describing: engineInstallationMediaPath)), engineVersion: \(String(describing: engineVersion)), failureCause: \(String(describing: failureCause)), installationMediaId: \(String(describing: installationMediaId)), oSInstallationMediaPath: \(String(describing: oSInstallationMediaPath)), status: \(String(describing: status)))"}
}

/// <p>Contains the installation media for a DB engine that requires an on-premises
///           customer provided license, such as Microsoft SQL Server.</p>
public struct InstallationMedia: Equatable {
    /// <p>The custom Availability Zone (AZ) that contains the installation media.</p>
    public let customAvailabilityZoneId: String?
    /// <p>The DB engine.</p>
    public let engine: String?
    /// <p>The path to the installation medium for the DB engine.</p>
    public let engineInstallationMediaPath: String?
    /// <p>The engine version of the DB engine.</p>
    public let engineVersion: String?
    /// <p>If an installation media failure occurred, the cause of the failure.</p>
    public let failureCause: InstallationMediaFailureCause?
    /// <p>The installation medium ID.</p>
    public let installationMediaId: String?
    /// <p>The path to the installation medium for the operating system associated with the DB engine.</p>
    public let oSInstallationMediaPath: String?
    /// <p>The status of the installation medium.</p>
    public let status: String?

    public init (
        customAvailabilityZoneId: String? = nil,
        engine: String? = nil,
        engineInstallationMediaPath: String? = nil,
        engineVersion: String? = nil,
        failureCause: InstallationMediaFailureCause? = nil,
        installationMediaId: String? = nil,
        oSInstallationMediaPath: String? = nil,
        status: String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.engine = engine
        self.engineInstallationMediaPath = engineInstallationMediaPath
        self.engineVersion = engineVersion
        self.failureCause = failureCause
        self.installationMediaId = installationMediaId
        self.oSInstallationMediaPath = oSInstallationMediaPath
        self.status = status
    }
}

extension InstallationMediaAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstallationMediaAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension InstallationMediaAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InstallationMediaAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified installation medium has already been imported.</p>
public struct InstallationMediaAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InstallationMediaAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension InstallationMediaAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InstallationMediaFailureCause: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InstallationMediaFailureCause: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstallationMediaFailureCause(message: \(String(describing: message)))"}
}

/// <p>Contains the cause of an installation media failure. Installation media is used
///           for a DB engine that requires an on-premises
///           customer provided license, such as Microsoft SQL Server.</p>
public struct InstallationMediaFailureCause: Equatable {
    /// <p>The reason that an installation media import failed.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

extension InstallationMediaNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstallationMediaNotFoundFault(message: \(String(describing: message)))"}
}

extension InstallationMediaNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InstallationMediaNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>InstallationMediaID</code> doesn't refer to an existing installation medium.</p>
public struct InstallationMediaNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InstallationMediaNotFoundFaultBody: Equatable {
    public let message: String?
}

extension InstallationMediaNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InstanceQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceQuotaExceededFault(message: \(String(describing: message)))"}
}

extension InstanceQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InstanceQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB
///             instances.</p>
public struct InstanceQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InstanceQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension InstanceQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientAvailableIPsInSubnetFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientAvailableIPsInSubnetFault(message: \(String(describing: message)))"}
}

extension InsufficientAvailableIPsInSubnetFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InsufficientAvailableIPsInSubnetFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation can't be performed because there aren't enough available IP addresses
///            in the proxy's subnets. Add more CIDR blocks to the VPC or remove IP address that aren't required
///            from the subnets.</p>
public struct InsufficientAvailableIPsInSubnetFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientAvailableIPsInSubnetFaultBody: Equatable {
    public let message: String?
}

extension InsufficientAvailableIPsInSubnetFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientDBClusterCapacityFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientDBClusterCapacityFault(message: \(String(describing: message)))"}
}

extension InsufficientDBClusterCapacityFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InsufficientDBClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB cluster doesn't have enough capacity for the current operation.</p>
public struct InsufficientDBClusterCapacityFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDBClusterCapacityFaultBody: Equatable {
    public let message: String?
}

extension InsufficientDBClusterCapacityFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientDBInstanceCapacityFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientDBInstanceCapacityFault(message: \(String(describing: message)))"}
}

extension InsufficientDBInstanceCapacityFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InsufficientDBInstanceCapacityFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified DB instance class isn't available in the specified Availability
///             Zone.</p>
public struct InsufficientDBInstanceCapacityFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDBInstanceCapacityFaultBody: Equatable {
    public let message: String?
}

extension InsufficientDBInstanceCapacityFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientStorageClusterCapacityFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientStorageClusterCapacityFault(message: \(String(describing: message)))"}
}

extension InsufficientStorageClusterCapacityFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InsufficientStorageClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is insufficient storage available for the current action. You might be able to
///             resolve this error by updating your subnet group to use different Availability Zones
///             that have more storage available.</p>
public struct InsufficientStorageClusterCapacityFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientStorageClusterCapacityFaultBody: Equatable {
    public let message: String?
}

extension InsufficientStorageClusterCapacityFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterCapacityFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBClusterCapacityFault(message: \(String(describing: message)))"}
}

extension InvalidDBClusterCapacityFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>Capacity</code> isn't a valid Aurora Serverless DB cluster
///             capacity. Valid capacity values are <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>,
///             <code>32</code>, <code>64</code>, <code>128</code>, and <code>256</code>.</p>
public struct InvalidDBClusterCapacityFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterCapacityFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBClusterCapacityFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterEndpointStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBClusterEndpointStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBClusterEndpointStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBClusterEndpointStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation can't be performed on the endpoint while the endpoint is in this state.</p>
public struct InvalidDBClusterEndpointStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterEndpointStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBClusterEndpointStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterSnapshotStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBClusterSnapshotStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBClusterSnapshotStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBClusterSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The supplied value isn't a valid DB cluster snapshot state.</p>
public struct InvalidDBClusterSnapshotStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterSnapshotStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBClusterSnapshotStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBClusterStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBClusterStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBClusterStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation can't be performed while the cluster is in this state.</p>
public struct InvalidDBClusterStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBClusterStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBInstanceAutomatedBackupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBInstanceAutomatedBackupStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBInstanceAutomatedBackupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBInstanceAutomatedBackupStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The automated backup is in an invalid state.
///     	    For example, this automated backup is associated with an active instance. </p>
public struct InvalidDBInstanceAutomatedBackupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBInstanceAutomatedBackupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBInstanceAutomatedBackupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBInstanceStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBInstanceStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBInstanceStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBInstanceStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB instance isn't in a valid state.</p>
public struct InvalidDBInstanceStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBInstanceStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBInstanceStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBParameterGroupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBParameterGroupStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBParameterGroupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBParameterGroupStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB parameter group is in use or is in an invalid state. If you are attempting
///             to delete the parameter group, you can't delete it when the parameter group is in
///             this state.</p>
public struct InvalidDBParameterGroupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBParameterGroupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBParameterGroupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBProxyEndpointStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBProxyEndpointStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBProxyEndpointStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBProxyEndpointStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't perform this operation while the DB proxy endpoint is in a particular state.</p>
public struct InvalidDBProxyEndpointStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBProxyEndpointStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBProxyEndpointStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBProxyStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBProxyStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBProxyStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBProxyStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation can't be performed while the proxy is in this state.</p>
public struct InvalidDBProxyStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBProxyStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBProxyStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSecurityGroupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBSecurityGroupStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBSecurityGroupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBSecurityGroupStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the DB security group doesn't allow deletion.</p>
public struct InvalidDBSecurityGroupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSecurityGroupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBSecurityGroupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSnapshotStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBSnapshotStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBSnapshotStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the DB snapshot doesn't allow deletion.</p>
public struct InvalidDBSnapshotStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSnapshotStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBSnapshotStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetGroupFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBSubnetGroupFault(message: \(String(describing: message)))"}
}

extension InvalidDBSubnetGroupFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBSubnetGroupFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DBSubnetGroup doesn't belong to the same VPC as that of an existing
///             cross-region read replica of the same source instance.</p>
public struct InvalidDBSubnetGroupFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetGroupFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBSubnetGroupFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetGroupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBSubnetGroupStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBSubnetGroupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBSubnetGroupStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB subnet group cannot be deleted because it's in use.</p>
public struct InvalidDBSubnetGroupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetGroupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBSubnetGroupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBSubnetStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBSubnetStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBSubnetStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             The DB subnet isn't in the <i>available</i> state.
///         </p>
public struct InvalidDBSubnetStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBSubnetStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventSubscriptionStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEventSubscriptionStateFault(message: \(String(describing: message)))"}
}

extension InvalidEventSubscriptionStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidEventSubscriptionStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This error can occur if someone else is modifying a subscription. You should retry the action.</p>
public struct InvalidEventSubscriptionStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventSubscriptionStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidEventSubscriptionStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExportOnlyFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidExportOnlyFault(message: \(String(describing: message)))"}
}

extension InvalidExportOnlyFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidExportOnlyFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The export is invalid for exporting to an Amazon S3 bucket.</p>
public struct InvalidExportOnlyFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExportOnlyFaultBody: Equatable {
    public let message: String?
}

extension InvalidExportOnlyFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExportSourceStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidExportSourceStateFault(message: \(String(describing: message)))"}
}

extension InvalidExportSourceStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidExportSourceStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the export snapshot is invalid for exporting to an Amazon S3 bucket.</p>
public struct InvalidExportSourceStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExportSourceStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidExportSourceStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExportTaskStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidExportTaskStateFault(message: \(String(describing: message)))"}
}

extension InvalidExportTaskStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidExportTaskStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't cancel an export task that has completed.</p>
public struct InvalidExportTaskStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExportTaskStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidExportTaskStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidGlobalClusterStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidGlobalClusterStateFault(message: \(String(describing: message)))"}
}

extension InvalidGlobalClusterStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidGlobalClusterStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The global cluster is in an invalid state and can't perform the requested operation. </p>
public struct InvalidGlobalClusterStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidGlobalClusterStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidGlobalClusterStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOptionGroupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOptionGroupStateFault(message: \(String(describing: message)))"}
}

extension InvalidOptionGroupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidOptionGroupStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             The option group isn't in the <i>available</i> state.
///         </p>
public struct InvalidOptionGroupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOptionGroupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidOptionGroupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRestoreFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRestoreFault(message: \(String(describing: message)))"}
}

extension InvalidRestoreFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidRestoreFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot restore from VPC backup to non-VPC DB instance.</p>
public struct InvalidRestoreFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRestoreFaultBody: Equatable {
    public let message: String?
}

extension InvalidRestoreFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidS3BucketFault(message: \(String(describing: message)))"}
}

extension InvalidS3BucketFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidS3BucketFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Amazon S3 bucket name can't be found or Amazon RDS isn't
///             authorized to access the specified Amazon S3 bucket. Verify the <b>SourceS3BucketName</b> and <b>S3IngestionRoleArn</b> values and try again.</p>
public struct InvalidS3BucketFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3BucketFaultBody: Equatable {
    public let message: String?
}

extension InvalidS3BucketFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSubnet(message: \(String(describing: message)))"}
}

extension InvalidSubnet: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSubnetBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
public struct InvalidSubnet: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Equatable {
    public let message: String?
}

extension InvalidSubnetBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidVPCNetworkStateFault(message: \(String(describing: message)))"}
}

extension InvalidVPCNetworkStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidVPCNetworkStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB subnet group doesn't cover all Availability Zones after it's
///             created because of users' change.</p>
public struct InvalidVPCNetworkStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidVPCNetworkStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSKeyNotAccessibleFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSKeyNotAccessibleFault(message: \(String(describing: message)))"}
}

extension KMSKeyNotAccessibleFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<KMSKeyNotAccessibleFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred accessing an AWS KMS key.</p>
public struct KMSKeyNotAccessibleFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSKeyNotAccessibleFaultBody: Equatable {
    public let message: String?
}

extension KMSKeyNotAccessibleFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(filters: \(String(describing: filters)), resourceName: \(String(describing: resourceName)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
        try container.encode("ListTagsForResource", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

/// <p></p>
public struct ListTagsForResourceInput: Equatable {
    /// <p>This parameter isn't currently supported.</p>
    public let filters: [Filter]?
    /// <p>The Amazon RDS resource with tags to be listed. This value is an Amazon Resource Name (ARN). For information about
    ///             creating an ARN,
    ///             see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///                 Constructing an ARN for Amazon RDS</a> in the <i>Amazon RDS User Guide</i>.</p>
    public let resourceName: String?

    public init (
        filters: [Filter]? = nil,
        resourceName: String? = nil
    )
    {
        self.filters = filters
        self.resourceName = resourceName
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tagList: \(String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

/// <p></p>
public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>List of tags returned by the ListTagsForResource operation.</p>
    public let tagList: [Tag]?

    public init (
        tagList: [Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tagList: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListTagsForResourceResult"))
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagListBuffer:[Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

extension MinimumEngineVersionPerAllowedValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedValue = "AllowedValue"
        case minimumEngineVersion = "MinimumEngineVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allowedValue = allowedValue {
            try container.encode(allowedValue, forKey: Key("AllowedValue"))
        }
        if let minimumEngineVersion = minimumEngineVersion {
            try container.encode(minimumEngineVersion, forKey: Key("MinimumEngineVersion"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedValue)
        allowedValue = allowedValueDecoded
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
    }
}

extension MinimumEngineVersionPerAllowedValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MinimumEngineVersionPerAllowedValue(allowedValue: \(String(describing: allowedValue)), minimumEngineVersion: \(String(describing: minimumEngineVersion)))"}
}

/// <p>The minimum DB engine version required for each corresponding allowed value for an option setting.</p>
public struct MinimumEngineVersionPerAllowedValue: Equatable {
    /// <p>The allowed value for an option setting.</p>
    public let allowedValue: String?
    /// <p>The minimum DB engine version required for the allowed value.</p>
    public let minimumEngineVersion: String?

    public init (
        allowedValue: String? = nil,
        minimumEngineVersion: String? = nil
    )
    {
        self.allowedValue = allowedValue
        self.minimumEngineVersion = minimumEngineVersion
    }
}

public struct ModifyCertificatesInputBodyMiddleware: Middleware {
    public let id: String = "ModifyCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyCertificatesInput>
    public typealias MOutput = OperationOutput<ModifyCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyCertificatesOutputError>
}

extension ModifyCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyCertificatesInput(certificateIdentifier: \(String(describing: certificateIdentifier)), removeCustomerOverride: \(String(describing: removeCustomerOverride)))"}
}

extension ModifyCertificatesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificateIdentifier = certificateIdentifier {
            try container.encode(certificateIdentifier, forKey: Key("CertificateIdentifier"))
        }
        if let removeCustomerOverride = removeCustomerOverride {
            try container.encode(removeCustomerOverride, forKey: Key("RemoveCustomerOverride"))
        }
        try container.encode("ModifyCertificates", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyCertificatesInput>
    public typealias MOutput = OperationOutput<ModifyCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyCertificatesOutputError>
}

public struct ModifyCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyCertificatesInput>
    public typealias MOutput = OperationOutput<ModifyCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyCertificatesOutputError>
}

public struct ModifyCertificatesInput: Equatable {
    /// <p>The new default certificate identifier to override the current one with.</p>
    ///          <p>To determine the valid values, use the <code>describe-certificates</code> AWS CLI
    ///             command or the <code>DescribeCertificates</code> API operation.</p>
    public let certificateIdentifier: String?
    /// <p>A value that indicates whether to remove the override for the default certificate.
    ///             If the override is removed, the default certificate is the system
    ///             default.</p>
    public let removeCustomerOverride: Bool?

    public init (
        certificateIdentifier: String? = nil,
        removeCustomerOverride: Bool? = nil
    )
    {
        self.certificateIdentifier = certificateIdentifier
        self.removeCustomerOverride = removeCustomerOverride
    }
}

extension ModifyCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateNotFoundFault" : self = .certificateNotFoundFault(try CertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyCertificatesOutputError: Equatable {
    case certificateNotFoundFault(CertificateNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyCertificatesOutputResponse(certificate: \(String(describing: certificate)))"}
}

extension ModifyCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct ModifyCertificatesOutputResponse: Equatable {
    /// <p>A CA certificate for an AWS account.</p>
    public let certificate: Certificate?

    public init (
        certificate: Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct ModifyCertificatesOutputResponseBody: Equatable {
    public let certificate: Certificate?
}

extension ModifyCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyCertificatesResult"))
        let certificateDecoded = try containerValues.decodeIfPresent(Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

public struct ModifyCurrentDBClusterCapacityInputBodyMiddleware: Middleware {
    public let id: String = "ModifyCurrentDBClusterCapacityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyCurrentDBClusterCapacityInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyCurrentDBClusterCapacityInput>
    public typealias MOutput = OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyCurrentDBClusterCapacityOutputError>
}

extension ModifyCurrentDBClusterCapacityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyCurrentDBClusterCapacityInput(capacity: \(String(describing: capacity)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), secondsBeforeTimeout: \(String(describing: secondsBeforeTimeout)), timeoutAction: \(String(describing: timeoutAction)))"}
}

extension ModifyCurrentDBClusterCapacityInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let capacity = capacity {
            try container.encode(capacity, forKey: Key("Capacity"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let secondsBeforeTimeout = secondsBeforeTimeout {
            try container.encode(secondsBeforeTimeout, forKey: Key("SecondsBeforeTimeout"))
        }
        if let timeoutAction = timeoutAction {
            try container.encode(timeoutAction, forKey: Key("TimeoutAction"))
        }
        try container.encode("ModifyCurrentDBClusterCapacity", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyCurrentDBClusterCapacityInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyCurrentDBClusterCapacityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyCurrentDBClusterCapacityInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyCurrentDBClusterCapacityInput>
    public typealias MOutput = OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyCurrentDBClusterCapacityOutputError>
}

public struct ModifyCurrentDBClusterCapacityInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyCurrentDBClusterCapacityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyCurrentDBClusterCapacityInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyCurrentDBClusterCapacityInput>
    public typealias MOutput = OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyCurrentDBClusterCapacityOutputError>
}

public struct ModifyCurrentDBClusterCapacityInput: Equatable {
    /// <p>The DB cluster capacity.</p>
    ///         <p>When you change the capacity of a paused Aurora Serverless DB cluster, it automatically resumes.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For Aurora MySQL, valid capacity values are <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>, and <code>256</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For Aurora PostgreSQL, valid capacity values are <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>192</code>, and <code>384</code>.</p>
    ///             </li>
    ///          </ul>
    public let capacity: Int?
    /// <p>The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Must match the identifier of an existing DB cluster.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>The amount of time, in seconds, that Aurora Serverless tries to find a scaling point
    ///             to perform seamless scaling before enforcing the timeout action. The default is
    ///             300.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Value must be from 10 through 600.</p>
    ///             </li>
    ///          </ul>
    public let secondsBeforeTimeout: Int?
    /// <p>The action to take when the timeout is reached, either <code>ForceApplyCapacityChange</code> or <code>RollbackCapacityChange</code>.</p>
    ///         <p>
    ///             <code>ForceApplyCapacityChange</code>, the default, sets the capacity to the specified value as soon as possible.</p>
    ///         <p>
    ///             <code>RollbackCapacityChange</code> ignores the capacity change if a scaling point isn't found in the timeout period.</p>
    public let timeoutAction: String?

    public init (
        capacity: Int? = nil,
        dBClusterIdentifier: String? = nil,
        secondsBeforeTimeout: Int? = nil,
        timeoutAction: String? = nil
    )
    {
        self.capacity = capacity
        self.dBClusterIdentifier = dBClusterIdentifier
        self.secondsBeforeTimeout = secondsBeforeTimeout
        self.timeoutAction = timeoutAction
    }
}

extension ModifyCurrentDBClusterCapacityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyCurrentDBClusterCapacityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterCapacityFault" : self = .invalidDBClusterCapacityFault(try InvalidDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyCurrentDBClusterCapacityOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterCapacityFault(InvalidDBClusterCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyCurrentDBClusterCapacityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyCurrentDBClusterCapacityOutputResponse(currentCapacity: \(String(describing: currentCapacity)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), pendingCapacity: \(String(describing: pendingCapacity)), secondsBeforeTimeout: \(String(describing: secondsBeforeTimeout)), timeoutAction: \(String(describing: timeoutAction)))"}
}

extension ModifyCurrentDBClusterCapacityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyCurrentDBClusterCapacityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.currentCapacity = output.currentCapacity
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.pendingCapacity = output.pendingCapacity
            self.secondsBeforeTimeout = output.secondsBeforeTimeout
            self.timeoutAction = output.timeoutAction
        } else {
            self.currentCapacity = nil
            self.dBClusterIdentifier = nil
            self.pendingCapacity = nil
            self.secondsBeforeTimeout = nil
            self.timeoutAction = nil
        }
    }
}

public struct ModifyCurrentDBClusterCapacityOutputResponse: Equatable {
    /// <p>The current capacity of the DB cluster.</p>
    public let currentCapacity: Int?
    /// <p>A user-supplied DB cluster identifier. This identifier is the unique key that
    ///             identifies a DB cluster. </p>
    public let dBClusterIdentifier: String?
    /// <p>A value that specifies the capacity that the DB cluster scales to next.</p>
    public let pendingCapacity: Int?
    /// <p>The number of seconds before a call to <code>ModifyCurrentDBClusterCapacity</code> times out.</p>
    public let secondsBeforeTimeout: Int?
    /// <p>The timeout action of a call to <code>ModifyCurrentDBClusterCapacity</code>, either
    ///             <code>ForceApplyCapacityChange</code> or <code>RollbackCapacityChange</code>.</p>
    public let timeoutAction: String?

    public init (
        currentCapacity: Int? = nil,
        dBClusterIdentifier: String? = nil,
        pendingCapacity: Int? = nil,
        secondsBeforeTimeout: Int? = nil,
        timeoutAction: String? = nil
    )
    {
        self.currentCapacity = currentCapacity
        self.dBClusterIdentifier = dBClusterIdentifier
        self.pendingCapacity = pendingCapacity
        self.secondsBeforeTimeout = secondsBeforeTimeout
        self.timeoutAction = timeoutAction
    }
}

struct ModifyCurrentDBClusterCapacityOutputResponseBody: Equatable {
    public let dBClusterIdentifier: String?
    public let pendingCapacity: Int?
    public let currentCapacity: Int?
    public let secondsBeforeTimeout: Int?
    public let timeoutAction: String?
}

extension ModifyCurrentDBClusterCapacityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentCapacity = "CurrentCapacity"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case pendingCapacity = "PendingCapacity"
        case secondsBeforeTimeout = "SecondsBeforeTimeout"
        case timeoutAction = "TimeoutAction"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyCurrentDBClusterCapacityResult"))
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let pendingCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pendingCapacity)
        pendingCapacity = pendingCapacityDecoded
        let currentCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentCapacity)
        currentCapacity = currentCapacityDecoded
        let secondsBeforeTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .secondsBeforeTimeout)
        secondsBeforeTimeout = secondsBeforeTimeoutDecoded
        let timeoutActionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeoutAction)
        timeoutAction = timeoutActionDecoded
    }
}

public struct ModifyDBClusterEndpointInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterEndpointOutputError>
}

extension ModifyDBClusterEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterEndpointInput(dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)))"}
}

extension ModifyDBClusterEndpointInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: Key("DBClusterEndpointIdentifier"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterEndpoint", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBClusterEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterEndpointOutputError>
}

public struct ModifyDBClusterEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterEndpointOutputError>
}

public struct ModifyDBClusterEndpointInput: Equatable {
    /// <p>The identifier of the endpoint to modify. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>ANY</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///        All other eligible instances are reachable through the custom endpoint.
    ///        Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?

    public init (
        dBClusterEndpointIdentifier: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
    }
}

extension ModifyDBClusterEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointNotFoundFault" : self = .dBClusterEndpointNotFoundFault(try DBClusterEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterEndpointStateFault" : self = .invalidDBClusterEndpointStateFault(try InvalidDBClusterEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterEndpointOutputError: Equatable {
    case dBClusterEndpointNotFoundFault(DBClusterEndpointNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterEndpointStateFault(InvalidDBClusterEndpointStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterEndpointOutputResponse(customEndpointType: \(String(describing: customEndpointType)), dBClusterEndpointArn: \(String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), endpoint: \(String(describing: endpoint)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)), status: \(String(describing: status)))"}
}

extension ModifyDBClusterEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// <p>This data type represents the information you need to connect to an Amazon Aurora DB cluster.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBClusterEndpoint</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon RDS DB instance endpoints,
///         see <code>Endpoint</code>.</p>
public struct ModifyDBClusterEndpointOutputResponse: Equatable {
    /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
    ///        <code>WRITER</code>, <code>ANY</code>.</p>
    public let customEndpointType: String?
    /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
    public let dBClusterEndpointArn: String?
    /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
    public let dBClusterEndpointResourceIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///             stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>The DNS address of the endpoint.</p>
    public let endpoint: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///        All other eligible instances are reachable through the custom endpoint.
    ///        Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?
    /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that can't be used for a certain kind of cluster,
    ///      such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
    public let status: String?

    public init (
        customEndpointType: String? = nil,
        dBClusterEndpointArn: String? = nil,
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterEndpointResourceIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        endpoint: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil,
        status: String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct ModifyDBClusterEndpointOutputResponseBody: Equatable {
    public let dBClusterEndpointIdentifier: String?
    public let dBClusterIdentifier: String?
    public let dBClusterEndpointResourceIdentifier: String?
    public let endpoint: String?
    public let status: String?
    public let endpointType: String?
    public let customEndpointType: String?
    public let staticMembers: [String]?
    public let excludedMembers: [String]?
    public let dBClusterEndpointArn: String?
}

extension ModifyDBClusterEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var staticMembersBuffer:[String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var excludedMembersBuffer:[String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct ModifyDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterOutputError>
}

extension ModifyDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterInput(allowMajorVersionUpgrade: \(String(describing: allowMajorVersionUpgrade)), applyImmediately: \(String(describing: applyImmediately)), backtrackWindow: \(String(describing: backtrackWindow)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), cloudwatchLogsExportConfiguration: \(String(describing: cloudwatchLogsExportConfiguration)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBInstanceParameterGroupName: \(String(describing: dBInstanceParameterGroupName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableGlobalWriteForwarding: \(String(describing: enableGlobalWriteForwarding)), enableHttpEndpoint: \(String(describing: enableHttpEndpoint)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), engineVersion: \(String(describing: engineVersion)), masterUserPassword: \(String(describing: masterUserPassword)), newDBClusterIdentifier: \(String(describing: newDBClusterIdentifier)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), scalingConfiguration: \(String(describing: scalingConfiguration)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allowMajorVersionUpgrade != false {
            try container.encode(allowMajorVersionUpgrade, forKey: Key("AllowMajorVersionUpgrade"))
        }
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: Key("ApplyImmediately"))
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration {
            try container.encode(cloudwatchLogsExportConfiguration, forKey: Key("CloudwatchLogsExportConfiguration"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBInstanceParameterGroupName = dBInstanceParameterGroupName {
            try container.encode(dBInstanceParameterGroupName, forKey: Key("DBInstanceParameterGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableGlobalWriteForwarding = enableGlobalWriteForwarding {
            try container.encode(enableGlobalWriteForwarding, forKey: Key("EnableGlobalWriteForwarding"))
        }
        if let enableHttpEndpoint = enableHttpEndpoint {
            try container.encode(enableHttpEndpoint, forKey: Key("EnableHttpEndpoint"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let newDBClusterIdentifier = newDBClusterIdentifier {
            try container.encode(newDBClusterIdentifier, forKey: Key("NewDBClusterIdentifier"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let scalingConfiguration = scalingConfiguration {
            try container.encode(scalingConfiguration, forKey: Key("ScalingConfiguration"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterOutputError>
}

public struct ModifyDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterOutputError>
}

/// <p></p>
public struct ModifyDBClusterInput: Equatable {
    /// <p>A value that indicates whether major version upgrades are allowed.</p>
    ///          <p>Constraints: You must allow major version upgrades when specifying a value for the
    ///                 <code>EngineVersion</code> parameter that is a different major version than the DB
    ///             cluster's current version.</p>
    public let allowMajorVersionUpgrade: Bool
    /// <p>A value that indicates whether the modifications in this request and
    ///       any pending modifications are asynchronously applied
    ///       as soon as possible, regardless of the
    ///       <code>PreferredMaintenanceWindow</code> setting for the DB cluster.
    ///       If this parameter is disabled, changes to the
    ///       DB cluster are applied during the next maintenance window.</p>
    ///          <p>The <code>ApplyImmediately</code> parameter only affects the <code>EnableIAMDatabaseAuthentication</code>,
    ///       <code>MasterUserPassword</code>, and <code>NewDBClusterIdentifier</code> values. If the <code>ApplyImmediately</code>
    ///       parameter is disabled, then changes to the <code>EnableIAMDatabaseAuthentication</code>, <code>MasterUserPassword</code>,
    ///       and <code>NewDBClusterIdentifier</code> values are applied during the next maintenance window. All other changes are
    ///       applied immediately, regardless of the value of the <code>ApplyImmediately</code> parameter.</p>
    ///          <p>By default, this parameter is disabled.</p>
    public let applyImmediately: Bool
    /// <p>The target backtrack window, in seconds. To disable backtracking, set this value to
    ///             0.</p>
    ///         <note>
    ///             <p>Currently, Backtrack is only supported for Aurora MySQL DB clusters.</p>
    ///         </note>
    ///         <p>Default: 0</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>If specified, this value must be set to a number from 0 to 259,200 (72 hours).</p>
    ///             </li>
    ///          </ul>
    public let backtrackWindow: Int?
    /// <p>The number of days for which automated backups are retained. You must specify a minimum value of 1.</p>
    ///          <p>Default: 1</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be a value from 1 to 35</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Int?
    /// <p>The configuration setting for the log types to be enabled for export to CloudWatch Logs for a specific DB cluster.</p>
    public let cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration?
    /// <p>A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster.
    ///             The default is not to copy them.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints: This identifier must match the identifier of an existing DB
    ///             cluster.</p>
    public let dBClusterIdentifier: String?
    /// <p>The name of the DB cluster parameter group to use for the DB cluster.</p>
    public let dBClusterParameterGroupName: String?
    /// <p>The name of the DB parameter group to apply to all instances of the DB cluster. </p>
    ///          <note>
    ///             <p>When you apply a parameter group using the <code>DBInstanceParameterGroupName</code> parameter, the DB
    ///                 cluster isn't rebooted automatically. Also, parameter changes aren't
    ///                 applied during the next maintenance window but instead are applied immediately.</p>
    ///          </note>
    ///          <p>Default: The existing name setting</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The DB parameter group must be in the same DB parameter group family as this DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>The <code>DBInstanceParameterGroupName</code> parameter is only valid in combination with
    ///               the <code>AllowMajorVersionUpgrade</code> parameter.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceParameterGroupName: String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled.
    ///         </p>
    public let deletionProtection: Bool?
    /// <p>The Active Directory directory ID to move the DB cluster to.
    ///           Specify <code>none</code> to remove the cluster from its current domain.
    ///           The domain must be created prior to this operation.
    ///       </p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html">Kerberos Authentication</a>
    ///             in the <i>Amazon Aurora User Guide</i>.
    ///       </p>
    public let domain: String?
    /// <p>Specify the name of the IAM role to be used when making API calls to the Directory Service.</p>
    public let domainIAMRoleName: String?
    /// <p>A value that indicates whether to enable this DB cluster to forward write operations to the primary cluster of an
    ///       Aurora global database (<a>GlobalCluster</a>). By default, write operations are not allowed on Aurora DB clusters that
    ///       are secondary clusters in an Aurora global database.</p>
    ///          <p>You can set this value only on Aurora DB clusters that are members of an Aurora global database. With this parameter
    ///       enabled, a secondary cluster can forward writes to the current primary cluster and the resulting changes are replicated back to
    ///       this cluster. For the primary DB cluster of an Aurora global database, this value is used immediately if the primary is
    ///       demoted by the <a>FailoverGlobalCluster</a> API operation, but it does nothing until then.
    ///     </p>
    public let enableGlobalWriteForwarding: Bool?
    /// <p>A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster. By default, the HTTP endpoint
    ///             is disabled.</p>
    ///         <p>When enabled, the HTTP endpoint provides a connectionless web service API for running
    ///             SQL queries on the Aurora Serverless DB cluster. You can also query your database
    ///             from inside the RDS console with the query editor.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html">Using the Data API for Aurora Serverless</a> in the
    ///             <i>Amazon Aurora User Guide</i>.</p>
    public let enableHttpEndpoint: Bool?
    /// <p>A value that indicates whether to enable mapping of AWS Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.</p>
    ///
    ///         <p>For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html">
    ///                 IAM Database Authentication</a> in the <i>Amazon Aurora User Guide.</i>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>The version number of the database engine to which you want to upgrade.
    ///             Changing this parameter results in an outage. The change is applied during
    ///             the next maintenance window unless <code>ApplyImmediately</code> is enabled.</p>
    ///         <p>To list all of the available engine versions for <code>aurora</code> (for MySQL 5.6-compatible Aurora), use the following command:</p>
    ///         <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    ///         <p>To list all of the available engine versions for <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora), use the following command:</p>
    ///         <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    ///         <p>To list all of the available engine versions for <code>aurora-postgresql</code>, use the following command:</p>
    ///         <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    public let engineVersion: String?
    /// <p>The new password for the master database user. This password can contain any printable ASCII character except "/", """, or "@".</p>
    ///          <p>Constraints: Must contain from 8 to 41 characters.</p>
    public let masterUserPassword: String?
    /// <p>The new DB cluster identifier for the DB cluster when renaming a DB cluster. This value is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>The first character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster2</code>
    ///          </p>
    public let newDBClusterIdentifier: String?
    /// <p>A value that indicates that the DB cluster should be associated with the specified option group.
    ///             Changing this parameter doesn't result in an outage except in the following case, and the change
    ///             is applied during the next maintenance window
    ///             unless the <code>ApplyImmediately</code> is enabled for this request. If the parameter change results in an option group that
    ///             enables OEM, this change can cause a brief (sub-second) period during which new connections
    ///             are rejected but existing connections are not interrupted.
    ///         </p>
    ///          <p>Permanent options can't be removed from an option group. The option group can't be removed from a DB cluster once it is associated with a DB cluster.</p>
    public let optionGroupName: String?
    /// <p>The port number on which the DB cluster accepts connections.</p>
    ///          <p>Constraints: Value must be <code>1150-65535</code>
    ///          </p>
    ///          <p>Default: The same port as the original DB cluster.</p>
    public let port: Int?
    /// <p>The daily time range during which automated backups are created
    ///             if automated backups are enabled,
    ///             using the <code>BackupRetentionPeriod</code> parameter.
    ///         </p>
    ///          <p>The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each AWS Region.
    ///             To view the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow">
    ///                 Backup window</a> in the <i>Amazon Aurora User Guide.</i>
    ///         </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be in the format <code>hh24:mi-hh24:mi</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Coordinated Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes.</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: String?
    /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
    ///          <p>Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///          </p>
    ///          <p>The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each AWS Region, occurring on a random day of the
    ///             week. To see the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora">
    ///                 Adjusting the Preferred DB Cluster Maintenance Window</a> in the <i>Amazon Aurora User Guide.</i>
    ///         </p>
    ///          <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    ///          <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The scaling properties of the DB cluster. You can only modify scaling properties for DB clusters in <code>serverless</code> DB engine mode.</p>
    public let scalingConfiguration: ScalingConfiguration?
    /// <p>A list of VPC security groups that the DB cluster will belong to.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        allowMajorVersionUpgrade: Bool = false,
        applyImmediately: Bool = false,
        backtrackWindow: Int? = nil,
        backupRetentionPeriod: Int? = nil,
        cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterParameterGroupName: String? = nil,
        dBInstanceParameterGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableGlobalWriteForwarding: Bool? = nil,
        enableHttpEndpoint: Bool? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        engineVersion: String? = nil,
        masterUserPassword: String? = nil,
        newDBClusterIdentifier: String? = nil,
        optionGroupName: String? = nil,
        port: Int? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        scalingConfiguration: ScalingConfiguration? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.backtrackWindow = backtrackWindow
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBInstanceParameterGroupName = dBInstanceParameterGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableGlobalWriteForwarding = enableGlobalWriteForwarding
        self.enableHttpEndpoint = enableHttpEndpoint
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engineVersion = engineVersion
        self.masterUserPassword = masterUserPassword
        self.newDBClusterIdentifier = newDBClusterIdentifier
        self.optionGroupName = optionGroupName
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.scalingConfiguration = scalingConfiguration
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupStateFault" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterOutputError: Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension ModifyDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct ModifyDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Aurora DB cluster.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusters</code>,
    ///         <code>StopDBCluster</code>, and <code>StartDBCluster</code> actions.
    ///       </p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct ModifyDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension ModifyDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct ModifyDBClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterParameterGroupOutputError>
}

extension ModifyDBClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterParameterGroupInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), parameters: \(String(describing: parameters)))"}
}

extension ModifyDBClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterParameterGroupOutputError>
}

public struct ModifyDBClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterParameterGroupOutputError>
}

/// <p></p>
public struct ModifyDBClusterParameterGroupInput: Equatable {
    /// <p>The name of the DB cluster parameter group to modify.</p>
    public let dBClusterParameterGroupName: String?
    /// <p>A list of parameters in the DB cluster parameter group to modify.</p>
    ///          <p>Valid Values (for the application method): <code>immediate | pending-reboot</code>
    ///          </p>
    ///          <note>
    ///             <p>You can use the <code>immediate</code> value with dynamic parameters only. You can use the
    ///               <code>pending-reboot</code> value for both dynamic and static parameters.</p>
    ///             <p>When the application method is <code>immediate</code>, changes to dynamic parameters are applied immediately
    ///           to the DB clusters associated with the parameter group. When the application method is <code>pending-reboot</code>,
    ///           changes to dynamic and static parameters are applied after a reboot without failover to the DB clusters associated with the
    ///           parameter group.</p>
    ///          </note>
    public let parameters: [Parameter]?

    public init (
        dBClusterParameterGroupName: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.parameters = parameters
    }
}

extension ModifyDBClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterParameterGroupOutputResponse(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)))"}
}

extension ModifyDBClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterParameterGroupName = output.dBClusterParameterGroupName
        } else {
            self.dBClusterParameterGroupName = nil
        }
    }
}

/// <p></p>
public struct ModifyDBClusterParameterGroupOutputResponse: Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBClusterParameterGroupName: String?

    public init (
        dBClusterParameterGroupName: String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

struct ModifyDBClusterParameterGroupOutputResponseBody: Equatable {
    public let dBClusterParameterGroupName: String?
}

extension ModifyDBClusterParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBClusterParameterGroupResult"))
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
    }
}

public struct ModifyDBClusterSnapshotAttributeInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBClusterSnapshotAttributeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

extension ModifyDBClusterSnapshotAttributeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterSnapshotAttributeInput(attributeName: \(String(describing: attributeName)), dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)), valuesToAdd: \(String(describing: valuesToAdd)), valuesToRemove: \(String(describing: valuesToRemove)))"}
}

extension ModifyDBClusterSnapshotAttributeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        if let valuesToAdd = valuesToAdd {
            var valuesToAddContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValuesToAdd"))
            for (index0, string0) in valuesToAdd.enumerated() {
                try valuesToAddContainer.encode(string0, forKey: Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        if let valuesToRemove = valuesToRemove {
            var valuesToRemoveContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValuesToRemove"))
            for (index0, string0) in valuesToRemove.enumerated() {
                try valuesToRemoveContainer.encode(string0, forKey: Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterSnapshotAttribute", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBClusterSnapshotAttributeInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBClusterSnapshotAttributeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

public struct ModifyDBClusterSnapshotAttributeInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBClusterSnapshotAttributeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

/// <p></p>
public struct ModifyDBClusterSnapshotAttributeInput: Equatable {
    /// <p>The name of the DB cluster snapshot attribute to modify.</p>
    ///         <p>To manage authorization for other AWS accounts to copy or restore a manual DB cluster snapshot,
    ///             set this value to <code>restore</code>.</p>
    ///         <note>
    ///             <p>To view the list of attributes available to modify, use the
    ///                 <a>DescribeDBClusterSnapshotAttributes</a> API action.</p>
    ///         </note>
    public let attributeName: String?
    /// <p>The identifier for the DB cluster snapshot to modify the attributes for.</p>
    public let dBClusterSnapshotIdentifier: String?
    /// <p>A list of DB cluster snapshot attributes to add to the attribute specified by <code>AttributeName</code>.</p>
    ///         <p>To authorize other AWS accounts to copy or restore a manual DB cluster snapshot, set this list to include one or more AWS account
    ///             IDs, or <code>all</code> to make the manual DB cluster snapshot restorable by
    ///             any AWS account. Do not add the <code>all</code> value for any
    ///             manual DB cluster snapshots that contain private information that you don't want available
    ///             to all AWS accounts.</p>
    public let valuesToAdd: [String]?
    /// <p>A list of DB cluster snapshot attributes to remove from the attribute specified by <code>AttributeName</code>.</p>
    ///         <p>To remove authorization for other AWS accounts to copy or restore a manual DB cluster snapshot, set this list to include
    ///             one or more AWS account
    ///             identifiers, or <code>all</code> to remove authorization for any AWS account to copy or
    ///             restore the DB cluster snapshot. If you specify <code>all</code>, an AWS account whose account ID is
    ///             explicitly added to the <code>restore</code> attribute
    ///             can still copy or restore a manual DB cluster snapshot.</p>
    public let valuesToRemove: [String]?

    public init (
        attributeName: String? = nil,
        dBClusterSnapshotIdentifier: String? = nil,
        valuesToAdd: [String]? = nil,
        valuesToRemove: [String]? = nil
    )
    {
        self.attributeName = attributeName
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.valuesToAdd = valuesToAdd
        self.valuesToRemove = valuesToRemove
    }
}

extension ModifyDBClusterSnapshotAttributeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterSnapshotAttributeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SharedSnapshotQuotaExceededFault" : self = .sharedSnapshotQuotaExceededFault(try SharedSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterSnapshotAttributeOutputError: Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case sharedSnapshotQuotaExceededFault(SharedSnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterSnapshotAttributeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterSnapshotAttributeOutputResponse(dBClusterSnapshotAttributesResult: \(String(describing: dBClusterSnapshotAttributesResult)))"}
}

extension ModifyDBClusterSnapshotAttributeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBClusterSnapshotAttributeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshotAttributesResult = output.dBClusterSnapshotAttributesResult
        } else {
            self.dBClusterSnapshotAttributesResult = nil
        }
    }
}

public struct ModifyDBClusterSnapshotAttributeOutputResponse: Equatable {
    /// <p>Contains the results of a successful call to the <code>DescribeDBClusterSnapshotAttributes</code>
    ///             API action.</p>
    ///         <p>Manual DB cluster snapshot attributes are used to authorize other AWS accounts
    ///             to copy or restore a manual DB cluster snapshot. For more information, see the <code>ModifyDBClusterSnapshotAttribute</code>
    ///             API action.</p>
    public let dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult?

    public init (
        dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult? = nil
    )
    {
        self.dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResult
    }
}

struct ModifyDBClusterSnapshotAttributeOutputResponseBody: Equatable {
    public let dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult?
}

extension ModifyDBClusterSnapshotAttributeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBClusterSnapshotAttributeResult"))
        let dBClusterSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(DBClusterSnapshotAttributesResult.self, forKey: .dBClusterSnapshotAttributesResult)
        dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResultDecoded
    }
}

public struct ModifyDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBInstanceOutputError>
}

extension ModifyDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBInstanceInput(allocatedStorage: \(String(describing: allocatedStorage)), allowMajorVersionUpgrade: \(String(describing: allowMajorVersionUpgrade)), applyImmediately: \(String(describing: applyImmediately)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), awsBackupRecoveryPointArn: \(String(describing: awsBackupRecoveryPointArn)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(String(describing: cACertificateIdentifier)), certificateRotationRestart: \(String(describing: certificateRotationRestart)), cloudwatchLogsExportConfiguration: \(String(describing: cloudwatchLogsExportConfiguration)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), dBPortNumber: \(String(describing: dBPortNumber)), dBSecurityGroups: \(String(describing: dBSecurityGroups)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableCustomerOwnedIp: \(String(describing: enableCustomerOwnedIp)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(String(describing: enablePerformanceInsights)), engineVersion: \(String(describing: engineVersion)), iops: \(String(describing: iops)), licenseModel: \(String(describing: licenseModel)), masterUserPassword: \(String(describing: masterUserPassword)), maxAllocatedStorage: \(String(describing: maxAllocatedStorage)), monitoringInterval: \(String(describing: monitoringInterval)), monitoringRoleArn: \(String(describing: monitoringRoleArn)), multiAZ: \(String(describing: multiAZ)), newDBInstanceIdentifier: \(String(describing: newDBInstanceIdentifier)), optionGroupName: \(String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(String(describing: performanceInsightsKMSKeyId)), performanceInsightsRetentionPeriod: \(String(describing: performanceInsightsRetentionPeriod)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), processorFeatures: \(String(describing: processorFeatures)), promotionTier: \(String(describing: promotionTier)), publiclyAccessible: \(String(describing: publiclyAccessible)), replicaMode: \(String(describing: replicaMode)), storageType: \(String(describing: storageType)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), tdeCredentialPassword: \(String(describing: tdeCredentialPassword)), useDefaultProcessorFeatures: \(String(describing: useDefaultProcessorFeatures)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if allowMajorVersionUpgrade != false {
            try container.encode(allowMajorVersionUpgrade, forKey: Key("AllowMajorVersionUpgrade"))
        }
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: Key("ApplyImmediately"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let awsBackupRecoveryPointArn = awsBackupRecoveryPointArn {
            try container.encode(awsBackupRecoveryPointArn, forKey: Key("AwsBackupRecoveryPointArn"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: Key("CACertificateIdentifier"))
        }
        if let certificateRotationRestart = certificateRotationRestart {
            try container.encode(certificateRotationRestart, forKey: Key("CertificateRotationRestart"))
        }
        if let cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration {
            try container.encode(cloudwatchLogsExportConfiguration, forKey: Key("CloudwatchLogsExportConfiguration"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let dBPortNumber = dBPortNumber {
            try container.encode(dBPortNumber, forKey: Key("DBPortNumber"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: Key("EnablePerformanceInsights"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let newDBInstanceIdentifier = newDBInstanceIdentifier {
            try container.encode(newDBInstanceIdentifier, forKey: Key("NewDBInstanceIdentifier"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: Key("PerformanceInsightsRetentionPeriod"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: Key("PromotionTier"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let replicaMode = replicaMode {
            try container.encode(replicaMode, forKey: Key("ReplicaMode"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: Key("TdeCredentialPassword"))
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBInstanceOutputError>
}

public struct ModifyDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBInstanceOutputError>
}

/// <p></p>
public struct ModifyDBInstanceInput: Equatable {
    /// <p>The new amount of storage (in gibibytes) to allocate for the DB instance.
    ///       </p>
    ///
    ///          <p>For MariaDB, MySQL, Oracle, and PostgreSQL,
    ///           the value supplied must be at least 10% greater than the current value.
    ///           Values that are not at least 10% greater than the existing value are rounded up
    ///           so that they are 10% greater than the current value.
    ///       </p>
    ///
    ///          <p>For the valid values for allocated storage for each engine,
    ///           see <code>CreateDBInstance</code>.
    ///       </p>
    public let allocatedStorage: Int?
    /// <p>A value that indicates whether major version upgrades are allowed. Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible.</p>
    ///          <p>Constraints: Major version upgrades must be allowed when specifying a value for the EngineVersion parameter that is a different major version than the DB instance's current version.</p>
    public let allowMajorVersionUpgrade: Bool
    /// <p>A value that indicates whether the modifications in this request and
    ///         any pending modifications are asynchronously applied
    ///         as soon as possible, regardless of the
    ///         <code>PreferredMaintenanceWindow</code> setting for the DB instance. By default, this parameter is
    ///           disabled.
    ///         </p>
    ///          <p>
    ///         If this parameter is disabled, changes to the
    ///         DB instance are applied during the next maintenance window. Some parameter changes can cause an outage
    ///         and are applied on the next call to <a>RebootDBInstance</a>, or the next failure reboot.
    ///         Review the table of parameters in <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.DBInstance.Modifying.html">Modifying a DB Instance</a>
    ///           in the <i>Amazon RDS User Guide.</i> to see the impact of enabling
    ///           or disabling <code>ApplyImmediately</code> for each modified parameter and to determine when the changes are applied.
    ///         </p>
    public let applyImmediately: Bool
    /// <p>
    ///     A value that indicates whether minor version upgrades are applied automatically
    ///     to the DB instance during the maintenance window.
    ///     Changing this parameter doesn't result in an outage except in the following case
    ///     and the change is asynchronously applied as soon as possible.
    ///     An outage results if this parameter is enabled during the maintenance window,
    ///     and a newer minor version is available, and RDS has enabled auto patching for that engine version.
    ///     </p>
    public let autoMinorVersionUpgrade: Bool?
    /// <p>The Amazon Resource Name (ARN) of the recovery point in AWS Backup.</p>
    public let awsBackupRecoveryPointArn: String?
    /// <p>The number of days to retain automated backups. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.</p>
    ///         <note>
    ///             <p>Enabling and disabling backups can result in a brief I/O suspension that lasts from a few seconds to a few minutes, depending on the size and class of your DB instance.</p>
    ///         </note>
    ///         <p>These changes are applied during the next maintenance window unless the <code>ApplyImmediately</code> parameter is enabled
    ///             for this request. If you change the parameter from one non-zero value to another non-zero value, the change is asynchronously
    ///             applied as soon as possible.</p>
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///         <p>Not applicable. The retention period for automated backups is managed by the DB
    ///             cluster. For more information, see <code>ModifyDBCluster</code>.</p>
    ///          <p>Default: Uses existing setting</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be a value from 0 to 35</p>
    ///             </li>
    ///             <li>
    ///                <p>Can be specified for a MySQL read replica only if the source is running MySQL 5.6 or
    ///                     later</p>
    ///             </li>
    ///             <li>
    ///                <p>Can be specified for a PostgreSQL read replica only if the source is running PostgreSQL
    ///                     9.3.5</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be set to 0 if the DB instance is a source to read replicas</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Int?
    /// <p>Indicates the certificate that needs to be associated with the instance.</p>
    public let cACertificateIdentifier: String?
    /// <p>A value that indicates whether the DB instance is restarted when you rotate your
    ///             SSL/TLS certificate.</p>
    ///         <p>By default, the DB instance is restarted when you rotate your SSL/TLS certificate. The certificate
    ///             is not updated until the DB instance is restarted.</p>
    ///         <important>
    ///             <p>Set this parameter only if you are <i>not</i> using SSL/TLS to connect to the DB instance.</p>
    ///         </important>
    ///         <p>If you are using SSL/TLS to connect to the DB instance, follow the appropriate instructions for your
    ///             DB engine to rotate your SSL/TLS certificate:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For more information about rotating your SSL/TLS certificate for RDS DB engines, see
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html">
    ///                         Rotating Your SSL/TLS Certificate.</a> in the <i>Amazon RDS User Guide.</i>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>For more information about rotating your SSL/TLS certificate for Aurora DB engines, see
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html">
    ///                         Rotating Your SSL/TLS Certificate</a> in the <i>Amazon Aurora User Guide.</i>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let certificateRotationRestart: Bool?
    /// <p>The configuration setting for the log types to be enabled for export to CloudWatch Logs for a specific DB instance.</p>
    ///         <p>A change to the <code>CloudwatchLogsExportConfiguration</code> parameter is always applied to the DB instance
    ///             immediately. Therefore, the <code>ApplyImmediately</code> parameter has no effect.</p>
    public let cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration?
    /// <p>A value that indicates whether to copy all tags from the DB instance to snapshots of the DB instance. By default, tags are not copied.</p>
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this
    ///           value for an Aurora DB instance has no effect on the DB cluster setting. For more
    ///           information, see <code>ModifyDBCluster</code>.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The new compute and memory capacity of the DB instance, for example, <code>db.m4.large</code>.
    ///           Not all DB instance classes are available in all AWS Regions, or for all database engines.
    ///           For the full list of DB instance classes,
    ///           and availability for your engine, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance Class</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///          <p>If you modify the DB instance class, an outage occurs during the change.
    ///         The change is applied during the next maintenance window,
    ///         unless <code>ApplyImmediately</code> is enabled for this request.
    ///         </p>
    ///          <p>Default: Uses existing setting</p>
    public let dBInstanceClass: String?
    /// <p>The DB instance identifier. This value is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p>The name of the DB parameter group to apply to the DB instance. Changing this
    ///             setting doesn't result in an outage. The parameter group name itself is changed
    ///             immediately, but the actual parameter changes are not applied until you reboot the
    ///             instance without failover. In this case, the DB instance isn't rebooted automatically and the
    ///             parameter changes isn't applied during the next maintenance window.</p>
    ///          <p>Default: Uses existing setting</p>
    ///          <p>Constraints: The DB parameter group must be in the same DB parameter group family as this DB instance.</p>
    public let dBParameterGroupName: String?
    /// <p>The port number on which the database accepts connections.</p>
    ///          <p>The value of the <code>DBPortNumber</code> parameter must not match any of the port values specified for options in the option
    ///       group for the DB instance.</p>
    ///          <p>Your database will restart when you change the <code>DBPortNumber</code> value regardless of the value of the <code>ApplyImmediately</code>
    ///       parameter.</p>
    ///          <p>
    ///             <b>MySQL</b>
    ///          </p>
    ///          <p>
    ///       Default: <code>3306</code>
    ///          </p>
    ///          <p> Valid values: <code>1150-65535</code>
    ///         </p>
    ///          <p>
    ///             <b>MariaDB</b>
    ///          </p>
    ///          <p>
    ///       Default: <code>3306</code>
    ///          </p>
    ///          <p> Valid values: <code>1150-65535</code>
    ///         </p>
    ///          <p>
    ///             <b>PostgreSQL</b>
    ///          </p>
    ///          <p>
    ///       Default: <code>5432</code>
    ///          </p>
    ///          <p> Valid values: <code>1150-65535</code>
    ///         </p>
    ///          <p>Type: Integer</p>
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///          <p>
    ///       Default: <code>1521</code>
    ///          </p>
    ///          <p> Valid values: <code>1150-65535</code>
    ///         </p>
    ///          <p>
    ///             <b>SQL Server</b>
    ///          </p>
    ///          <p>
    ///       Default: <code>1433</code>
    ///          </p>
    ///         <p> Valid values: <code>1150-65535</code> except <code>1234</code>, <code>1434</code>,
    ///                 <code>3260</code>, <code>3343</code>, <code>3389</code>, <code>47001</code>, and
    ///                 <code>49152-49156</code>.</p>
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>
    ///       Default: <code>3306</code>
    ///          </p>
    ///          <p> Valid values: <code>1150-65535</code>
    ///         </p>
    public let dBPortNumber: Int?
    /// <p>A list of DB security groups to authorize on this DB instance. Changing this setting doesn't result in an outage and the change is asynchronously applied as soon as possible.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match existing DBSecurityGroups.</p>
    ///             </li>
    ///          </ul>
    public let dBSecurityGroups: [String]?
    /// <p>The new DB subnet group for the DB instance.
    ///           You can use this parameter to move your DB instance to a different VPC.
    ///
    ///           If your DB instance isn't in a VPC, you can also use this parameter to move your DB instance into a VPC.
    ///           For more information, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html#USER_VPC.Non-VPC2VPC">Working with a DB instance in a VPC</a>
    ///           in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///          <p>Changing the subnet group causes an outage during the change.
    ///         The change is applied during the next maintenance window,
    ///         unless you enable <code>ApplyImmediately</code>.
    ///     </p>
    ///          <p>Constraints: If supplied, must match the name of an existing DBSubnetGroup.</p>
    ///          <p>Example: <code>mySubnetGroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance</a>.
    ///         </p>
    public let deletionProtection: Bool?
    /// <p>The Active Directory directory ID to move the DB instance to.
    ///           Specify <code>none</code> to remove the instance from its current domain.
    ///           The domain must be created prior to this operation. Currently, only MySQL, Microsoft SQL
    ///           Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///           Kerberos Authentication</a> in the <i>Amazon RDS User Guide</i>.</p>
    public let domain: String?
    /// <p>The name of the IAM role to use when making API calls to the Directory Service.</p>
    public let domainIAMRoleName: String?
    /// <p>A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance.</p>
    ///         <p>A <i>CoIP</i> provides local or external connectivity to resources in
    ///             your Outpost subnets through your on-premises network. For some use cases, a CoIP can
    ///             provide lower latency for connections to the DB instance from outside of its virtual
    ///             private cloud (VPC) on your local network.</p>
    ///         <p>For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Working with Amazon RDS on AWS Outposts</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    ///         <p>For more information about CoIPs, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing">Customer-owned IP addresses</a>
    ///             in the <i>AWS Outposts User Guide</i>.</p>
    public let enableCustomerOwnedIp: Bool?
    /// <p>A value that indicates whether to enable mapping of AWS Identity and Access
    ///           Management (IAM) accounts to database accounts. By default, mapping is disabled.</p>
    ///
    ///          <p>This setting doesn't apply to Amazon Aurora. Mapping AWS IAM accounts to database accounts is managed by the DB
    ///           cluster.</p>
    ///
    ///          <p>For more information about IAM database authentication, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///               IAM Database Authentication for MySQL and PostgreSQL</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>A value that indicates whether to enable Performance Insights for the DB instance.</p>
    ///         <p>For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html">Using Amazon Performance Insights</a> in the <i>Amazon Relational Database Service
    ///                     User Guide</i>.
    ///         </p>
    public let enablePerformanceInsights: Bool?
    /// <p>
    ///     The version number of the database engine to upgrade to.
    ///     Changing this parameter results in an outage and the change
    ///     is applied during the next maintenance window
    ///     unless the <code>ApplyImmediately</code> parameter is enabled for this request.
    ///     </p>
    ///          <p>For major version upgrades, if a nondefault DB parameter group is currently in use, a
    ///             new DB parameter group in the DB parameter group family for the new engine version must
    ///             be specified. The new DB parameter group can be the default for that DB parameter group
    ///             family.</p>
    ///          <p>If you specify only a major version, Amazon RDS will update the DB instance to the
    ///           default minor version if the current minor version is lower.
    ///           For information about valid engine versions, see <code>CreateDBInstance</code>,
    ///           or call <code>DescribeDBEngineVersions</code>.</p>
    public let engineVersion: String?
    /// <p>The new Provisioned IOPS (I/O operations per second) value for the RDS instance.
    ///       </p>
    ///          <p>Changing this setting doesn't result in an outage and
    ///             the change is applied during the next maintenance window
    ///             unless the <code>ApplyImmediately</code> parameter is enabled for this request.
    ///           If you are migrating from Provisioned IOPS to standard storage, set this value to 0.
    ///           The DB instance will require a reboot for the change in storage type to take effect.
    ///       </p>
    ///          <p>If you choose to migrate your DB instance from using standard storage to using
    ///             Provisioned IOPS, or from using Provisioned IOPS to using standard storage, the process
    ///             can take time. The duration of the migration depends on several factors such as database
    ///             load, storage size, storage type (standard or Provisioned IOPS), amount of IOPS
    ///             provisioned (if any), and the number of prior scale storage operations. Typical
    ///             migration times are under 24 hours, but the process can take up to several days in some
    ///             cases. During the migration, the DB instance is available for use, but might experience
    ///             performance degradation. While the migration takes place, nightly backups for the
    ///             instance are suspended. No other Amazon RDS operations can take place for the instance,
    ///             including modifying the instance, rebooting the instance, deleting the instance,
    ///             creating a read replica for the instance, and creating a DB snapshot of the instance. </p>
    ///          <p>Constraints: For MariaDB, MySQL, Oracle, and PostgreSQL,
    ///           the value supplied must be at least 10% greater than the current value.
    ///           Values that are not at least 10% greater than the existing value are rounded up so that they are 10% greater than the current value.
    ///       </p>
    ///          <p>Default: Uses existing setting</p>
    public let iops: Int?
    /// <p>The license model for the DB instance.</p>
    ///         <p>Valid values: <code>license-included</code> | <code>bring-your-own-license</code> |
    ///             <code>general-public-license</code>
    ///          </p>
    public let licenseModel: String?
    /// <p>The new password for the master user. The password can include any printable ASCII character except "/", """, or "@".</p>
    ///          <p>
    ///         Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible.
    ///         Between the time of the request and the completion of the request,
    ///         the <code>MasterUserPassword</code> element exists in the
    ///         <code>PendingModifiedValues</code> element of the operation response.
    ///         </p>
    ///
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///         <p>Not applicable. The password for the master user is managed by the DB cluster. For
    ///             more information, see <code>ModifyDBCluster</code>.
    ///         </p>
    ///
    ///          <p>Default: Uses existing setting</p>
    ///
    ///          <p>
    ///             <b>MariaDB</b>
    ///          </p>
    ///          <p>Constraints: Must contain from 8 to 41 characters.</p>
    ///
    ///          <p>
    ///             <b>Microsoft SQL Server</b>
    ///          </p>
    ///          <p>Constraints: Must contain from 8 to 128 characters.</p>
    ///
    ///          <p>
    ///             <b>MySQL</b>
    ///          </p>
    ///          <p>Constraints: Must contain from 8 to 41 characters.</p>
    ///
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///          <p>Constraints: Must contain from 8 to 30 characters.</p>
    ///
    ///          <p>
    ///             <b>PostgreSQL</b>
    ///          </p>
    ///          <p>Constraints: Must contain from 8 to 128 characters.</p>
    ///
    ///          <note>
    ///             <p>Amazon RDS API actions never return the password,
    ///               so this action provides a way to regain access to a primary instance user if the password is lost.
    ///               This includes restoring privileges that might have been accidentally revoked.
    ///           </p>
    ///          </note>
    public let masterUserPassword: String?
    /// <p>The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.</p>
    ///         <p>For more information about this setting, including limitations that apply to it, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling">
    ///                 Managing capacity automatically with Amazon RDS storage autoscaling</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    public let maxAllocatedStorage: Int?
    /// <p>The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0.</p>
    ///          <p>If <code>MonitoringRoleArn</code> is specified, then you must also set <code>MonitoringInterval</code>
    ///       to a value other than 0.</p>
    ///          <p>Valid Values: <code>0, 1, 5, 10, 15, 30, 60</code>
    ///          </p>
    public let monitoringInterval: Int?
    /// <p>The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For
    ///       example, <code>arn:aws:iam:123456789012:role/emaccess</code>. For information on creating a monitoring role,
    ///       go to <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.html#USER_Monitoring.OS.IAMRole">To
    ///           create an IAM role for Amazon RDS Enhanced Monitoring</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///          <p>If <code>MonitoringInterval</code> is set to a value other than 0, then you must supply a <code>MonitoringRoleArn</code> value.</p>
    public let monitoringRoleArn: String?
    /// <p>A value that indicates whether the DB instance is a Multi-AZ deployment.
    ///     Changing this parameter doesn't result in an outage and the change
    ///     is applied during the next maintenance window
    ///     unless the <code>ApplyImmediately</code> parameter is
    ///         enabled for this request.
    ///     </p>
    public let multiAZ: Bool?
    /// <p>
    ///             The new DB instance identifier for the DB instance when renaming a DB
    ///             instance. When you change the DB instance identifier, an instance
    ///             reboot occurs immediately if you enable <code>ApplyImmediately</code>, or will occur
    ///             during the next maintenance window if you disable Apply Immediately. This value is stored
    ///             as a lowercase string.
    ///         </p>
    ///
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>The first character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>mydbinstance</code>
    ///          </p>
    public let newDBInstanceIdentifier: String?
    /// <p>
    ///             A value that indicates the DB instance should be associated with the specified option group.
    ///             Changing this parameter doesn't result in an outage except in the following case and the change
    ///             is applied during the next maintenance window
    ///             unless the <code>ApplyImmediately</code> parameter is enabled
    ///             for this request. If the parameter change results in an option group that
    ///             enables OEM, this change can cause a brief (sub-second) period during which new connections
    ///             are rejected but existing connections are not interrupted.
    ///         </p>
    ///          <p>Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance once it is associated with a DB instance</p>
    public let optionGroupName: String?
    /// <p>The AWS KMS key identifier for encryption of Performance Insights data.</p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    ///         <p>If you do not specify a value for <code>PerformanceInsightsKMSKeyId</code>, then Amazon RDS
    ///             uses your default CMK. There is a default CMK for your AWS account.
    ///             Your AWS account has a different default CMK for each AWS Region.</p>
    public let performanceInsightsKMSKeyId: String?
    /// <p>The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years). </p>
    public let performanceInsightsRetentionPeriod: Int?
    /// <p>
    ///         The daily time range during which automated backups are created
    ///         if automated backups are enabled,
    ///         as determined by the <code>BackupRetentionPeriod</code> parameter.
    ///         Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible.
    ///         The default is a 30-minute window selected at random from an
    ///         8-hour block of time for each AWS Region. For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow">Backup window</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///         <p>Not applicable. The daily time range for creating automated backups is managed by
    ///             the DB cluster. For more information, see <code>ModifyDBCluster</code>.</p>
    ///
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be in the format hh24:mi-hh24:mi</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Time Coordinated (UTC)</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: String?
    /// <p>The weekly time range (in UTC) during which system maintenance can occur, which
    ///             might result in an outage. Changing this parameter doesn't result in an outage, except
    ///             in the following situation, and the change is asynchronously applied as soon as
    ///             possible. If there are pending actions that cause a reboot, and the maintenance window
    ///             is changed to include the current time, then changing this parameter will cause a reboot
    ///             of the DB instance. If moving this window to the current time, there must be at least 30
    ///             minutes between the current time and end of the window to ensure pending changes are
    ///             applied.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance">Amazon RDS Maintenance Window</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///          <p>Default: Uses existing setting</p>
    ///          <p>Format: ddd:hh24:mi-ddd:hh24:mi</p>
    ///          <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
    ///          <p>Constraints: Must be at least 30 minutes</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    public let processorFeatures: [ProcessorFeature]?
    /// <p>A value that specifies the order in which an Aurora Replica is promoted to the primary instance
    ///       after a failure of the existing primary instance. For more information,
    ///       see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance">
    ///           Fault Tolerance for an Aurora DB Cluster</a> in the <i>Amazon Aurora User Guide</i>.
    ///     </p>
    ///          <p>Default: 1</p>
    ///          <p>Valid Values: 0 - 15</p>
    public let promotionTier: Int?
    /// <p>A value that indicates whether the DB instance is publicly accessible.
    ///       </p>
    ///          <p>When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///           and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///           and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.</p>
    ///          <p>When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.</p>
    ///          <p>
    ///             <code>PubliclyAccessible</code> only applies to DB instances in a VPC.
    ///       The DB instance must be part of a public subnet and
    ///       <code>PubliclyAccessible</code> must be enabled for it to be publicly accessible.
    ///       </p>
    ///          <p>Changes to the <code>PubliclyAccessible</code> parameter are applied immediately regardless
    ///       of the value of the <code>ApplyImmediately</code> parameter.</p>
    public let publiclyAccessible: Bool?
    /// <p>A value that sets the open mode of a replica database to either mounted or read-only.</p>
    ///         <note>
    ///             <p>Currently, this parameter is only supported for Oracle DB instances.</p>
    ///         </note>
    ///         <p>Mounted DB replicas are included in Oracle Enterprise Edition. The main use case for
    ///             mounted replicas is cross-Region disaster recovery. The primary database doesn't use
    ///             Active Data Guard to transmit information to the mounted replica. Because it doesn't
    ///             accept user connections, a mounted replica can't serve a read-only workload.
    ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html">Working with Oracle Read Replicas for Amazon RDS</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    public let replicaMode: ReplicaMode?
    /// <p>Specifies the storage type to be associated with the DB instance.
    ///       </p>
    ///          <p>If you specify Provisioned IOPS (<code>io1</code>),
    ///           you must also include a value for the <code>Iops</code> parameter.
    ///       </p>
    ///          <p>If you choose to migrate your DB instance from using standard storage to using
    ///             Provisioned IOPS, or from using Provisioned IOPS to using standard storage, the process
    ///             can take time. The duration of the migration depends on several factors such as database
    ///             load, storage size, storage type (standard or Provisioned IOPS), amount of IOPS
    ///             provisioned (if any), and the number of prior scale storage operations. Typical
    ///             migration times are under 24 hours, but the process can take up to several days in some
    ///             cases. During the migration, the DB instance is available for use, but might experience
    ///             performance degradation. While the migration takes place, nightly backups for the
    ///             instance are suspended. No other Amazon RDS operations can take place for the instance,
    ///             including modifying the instance, rebooting the instance, deleting the instance,
    ///             creating a read replica for the instance, and creating a DB snapshot of the instance. </p>
    ///          <p>
    ///           Valid values: <code>standard | gp2 | io1</code>
    ///          </p>
    ///          <p>Default: <code>io1</code> if the <code>Iops</code> parameter
    ///           is specified, otherwise <code>gp2</code>
    ///          </p>
    public let storageType: String?
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>The password for the given ARN from the key store in order to access the device.</p>
    public let tdeCredentialPassword: String?
    /// <p>A value that indicates whether the DB instance class of the DB instance uses its default
    ///             processor features.</p>
    public let useDefaultProcessorFeatures: Bool?
    /// <p>A list of EC2 VPC security groups to authorize on this DB instance. This change is asynchronously applied as soon as possible.</p>
    ///          <p>
    ///             <b>Amazon Aurora</b>
    ///          </p>
    ///          <p>Not applicable. The associated list of EC2 VPC security groups is managed by
    ///           the DB cluster. For more information, see <code>ModifyDBCluster</code>.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match existing VpcSecurityGroupIds.</p>
    ///             </li>
    ///          </ul>
    public let vpcSecurityGroupIds: [String]?

    public init (
        allocatedStorage: Int? = nil,
        allowMajorVersionUpgrade: Bool = false,
        applyImmediately: Bool = false,
        autoMinorVersionUpgrade: Bool? = nil,
        awsBackupRecoveryPointArn: String? = nil,
        backupRetentionPeriod: Int? = nil,
        cACertificateIdentifier: String? = nil,
        certificateRotationRestart: Bool? = nil,
        cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBParameterGroupName: String? = nil,
        dBPortNumber: Int? = nil,
        dBSecurityGroups: [String]? = nil,
        dBSubnetGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableCustomerOwnedIp: Bool? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        enablePerformanceInsights: Bool? = nil,
        engineVersion: String? = nil,
        iops: Int? = nil,
        licenseModel: String? = nil,
        masterUserPassword: String? = nil,
        maxAllocatedStorage: Int? = nil,
        monitoringInterval: Int? = nil,
        monitoringRoleArn: String? = nil,
        multiAZ: Bool? = nil,
        newDBInstanceIdentifier: String? = nil,
        optionGroupName: String? = nil,
        performanceInsightsKMSKeyId: String? = nil,
        performanceInsightsRetentionPeriod: Int? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        processorFeatures: [ProcessorFeature]? = nil,
        promotionTier: Int? = nil,
        publiclyAccessible: Bool? = nil,
        replicaMode: ReplicaMode? = nil,
        storageType: String? = nil,
        tdeCredentialArn: String? = nil,
        tdeCredentialPassword: String? = nil,
        useDefaultProcessorFeatures: Bool? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cACertificateIdentifier = cACertificateIdentifier
        self.certificateRotationRestart = certificateRotationRestart
        self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBParameterGroupName = dBParameterGroupName
        self.dBPortNumber = dBPortNumber
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engineVersion = engineVersion
        self.iops = iops
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.newDBInstanceIdentifier = newDBInstanceIdentifier
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.processorFeatures = processorFeatures
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.replicaMode = replicaMode
        self.storageType = storageType
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFoundFault" : self = .certificateNotFoundFault(try CertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExistsFault" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBUpgradeDependencyFailureFault" : self = .dBUpgradeDependencyFailureFault(try DBUpgradeDependencyFailureFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacityFault" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupStateFault" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupportedFault" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBInstanceOutputError: Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case certificateNotFoundFault(CertificateNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBUpgradeDependencyFailureFault(DBUpgradeDependencyFailureFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBInstanceOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension ModifyDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct ModifyDBInstanceOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB instance.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
    ///       </p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct ModifyDBInstanceOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension ModifyDBInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct ModifyDBParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBParameterGroupOutputError>
}

extension ModifyDBParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBParameterGroupInput(dBParameterGroupName: \(String(describing: dBParameterGroupName)), parameters: \(String(describing: parameters)))"}
}

extension ModifyDBParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBParameterGroupOutputError>
}

public struct ModifyDBParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBParameterGroupOutputError>
}

/// <p></p>
public struct ModifyDBParameterGroupInput: Equatable {
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing <code>DBParameterGroup</code>.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>An array of parameter names, values, and the application methods for the parameter update. At least one parameter name, value, and
    ///           application method method must be supplied; later arguments are optional. A maximum of 20 parameters can be modified in a single request.</p>
    ///          <p>Valid Values (for the application method): <code>immediate | pending-reboot</code>
    ///          </p>
    ///          <note>
    ///             <p>You can use the <code>immediate</code> value with dynamic parameters only. You can use the
    ///               <code>pending-reboot</code> value for both dynamic and static parameters.</p>
    ///             <p>When the application method is <code>immediate</code>, changes to dynamic parameters are applied immediately
    ///           to the DB instances associated with the parameter group. When the application method is <code>pending-reboot</code>,
    ///           changes to dynamic and static parameters are applied after a reboot without failover to the DB instances associated with the
    ///           parameter group.</p>
    ///          </note>
    public let parameters: [Parameter]?

    public init (
        dBParameterGroupName: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameters = parameters
    }
}

extension ModifyDBParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBParameterGroupOutputResponse(dBParameterGroupName: \(String(describing: dBParameterGroupName)))"}
}

extension ModifyDBParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBParameterGroupName = output.dBParameterGroupName
        } else {
            self.dBParameterGroupName = nil
        }
    }
}

/// <p>
///         Contains the result of a successful invocation of the
///         <code>ModifyDBParameterGroup</code> or <code>ResetDBParameterGroup</code> action.
///         </p>
public struct ModifyDBParameterGroupOutputResponse: Equatable {
    /// <p>The name of the DB parameter group.</p>
    public let dBParameterGroupName: String?

    public init (
        dBParameterGroupName: String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

struct ModifyDBParameterGroupOutputResponseBody: Equatable {
    public let dBParameterGroupName: String?
}

extension ModifyDBParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBParameterGroupResult"))
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
    }
}

public struct ModifyDBProxyEndpointInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBProxyEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBProxyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBProxyEndpointInput>
    public typealias MOutput = OperationOutput<ModifyDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBProxyEndpointOutputError>
}

extension ModifyDBProxyEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBProxyEndpointInput(dBProxyEndpointName: \(String(describing: dBProxyEndpointName)), newDBProxyEndpointName: \(String(describing: newDBProxyEndpointName)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyDBProxyEndpointInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: Key("DBProxyEndpointName"))
        }
        if let newDBProxyEndpointName = newDBProxyEndpointName {
            try container.encode(newDBProxyEndpointName, forKey: Key("NewDBProxyEndpointName"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBProxyEndpoint", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBProxyEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBProxyEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBProxyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBProxyEndpointInput>
    public typealias MOutput = OperationOutput<ModifyDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBProxyEndpointOutputError>
}

public struct ModifyDBProxyEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBProxyEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBProxyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBProxyEndpointInput>
    public typealias MOutput = OperationOutput<ModifyDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBProxyEndpointOutputError>
}

public struct ModifyDBProxyEndpointInput: Equatable {
    /// <p>The name of the DB proxy sociated with the DB proxy endpoint that you want to modify.</p>
    public let dBProxyEndpointName: String?
    /// <p>The new identifier for the <code>DBProxyEndpoint</code>. An identifier must
    ///         begin with a letter and must contain only ASCII letters, digits, and hyphens; it
    ///         can't end with a hyphen or contain two consecutive hyphens.</p>
    public let newDBProxyEndpointName: String?
    /// <p>The VPC security group IDs for the DB proxy endpoint. When the DB proxy endpoint
    ///         uses a different VPC than the original proxy, you also specify a different
    ///         set of security group IDs than for the original proxy.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        dBProxyEndpointName: String? = nil,
        newDBProxyEndpointName: String? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
        self.newDBProxyEndpointName = newDBProxyEndpointName
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyDBProxyEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBProxyEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointAlreadyExistsFault" : self = .dBProxyEndpointAlreadyExistsFault(try DBProxyEndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyEndpointNotFoundFault" : self = .dBProxyEndpointNotFoundFault(try DBProxyEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyEndpointStateFault" : self = .invalidDBProxyEndpointStateFault(try InvalidDBProxyEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBProxyEndpointOutputError: Equatable {
    case dBProxyEndpointAlreadyExistsFault(DBProxyEndpointAlreadyExistsFault)
    case dBProxyEndpointNotFoundFault(DBProxyEndpointNotFoundFault)
    case invalidDBProxyEndpointStateFault(InvalidDBProxyEndpointStateFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBProxyEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBProxyEndpointOutputResponse(dBProxyEndpoint: \(String(describing: dBProxyEndpoint)))"}
}

extension ModifyDBProxyEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBProxyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBProxyEndpoint = output.dBProxyEndpoint
        } else {
            self.dBProxyEndpoint = nil
        }
    }
}

public struct ModifyDBProxyEndpointOutputResponse: Equatable {
    /// <p>The <code>DBProxyEndpoint</code> object representing the new settings for the DB proxy endpoint.</p>
    public let dBProxyEndpoint: DBProxyEndpoint?

    public init (
        dBProxyEndpoint: DBProxyEndpoint? = nil
    )
    {
        self.dBProxyEndpoint = dBProxyEndpoint
    }
}

struct ModifyDBProxyEndpointOutputResponseBody: Equatable {
    public let dBProxyEndpoint: DBProxyEndpoint?
}

extension ModifyDBProxyEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBProxyEndpoint = "DBProxyEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBProxyEndpointResult"))
        let dBProxyEndpointDecoded = try containerValues.decodeIfPresent(DBProxyEndpoint.self, forKey: .dBProxyEndpoint)
        dBProxyEndpoint = dBProxyEndpointDecoded
    }
}

public struct ModifyDBProxyInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBProxyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBProxyInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBProxyInput>
    public typealias MOutput = OperationOutput<ModifyDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBProxyOutputError>
}

extension ModifyDBProxyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBProxyInput(auth: \(String(describing: auth)), dBProxyName: \(String(describing: dBProxyName)), debugLogging: \(String(describing: debugLogging)), idleClientTimeout: \(String(describing: idleClientTimeout)), newDBProxyName: \(String(describing: newDBProxyName)), requireTLS: \(String(describing: requireTLS)), roleArn: \(String(describing: roleArn)), securityGroups: \(String(describing: securityGroups)))"}
}

extension ModifyDBProxyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let auth = auth {
            var authContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Auth"))
            for (index0, userauthconfig0) in auth.enumerated() {
                try authContainer.encode(userauthconfig0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if let debugLogging = debugLogging {
            try container.encode(debugLogging, forKey: Key("DebugLogging"))
        }
        if let idleClientTimeout = idleClientTimeout {
            try container.encode(idleClientTimeout, forKey: Key("IdleClientTimeout"))
        }
        if let newDBProxyName = newDBProxyName {
            try container.encode(newDBProxyName, forKey: Key("NewDBProxyName"))
        }
        if let requireTLS = requireTLS {
            try container.encode(requireTLS, forKey: Key("RequireTLS"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroups"))
            for (index0, string0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBProxy", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBProxyInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBProxyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBProxyInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBProxyInput>
    public typealias MOutput = OperationOutput<ModifyDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBProxyOutputError>
}

public struct ModifyDBProxyInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBProxyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBProxyInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBProxyInput>
    public typealias MOutput = OperationOutput<ModifyDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBProxyOutputError>
}

public struct ModifyDBProxyInput: Equatable {
    /// <p>The new authentication settings for the <code>DBProxy</code>.</p>
    public let auth: [UserAuthConfig]?
    /// <p>The identifier for the <code>DBProxy</code> to modify.</p>
    public let dBProxyName: String?
    /// <p>Whether the proxy includes detailed information about SQL statements in its logs.
    ///         This information helps you to debug issues involving SQL behavior or the performance
    ///         and scalability of the proxy connections. The debug information includes the text of
    ///         SQL statements that you submit through the proxy. Thus, only enable this setting
    ///         when needed for debugging, and only when you have security measures in place to
    ///         safeguard any sensitive information that appears in the logs.</p>
    public let debugLogging: Bool?
    /// <p>The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this
    ///         value higher or lower than the connection timeout limit for the associated database.</p>
    public let idleClientTimeout: Int?
    /// <p>The new identifier for the <code>DBProxy</code>. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.</p>
    public let newDBProxyName: String?
    /// <p>Whether Transport Layer Security (TLS) encryption is required for connections to the proxy.
    ///         By enabling this setting, you can enforce encrypted TLS connections to the proxy, even if the associated database doesn't
    ///         use TLS.</p>
    public let requireTLS: Bool?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in AWS Secrets Manager.</p>
    public let roleArn: String?
    /// <p>The new list of security groups for the <code>DBProxy</code>.</p>
    public let securityGroups: [String]?

    public init (
        auth: [UserAuthConfig]? = nil,
        dBProxyName: String? = nil,
        debugLogging: Bool? = nil,
        idleClientTimeout: Int? = nil,
        newDBProxyName: String? = nil,
        requireTLS: Bool? = nil,
        roleArn: String? = nil,
        securityGroups: [String]? = nil
    )
    {
        self.auth = auth
        self.dBProxyName = dBProxyName
        self.debugLogging = debugLogging
        self.idleClientTimeout = idleClientTimeout
        self.newDBProxyName = newDBProxyName
        self.requireTLS = requireTLS
        self.roleArn = roleArn
        self.securityGroups = securityGroups
    }
}

extension ModifyDBProxyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBProxyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyAlreadyExistsFault" : self = .dBProxyAlreadyExistsFault(try DBProxyAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBProxyOutputError: Equatable {
    case dBProxyAlreadyExistsFault(DBProxyAlreadyExistsFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBProxyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBProxyOutputResponse(dBProxy: \(String(describing: dBProxy)))"}
}

extension ModifyDBProxyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBProxyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBProxy = output.dBProxy
        } else {
            self.dBProxy = nil
        }
    }
}

public struct ModifyDBProxyOutputResponse: Equatable {
    /// <p>The <code>DBProxy</code> object representing the new settings for the proxy.</p>
    public let dBProxy: DBProxy?

    public init (
        dBProxy: DBProxy? = nil
    )
    {
        self.dBProxy = dBProxy
    }
}

struct ModifyDBProxyOutputResponseBody: Equatable {
    public let dBProxy: DBProxy?
}

extension ModifyDBProxyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBProxy = "DBProxy"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBProxyResult"))
        let dBProxyDecoded = try containerValues.decodeIfPresent(DBProxy.self, forKey: .dBProxy)
        dBProxy = dBProxyDecoded
    }
}

public struct ModifyDBProxyTargetGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBProxyTargetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBProxyTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBProxyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBProxyTargetGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBProxyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBProxyTargetGroupOutputError>
}

extension ModifyDBProxyTargetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBProxyTargetGroupInput(connectionPoolConfig: \(String(describing: connectionPoolConfig)), dBProxyName: \(String(describing: dBProxyName)), newName: \(String(describing: newName)), targetGroupName: \(String(describing: targetGroupName)))"}
}

extension ModifyDBProxyTargetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let connectionPoolConfig = connectionPoolConfig {
            try container.encode(connectionPoolConfig, forKey: Key("ConnectionPoolConfig"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if let newName = newName {
            try container.encode(newName, forKey: Key("NewName"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: Key("TargetGroupName"))
        }
        try container.encode("ModifyDBProxyTargetGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBProxyTargetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBProxyTargetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBProxyTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBProxyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBProxyTargetGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBProxyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBProxyTargetGroupOutputError>
}

public struct ModifyDBProxyTargetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBProxyTargetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBProxyTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBProxyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBProxyTargetGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBProxyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBProxyTargetGroupOutputError>
}

public struct ModifyDBProxyTargetGroupInput: Equatable {
    /// <p>The settings that determine the size and behavior of the connection pool for the target group.</p>
    public let connectionPoolConfig: ConnectionPoolConfiguration?
    /// <p>The name of the new proxy to which to assign the target group.</p>
    public let dBProxyName: String?
    /// <p>The new name for the modified <code>DBProxyTarget</code>. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.</p>
    public let newName: String?
    /// <p>The name of the new target group to assign to the proxy.</p>
    public let targetGroupName: String?

    public init (
        connectionPoolConfig: ConnectionPoolConfiguration? = nil,
        dBProxyName: String? = nil,
        newName: String? = nil,
        targetGroupName: String? = nil
    )
    {
        self.connectionPoolConfig = connectionPoolConfig
        self.dBProxyName = dBProxyName
        self.newName = newName
        self.targetGroupName = targetGroupName
    }
}

extension ModifyDBProxyTargetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBProxyTargetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBProxyTargetGroupOutputError: Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBProxyTargetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBProxyTargetGroupOutputResponse(dBProxyTargetGroup: \(String(describing: dBProxyTargetGroup)))"}
}

extension ModifyDBProxyTargetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBProxyTargetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBProxyTargetGroup = output.dBProxyTargetGroup
        } else {
            self.dBProxyTargetGroup = nil
        }
    }
}

public struct ModifyDBProxyTargetGroupOutputResponse: Equatable {
    /// <p>The settings of the modified <code>DBProxyTarget</code>.</p>
    public let dBProxyTargetGroup: DBProxyTargetGroup?

    public init (
        dBProxyTargetGroup: DBProxyTargetGroup? = nil
    )
    {
        self.dBProxyTargetGroup = dBProxyTargetGroup
    }
}

struct ModifyDBProxyTargetGroupOutputResponseBody: Equatable {
    public let dBProxyTargetGroup: DBProxyTargetGroup?
}

extension ModifyDBProxyTargetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBProxyTargetGroup = "DBProxyTargetGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBProxyTargetGroupResult"))
        let dBProxyTargetGroupDecoded = try containerValues.decodeIfPresent(DBProxyTargetGroup.self, forKey: .dBProxyTargetGroup)
        dBProxyTargetGroup = dBProxyTargetGroupDecoded
    }
}

public struct ModifyDBSnapshotAttributeInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBSnapshotAttributeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSnapshotAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSnapshotAttributeInput>
    public typealias MOutput = OperationOutput<ModifyDBSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSnapshotAttributeOutputError>
}

extension ModifyDBSnapshotAttributeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBSnapshotAttributeInput(attributeName: \(String(describing: attributeName)), dBSnapshotIdentifier: \(String(describing: dBSnapshotIdentifier)), valuesToAdd: \(String(describing: valuesToAdd)), valuesToRemove: \(String(describing: valuesToRemove)))"}
}

extension ModifyDBSnapshotAttributeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: Key("DBSnapshotIdentifier"))
        }
        if let valuesToAdd = valuesToAdd {
            var valuesToAddContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValuesToAdd"))
            for (index0, string0) in valuesToAdd.enumerated() {
                try valuesToAddContainer.encode(string0, forKey: Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        if let valuesToRemove = valuesToRemove {
            var valuesToRemoveContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValuesToRemove"))
            for (index0, string0) in valuesToRemove.enumerated() {
                try valuesToRemoveContainer.encode(string0, forKey: Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBSnapshotAttribute", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBSnapshotAttributeInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBSnapshotAttributeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSnapshotAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSnapshotAttributeInput>
    public typealias MOutput = OperationOutput<ModifyDBSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSnapshotAttributeOutputError>
}

public struct ModifyDBSnapshotAttributeInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBSnapshotAttributeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSnapshotAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSnapshotAttributeInput>
    public typealias MOutput = OperationOutput<ModifyDBSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSnapshotAttributeOutputError>
}

/// <p></p>
public struct ModifyDBSnapshotAttributeInput: Equatable {
    /// <p>The name of the DB snapshot attribute to modify.</p>
    ///          <p>To manage authorization for other AWS accounts to copy or restore a manual DB snapshot,
    ///       set this value to <code>restore</code>.</p>
    ///          <note>
    ///             <p>To view the list of attributes available to modify, use the
    ///               <a>DescribeDBSnapshotAttributes</a> API action.</p>
    ///          </note>
    public let attributeName: String?
    /// <p>The identifier for the DB snapshot to modify the attributes for.</p>
    public let dBSnapshotIdentifier: String?
    /// <p>A list of DB snapshot attributes to add to the attribute specified by <code>AttributeName</code>.</p>
    ///          <p>To authorize other AWS accounts to copy or restore a manual snapshot, set this list to include one or more AWS account
    ///       IDs, or <code>all</code> to make the manual DB snapshot restorable by
    ///       any AWS account. Do not add the <code>all</code> value for any
    ///       manual DB snapshots that contain private information that you don't want available
    ///       to all AWS accounts.</p>
    public let valuesToAdd: [String]?
    /// <p>A list of DB snapshot attributes to remove from the attribute specified by <code>AttributeName</code>.</p>
    ///          <p>To remove authorization for other AWS accounts to copy or restore a manual snapshot, set this list to include
    ///       one or more AWS account
    ///       identifiers, or <code>all</code> to remove authorization for any AWS account to copy or
    ///       restore the DB snapshot. If you specify <code>all</code>, an AWS account whose
    ///       account ID is explicitly added to the <code>restore</code> attribute
    ///       can still copy or restore the manual DB snapshot.</p>
    public let valuesToRemove: [String]?

    public init (
        attributeName: String? = nil,
        dBSnapshotIdentifier: String? = nil,
        valuesToAdd: [String]? = nil,
        valuesToRemove: [String]? = nil
    )
    {
        self.attributeName = attributeName
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.valuesToAdd = valuesToAdd
        self.valuesToRemove = valuesToRemove
    }
}

extension ModifyDBSnapshotAttributeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBSnapshotAttributeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotStateFault" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SharedSnapshotQuotaExceededFault" : self = .sharedSnapshotQuotaExceededFault(try SharedSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBSnapshotAttributeOutputError: Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case sharedSnapshotQuotaExceededFault(SharedSnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBSnapshotAttributeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBSnapshotAttributeOutputResponse(dBSnapshotAttributesResult: \(String(describing: dBSnapshotAttributesResult)))"}
}

extension ModifyDBSnapshotAttributeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBSnapshotAttributeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSnapshotAttributesResult = output.dBSnapshotAttributesResult
        } else {
            self.dBSnapshotAttributesResult = nil
        }
    }
}

public struct ModifyDBSnapshotAttributeOutputResponse: Equatable {
    /// <p>Contains the results of a successful call to the <code>DescribeDBSnapshotAttributes</code>
    ///     API action.</p>
    ///          <p>Manual DB snapshot attributes are used to authorize other AWS accounts
    ///       to copy or restore a manual DB snapshot. For more information, see the <code>ModifyDBSnapshotAttribute</code>
    ///       API action.</p>
    public let dBSnapshotAttributesResult: DBSnapshotAttributesResult?

    public init (
        dBSnapshotAttributesResult: DBSnapshotAttributesResult? = nil
    )
    {
        self.dBSnapshotAttributesResult = dBSnapshotAttributesResult
    }
}

struct ModifyDBSnapshotAttributeOutputResponseBody: Equatable {
    public let dBSnapshotAttributesResult: DBSnapshotAttributesResult?
}

extension ModifyDBSnapshotAttributeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSnapshotAttributesResult = "DBSnapshotAttributesResult"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBSnapshotAttributeResult"))
        let dBSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(DBSnapshotAttributesResult.self, forKey: .dBSnapshotAttributesResult)
        dBSnapshotAttributesResult = dBSnapshotAttributesResultDecoded
    }
}

public struct ModifyDBSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSnapshotInput>
    public typealias MOutput = OperationOutput<ModifyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSnapshotOutputError>
}

extension ModifyDBSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBSnapshotInput(dBSnapshotIdentifier: \(String(describing: dBSnapshotIdentifier)), engineVersion: \(String(describing: engineVersion)), optionGroupName: \(String(describing: optionGroupName)))"}
}

extension ModifyDBSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: Key("DBSnapshotIdentifier"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        try container.encode("ModifyDBSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSnapshotInput>
    public typealias MOutput = OperationOutput<ModifyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSnapshotOutputError>
}

public struct ModifyDBSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSnapshotInput>
    public typealias MOutput = OperationOutput<ModifyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSnapshotOutputError>
}

public struct ModifyDBSnapshotInput: Equatable {
    /// <p>The identifier of the DB snapshot to modify.</p>
    public let dBSnapshotIdentifier: String?
    /// <p>The engine version to upgrade the DB snapshot to.
    ///       </p>
    ///
    ///          <p>The following are the database engines and engine versions that are available when you upgrade a DB snapshot.
    ///       </p>
    ///
    ///          <p>
    ///             <b>MySQL</b>
    ///          </p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>5.5.46</code> (supported for 5.1 DB snapshots)</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>12.1.0.2.v8</code>  (supported for 12.1.0.1 DB snapshots)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>11.2.0.4.v12</code> (supported for 11.2.0.2 DB snapshots)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>11.2.0.4.v11</code> (supported for 11.2.0.3 DB snapshots)</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>
    ///             <b>PostgreSQL</b>
    ///          </p>
    ///          <p>For the list of engine versions that are available for upgrading a DB snapshot, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.PostgreSQL.html#USER_UpgradeDBInstance.PostgreSQL.MajorVersion">
    ///               Upgrading the PostgreSQL DB Engine for Amazon RDS</a>.
    ///       </p>
    public let engineVersion: String?
    /// <p>The option group to identify with the upgraded DB snapshot.
    ///         </p>
    ///
    ///         <p>You can specify this parameter when you upgrade an Oracle DB snapshot.
    ///             The same option group considerations apply when upgrading a DB snapshot as when upgrading a DB instance.
    ///             For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Oracle.html#USER_UpgradeDBInstance.Oracle.OGPG.OG">Option group considerations</a> in the <i>Amazon RDS User Guide.</i>
    ///         </p>
    public let optionGroupName: String?

    public init (
        dBSnapshotIdentifier: String? = nil,
        engineVersion: String? = nil,
        optionGroupName: String? = nil
    )
    {
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.engineVersion = engineVersion
        self.optionGroupName = optionGroupName
    }
}

extension ModifyDBSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBSnapshotOutputError: Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBSnapshotOutputResponse(dBSnapshot: \(String(describing: dBSnapshot)))"}
}

extension ModifyDBSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct ModifyDBSnapshotOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB snapshot.
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBSnapshots</code> action.
    ///       </p>
    public let dBSnapshot: DBSnapshot?

    public init (
        dBSnapshot: DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct ModifyDBSnapshotOutputResponseBody: Equatable {
    public let dBSnapshot: DBSnapshot?
}

extension ModifyDBSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

public struct ModifyDBSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSubnetGroupOutputError>
}

extension ModifyDBSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBSubnetGroupInput(dBSubnetGroupDescription: \(String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), subnetIds: \(String(describing: subnetIds)))"}
}

extension ModifyDBSubnetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBSubnetGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSubnetGroupOutputError>
}

public struct ModifyDBSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSubnetGroupOutputError>
}

/// <p></p>
public struct ModifyDBSubnetGroupInput: Equatable {
    /// <p>The description for the DB subnet group.</p>
    public let dBSubnetGroupDescription: String?
    /// <p>The name for the DB subnet group. This value is stored as a lowercase string.
    ///           You can't modify the default subnet group.
    ///       </p>
    ///          <p>Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>The EC2 subnet IDs for the DB subnet group.</p>
    public let subnetIds: [String]?

    public init (
        dBSubnetGroupDescription: String? = nil,
        dBSubnetGroupName: String? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetIds = subnetIds
    }
}

extension ModifyDBSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetQuotaExceededFault" : self = .dBSubnetQuotaExceededFault(try DBSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetAlreadyInUse" : self = .subnetAlreadyInUse(try SubnetAlreadyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBSubnetGroupOutputError: Equatable {
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case dBSubnetQuotaExceededFault(DBSubnetQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case subnetAlreadyInUse(SubnetAlreadyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBSubnetGroupOutputResponse(dBSubnetGroup: \(String(describing: dBSubnetGroup)))"}
}

extension ModifyDBSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSubnetGroup = output.dBSubnetGroup
        } else {
            self.dBSubnetGroup = nil
        }
    }
}

public struct ModifyDBSubnetGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB subnet group.
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBSubnetGroups</code> action.
    ///       </p>
    public let dBSubnetGroup: DBSubnetGroup?

    public init (
        dBSubnetGroup: DBSubnetGroup? = nil
    )
    {
        self.dBSubnetGroup = dBSubnetGroup
    }
}

struct ModifyDBSubnetGroupOutputResponseBody: Equatable {
    public let dBSubnetGroup: DBSubnetGroup?
}

extension ModifyDBSubnetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSubnetGroup = "DBSubnetGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBSubnetGroupResult"))
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
    }
}

public struct ModifyEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

extension ModifyEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEventSubscriptionInput(enabled: \(String(describing: enabled)), eventCategories: \(String(describing: eventCategories)), snsTopicArn: \(String(describing: snsTopicArn)), sourceType: \(String(describing: sourceType)), subscriptionName: \(String(describing: subscriptionName)))"}
}

extension ModifyEventSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: Key("SnsTopicArn"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("ModifyEventSubscription", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

public struct ModifyEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

/// <p></p>
public struct ModifyEventSubscriptionInput: Equatable {
    /// <p>
    ///             A value that indicates whether to activate the subscription.
    ///       </p>
    public let enabled: Bool?
    /// <p>
    ///             A list of event categories for a source type (<code>SourceType</code>) that you want to subscribe to.
    ///             You can see a list of the categories for a given source type
    ///             in <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.html">Events</a> in the <i>Amazon RDS User Guide</i>
    ///             or by using the <code>DescribeEventCategories</code> operation.
    ///         </p>
    public let eventCategories: [String]?
    /// <p>The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.</p>
    public let snsTopicArn: String?
    /// <p>The type of source that is generating the events. For example, if you want to be notified of events generated by a DB instance, you would set this parameter to db-instance. If this value isn't specified, all events are returned.</p>
    ///          <p>Valid values: <code>db-instance</code> | <code>db-cluster</code> | <code>db-parameter-group</code> | <code>db-security-group</code> | <code>db-snapshot</code> | <code>db-cluster-snapshot</code>
    ///          </p>
    public let sourceType: String?
    /// <p>The name of the RDS event notification subscription.</p>
    public let subscriptionName: String?

    public init (
        enabled: Bool? = nil,
        eventCategories: [String]? = nil,
        snsTopicArn: String? = nil,
        sourceType: String? = nil,
        subscriptionName: String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

extension ModifyEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceededFault" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFoundFault" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFoundFault" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEventSubscriptionOutputError: Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEventSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension ModifyEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct ModifyEventSubscriptionOutputResponse: Equatable {
    /// <p>Contains the results of a successful invocation of the <code>DescribeEventSubscriptions</code> action.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct ModifyEventSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension ModifyEventSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct ModifyGlobalClusterInputBodyMiddleware: Middleware {
    public let id: String = "ModifyGlobalClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyGlobalClusterInput>
    public typealias MOutput = OperationOutput<ModifyGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyGlobalClusterOutputError>
}

extension ModifyGlobalClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyGlobalClusterInput(allowMajorVersionUpgrade: \(String(describing: allowMajorVersionUpgrade)), deletionProtection: \(String(describing: deletionProtection)), engineVersion: \(String(describing: engineVersion)), globalClusterIdentifier: \(String(describing: globalClusterIdentifier)), newGlobalClusterIdentifier: \(String(describing: newGlobalClusterIdentifier)))"}
}

extension ModifyGlobalClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allowMajorVersionUpgrade = allowMajorVersionUpgrade {
            try container.encode(allowMajorVersionUpgrade, forKey: Key("AllowMajorVersionUpgrade"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: Key("GlobalClusterIdentifier"))
        }
        if let newGlobalClusterIdentifier = newGlobalClusterIdentifier {
            try container.encode(newGlobalClusterIdentifier, forKey: Key("NewGlobalClusterIdentifier"))
        }
        try container.encode("ModifyGlobalCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyGlobalClusterInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyGlobalClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyGlobalClusterInput>
    public typealias MOutput = OperationOutput<ModifyGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyGlobalClusterOutputError>
}

public struct ModifyGlobalClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyGlobalClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyGlobalClusterInput>
    public typealias MOutput = OperationOutput<ModifyGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyGlobalClusterOutputError>
}

public struct ModifyGlobalClusterInput: Equatable {
    /// <p>A value that indicates whether major version upgrades are allowed.</p>
    ///          <p>Constraints: You must allow major version upgrades when specifying a value for the
    ///                 <code>EngineVersion</code> parameter that is a different major version than the DB
    ///             cluster's current version.</p>
    ///          <p>If you upgrade the major version of a global database, the cluster and DB instance parameter
    ///         groups are set to the default parameter groups for the new version. Apply any custom parameter
    ///         groups after completing the upgrade.</p>
    public let allowMajorVersionUpgrade: Bool?
    /// <p>
    ///         Indicates if the global database cluster has deletion protection enabled. The global database cluster
    ///         can't be deleted when deletion protection is enabled.
    ///       </p>
    public let deletionProtection: Bool?
    /// <p>The version number of the database engine to which you want to upgrade.
    ///           Changing this parameter results in an outage. The change is applied during
    ///           the next maintenance window unless <code>ApplyImmediately</code> is enabled.</p>
    ///          <p>To list all of the available engine versions for <code>aurora</code> (for MySQL 5.6-compatible Aurora), use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora --query '*[]|[?SupportsGlobalDatabases == `true`].[EngineVersion]'</code>
    ///          </p>
    ///          <p>To list all of the available engine versions for <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora), use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora-mysql --query '*[]|[?SupportsGlobalDatabases == `true`].[EngineVersion]'</code>
    ///          </p>
    ///          <p>To list all of the available engine versions for <code>aurora-postgresql</code>, use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora-postgresql --query '*[]|[?SupportsGlobalDatabases == `true`].[EngineVersion]'</code>
    ///          </p>
    public let engineVersion: String?
    /// <p>
    ///         The DB cluster identifier for the global cluster being modified. This parameter isn't case-sensitive.
    ///       </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing global database cluster.</p>
    ///             </li>
    ///          </ul>
    public let globalClusterIdentifier: String?
    /// <p>
    ///         The new cluster identifier for the global database cluster when modifying a global database cluster.
    ///         This value is stored as a lowercase string.
    ///       </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>The first character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster2</code>
    ///          </p>
    public let newGlobalClusterIdentifier: String?

    public init (
        allowMajorVersionUpgrade: Bool? = nil,
        deletionProtection: Bool? = nil,
        engineVersion: String? = nil,
        globalClusterIdentifier: String? = nil,
        newGlobalClusterIdentifier: String? = nil
    )
    {
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.deletionProtection = deletionProtection
        self.engineVersion = engineVersion
        self.globalClusterIdentifier = globalClusterIdentifier
        self.newGlobalClusterIdentifier = newGlobalClusterIdentifier
    }
}

extension ModifyGlobalClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyGlobalClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyGlobalClusterOutputError: Equatable {
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyGlobalClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyGlobalClusterOutputResponse(globalCluster: \(String(describing: globalCluster)))"}
}

extension ModifyGlobalClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct ModifyGlobalClusterOutputResponse: Equatable {
    /// <p>A data type representing an Aurora global database.</p>
    public let globalCluster: GlobalCluster?

    public init (
        globalCluster: GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct ModifyGlobalClusterOutputResponseBody: Equatable {
    public let globalCluster: GlobalCluster?
}

extension ModifyGlobalClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

public struct ModifyOptionGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyOptionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyOptionGroupInput>
    public typealias MOutput = OperationOutput<ModifyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyOptionGroupOutputError>
}

extension ModifyOptionGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyOptionGroupInput(applyImmediately: \(String(describing: applyImmediately)), optionGroupName: \(String(describing: optionGroupName)), optionsToInclude: \(String(describing: optionsToInclude)), optionsToRemove: \(String(describing: optionsToRemove)))"}
}

extension ModifyOptionGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: Key("ApplyImmediately"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let optionsToInclude = optionsToInclude {
            var optionsToIncludeContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionsToInclude"))
            for (index0, optionconfiguration0) in optionsToInclude.enumerated() {
                try optionsToIncludeContainer.encode(optionconfiguration0, forKey: Key("OptionConfiguration.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsToRemove = optionsToRemove {
            var optionsToRemoveContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionsToRemove"))
            for (index0, string0) in optionsToRemove.enumerated() {
                try optionsToRemoveContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyOptionGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyOptionGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyOptionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyOptionGroupInput>
    public typealias MOutput = OperationOutput<ModifyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyOptionGroupOutputError>
}

public struct ModifyOptionGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyOptionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyOptionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyOptionGroupInput>
    public typealias MOutput = OperationOutput<ModifyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyOptionGroupOutputError>
}

/// <p></p>
public struct ModifyOptionGroupInput: Equatable {
    /// <p>A value that indicates whether to apply the change immediately or during the next maintenance window for each instance associated with the option group.</p>
    public let applyImmediately: Bool
    /// <p>The name of the option group to be modified.</p>
    ///          <p>Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance once it is associated with a DB instance</p>
    public let optionGroupName: String?
    /// <p>Options in this list are added to the option group or, if already present, the specified configuration is used to update the existing configuration.</p>
    public let optionsToInclude: [OptionConfiguration]?
    /// <p>Options in this list are removed from the option group.</p>
    public let optionsToRemove: [String]?

    public init (
        applyImmediately: Bool = false,
        optionGroupName: String? = nil,
        optionsToInclude: [OptionConfiguration]? = nil,
        optionsToRemove: [String]? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.optionGroupName = optionGroupName
        self.optionsToInclude = optionsToInclude
        self.optionsToRemove = optionsToRemove
    }
}

extension ModifyOptionGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyOptionGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidOptionGroupStateFault" : self = .invalidOptionGroupStateFault(try InvalidOptionGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyOptionGroupOutputError: Equatable {
    case invalidOptionGroupStateFault(InvalidOptionGroupStateFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyOptionGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyOptionGroupOutputResponse(optionGroup: \(String(describing: optionGroup)))"}
}

extension ModifyOptionGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyOptionGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.optionGroup = output.optionGroup
        } else {
            self.optionGroup = nil
        }
    }
}

public struct ModifyOptionGroupOutputResponse: Equatable {
    /// <p></p>
    public let optionGroup: OptionGroup?

    public init (
        optionGroup: OptionGroup? = nil
    )
    {
        self.optionGroup = optionGroup
    }
}

struct ModifyOptionGroupOutputResponseBody: Equatable {
    public let optionGroup: OptionGroup?
}

extension ModifyOptionGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case optionGroup = "OptionGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyOptionGroupResult"))
        let optionGroupDecoded = try containerValues.decodeIfPresent(OptionGroup.self, forKey: .optionGroup)
        optionGroup = optionGroupDecoded
    }
}

extension Option: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBSecurityGroupMemberships = "DBSecurityGroupMemberships"
        case optionDescription = "OptionDescription"
        case optionName = "OptionName"
        case optionSettings = "OptionSettings"
        case optionVersion = "OptionVersion"
        case permanent = "Permanent"
        case persistent = "Persistent"
        case port = "Port"
        case vpcSecurityGroupMemberships = "VpcSecurityGroupMemberships"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSecurityGroupMemberships = dBSecurityGroupMemberships {
            var dBSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBSecurityGroupMemberships"))
            for (index0, dbsecuritygroupmembership0) in dBSecurityGroupMemberships.enumerated() {
                try dBSecurityGroupMembershipsContainer.encode(dbsecuritygroupmembership0, forKey: Key("DBSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let optionDescription = optionDescription {
            try container.encode(optionDescription, forKey: Key("OptionDescription"))
        }
        if let optionName = optionName {
            try container.encode(optionName, forKey: Key("OptionName"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionSettings"))
            for (index0, optionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(optionsetting0, forKey: Key("OptionSetting.\(index0.advanced(by: 1))"))
            }
        }
        if let optionVersion = optionVersion {
            try container.encode(optionVersion, forKey: Key("OptionVersion"))
        }
        if permanent != false {
            try container.encode(permanent, forKey: Key("Permanent"))
        }
        if persistent != false {
            try container.encode(persistent, forKey: Key("Persistent"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let vpcSecurityGroupMemberships = vpcSecurityGroupMemberships {
            var vpcSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupMemberships"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroupMemberships.enumerated() {
                try vpcSecurityGroupMembershipsContainer.encode(vpcsecuritygroupmembership0, forKey: Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionName)
        optionName = optionNameDecoded
        let optionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionDescription)
        optionDescription = optionDescriptionDecoded
        let persistentDecoded = try containerValues.decode(Bool.self, forKey: .persistent)
        persistent = persistentDecoded
        let permanentDecoded = try containerValues.decode(Bool.self, forKey: .permanent)
        permanent = permanentDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let optionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionVersion)
        optionVersion = optionVersionDecoded
        if containerValues.contains(.optionSettings) {
            struct KeyVal0{struct OptionSetting{}}
            let optionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionSetting>.CodingKeys.self, forKey: .optionSettings)
            if let optionSettingsWrappedContainer = optionSettingsWrappedContainer {
                let optionSettingsContainer = try optionSettingsWrappedContainer.decodeIfPresent([OptionSetting].self, forKey: .member)
                var optionSettingsBuffer:[OptionSetting]? = nil
                if let optionSettingsContainer = optionSettingsContainer {
                    optionSettingsBuffer = [OptionSetting]()
                    for structureContainer0 in optionSettingsContainer {
                        optionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionSettings = optionSettingsBuffer
            } else {
                optionSettings = []
            }
        } else {
            optionSettings = nil
        }
        if containerValues.contains(.dBSecurityGroupMemberships) {
            struct KeyVal0{struct DBSecurityGroup{}}
            let dBSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroup>.CodingKeys.self, forKey: .dBSecurityGroupMemberships)
            if let dBSecurityGroupMembershipsWrappedContainer = dBSecurityGroupMembershipsWrappedContainer {
                let dBSecurityGroupMembershipsContainer = try dBSecurityGroupMembershipsWrappedContainer.decodeIfPresent([DBSecurityGroupMembership].self, forKey: .member)
                var dBSecurityGroupMembershipsBuffer:[DBSecurityGroupMembership]? = nil
                if let dBSecurityGroupMembershipsContainer = dBSecurityGroupMembershipsContainer {
                    dBSecurityGroupMembershipsBuffer = [DBSecurityGroupMembership]()
                    for structureContainer0 in dBSecurityGroupMembershipsContainer {
                        dBSecurityGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                dBSecurityGroupMemberships = dBSecurityGroupMembershipsBuffer
            } else {
                dBSecurityGroupMemberships = []
            }
        } else {
            dBSecurityGroupMemberships = nil
        }
        if containerValues.contains(.vpcSecurityGroupMemberships) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroupMemberships)
            if let vpcSecurityGroupMembershipsWrappedContainer = vpcSecurityGroupMembershipsWrappedContainer {
                let vpcSecurityGroupMembershipsContainer = try vpcSecurityGroupMembershipsWrappedContainer.decodeIfPresent([VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupMembershipsBuffer:[VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupMembershipsContainer = vpcSecurityGroupMembershipsContainer {
                    vpcSecurityGroupMembershipsBuffer = [VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupMembershipsContainer {
                        vpcSecurityGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroupMemberships = vpcSecurityGroupMembershipsBuffer
            } else {
                vpcSecurityGroupMemberships = []
            }
        } else {
            vpcSecurityGroupMemberships = nil
        }
    }
}

extension Option: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Option(dBSecurityGroupMemberships: \(String(describing: dBSecurityGroupMemberships)), optionDescription: \(String(describing: optionDescription)), optionName: \(String(describing: optionName)), optionSettings: \(String(describing: optionSettings)), optionVersion: \(String(describing: optionVersion)), permanent: \(String(describing: permanent)), persistent: \(String(describing: persistent)), port: \(String(describing: port)), vpcSecurityGroupMemberships: \(String(describing: vpcSecurityGroupMemberships)))"}
}

/// <p>Option details.</p>
public struct Option: Equatable {
    /// <p>If the option requires access to a port, then this DB security group allows access to the port.</p>
    public let dBSecurityGroupMemberships: [DBSecurityGroupMembership]?
    /// <p>The description of the option.</p>
    public let optionDescription: String?
    /// <p>The name of the option.</p>
    public let optionName: String?
    /// <p>The option settings for this option.</p>
    public let optionSettings: [OptionSetting]?
    /// <p>The version of the option.</p>
    public let optionVersion: String?
    /// <p>Indicate if this option is permanent.</p>
    public let permanent: Bool
    /// <p>Indicate if this option is persistent.</p>
    public let persistent: Bool
    /// <p>If required, the port configured for this option to use.</p>
    public let port: Int?
    /// <p>If the option requires access to a port, then this VPC security group allows access to the port.</p>
    public let vpcSecurityGroupMemberships: [VpcSecurityGroupMembership]?

    public init (
        dBSecurityGroupMemberships: [DBSecurityGroupMembership]? = nil,
        optionDescription: String? = nil,
        optionName: String? = nil,
        optionSettings: [OptionSetting]? = nil,
        optionVersion: String? = nil,
        permanent: Bool = false,
        persistent: Bool = false,
        port: Int? = nil,
        vpcSecurityGroupMemberships: [VpcSecurityGroupMembership]? = nil
    )
    {
        self.dBSecurityGroupMemberships = dBSecurityGroupMemberships
        self.optionDescription = optionDescription
        self.optionName = optionName
        self.optionSettings = optionSettings
        self.optionVersion = optionVersion
        self.permanent = permanent
        self.persistent = persistent
        self.port = port
        self.vpcSecurityGroupMemberships = vpcSecurityGroupMemberships
    }
}

extension OptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBSecurityGroupMemberships = "DBSecurityGroupMemberships"
        case optionName = "OptionName"
        case optionSettings = "OptionSettings"
        case optionVersion = "OptionVersion"
        case port = "Port"
        case vpcSecurityGroupMemberships = "VpcSecurityGroupMemberships"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSecurityGroupMemberships = dBSecurityGroupMemberships {
            var dBSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBSecurityGroupMemberships"))
            for (index0, string0) in dBSecurityGroupMemberships.enumerated() {
                try dBSecurityGroupMembershipsContainer.encode(string0, forKey: Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let optionName = optionName {
            try container.encode(optionName, forKey: Key("OptionName"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionSettings"))
            for (index0, optionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(optionsetting0, forKey: Key("OptionSetting.\(index0.advanced(by: 1))"))
            }
        }
        if let optionVersion = optionVersion {
            try container.encode(optionVersion, forKey: Key("OptionVersion"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let vpcSecurityGroupMemberships = vpcSecurityGroupMemberships {
            var vpcSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupMemberships"))
            for (index0, string0) in vpcSecurityGroupMemberships.enumerated() {
                try vpcSecurityGroupMembershipsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionName)
        optionName = optionNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let optionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionVersion)
        optionVersion = optionVersionDecoded
        if containerValues.contains(.dBSecurityGroupMemberships) {
            struct KeyVal0{struct DBSecurityGroupName{}}
            let dBSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroupName>.CodingKeys.self, forKey: .dBSecurityGroupMemberships)
            if let dBSecurityGroupMembershipsWrappedContainer = dBSecurityGroupMembershipsWrappedContainer {
                let dBSecurityGroupMembershipsContainer = try dBSecurityGroupMembershipsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var dBSecurityGroupMembershipsBuffer:[String]? = nil
                if let dBSecurityGroupMembershipsContainer = dBSecurityGroupMembershipsContainer {
                    dBSecurityGroupMembershipsBuffer = [String]()
                    for stringContainer0 in dBSecurityGroupMembershipsContainer {
                        dBSecurityGroupMembershipsBuffer?.append(stringContainer0)
                    }
                }
                dBSecurityGroupMemberships = dBSecurityGroupMembershipsBuffer
            } else {
                dBSecurityGroupMemberships = []
            }
        } else {
            dBSecurityGroupMemberships = nil
        }
        if containerValues.contains(.vpcSecurityGroupMemberships) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupMemberships)
            if let vpcSecurityGroupMembershipsWrappedContainer = vpcSecurityGroupMembershipsWrappedContainer {
                let vpcSecurityGroupMembershipsContainer = try vpcSecurityGroupMembershipsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var vpcSecurityGroupMembershipsBuffer:[String]? = nil
                if let vpcSecurityGroupMembershipsContainer = vpcSecurityGroupMembershipsContainer {
                    vpcSecurityGroupMembershipsBuffer = [String]()
                    for stringContainer0 in vpcSecurityGroupMembershipsContainer {
                        vpcSecurityGroupMembershipsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupMemberships = vpcSecurityGroupMembershipsBuffer
            } else {
                vpcSecurityGroupMemberships = []
            }
        } else {
            vpcSecurityGroupMemberships = nil
        }
        if containerValues.contains(.optionSettings) {
            struct KeyVal0{struct OptionSetting{}}
            let optionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionSetting>.CodingKeys.self, forKey: .optionSettings)
            if let optionSettingsWrappedContainer = optionSettingsWrappedContainer {
                let optionSettingsContainer = try optionSettingsWrappedContainer.decodeIfPresent([OptionSetting].self, forKey: .member)
                var optionSettingsBuffer:[OptionSetting]? = nil
                if let optionSettingsContainer = optionSettingsContainer {
                    optionSettingsBuffer = [OptionSetting]()
                    for structureContainer0 in optionSettingsContainer {
                        optionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionSettings = optionSettingsBuffer
            } else {
                optionSettings = []
            }
        } else {
            optionSettings = nil
        }
    }
}

extension OptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionConfiguration(dBSecurityGroupMemberships: \(String(describing: dBSecurityGroupMemberships)), optionName: \(String(describing: optionName)), optionSettings: \(String(describing: optionSettings)), optionVersion: \(String(describing: optionVersion)), port: \(String(describing: port)), vpcSecurityGroupMemberships: \(String(describing: vpcSecurityGroupMemberships)))"}
}

/// <p>A list of all available options</p>
public struct OptionConfiguration: Equatable {
    /// <p>A list of DBSecurityGroupMembership name strings used for this option.</p>
    public let dBSecurityGroupMemberships: [String]?
    /// <p>The configuration of options to include in a group.</p>
    public let optionName: String?
    /// <p>The option settings to include in an option group.</p>
    public let optionSettings: [OptionSetting]?
    /// <p>The version for the option.</p>
    public let optionVersion: String?
    /// <p>The optional port for the option.</p>
    public let port: Int?
    /// <p>A list of VpcSecurityGroupMembership name strings used for this option.</p>
    public let vpcSecurityGroupMemberships: [String]?

    public init (
        dBSecurityGroupMemberships: [String]? = nil,
        optionName: String? = nil,
        optionSettings: [OptionSetting]? = nil,
        optionVersion: String? = nil,
        port: Int? = nil,
        vpcSecurityGroupMemberships: [String]? = nil
    )
    {
        self.dBSecurityGroupMemberships = dBSecurityGroupMemberships
        self.optionName = optionName
        self.optionSettings = optionSettings
        self.optionVersion = optionVersion
        self.port = port
        self.vpcSecurityGroupMemberships = vpcSecurityGroupMemberships
    }
}

extension OptionGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowsVpcAndNonVpcInstanceMemberships = "AllowsVpcAndNonVpcInstanceMemberships"
        case engineName = "EngineName"
        case majorEngineVersion = "MajorEngineVersion"
        case optionGroupArn = "OptionGroupArn"
        case optionGroupDescription = "OptionGroupDescription"
        case optionGroupName = "OptionGroupName"
        case options = "Options"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allowsVpcAndNonVpcInstanceMemberships != false {
            try container.encode(allowsVpcAndNonVpcInstanceMemberships, forKey: Key("AllowsVpcAndNonVpcInstanceMemberships"))
        }
        if let engineName = engineName {
            try container.encode(engineName, forKey: Key("EngineName"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: Key("MajorEngineVersion"))
        }
        if let optionGroupArn = optionGroupArn {
            try container.encode(optionGroupArn, forKey: Key("OptionGroupArn"))
        }
        if let optionGroupDescription = optionGroupDescription {
            try container.encode(optionGroupDescription, forKey: Key("OptionGroupDescription"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let options = options {
            var optionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Options"))
            for (index0, option0) in options.enumerated() {
                try optionsContainer.encode(option0, forKey: Key("Option.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let optionGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionGroupDescription)
        optionGroupDescription = optionGroupDescriptionDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        if containerValues.contains(.options) {
            struct KeyVal0{struct Option{}}
            let optionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Option>.CodingKeys.self, forKey: .options)
            if let optionsWrappedContainer = optionsWrappedContainer {
                let optionsContainer = try optionsWrappedContainer.decodeIfPresent([Option].self, forKey: .member)
                var optionsBuffer:[Option]? = nil
                if let optionsContainer = optionsContainer {
                    optionsBuffer = [Option]()
                    for structureContainer0 in optionsContainer {
                        optionsBuffer?.append(structureContainer0)
                    }
                }
                options = optionsBuffer
            } else {
                options = []
            }
        } else {
            options = nil
        }
        let allowsVpcAndNonVpcInstanceMembershipsDecoded = try containerValues.decode(Bool.self, forKey: .allowsVpcAndNonVpcInstanceMemberships)
        allowsVpcAndNonVpcInstanceMemberships = allowsVpcAndNonVpcInstanceMembershipsDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let optionGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionGroupArn)
        optionGroupArn = optionGroupArnDecoded
    }
}

extension OptionGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionGroup(allowsVpcAndNonVpcInstanceMemberships: \(String(describing: allowsVpcAndNonVpcInstanceMemberships)), engineName: \(String(describing: engineName)), majorEngineVersion: \(String(describing: majorEngineVersion)), optionGroupArn: \(String(describing: optionGroupArn)), optionGroupDescription: \(String(describing: optionGroupDescription)), optionGroupName: \(String(describing: optionGroupName)), options: \(String(describing: options)), vpcId: \(String(describing: vpcId)))"}
}

/// <p></p>
public struct OptionGroup: Equatable {
    /// <p>Indicates whether this option group can be applied to both VPC
    ///            and non-VPC instances. The value <code>true</code> indicates the option group
    ///            can be applied to both VPC and non-VPC instances.
    ///         </p>
    public let allowsVpcAndNonVpcInstanceMemberships: Bool
    /// <p>Indicates the name of the engine that this option group can be applied to.</p>
    public let engineName: String?
    /// <p>Indicates the major engine version associated with this option group.</p>
    public let majorEngineVersion: String?
    /// <p>The Amazon Resource Name (ARN) for the option group.</p>
    public let optionGroupArn: String?
    /// <p>Provides a description of the option group.</p>
    public let optionGroupDescription: String?
    /// <p>Specifies the name of the option group.</p>
    public let optionGroupName: String?
    /// <p>Indicates what options are available in the option group.</p>
    public let options: [Option]?
    /// <p>If <b>AllowsVpcAndNonVpcInstanceMemberships</b> is <code>false</code>, this field is blank.
    ///            If <b>AllowsVpcAndNonVpcInstanceMemberships</b> is <code>true</code> and this field is blank,
    ///            then this option group can be applied to both VPC and non-VPC instances.
    ///            If this field contains a value, then this option group can only be
    ///            applied to instances that are in the VPC indicated by this field.
    ///         </p>
    public let vpcId: String?

    public init (
        allowsVpcAndNonVpcInstanceMemberships: Bool = false,
        engineName: String? = nil,
        majorEngineVersion: String? = nil,
        optionGroupArn: String? = nil,
        optionGroupDescription: String? = nil,
        optionGroupName: String? = nil,
        options: [Option]? = nil,
        vpcId: String? = nil
    )
    {
        self.allowsVpcAndNonVpcInstanceMemberships = allowsVpcAndNonVpcInstanceMemberships
        self.engineName = engineName
        self.majorEngineVersion = majorEngineVersion
        self.optionGroupArn = optionGroupArn
        self.optionGroupDescription = optionGroupDescription
        self.optionGroupName = optionGroupName
        self.options = options
        self.vpcId = vpcId
    }
}

extension OptionGroupAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionGroupAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension OptionGroupAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OptionGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The option group you are trying to create already exists.</p>
public struct OptionGroupAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OptionGroupAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension OptionGroupAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OptionGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case optionGroupName = "OptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension OptionGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionGroupMembership(optionGroupName: \(String(describing: optionGroupName)), status: \(String(describing: status)))"}
}

/// <p>Provides information on the option groups the DB instance is a member of.</p>
public struct OptionGroupMembership: Equatable {
    /// <p>The name of the option group that the instance belongs to.</p>
    public let optionGroupName: String?
    /// <p>The status of the DB instance's option group membership. Valid values are:
    ///       <code>in-sync</code>,
    ///       <code>pending-apply</code>,
    ///       <code>pending-removal</code>,
    ///       <code>pending-maintenance-apply</code>,
    ///       <code>pending-maintenance-removal</code>,
    ///       <code>applying</code>,
    ///       <code>removing</code>,
    ///       and <code>failed</code>.
    ///         </p>
    public let status: String?

    public init (
        optionGroupName: String? = nil,
        status: String? = nil
    )
    {
        self.optionGroupName = optionGroupName
        self.status = status
    }
}

extension OptionGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension OptionGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OptionGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified option group could not be found.</p>
public struct OptionGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OptionGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension OptionGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OptionGroupOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultPort = "DefaultPort"
        case description = "Description"
        case engineName = "EngineName"
        case majorEngineVersion = "MajorEngineVersion"
        case minimumRequiredMinorEngineVersion = "MinimumRequiredMinorEngineVersion"
        case name = "Name"
        case optionGroupOptionSettings = "OptionGroupOptionSettings"
        case optionGroupOptionVersions = "OptionGroupOptionVersions"
        case optionsConflictsWith = "OptionsConflictsWith"
        case optionsDependedOn = "OptionsDependedOn"
        case permanent = "Permanent"
        case persistent = "Persistent"
        case portRequired = "PortRequired"
        case requiresAutoMinorEngineVersionUpgrade = "RequiresAutoMinorEngineVersionUpgrade"
        case supportsOptionVersionDowngrade = "SupportsOptionVersionDowngrade"
        case vpcOnly = "VpcOnly"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultPort = defaultPort {
            try container.encode(defaultPort, forKey: Key("DefaultPort"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let engineName = engineName {
            try container.encode(engineName, forKey: Key("EngineName"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: Key("MajorEngineVersion"))
        }
        if let minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersion {
            try container.encode(minimumRequiredMinorEngineVersion, forKey: Key("MinimumRequiredMinorEngineVersion"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let optionGroupOptionSettings = optionGroupOptionSettings {
            var optionGroupOptionSettingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionGroupOptionSettings"))
            for (index0, optiongroupoptionsetting0) in optionGroupOptionSettings.enumerated() {
                try optionGroupOptionSettingsContainer.encode(optiongroupoptionsetting0, forKey: Key("OptionGroupOptionSetting.\(index0.advanced(by: 1))"))
            }
        }
        if let optionGroupOptionVersions = optionGroupOptionVersions {
            var optionGroupOptionVersionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionGroupOptionVersions"))
            for (index0, optionversion0) in optionGroupOptionVersions.enumerated() {
                try optionGroupOptionVersionsContainer.encode(optionversion0, forKey: Key("OptionVersion.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsConflictsWith = optionsConflictsWith {
            var optionsConflictsWithContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionsConflictsWith"))
            for (index0, string0) in optionsConflictsWith.enumerated() {
                try optionsConflictsWithContainer.encode(string0, forKey: Key("OptionConflictName.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsDependedOn = optionsDependedOn {
            var optionsDependedOnContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionsDependedOn"))
            for (index0, string0) in optionsDependedOn.enumerated() {
                try optionsDependedOnContainer.encode(string0, forKey: Key("OptionName.\(index0.advanced(by: 1))"))
            }
        }
        if permanent != false {
            try container.encode(permanent, forKey: Key("Permanent"))
        }
        if persistent != false {
            try container.encode(persistent, forKey: Key("Persistent"))
        }
        if portRequired != false {
            try container.encode(portRequired, forKey: Key("PortRequired"))
        }
        if requiresAutoMinorEngineVersionUpgrade != false {
            try container.encode(requiresAutoMinorEngineVersionUpgrade, forKey: Key("RequiresAutoMinorEngineVersionUpgrade"))
        }
        if let supportsOptionVersionDowngrade = supportsOptionVersionDowngrade {
            try container.encode(supportsOptionVersionDowngrade, forKey: Key("SupportsOptionVersionDowngrade"))
        }
        if vpcOnly != false {
            try container.encode(vpcOnly, forKey: Key("VpcOnly"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        let minimumRequiredMinorEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minimumRequiredMinorEngineVersion)
        minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersionDecoded
        let portRequiredDecoded = try containerValues.decode(Bool.self, forKey: .portRequired)
        portRequired = portRequiredDecoded
        let defaultPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultPort)
        defaultPort = defaultPortDecoded
        if containerValues.contains(.optionsDependedOn) {
            struct KeyVal0{struct OptionName{}}
            let optionsDependedOnWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionName>.CodingKeys.self, forKey: .optionsDependedOn)
            if let optionsDependedOnWrappedContainer = optionsDependedOnWrappedContainer {
                let optionsDependedOnContainer = try optionsDependedOnWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var optionsDependedOnBuffer:[String]? = nil
                if let optionsDependedOnContainer = optionsDependedOnContainer {
                    optionsDependedOnBuffer = [String]()
                    for stringContainer0 in optionsDependedOnContainer {
                        optionsDependedOnBuffer?.append(stringContainer0)
                    }
                }
                optionsDependedOn = optionsDependedOnBuffer
            } else {
                optionsDependedOn = []
            }
        } else {
            optionsDependedOn = nil
        }
        if containerValues.contains(.optionsConflictsWith) {
            struct KeyVal0{struct OptionConflictName{}}
            let optionsConflictsWithWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionConflictName>.CodingKeys.self, forKey: .optionsConflictsWith)
            if let optionsConflictsWithWrappedContainer = optionsConflictsWithWrappedContainer {
                let optionsConflictsWithContainer = try optionsConflictsWithWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var optionsConflictsWithBuffer:[String]? = nil
                if let optionsConflictsWithContainer = optionsConflictsWithContainer {
                    optionsConflictsWithBuffer = [String]()
                    for stringContainer0 in optionsConflictsWithContainer {
                        optionsConflictsWithBuffer?.append(stringContainer0)
                    }
                }
                optionsConflictsWith = optionsConflictsWithBuffer
            } else {
                optionsConflictsWith = []
            }
        } else {
            optionsConflictsWith = nil
        }
        let persistentDecoded = try containerValues.decode(Bool.self, forKey: .persistent)
        persistent = persistentDecoded
        let permanentDecoded = try containerValues.decode(Bool.self, forKey: .permanent)
        permanent = permanentDecoded
        let requiresAutoMinorEngineVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .requiresAutoMinorEngineVersionUpgrade)
        requiresAutoMinorEngineVersionUpgrade = requiresAutoMinorEngineVersionUpgradeDecoded
        let vpcOnlyDecoded = try containerValues.decode(Bool.self, forKey: .vpcOnly)
        vpcOnly = vpcOnlyDecoded
        let supportsOptionVersionDowngradeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .supportsOptionVersionDowngrade)
        supportsOptionVersionDowngrade = supportsOptionVersionDowngradeDecoded
        if containerValues.contains(.optionGroupOptionSettings) {
            struct KeyVal0{struct OptionGroupOptionSetting{}}
            let optionGroupOptionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupOptionSetting>.CodingKeys.self, forKey: .optionGroupOptionSettings)
            if let optionGroupOptionSettingsWrappedContainer = optionGroupOptionSettingsWrappedContainer {
                let optionGroupOptionSettingsContainer = try optionGroupOptionSettingsWrappedContainer.decodeIfPresent([OptionGroupOptionSetting].self, forKey: .member)
                var optionGroupOptionSettingsBuffer:[OptionGroupOptionSetting]? = nil
                if let optionGroupOptionSettingsContainer = optionGroupOptionSettingsContainer {
                    optionGroupOptionSettingsBuffer = [OptionGroupOptionSetting]()
                    for structureContainer0 in optionGroupOptionSettingsContainer {
                        optionGroupOptionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupOptionSettings = optionGroupOptionSettingsBuffer
            } else {
                optionGroupOptionSettings = []
            }
        } else {
            optionGroupOptionSettings = nil
        }
        if containerValues.contains(.optionGroupOptionVersions) {
            struct KeyVal0{struct OptionVersion{}}
            let optionGroupOptionVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionVersion>.CodingKeys.self, forKey: .optionGroupOptionVersions)
            if let optionGroupOptionVersionsWrappedContainer = optionGroupOptionVersionsWrappedContainer {
                let optionGroupOptionVersionsContainer = try optionGroupOptionVersionsWrappedContainer.decodeIfPresent([OptionVersion].self, forKey: .member)
                var optionGroupOptionVersionsBuffer:[OptionVersion]? = nil
                if let optionGroupOptionVersionsContainer = optionGroupOptionVersionsContainer {
                    optionGroupOptionVersionsBuffer = [OptionVersion]()
                    for structureContainer0 in optionGroupOptionVersionsContainer {
                        optionGroupOptionVersionsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupOptionVersions = optionGroupOptionVersionsBuffer
            } else {
                optionGroupOptionVersions = []
            }
        } else {
            optionGroupOptionVersions = nil
        }
    }
}

extension OptionGroupOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionGroupOption(defaultPort: \(String(describing: defaultPort)), description: \(String(describing: description)), engineName: \(String(describing: engineName)), majorEngineVersion: \(String(describing: majorEngineVersion)), minimumRequiredMinorEngineVersion: \(String(describing: minimumRequiredMinorEngineVersion)), name: \(String(describing: name)), optionGroupOptionSettings: \(String(describing: optionGroupOptionSettings)), optionGroupOptionVersions: \(String(describing: optionGroupOptionVersions)), optionsConflictsWith: \(String(describing: optionsConflictsWith)), optionsDependedOn: \(String(describing: optionsDependedOn)), permanent: \(String(describing: permanent)), persistent: \(String(describing: persistent)), portRequired: \(String(describing: portRequired)), requiresAutoMinorEngineVersionUpgrade: \(String(describing: requiresAutoMinorEngineVersionUpgrade)), supportsOptionVersionDowngrade: \(String(describing: supportsOptionVersionDowngrade)), vpcOnly: \(String(describing: vpcOnly)))"}
}

/// <p>Available option.</p>
public struct OptionGroupOption: Equatable {
    /// <p>If the option requires a port, specifies the default port for the option.</p>
    public let defaultPort: Int?
    /// <p>The description of the option.</p>
    public let description: String?
    /// <p>The name of the engine that this option can be applied to.</p>
    public let engineName: String?
    /// <p>Indicates the major engine version that the option is available for.</p>
    public let majorEngineVersion: String?
    /// <p>The minimum required engine version for the option to be applied.</p>
    public let minimumRequiredMinorEngineVersion: String?
    /// <p>The name of the option.</p>
    public let name: String?
    /// <p>The option settings that are available (and the default value) for each option in an option group.</p>
    public let optionGroupOptionSettings: [OptionGroupOptionSetting]?
    /// <p>The versions that are available for the option.</p>
    public let optionGroupOptionVersions: [OptionVersion]?
    /// <p>The options that conflict with this option.</p>
    public let optionsConflictsWith: [String]?
    /// <p>The options that are prerequisites for this option.</p>
    public let optionsDependedOn: [String]?
    /// <p>Permanent options can never be removed from an option group. An option group containing a permanent option can't be removed from a DB instance.</p>
    public let permanent: Bool
    /// <p>Persistent options can't be removed from an option group while DB instances are associated with the option group. If you disassociate all DB instances from the option group, your can remove the persistent option from the option group.</p>
    public let persistent: Bool
    /// <p>Specifies whether the option requires a port.</p>
    public let portRequired: Bool
    /// <p>If true, you must enable the Auto Minor Version Upgrade setting for your DB instance
    ///             before you can use this option.
    ///             You can enable Auto Minor Version Upgrade when you first create your DB instance,
    ///             or by modifying your DB instance later.
    ///         </p>
    public let requiresAutoMinorEngineVersionUpgrade: Bool
    /// <p>If true, you can change the option to an earlier version of the option.
    ///             This only applies to options that have different versions available.
    ///         </p>
    public let supportsOptionVersionDowngrade: Bool?
    /// <p>If true, you can only use this option with a DB instance that is in a VPC.
    ///         </p>
    public let vpcOnly: Bool

    public init (
        defaultPort: Int? = nil,
        description: String? = nil,
        engineName: String? = nil,
        majorEngineVersion: String? = nil,
        minimumRequiredMinorEngineVersion: String? = nil,
        name: String? = nil,
        optionGroupOptionSettings: [OptionGroupOptionSetting]? = nil,
        optionGroupOptionVersions: [OptionVersion]? = nil,
        optionsConflictsWith: [String]? = nil,
        optionsDependedOn: [String]? = nil,
        permanent: Bool = false,
        persistent: Bool = false,
        portRequired: Bool = false,
        requiresAutoMinorEngineVersionUpgrade: Bool = false,
        supportsOptionVersionDowngrade: Bool? = nil,
        vpcOnly: Bool = false
    )
    {
        self.defaultPort = defaultPort
        self.description = description
        self.engineName = engineName
        self.majorEngineVersion = majorEngineVersion
        self.minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersion
        self.name = name
        self.optionGroupOptionSettings = optionGroupOptionSettings
        self.optionGroupOptionVersions = optionGroupOptionVersions
        self.optionsConflictsWith = optionsConflictsWith
        self.optionsDependedOn = optionsDependedOn
        self.permanent = permanent
        self.persistent = persistent
        self.portRequired = portRequired
        self.requiresAutoMinorEngineVersionUpgrade = requiresAutoMinorEngineVersionUpgrade
        self.supportsOptionVersionDowngrade = supportsOptionVersionDowngrade
        self.vpcOnly = vpcOnly
    }
}

extension OptionGroupOptionSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedValues = "AllowedValues"
        case applyType = "ApplyType"
        case defaultValue = "DefaultValue"
        case isModifiable = "IsModifiable"
        case isRequired = "IsRequired"
        case minimumEngineVersionPerAllowedValue = "MinimumEngineVersionPerAllowedValue"
        case settingDescription = "SettingDescription"
        case settingName = "SettingName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: Key("AllowedValues"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: Key("ApplyType"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: Key("IsModifiable"))
        }
        if isRequired != false {
            try container.encode(isRequired, forKey: Key("IsRequired"))
        }
        if let minimumEngineVersionPerAllowedValue = minimumEngineVersionPerAllowedValue {
            var minimumEngineVersionPerAllowedValueContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("MinimumEngineVersionPerAllowedValue"))
            for (index0, minimumengineversionperallowedvalue0) in minimumEngineVersionPerAllowedValue.enumerated() {
                try minimumEngineVersionPerAllowedValueContainer.encode(minimumengineversionperallowedvalue0, forKey: Key("MinimumEngineVersionPerAllowedValue.\(index0.advanced(by: 1))"))
            }
        }
        if let settingDescription = settingDescription {
            try container.encode(settingDescription, forKey: Key("SettingDescription"))
        }
        if let settingName = settingName {
            try container.encode(settingName, forKey: Key("SettingName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .settingName)
        settingName = settingNameDecoded
        let settingDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .settingDescription)
        settingDescription = settingDescriptionDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decode(Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let isRequiredDecoded = try containerValues.decode(Bool.self, forKey: .isRequired)
        isRequired = isRequiredDecoded
        if containerValues.contains(.minimumEngineVersionPerAllowedValue) {
            struct KeyVal0{struct MinimumEngineVersionPerAllowedValue{}}
            let minimumEngineVersionPerAllowedValueWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.MinimumEngineVersionPerAllowedValue>.CodingKeys.self, forKey: .minimumEngineVersionPerAllowedValue)
            if let minimumEngineVersionPerAllowedValueWrappedContainer = minimumEngineVersionPerAllowedValueWrappedContainer {
                let minimumEngineVersionPerAllowedValueContainer = try minimumEngineVersionPerAllowedValueWrappedContainer.decodeIfPresent([MinimumEngineVersionPerAllowedValue].self, forKey: .member)
                var minimumEngineVersionPerAllowedValueBuffer:[MinimumEngineVersionPerAllowedValue]? = nil
                if let minimumEngineVersionPerAllowedValueContainer = minimumEngineVersionPerAllowedValueContainer {
                    minimumEngineVersionPerAllowedValueBuffer = [MinimumEngineVersionPerAllowedValue]()
                    for structureContainer0 in minimumEngineVersionPerAllowedValueContainer {
                        minimumEngineVersionPerAllowedValueBuffer?.append(structureContainer0)
                    }
                }
                minimumEngineVersionPerAllowedValue = minimumEngineVersionPerAllowedValueBuffer
            } else {
                minimumEngineVersionPerAllowedValue = []
            }
        } else {
            minimumEngineVersionPerAllowedValue = nil
        }
    }
}

extension OptionGroupOptionSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionGroupOptionSetting(allowedValues: \(String(describing: allowedValues)), applyType: \(String(describing: applyType)), defaultValue: \(String(describing: defaultValue)), isModifiable: \(String(describing: isModifiable)), isRequired: \(String(describing: isRequired)), minimumEngineVersionPerAllowedValue: \(String(describing: minimumEngineVersionPerAllowedValue)), settingDescription: \(String(describing: settingDescription)), settingName: \(String(describing: settingName)))"}
}

/// <p>Option group option settings are used to display settings available for each option with their default values and other information. These values are used with the DescribeOptionGroupOptions action.</p>
public struct OptionGroupOptionSetting: Equatable {
    /// <p>Indicates the acceptable values for the option group option.</p>
    public let allowedValues: String?
    /// <p>The DB engine specific parameter type for the option group option.</p>
    public let applyType: String?
    /// <p>The default value for the option group option.</p>
    public let defaultValue: String?
    /// <p>Boolean value where true indicates that this option group option can be changed from the default value.</p>
    public let isModifiable: Bool
    /// <p>Boolean value where true indicates that a value must be specified for this option setting of the option group option.</p>
    public let isRequired: Bool
    /// <p>The minimum DB engine version required for the corresponding allowed value for this option setting.</p>
    public let minimumEngineVersionPerAllowedValue: [MinimumEngineVersionPerAllowedValue]?
    /// <p>The description of the option group option.</p>
    public let settingDescription: String?
    /// <p>The name of the option group option.</p>
    public let settingName: String?

    public init (
        allowedValues: String? = nil,
        applyType: String? = nil,
        defaultValue: String? = nil,
        isModifiable: Bool = false,
        isRequired: Bool = false,
        minimumEngineVersionPerAllowedValue: [MinimumEngineVersionPerAllowedValue]? = nil,
        settingDescription: String? = nil,
        settingName: String? = nil
    )
    {
        self.allowedValues = allowedValues
        self.applyType = applyType
        self.defaultValue = defaultValue
        self.isModifiable = isModifiable
        self.isRequired = isRequired
        self.minimumEngineVersionPerAllowedValue = minimumEngineVersionPerAllowedValue
        self.settingDescription = settingDescription
        self.settingName = settingName
    }
}

extension OptionGroupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionGroupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension OptionGroupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OptionGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota of 20 option groups was exceeded for this AWS account.</p>
public struct OptionGroupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OptionGroupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension OptionGroupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OptionSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedValues = "AllowedValues"
        case applyType = "ApplyType"
        case dataType = "DataType"
        case defaultValue = "DefaultValue"
        case description = "Description"
        case isCollection = "IsCollection"
        case isModifiable = "IsModifiable"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: Key("AllowedValues"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: Key("ApplyType"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: Key("DataType"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if isCollection != false {
            try container.encode(isCollection, forKey: Key("IsCollection"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: Key("IsModifiable"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decode(Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let isCollectionDecoded = try containerValues.decode(Bool.self, forKey: .isCollection)
        isCollection = isCollectionDecoded
    }
}

extension OptionSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionSetting(allowedValues: \(String(describing: allowedValues)), applyType: \(String(describing: applyType)), dataType: \(String(describing: dataType)), defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)), isCollection: \(String(describing: isCollection)), isModifiable: \(String(describing: isModifiable)), name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Option settings are the actual settings being applied or configured for that option. It is used when you modify an option group or describe option groups. For example, the NATIVE_NETWORK_ENCRYPTION option has a setting called SQLNET.ENCRYPTION_SERVER that can have several different values.</p>
public struct OptionSetting: Equatable {
    /// <p>The allowed values of the option setting.</p>
    public let allowedValues: String?
    /// <p>The DB engine specific parameter type.</p>
    public let applyType: String?
    /// <p>The data type of the option setting.</p>
    public let dataType: String?
    /// <p>The default value of the option setting.</p>
    public let defaultValue: String?
    /// <p>The description of the option setting.</p>
    public let description: String?
    /// <p>Indicates if the option setting is part of a collection.</p>
    public let isCollection: Bool
    /// <p>A Boolean value that, when true, indicates the option setting can be modified from the default.</p>
    public let isModifiable: Bool
    /// <p>The name of the option that has settings that you can set.</p>
    public let name: String?
    /// <p>The current value of the option setting.</p>
    public let value: String?

    public init (
        allowedValues: String? = nil,
        applyType: String? = nil,
        dataType: String? = nil,
        defaultValue: String? = nil,
        description: String? = nil,
        isCollection: Bool = false,
        isModifiable: Bool = false,
        name: String? = nil,
        value: String? = nil
    )
    {
        self.allowedValues = allowedValues
        self.applyType = applyType
        self.dataType = dataType
        self.defaultValue = defaultValue
        self.description = description
        self.isCollection = isCollection
        self.isModifiable = isModifiable
        self.name = name
        self.value = value
    }
}

extension OptionVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isDefault = "IsDefault"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if isDefault != false {
            try container.encode(isDefault, forKey: Key("IsDefault"))
        }
        if let version = version {
            try container.encode(version, forKey: Key("Version"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let isDefaultDecoded = try containerValues.decode(Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
    }
}

extension OptionVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionVersion(isDefault: \(String(describing: isDefault)), version: \(String(describing: version)))"}
}

/// <p>The version for an option. Option group option versions are returned by
///             the <code>DescribeOptionGroupOptions</code> action.</p>
public struct OptionVersion: Equatable {
    /// <p>True if the version is the default version of the option, and otherwise false.</p>
    public let isDefault: Bool
    /// <p>The version of the option.</p>
    public let version: String?

    public init (
        isDefault: Bool = false,
        version: String? = nil
    )
    {
        self.isDefault = isDefault
        self.version = version
    }
}

extension OrderableDBInstanceOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZoneGroup = "AvailabilityZoneGroup"
        case availabilityZones = "AvailabilityZones"
        case availableProcessorFeatures = "AvailableProcessorFeatures"
        case dBInstanceClass = "DBInstanceClass"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case licenseModel = "LicenseModel"
        case maxIopsPerDbInstance = "MaxIopsPerDbInstance"
        case maxIopsPerGib = "MaxIopsPerGib"
        case maxStorageSize = "MaxStorageSize"
        case minIopsPerDbInstance = "MinIopsPerDbInstance"
        case minIopsPerGib = "MinIopsPerGib"
        case minStorageSize = "MinStorageSize"
        case multiAZCapable = "MultiAZCapable"
        case outpostCapable = "OutpostCapable"
        case readReplicaCapable = "ReadReplicaCapable"
        case storageType = "StorageType"
        case supportedEngineModes = "SupportedEngineModes"
        case supportsEnhancedMonitoring = "SupportsEnhancedMonitoring"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsIAMDatabaseAuthentication = "SupportsIAMDatabaseAuthentication"
        case supportsIops = "SupportsIops"
        case supportsKerberosAuthentication = "SupportsKerberosAuthentication"
        case supportsPerformanceInsights = "SupportsPerformanceInsights"
        case supportsStorageAutoscaling = "SupportsStorageAutoscaling"
        case supportsStorageEncryption = "SupportsStorageEncryption"
        case vpc = "Vpc"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZoneGroup = availabilityZoneGroup {
            try container.encode(availabilityZoneGroup, forKey: Key("AvailabilityZoneGroup"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let availableProcessorFeatures = availableProcessorFeatures {
            var availableProcessorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailableProcessorFeatures"))
            for (index0, availableprocessorfeature0) in availableProcessorFeatures.enumerated() {
                try availableProcessorFeaturesContainer.encode(availableprocessorfeature0, forKey: Key("AvailableProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let maxIopsPerDbInstance = maxIopsPerDbInstance {
            try container.encode(maxIopsPerDbInstance, forKey: Key("MaxIopsPerDbInstance"))
        }
        if let maxIopsPerGib = maxIopsPerGib {
            try container.encode(maxIopsPerGib, forKey: Key("MaxIopsPerGib"))
        }
        if let maxStorageSize = maxStorageSize {
            try container.encode(maxStorageSize, forKey: Key("MaxStorageSize"))
        }
        if let minIopsPerDbInstance = minIopsPerDbInstance {
            try container.encode(minIopsPerDbInstance, forKey: Key("MinIopsPerDbInstance"))
        }
        if let minIopsPerGib = minIopsPerGib {
            try container.encode(minIopsPerGib, forKey: Key("MinIopsPerGib"))
        }
        if let minStorageSize = minStorageSize {
            try container.encode(minStorageSize, forKey: Key("MinStorageSize"))
        }
        if multiAZCapable != false {
            try container.encode(multiAZCapable, forKey: Key("MultiAZCapable"))
        }
        if outpostCapable != false {
            try container.encode(outpostCapable, forKey: Key("OutpostCapable"))
        }
        if readReplicaCapable != false {
            try container.encode(readReplicaCapable, forKey: Key("ReadReplicaCapable"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if supportsEnhancedMonitoring != false {
            try container.encode(supportsEnhancedMonitoring, forKey: Key("SupportsEnhancedMonitoring"))
        }
        if supportsGlobalDatabases != false {
            try container.encode(supportsGlobalDatabases, forKey: Key("SupportsGlobalDatabases"))
        }
        if supportsIAMDatabaseAuthentication != false {
            try container.encode(supportsIAMDatabaseAuthentication, forKey: Key("SupportsIAMDatabaseAuthentication"))
        }
        if supportsIops != false {
            try container.encode(supportsIops, forKey: Key("SupportsIops"))
        }
        if let supportsKerberosAuthentication = supportsKerberosAuthentication {
            try container.encode(supportsKerberosAuthentication, forKey: Key("SupportsKerberosAuthentication"))
        }
        if supportsPerformanceInsights != false {
            try container.encode(supportsPerformanceInsights, forKey: Key("SupportsPerformanceInsights"))
        }
        if let supportsStorageAutoscaling = supportsStorageAutoscaling {
            try container.encode(supportsStorageAutoscaling, forKey: Key("SupportsStorageAutoscaling"))
        }
        if supportsStorageEncryption != false {
            try container.encode(supportsStorageEncryption, forKey: Key("SupportsStorageEncryption"))
        }
        if vpc != false {
            try container.encode(vpc, forKey: Key("Vpc"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let availabilityZoneGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneGroup)
        availabilityZoneGroup = availabilityZoneGroupDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let multiAZCapableDecoded = try containerValues.decode(Bool.self, forKey: .multiAZCapable)
        multiAZCapable = multiAZCapableDecoded
        let readReplicaCapableDecoded = try containerValues.decode(Bool.self, forKey: .readReplicaCapable)
        readReplicaCapable = readReplicaCapableDecoded
        let vpcDecoded = try containerValues.decode(Bool.self, forKey: .vpc)
        vpc = vpcDecoded
        let supportsStorageEncryptionDecoded = try containerValues.decode(Bool.self, forKey: .supportsStorageEncryption)
        supportsStorageEncryption = supportsStorageEncryptionDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let supportsIopsDecoded = try containerValues.decode(Bool.self, forKey: .supportsIops)
        supportsIops = supportsIopsDecoded
        let supportsEnhancedMonitoringDecoded = try containerValues.decode(Bool.self, forKey: .supportsEnhancedMonitoring)
        supportsEnhancedMonitoring = supportsEnhancedMonitoringDecoded
        let supportsIAMDatabaseAuthenticationDecoded = try containerValues.decode(Bool.self, forKey: .supportsIAMDatabaseAuthentication)
        supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthenticationDecoded
        let supportsPerformanceInsightsDecoded = try containerValues.decode(Bool.self, forKey: .supportsPerformanceInsights)
        supportsPerformanceInsights = supportsPerformanceInsightsDecoded
        let minStorageSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minStorageSize)
        minStorageSize = minStorageSizeDecoded
        let maxStorageSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxStorageSize)
        maxStorageSize = maxStorageSizeDecoded
        let minIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minIopsPerDbInstance)
        minIopsPerDbInstance = minIopsPerDbInstanceDecoded
        let maxIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxIopsPerDbInstance)
        maxIopsPerDbInstance = maxIopsPerDbInstanceDecoded
        let minIopsPerGibDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .minIopsPerGib)
        minIopsPerGib = minIopsPerGibDecoded
        let maxIopsPerGibDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxIopsPerGib)
        maxIopsPerGib = maxIopsPerGibDecoded
        if containerValues.contains(.availableProcessorFeatures) {
            struct KeyVal0{struct AvailableProcessorFeature{}}
            let availableProcessorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailableProcessorFeature>.CodingKeys.self, forKey: .availableProcessorFeatures)
            if let availableProcessorFeaturesWrappedContainer = availableProcessorFeaturesWrappedContainer {
                let availableProcessorFeaturesContainer = try availableProcessorFeaturesWrappedContainer.decodeIfPresent([AvailableProcessorFeature].self, forKey: .member)
                var availableProcessorFeaturesBuffer:[AvailableProcessorFeature]? = nil
                if let availableProcessorFeaturesContainer = availableProcessorFeaturesContainer {
                    availableProcessorFeaturesBuffer = [AvailableProcessorFeature]()
                    for structureContainer0 in availableProcessorFeaturesContainer {
                        availableProcessorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                availableProcessorFeatures = availableProcessorFeaturesBuffer
            } else {
                availableProcessorFeatures = []
            }
        } else {
            availableProcessorFeatures = nil
        }
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedEngineModesBuffer:[String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        let supportsStorageAutoscalingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .supportsStorageAutoscaling)
        supportsStorageAutoscaling = supportsStorageAutoscalingDecoded
        let supportsKerberosAuthenticationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .supportsKerberosAuthentication)
        supportsKerberosAuthentication = supportsKerberosAuthenticationDecoded
        let outpostCapableDecoded = try containerValues.decode(Bool.self, forKey: .outpostCapable)
        outpostCapable = outpostCapableDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
    }
}

extension OrderableDBInstanceOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrderableDBInstanceOption(availabilityZoneGroup: \(String(describing: availabilityZoneGroup)), availabilityZones: \(String(describing: availabilityZones)), availableProcessorFeatures: \(String(describing: availableProcessorFeatures)), dBInstanceClass: \(String(describing: dBInstanceClass)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), licenseModel: \(String(describing: licenseModel)), maxIopsPerDbInstance: \(String(describing: maxIopsPerDbInstance)), maxIopsPerGib: \(String(describing: maxIopsPerGib)), maxStorageSize: \(String(describing: maxStorageSize)), minIopsPerDbInstance: \(String(describing: minIopsPerDbInstance)), minIopsPerGib: \(String(describing: minIopsPerGib)), minStorageSize: \(String(describing: minStorageSize)), multiAZCapable: \(String(describing: multiAZCapable)), outpostCapable: \(String(describing: outpostCapable)), readReplicaCapable: \(String(describing: readReplicaCapable)), storageType: \(String(describing: storageType)), supportedEngineModes: \(String(describing: supportedEngineModes)), supportsEnhancedMonitoring: \(String(describing: supportsEnhancedMonitoring)), supportsGlobalDatabases: \(String(describing: supportsGlobalDatabases)), supportsIAMDatabaseAuthentication: \(String(describing: supportsIAMDatabaseAuthentication)), supportsIops: \(String(describing: supportsIops)), supportsKerberosAuthentication: \(String(describing: supportsKerberosAuthentication)), supportsPerformanceInsights: \(String(describing: supportsPerformanceInsights)), supportsStorageAutoscaling: \(String(describing: supportsStorageAutoscaling)), supportsStorageEncryption: \(String(describing: supportsStorageEncryption)), vpc: \(String(describing: vpc)))"}
}

/// <p>Contains a list of available options for a DB instance.</p>
///          <p>
///           This data type is used as a response element in the <code>DescribeOrderableDBInstanceOptions</code> action.
///         </p>
public struct OrderableDBInstanceOption: Equatable {
    /// <p>The Availability Zone group for a DB instance.</p>
    public let availabilityZoneGroup: String?
    /// <p>A list of Availability Zones for a DB instance.</p>
    public let availabilityZones: [AvailabilityZone]?
    /// <p>A list of the available processor features for the DB instance class of a DB instance.</p>
    public let availableProcessorFeatures: [AvailableProcessorFeature]?
    /// <p>The DB instance class for a DB instance.</p>
    public let dBInstanceClass: String?
    /// <p>The engine type of a DB instance.</p>
    public let engine: String?
    /// <p>The engine version of a DB instance.</p>
    public let engineVersion: String?
    /// <p>The license model for a DB instance.</p>
    public let licenseModel: String?
    /// <p>Maximum total provisioned IOPS for a DB instance.</p>
    public let maxIopsPerDbInstance: Int?
    /// <p>Maximum provisioned IOPS per GiB for a DB instance.</p>
    public let maxIopsPerGib: Double?
    /// <p>Maximum storage size for a DB instance.</p>
    public let maxStorageSize: Int?
    /// <p>Minimum total provisioned IOPS for a DB instance.</p>
    public let minIopsPerDbInstance: Int?
    /// <p>Minimum provisioned IOPS per GiB for a DB instance.</p>
    public let minIopsPerGib: Double?
    /// <p>Minimum storage size for a DB instance.</p>
    public let minStorageSize: Int?
    /// <p>Indicates whether a DB instance is Multi-AZ capable.</p>
    public let multiAZCapable: Bool
    /// <p>Whether a DB instance supports RDS on Outposts.</p>
    ///         <p>For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Amazon RDS on AWS Outposts</a>
    ///             in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let outpostCapable: Bool
    /// <p>Indicates whether a DB instance can have a read replica.</p>
    public let readReplicaCapable: Bool
    /// <p>Indicates the storage type for a DB instance.</p>
    public let storageType: String?
    /// <p>A list of the supported DB engine modes.</p>
    public let supportedEngineModes: [String]?
    /// <p>Indicates whether a DB instance supports Enhanced Monitoring at intervals from 1 to 60 seconds.</p>
    public let supportsEnhancedMonitoring: Bool
    /// <p>A value that indicates whether you can use Aurora global databases with a specific combination of other DB engine attributes.</p>
    public let supportsGlobalDatabases: Bool
    /// <p>Indicates whether a DB instance supports IAM database authentication.</p>
    public let supportsIAMDatabaseAuthentication: Bool
    /// <p>Indicates whether a DB instance supports provisioned IOPS.</p>
    public let supportsIops: Bool
    /// <p>Whether a DB instance supports Kerberos Authentication.</p>
    public let supportsKerberosAuthentication: Bool?
    /// <p>True if a DB instance supports Performance Insights, otherwise false.</p>
    public let supportsPerformanceInsights: Bool
    /// <p>Whether Amazon RDS can automatically scale storage for DB instances that use the specified DB instance class.</p>
    public let supportsStorageAutoscaling: Bool?
    /// <p>Indicates whether a DB instance supports encrypted storage.</p>
    public let supportsStorageEncryption: Bool
    /// <p>Indicates whether a DB instance is in a VPC.</p>
    public let vpc: Bool

    public init (
        availabilityZoneGroup: String? = nil,
        availabilityZones: [AvailabilityZone]? = nil,
        availableProcessorFeatures: [AvailableProcessorFeature]? = nil,
        dBInstanceClass: String? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        licenseModel: String? = nil,
        maxIopsPerDbInstance: Int? = nil,
        maxIopsPerGib: Double? = nil,
        maxStorageSize: Int? = nil,
        minIopsPerDbInstance: Int? = nil,
        minIopsPerGib: Double? = nil,
        minStorageSize: Int? = nil,
        multiAZCapable: Bool = false,
        outpostCapable: Bool = false,
        readReplicaCapable: Bool = false,
        storageType: String? = nil,
        supportedEngineModes: [String]? = nil,
        supportsEnhancedMonitoring: Bool = false,
        supportsGlobalDatabases: Bool = false,
        supportsIAMDatabaseAuthentication: Bool = false,
        supportsIops: Bool = false,
        supportsKerberosAuthentication: Bool? = nil,
        supportsPerformanceInsights: Bool = false,
        supportsStorageAutoscaling: Bool? = nil,
        supportsStorageEncryption: Bool = false,
        vpc: Bool = false
    )
    {
        self.availabilityZoneGroup = availabilityZoneGroup
        self.availabilityZones = availabilityZones
        self.availableProcessorFeatures = availableProcessorFeatures
        self.dBInstanceClass = dBInstanceClass
        self.engine = engine
        self.engineVersion = engineVersion
        self.licenseModel = licenseModel
        self.maxIopsPerDbInstance = maxIopsPerDbInstance
        self.maxIopsPerGib = maxIopsPerGib
        self.maxStorageSize = maxStorageSize
        self.minIopsPerDbInstance = minIopsPerDbInstance
        self.minIopsPerGib = minIopsPerGib
        self.minStorageSize = minStorageSize
        self.multiAZCapable = multiAZCapable
        self.outpostCapable = outpostCapable
        self.readReplicaCapable = readReplicaCapable
        self.storageType = storageType
        self.supportedEngineModes = supportedEngineModes
        self.supportsEnhancedMonitoring = supportsEnhancedMonitoring
        self.supportsGlobalDatabases = supportsGlobalDatabases
        self.supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthentication
        self.supportsIops = supportsIops
        self.supportsKerberosAuthentication = supportsKerberosAuthentication
        self.supportsPerformanceInsights = supportsPerformanceInsights
        self.supportsStorageAutoscaling = supportsStorageAutoscaling
        self.supportsStorageEncryption = supportsStorageEncryption
        self.vpc = vpc
    }
}

extension Outpost: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension Outpost: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Outpost(arn: \(String(describing: arn)))"}
}

/// <p>A data type that represents an Outpost.</p>
///          <p>For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Amazon RDS on AWS Outposts</a>
///           in the <i>Amazon RDS User Guide.</i>
///          </p>
public struct Outpost: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

extension Parameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedValues = "AllowedValues"
        case applyMethod = "ApplyMethod"
        case applyType = "ApplyType"
        case dataType = "DataType"
        case description = "Description"
        case isModifiable = "IsModifiable"
        case minimumEngineVersion = "MinimumEngineVersion"
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
        case source = "Source"
        case supportedEngineModes = "SupportedEngineModes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: Key("AllowedValues"))
        }
        if let applyMethod = applyMethod {
            try container.encode(applyMethod, forKey: Key("ApplyMethod"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: Key("ApplyType"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: Key("DataType"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: Key("IsModifiable"))
        }
        if let minimumEngineVersion = minimumEngineVersion {
            try container.encode(minimumEngineVersion, forKey: Key("MinimumEngineVersion"))
        }
        if let parameterName = parameterName {
            try container.encode(parameterName, forKey: Key("ParameterName"))
        }
        if let parameterValue = parameterValue {
            try container.encode(parameterValue, forKey: Key("ParameterValue"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decode(Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
        let applyMethodDecoded = try containerValues.decodeIfPresent(ApplyMethod.self, forKey: .applyMethod)
        applyMethod = applyMethodDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedEngineModesBuffer:[String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
    }
}

extension Parameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Parameter(allowedValues: \(String(describing: allowedValues)), applyMethod: \(String(describing: applyMethod)), applyType: \(String(describing: applyType)), dataType: \(String(describing: dataType)), description: \(String(describing: description)), isModifiable: \(String(describing: isModifiable)), minimumEngineVersion: \(String(describing: minimumEngineVersion)), parameterName: \(String(describing: parameterName)), parameterValue: \(String(describing: parameterValue)), source: \(String(describing: source)), supportedEngineModes: \(String(describing: supportedEngineModes)))"}
}

/// <p>
///         This data type is used as a request parameter in the
///         <code>ModifyDBParameterGroup</code> and <code>ResetDBParameterGroup</code> actions.
///         </p>
///          <p>This data type is used as a response element in the
///         <code>DescribeEngineDefaultParameters</code> and <code>DescribeDBParameters</code> actions.</p>
public struct Parameter: Equatable {
    /// <p>Specifies the valid range of values for the parameter.</p>
    public let allowedValues: String?
    /// <p>Indicates when to apply parameter updates.</p>
    public let applyMethod: ApplyMethod?
    /// <p>Specifies the engine specific parameters type.</p>
    public let applyType: String?
    /// <p>Specifies the valid data type for the parameter.</p>
    public let dataType: String?
    /// <p>Provides a description of the parameter.</p>
    public let description: String?
    /// <p>
    ///         Indicates whether (<code>true</code>) or not (<code>false</code>) the parameter can be modified.
    ///         Some parameters have security or operational implications
    ///         that prevent them from being changed.
    ///         </p>
    public let isModifiable: Bool
    /// <p>The earliest engine version to which the parameter can apply.</p>
    public let minimumEngineVersion: String?
    /// <p>Specifies the name of the parameter.</p>
    public let parameterName: String?
    /// <p>Specifies the value of the parameter.</p>
    public let parameterValue: String?
    /// <p>Indicates the source of the parameter value.</p>
    public let source: String?
    /// <p>The valid DB engine modes.</p>
    public let supportedEngineModes: [String]?

    public init (
        allowedValues: String? = nil,
        applyMethod: ApplyMethod? = nil,
        applyType: String? = nil,
        dataType: String? = nil,
        description: String? = nil,
        isModifiable: Bool = false,
        minimumEngineVersion: String? = nil,
        parameterName: String? = nil,
        parameterValue: String? = nil,
        source: String? = nil,
        supportedEngineModes: [String]? = nil
    )
    {
        self.allowedValues = allowedValues
        self.applyMethod = applyMethod
        self.applyType = applyType
        self.dataType = dataType
        self.description = description
        self.isModifiable = isModifiable
        self.minimumEngineVersion = minimumEngineVersion
        self.parameterName = parameterName
        self.parameterValue = parameterValue
        self.source = source
        self.supportedEngineModes = supportedEngineModes
    }
}

extension PendingCloudwatchLogsExports: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logTypesToDisable = "LogTypesToDisable"
        case logTypesToEnable = "LogTypesToEnable"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let logTypesToDisable = logTypesToDisable {
            var logTypesToDisableContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LogTypesToDisable"))
            for (index0, string0) in logTypesToDisable.enumerated() {
                try logTypesToDisableContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let logTypesToEnable = logTypesToEnable {
            var logTypesToEnableContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LogTypesToEnable"))
            for (index0, string0) in logTypesToEnable.enumerated() {
                try logTypesToEnableContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.logTypesToEnable) {
            struct KeyVal0{struct member{}}
            let logTypesToEnableWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .logTypesToEnable)
            if let logTypesToEnableWrappedContainer = logTypesToEnableWrappedContainer {
                let logTypesToEnableContainer = try logTypesToEnableWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var logTypesToEnableBuffer:[String]? = nil
                if let logTypesToEnableContainer = logTypesToEnableContainer {
                    logTypesToEnableBuffer = [String]()
                    for stringContainer0 in logTypesToEnableContainer {
                        logTypesToEnableBuffer?.append(stringContainer0)
                    }
                }
                logTypesToEnable = logTypesToEnableBuffer
            } else {
                logTypesToEnable = []
            }
        } else {
            logTypesToEnable = nil
        }
        if containerValues.contains(.logTypesToDisable) {
            struct KeyVal0{struct member{}}
            let logTypesToDisableWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .logTypesToDisable)
            if let logTypesToDisableWrappedContainer = logTypesToDisableWrappedContainer {
                let logTypesToDisableContainer = try logTypesToDisableWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var logTypesToDisableBuffer:[String]? = nil
                if let logTypesToDisableContainer = logTypesToDisableContainer {
                    logTypesToDisableBuffer = [String]()
                    for stringContainer0 in logTypesToDisableContainer {
                        logTypesToDisableBuffer?.append(stringContainer0)
                    }
                }
                logTypesToDisable = logTypesToDisableBuffer
            } else {
                logTypesToDisable = []
            }
        } else {
            logTypesToDisable = nil
        }
    }
}

extension PendingCloudwatchLogsExports: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingCloudwatchLogsExports(logTypesToDisable: \(String(describing: logTypesToDisable)), logTypesToEnable: \(String(describing: logTypesToEnable)))"}
}

/// <p>A list of the log types whose configuration is still pending. In other words, these log types are in the process of being activated or deactivated.</p>
public struct PendingCloudwatchLogsExports: Equatable {
    /// <p>Log types that are in the process of being enabled. After they are enabled, these log types are exported to CloudWatch Logs.</p>
    public let logTypesToDisable: [String]?
    /// <p>Log types that are in the process of being deactivated. After they are deactivated, these log types aren't exported to CloudWatch Logs.</p>
    public let logTypesToEnable: [String]?

    public init (
        logTypesToDisable: [String]? = nil,
        logTypesToEnable: [String]? = nil
    )
    {
        self.logTypesToDisable = logTypesToDisable
        self.logTypesToEnable = logTypesToEnable
    }
}

extension PendingMaintenanceAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case autoAppliedAfterDate = "AutoAppliedAfterDate"
        case currentApplyDate = "CurrentApplyDate"
        case description = "Description"
        case forcedApplyDate = "ForcedApplyDate"
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let action = action {
            try container.encode(action, forKey: Key("Action"))
        }
        if let autoAppliedAfterDate = autoAppliedAfterDate {
            try container.encode(TimestampWrapper(autoAppliedAfterDate, format: .dateTime), forKey: Key("autoAppliedAfterDate"))
        }
        if let currentApplyDate = currentApplyDate {
            try container.encode(TimestampWrapper(currentApplyDate, format: .dateTime), forKey: Key("currentApplyDate"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let forcedApplyDate = forcedApplyDate {
            try container.encode(TimestampWrapper(forcedApplyDate, format: .dateTime), forKey: Key("forcedApplyDate"))
        }
        if let optInStatus = optInStatus {
            try container.encode(optInStatus, forKey: Key("OptInStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let autoAppliedAfterDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoAppliedAfterDate)
        var autoAppliedAfterDateBuffer:Date? = nil
        if let autoAppliedAfterDateDecoded = autoAppliedAfterDateDecoded {
            autoAppliedAfterDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(autoAppliedAfterDateDecoded, format: .dateTime)
        }
        autoAppliedAfterDate = autoAppliedAfterDateBuffer
        let forcedApplyDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forcedApplyDate)
        var forcedApplyDateBuffer:Date? = nil
        if let forcedApplyDateDecoded = forcedApplyDateDecoded {
            forcedApplyDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(forcedApplyDateDecoded, format: .dateTime)
        }
        forcedApplyDate = forcedApplyDateBuffer
        let optInStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
        let currentApplyDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentApplyDate)
        var currentApplyDateBuffer:Date? = nil
        if let currentApplyDateDecoded = currentApplyDateDecoded {
            currentApplyDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(currentApplyDateDecoded, format: .dateTime)
        }
        currentApplyDate = currentApplyDateBuffer
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension PendingMaintenanceAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingMaintenanceAction(action: \(String(describing: action)), autoAppliedAfterDate: \(String(describing: autoAppliedAfterDate)), currentApplyDate: \(String(describing: currentApplyDate)), description: \(String(describing: description)), forcedApplyDate: \(String(describing: forcedApplyDate)), optInStatus: \(String(describing: optInStatus)))"}
}

/// <p>Provides information about a pending maintenance action for a resource.</p>
public struct PendingMaintenanceAction: Equatable {
    /// <p>The type of pending maintenance action that is available for the resource.
    ///           Valid actions are <code>system-update</code>, <code>db-upgrade</code>, <code>hardware-maintenance</code>,
    ///           and <code>ca-certificate-rotation</code>.</p>
    public let action: String?
    /// <p>The date of the maintenance window when the action is applied.
    ///            The maintenance action is applied to the resource during
    ///            its first maintenance window after this date.</p>
    public let autoAppliedAfterDate: Date?
    /// <p>The effective date when the pending maintenance action is applied
    ///            to the resource. This date takes into account opt-in requests received from
    ///            the <code>ApplyPendingMaintenanceAction</code> API, the <code>AutoAppliedAfterDate</code>,
    ///            and the <code>ForcedApplyDate</code>. This value is blank if an
    ///            opt-in request has not been received and nothing has been specified as
    ///            <code>AutoAppliedAfterDate</code> or <code>ForcedApplyDate</code>.</p>
    public let currentApplyDate: Date?
    /// <p>A description providing more detail about the maintenance action.</p>
    public let description: String?
    /// <p>The date when the maintenance action is automatically applied.</p>
    ///          <p>On this date, the maintenance action is applied to the resource as soon as possible,
    ///             regardless of the maintenance window for the resource. There might be a delay of
    ///             one or more days from this date before the maintenance action is applied.</p>
    public let forcedApplyDate: Date?
    /// <p>Indicates the type of opt-in request that has been received for the resource.</p>
    public let optInStatus: String?

    public init (
        action: String? = nil,
        autoAppliedAfterDate: Date? = nil,
        currentApplyDate: Date? = nil,
        description: String? = nil,
        forcedApplyDate: Date? = nil,
        optInStatus: String? = nil
    )
    {
        self.action = action
        self.autoAppliedAfterDate = autoAppliedAfterDate
        self.currentApplyDate = currentApplyDate
        self.description = description
        self.forcedApplyDate = forcedApplyDate
        self.optInStatus = optInStatus
    }
}

extension PendingModifiedValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case iops = "Iops"
        case licenseModel = "LicenseModel"
        case masterUserPassword = "MasterUserPassword"
        case multiAZ = "MultiAZ"
        case pendingCloudwatchLogsExports = "PendingCloudwatchLogsExports"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: Key("CACertificateIdentifier"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let pendingCloudwatchLogsExports = pendingCloudwatchLogsExports {
            try container.encode(pendingCloudwatchLogsExports, forKey: Key("PendingCloudwatchLogsExports"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let pendingCloudwatchLogsExportsDecoded = try containerValues.decodeIfPresent(PendingCloudwatchLogsExports.self, forKey: .pendingCloudwatchLogsExports)
        pendingCloudwatchLogsExports = pendingCloudwatchLogsExportsDecoded
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
    }
}

extension PendingModifiedValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingModifiedValues(allocatedStorage: \(String(describing: allocatedStorage)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(String(describing: cACertificateIdentifier)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), engineVersion: \(String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(String(describing: iAMDatabaseAuthenticationEnabled)), iops: \(String(describing: iops)), licenseModel: \(String(describing: licenseModel)), masterUserPassword: \(String(describing: masterUserPassword)), multiAZ: \(String(describing: multiAZ)), pendingCloudwatchLogsExports: \(String(describing: pendingCloudwatchLogsExports)), port: \(String(describing: port)), processorFeatures: \(String(describing: processorFeatures)), storageType: \(String(describing: storageType)))"}
}

/// <p>
///         This data type is used as a response element in the <code>ModifyDBInstance</code> operation and
///           contains changes that will be applied during the next maintenance window.
///        </p>
public struct PendingModifiedValues: Equatable {
    /// <p>The allocated storage size for the DB instance specified in gibibytes .</p>
    public let allocatedStorage: Int?
    /// <p>The number of days for which automated backups are retained.</p>
    public let backupRetentionPeriod: Int?
    /// <p>The identifier of the CA certificate for the DB instance.</p>
    public let cACertificateIdentifier: String?
    /// <p>The name of the compute and memory capacity class for the DB instance.</p>
    public let dBInstanceClass: String?
    /// <p>The  database identifier for the DB instance.</p>
    public let dBInstanceIdentifier: String?
    /// <p>The DB subnet group for the DB instance.</p>
    public let dBSubnetGroupName: String?
    /// <p>The database engine version.</p>
    public let engineVersion: String?
    /// <p>Whether mapping of AWS Identity and Access Management (IAM) accounts to database accounts is enabled.</p>
    public let iAMDatabaseAuthenticationEnabled: Bool?
    /// <p>The Provisioned IOPS value for the DB instance.</p>
    public let iops: Int?
    /// <p>The license model for the DB instance.</p>
    ///         <p>Valid values: <code>license-included</code> | <code>bring-your-own-license</code> |
    ///             <code>general-public-license</code>
    ///          </p>
    public let licenseModel: String?
    /// <p>The master credentials for the DB instance.</p>
    public let masterUserPassword: String?
    /// <p>A value that indicates that the Single-AZ DB instance will change to a Multi-AZ deployment.</p>
    public let multiAZ: Bool?
    /// <p>A list of the log types whose configuration is still pending. In other words, these log types are in the process of being activated or deactivated.</p>
    public let pendingCloudwatchLogsExports: PendingCloudwatchLogsExports?
    /// <p>The port for the DB instance.</p>
    public let port: Int?
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class
    ///             of the DB instance.</p>
    public let processorFeatures: [ProcessorFeature]?
    /// <p>The storage type of the DB instance.</p>
    public let storageType: String?

    public init (
        allocatedStorage: Int? = nil,
        backupRetentionPeriod: Int? = nil,
        cACertificateIdentifier: String? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBSubnetGroupName: String? = nil,
        engineVersion: String? = nil,
        iAMDatabaseAuthenticationEnabled: Bool? = nil,
        iops: Int? = nil,
        licenseModel: String? = nil,
        masterUserPassword: String? = nil,
        multiAZ: Bool? = nil,
        pendingCloudwatchLogsExports: PendingCloudwatchLogsExports? = nil,
        port: Int? = nil,
        processorFeatures: [ProcessorFeature]? = nil,
        storageType: String? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cACertificateIdentifier = cACertificateIdentifier
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSubnetGroupName = dBSubnetGroupName
        self.engineVersion = engineVersion
        self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
        self.iops = iops
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.multiAZ = multiAZ
        self.pendingCloudwatchLogsExports = pendingCloudwatchLogsExports
        self.port = port
        self.processorFeatures = processorFeatures
        self.storageType = storageType
    }
}

extension PointInTimeRestoreNotEnabledFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PointInTimeRestoreNotEnabledFault(message: \(String(describing: message)))"}
}

extension PointInTimeRestoreNotEnabledFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PointInTimeRestoreNotEnabledFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>SourceDBInstanceIdentifier</code>
///         refers to a DB instance with
///         <code>BackupRetentionPeriod</code> equal to 0.
///         </p>
public struct PointInTimeRestoreNotEnabledFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PointInTimeRestoreNotEnabledFaultBody: Equatable {
    public let message: String?
}

extension PointInTimeRestoreNotEnabledFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProcessorFeature: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ProcessorFeature: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProcessorFeature(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Contains the processor features of a DB instance class.</p>
///         <p>To specify the number of CPU cores, use the <code>coreCount</code> feature name
///             for the <code>Name</code> parameter. To specify the number of threads per core, use the
///             <code>threadsPerCore</code> feature name for the <code>Name</code> parameter.</p>
///         <p>You can set the processor features of the DB instance class for a DB instance when you
///             call one of the following actions:</p>
///         <ul>
///             <li>
///                 <p>
///                   <code>CreateDBInstance</code>
///                </p>
///             </li>
///             <li>
///                 <p>
///                   <code>ModifyDBInstance</code>
///                </p>
///             </li>
///             <li>
///                 <p>
///                   <code>RestoreDBInstanceFromDBSnapshot</code>
///                </p>
///             </li>
///             <li>
///                 <p>
///                   <code>RestoreDBInstanceFromS3</code>
///                </p>
///             </li>
///             <li>
///                 <p>
///                   <code>RestoreDBInstanceToPointInTime</code>
///                </p>
///             </li>
///          </ul>
///         <p>You can view the valid processor values for a particular instance class by calling the
///                 <code>DescribeOrderableDBInstanceOptions</code> action and specifying the
///             instance class for the <code>DBInstanceClass</code> parameter.</p>
///         <p>In addition, you can use the following actions for DB instance class processor information:</p>
///         <ul>
///             <li>
///                 <p>
///                   <code>DescribeDBInstances</code>
///                </p>
///             </li>
///             <li>
///                 <p>
///                   <code>DescribeDBSnapshots</code>
///                </p>
///             </li>
///             <li>
///                 <p>
///                   <code>DescribeValidDBInstanceModifications</code>
///                </p>
///             </li>
///          </ul>
///         <p>If you call <code>DescribeDBInstances</code>, <code>ProcessorFeature</code> returns
///             non-null values only if the following conditions are met:</p>
///         <ul>
///             <li>
///                <p>You are accessing an Oracle DB instance.</p>
///             </li>
///             <li>
///                 <p>Your Oracle DB instance class supports configuring the number of CPU cores and threads per core.</p>
///             </li>
///             <li>
///                <p>The current number CPU cores and threads is set to a non-default value.</p>
///             </li>
///          </ul>
///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor">Configuring the
///                 Processor of the DB Instance Class</a> in the <i>Amazon RDS User Guide.
///             </i>
///          </p>
public struct ProcessorFeature: Equatable {
    /// <p>The name of the processor feature. Valid names are <code>coreCount</code> and <code>threadsPerCore</code>.</p>
    public let name: String?
    /// <p>The value of a processor feature name.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public struct PromoteReadReplicaDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "PromoteReadReplicaDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PromoteReadReplicaDBClusterOutputError>
}

extension PromoteReadReplicaDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PromoteReadReplicaDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)))"}
}

extension PromoteReadReplicaDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        try container.encode("PromoteReadReplicaDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct PromoteReadReplicaDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "PromoteReadReplicaDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PromoteReadReplicaDBClusterOutputError>
}

public struct PromoteReadReplicaDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "PromoteReadReplicaDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PromoteReadReplicaDBClusterOutputError>
}

/// <p></p>
public struct PromoteReadReplicaDBClusterInput: Equatable {
    /// <p>The identifier of the DB cluster read replica to promote. This parameter isn't
    ///             case-sensitive. </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DB cluster read replica.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster-replica1</code>
    ///          </p>
    public let dBClusterIdentifier: String?

    public init (
        dBClusterIdentifier: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension PromoteReadReplicaDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PromoteReadReplicaDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PromoteReadReplicaDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteReadReplicaDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PromoteReadReplicaDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension PromoteReadReplicaDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PromoteReadReplicaDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct PromoteReadReplicaDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Aurora DB cluster.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusters</code>,
    ///         <code>StopDBCluster</code>, and <code>StartDBCluster</code> actions.
    ///       </p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct PromoteReadReplicaDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension PromoteReadReplicaDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("PromoteReadReplicaDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct PromoteReadReplicaInputBodyMiddleware: Middleware {
    public let id: String = "PromoteReadReplicaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PromoteReadReplicaInput>,
                  next: H) -> Swift.Result<OperationOutput<PromoteReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PromoteReadReplicaInput>
    public typealias MOutput = OperationOutput<PromoteReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PromoteReadReplicaOutputError>
}

extension PromoteReadReplicaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PromoteReadReplicaInput(backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), preferredBackupWindow: \(String(describing: preferredBackupWindow)))"}
}

extension PromoteReadReplicaInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        try container.encode("PromoteReadReplica", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct PromoteReadReplicaInputHeadersMiddleware: Middleware {
    public let id: String = "PromoteReadReplicaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PromoteReadReplicaInput>,
                  next: H) -> Swift.Result<OperationOutput<PromoteReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PromoteReadReplicaInput>
    public typealias MOutput = OperationOutput<PromoteReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PromoteReadReplicaOutputError>
}

public struct PromoteReadReplicaInputQueryItemMiddleware: Middleware {
    public let id: String = "PromoteReadReplicaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PromoteReadReplicaInput>,
                  next: H) -> Swift.Result<OperationOutput<PromoteReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PromoteReadReplicaInput>
    public typealias MOutput = OperationOutput<PromoteReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PromoteReadReplicaOutputError>
}

/// <p></p>
public struct PromoteReadReplicaInput: Equatable {
    /// <p>The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.</p>
    ///          <p>Default: 1</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be a value from 0 to 35.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be set to 0 if the DB instance is a source to read replicas.</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Int?
    /// <p>The DB instance identifier. This value is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing read replica DB instance.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>mydbinstance</code>
    ///          </p>
    public let dBInstanceIdentifier: String?
    /// <p>
    ///         The daily time range during which automated backups are created
    ///         if automated backups are enabled,
    ///         using the <code>BackupRetentionPeriod</code> parameter.
    ///         </p>
    ///          <p>
    ///             The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each AWS Region.
    ///             To see the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/AdjustingTheMaintenanceWindow.html">
    ///             Adjusting the Preferred Maintenance Window</a> in the <i>Amazon RDS User Guide.</i>
    ///         </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be in the format <code>hh24:mi-hh24:mi</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Coordinated Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes.</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: String?

    public init (
        backupRetentionPeriod: Int? = nil,
        dBInstanceIdentifier: String? = nil,
        preferredBackupWindow: String? = nil
    )
    {
        self.backupRetentionPeriod = backupRetentionPeriod
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.preferredBackupWindow = preferredBackupWindow
    }
}

extension PromoteReadReplicaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PromoteReadReplicaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PromoteReadReplicaOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteReadReplicaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PromoteReadReplicaOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension PromoteReadReplicaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PromoteReadReplicaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct PromoteReadReplicaOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB instance.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
    ///       </p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct PromoteReadReplicaOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension PromoteReadReplicaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("PromoteReadReplicaResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension ProvisionedIopsNotAvailableInAZFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionedIopsNotAvailableInAZFault(message: \(String(describing: message)))"}
}

extension ProvisionedIopsNotAvailableInAZFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ProvisionedIopsNotAvailableInAZFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provisioned IOPS not available in the specified Availability Zone.</p>
public struct ProvisionedIopsNotAvailableInAZFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ProvisionedIopsNotAvailableInAZFaultBody: Equatable {
    public let message: String?
}

extension ProvisionedIopsNotAvailableInAZFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PurchaseReservedDBInstancesOfferingInputBodyMiddleware: Middleware {
    public let id: String = "PurchaseReservedDBInstancesOfferingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseReservedDBInstancesOfferingOutputError>
}

extension PurchaseReservedDBInstancesOfferingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PurchaseReservedDBInstancesOfferingInput(dBInstanceCount: \(String(describing: dBInstanceCount)), reservedDBInstanceId: \(String(describing: reservedDBInstanceId)), reservedDBInstancesOfferingId: \(String(describing: reservedDBInstancesOfferingId)), tags: \(String(describing: tags)))"}
}

extension PurchaseReservedDBInstancesOfferingInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceCount = dBInstanceCount {
            try container.encode(dBInstanceCount, forKey: Key("DBInstanceCount"))
        }
        if let reservedDBInstanceId = reservedDBInstanceId {
            try container.encode(reservedDBInstanceId, forKey: Key("ReservedDBInstanceId"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: Key("ReservedDBInstancesOfferingId"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("PurchaseReservedDBInstancesOffering", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct PurchaseReservedDBInstancesOfferingInputHeadersMiddleware: Middleware {
    public let id: String = "PurchaseReservedDBInstancesOfferingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseReservedDBInstancesOfferingOutputError>
}

public struct PurchaseReservedDBInstancesOfferingInputQueryItemMiddleware: Middleware {
    public let id: String = "PurchaseReservedDBInstancesOfferingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseReservedDBInstancesOfferingOutputError>
}

/// <p></p>
public struct PurchaseReservedDBInstancesOfferingInput: Equatable {
    /// <p>The number of instances to reserve.</p>
    ///          <p>Default: <code>1</code>
    ///          </p>
    public let dBInstanceCount: Int?
    /// <p>Customer-specified identifier to track this reservation.</p>
    ///          <p>Example: myreservationID</p>
    public let reservedDBInstanceId: String?
    /// <p>The ID of the Reserved DB instance offering to purchase.</p>
    ///          <p>Example: 438012d3-4052-4cc7-b2e3-8d3372e0e706</p>
    public let reservedDBInstancesOfferingId: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?

    public init (
        dBInstanceCount: Int? = nil,
        reservedDBInstanceId: String? = nil,
        reservedDBInstancesOfferingId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBInstanceCount = dBInstanceCount
        self.reservedDBInstanceId = reservedDBInstanceId
        self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
        self.tags = tags
    }
}

extension PurchaseReservedDBInstancesOfferingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PurchaseReservedDBInstancesOfferingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ReservedDBInstanceAlreadyExistsFault" : self = .reservedDBInstanceAlreadyExistsFault(try ReservedDBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedDBInstanceQuotaExceededFault" : self = .reservedDBInstanceQuotaExceededFault(try ReservedDBInstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedDBInstancesOfferingNotFoundFault" : self = .reservedDBInstancesOfferingNotFoundFault(try ReservedDBInstancesOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseReservedDBInstancesOfferingOutputError: Equatable {
    case reservedDBInstanceAlreadyExistsFault(ReservedDBInstanceAlreadyExistsFault)
    case reservedDBInstanceQuotaExceededFault(ReservedDBInstanceQuotaExceededFault)
    case reservedDBInstancesOfferingNotFoundFault(ReservedDBInstancesOfferingNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseReservedDBInstancesOfferingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PurchaseReservedDBInstancesOfferingOutputResponse(reservedDBInstance: \(String(describing: reservedDBInstance)))"}
}

extension PurchaseReservedDBInstancesOfferingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PurchaseReservedDBInstancesOfferingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reservedDBInstance = output.reservedDBInstance
        } else {
            self.reservedDBInstance = nil
        }
    }
}

public struct PurchaseReservedDBInstancesOfferingOutputResponse: Equatable {
    /// <p>
    ///             This data type is used as a response element in the
    ///             <code>DescribeReservedDBInstances</code> and
    ///             <code>PurchaseReservedDBInstancesOffering</code> actions.
    ///         </p>
    public let reservedDBInstance: ReservedDBInstance?

    public init (
        reservedDBInstance: ReservedDBInstance? = nil
    )
    {
        self.reservedDBInstance = reservedDBInstance
    }
}

struct PurchaseReservedDBInstancesOfferingOutputResponseBody: Equatable {
    public let reservedDBInstance: ReservedDBInstance?
}

extension PurchaseReservedDBInstancesOfferingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reservedDBInstance = "ReservedDBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("PurchaseReservedDBInstancesOfferingResult"))
        let reservedDBInstanceDecoded = try containerValues.decodeIfPresent(ReservedDBInstance.self, forKey: .reservedDBInstance)
        reservedDBInstance = reservedDBInstanceDecoded
    }
}

extension Range: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case from = "From"
        case step = "Step"
        case to = "To"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if from != 0 {
            try container.encode(from, forKey: Key("From"))
        }
        if let step = step {
            try container.encode(step, forKey: Key("Step"))
        }
        if to != 0 {
            try container.encode(to, forKey: Key("To"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decode(Int.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decode(Int.self, forKey: .to)
        to = toDecoded
        let stepDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .step)
        step = stepDecoded
    }
}

extension Range: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Range(from: \(String(describing: from)), step: \(String(describing: step)), to: \(String(describing: to)))"}
}

/// <p>A range of integer values.</p>
public struct Range: Equatable {
    /// <p>The minimum value in the range.</p>
    public let from: Int
    /// <p>The step value for the range.
    ///             For example, if you have a range of 5,000 to 10,000,
    ///             with a step value of 1,000,
    ///             the valid values start at 5,000 and step up by 1,000.
    ///             Even though 7,500 is within the range,
    ///             it isn't a valid value for the range.
    ///             The valid values are 5,000, 6,000, 7,000, 8,000...
    ///         </p>
    public let step: Int?
    /// <p>The maximum value in the range.</p>
    public let to: Int

    public init (
        from: Int = 0,
        step: Int? = nil,
        to: Int = 0
    )
    {
        self.from = from
        self.step = step
        self.to = to
    }
}

public struct RebootDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "RebootDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootDBInstanceOutputError>
}

extension RebootDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootDBInstanceInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), forceFailover: \(String(describing: forceFailover)))"}
}

extension RebootDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let forceFailover = forceFailover {
            try container.encode(forceFailover, forKey: Key("ForceFailover"))
        }
        try container.encode("RebootDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RebootDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "RebootDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootDBInstanceOutputError>
}

public struct RebootDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "RebootDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootDBInstanceOutputError>
}

/// <p></p>
public struct RebootDBInstanceInput: Equatable {
    /// <p>The DB instance identifier. This parameter is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p>
    ///           A value that indicates whether the reboot is conducted through a Multi-AZ failover.
    ///       </p>
    ///          <p>Constraint: You can't enable force failover if the instance isn't configured for Multi-AZ.</p>
    public let forceFailover: Bool?

    public init (
        dBInstanceIdentifier: String? = nil,
        forceFailover: Bool? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.forceFailover = forceFailover
    }
}

extension RebootDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RebootDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootDBInstanceOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootDBInstanceOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension RebootDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RebootDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RebootDBInstanceOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB instance.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
    ///       </p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RebootDBInstanceOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension RebootDBInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RebootDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension RecurringCharge: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recurringChargeAmount = "RecurringChargeAmount"
        case recurringChargeFrequency = "RecurringChargeFrequency"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if recurringChargeAmount != 0.0 {
            try container.encode(String(recurringChargeAmount), forKey: Key("RecurringChargeAmount"))
        }
        if let recurringChargeFrequency = recurringChargeFrequency {
            try container.encode(recurringChargeFrequency, forKey: Key("RecurringChargeFrequency"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recurringChargeAmountDecoded = try containerValues.decode(Double.self, forKey: .recurringChargeAmount)
        recurringChargeAmount = recurringChargeAmountDecoded
        let recurringChargeFrequencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recurringChargeFrequency)
        recurringChargeFrequency = recurringChargeFrequencyDecoded
    }
}

extension RecurringCharge: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecurringCharge(recurringChargeAmount: \(String(describing: recurringChargeAmount)), recurringChargeFrequency: \(String(describing: recurringChargeFrequency)))"}
}

/// <p>
///             This data type is used as a response element in the
///             <code>DescribeReservedDBInstances</code> and <code>DescribeReservedDBInstancesOfferings</code> actions.
///         </p>
public struct RecurringCharge: Equatable {
    /// <p>The amount of the recurring charge.</p>
    public let recurringChargeAmount: Double
    /// <p>The frequency of the recurring charge.</p>
    public let recurringChargeFrequency: String?

    public init (
        recurringChargeAmount: Double = 0.0,
        recurringChargeFrequency: String? = nil
    )
    {
        self.recurringChargeAmount = recurringChargeAmount
        self.recurringChargeFrequency = recurringChargeFrequency
    }
}

public struct RegisterDBProxyTargetsInputBodyMiddleware: Middleware {
    public let id: String = "RegisterDBProxyTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDBProxyTargetsInput>
    public typealias MOutput = OperationOutput<RegisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDBProxyTargetsOutputError>
}

extension RegisterDBProxyTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterDBProxyTargetsInput(dBClusterIdentifiers: \(String(describing: dBClusterIdentifiers)), dBInstanceIdentifiers: \(String(describing: dBInstanceIdentifiers)), dBProxyName: \(String(describing: dBProxyName)), targetGroupName: \(String(describing: targetGroupName)))"}
}

extension RegisterDBProxyTargetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifiers = dBClusterIdentifiers {
            var dBClusterIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBClusterIdentifiers"))
            for (index0, string0) in dBClusterIdentifiers.enumerated() {
                try dBClusterIdentifiersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceIdentifiers = dBInstanceIdentifiers {
            var dBInstanceIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBInstanceIdentifiers"))
            for (index0, string0) in dBInstanceIdentifiers.enumerated() {
                try dBInstanceIdentifiersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: Key("DBProxyName"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: Key("TargetGroupName"))
        }
        try container.encode("RegisterDBProxyTargets", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RegisterDBProxyTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterDBProxyTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDBProxyTargetsInput>
    public typealias MOutput = OperationOutput<RegisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDBProxyTargetsOutputError>
}

public struct RegisterDBProxyTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterDBProxyTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDBProxyTargetsInput>
    public typealias MOutput = OperationOutput<RegisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDBProxyTargetsOutputError>
}

public struct RegisterDBProxyTargetsInput: Equatable {
    /// <p>One or more DB cluster identifiers.</p>
    public let dBClusterIdentifiers: [String]?
    /// <p>One or more DB instance identifiers.</p>
    public let dBInstanceIdentifiers: [String]?
    /// <p>The identifier of the <code>DBProxy</code> that is associated with the <code>DBProxyTargetGroup</code>.</p>
    public let dBProxyName: String?
    /// <p>The identifier of the <code>DBProxyTargetGroup</code>.</p>
    public let targetGroupName: String?

    public init (
        dBClusterIdentifiers: [String]? = nil,
        dBInstanceIdentifiers: [String]? = nil,
        dBProxyName: String? = nil,
        targetGroupName: String? = nil
    )
    {
        self.dBClusterIdentifiers = dBClusterIdentifiers
        self.dBInstanceIdentifiers = dBInstanceIdentifiers
        self.dBProxyName = dBProxyName
        self.targetGroupName = targetGroupName
    }
}

extension RegisterDBProxyTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RegisterDBProxyTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetAlreadyRegisteredFault" : self = .dBProxyTargetAlreadyRegisteredFault(try DBProxyTargetAlreadyRegisteredFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientAvailableIPsInSubnetFault" : self = .insufficientAvailableIPsInSubnetFault(try InsufficientAvailableIPsInSubnetFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterDBProxyTargetsOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetAlreadyRegisteredFault(DBProxyTargetAlreadyRegisteredFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case insufficientAvailableIPsInSubnetFault(InsufficientAvailableIPsInSubnetFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterDBProxyTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterDBProxyTargetsOutputResponse(dBProxyTargets: \(String(describing: dBProxyTargets)))"}
}

extension RegisterDBProxyTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterDBProxyTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBProxyTargets = output.dBProxyTargets
        } else {
            self.dBProxyTargets = nil
        }
    }
}

public struct RegisterDBProxyTargetsOutputResponse: Equatable {
    /// <p>One or more <code>DBProxyTarget</code> objects that are created when you register targets with a target group.</p>
    public let dBProxyTargets: [DBProxyTarget]?

    public init (
        dBProxyTargets: [DBProxyTarget]? = nil
    )
    {
        self.dBProxyTargets = dBProxyTargets
    }
}

struct RegisterDBProxyTargetsOutputResponseBody: Equatable {
    public let dBProxyTargets: [DBProxyTarget]?
}

extension RegisterDBProxyTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBProxyTargets = "DBProxyTargets"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RegisterDBProxyTargetsResult"))
        if containerValues.contains(.dBProxyTargets) {
            struct KeyVal0{struct member{}}
            let dBProxyTargetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBProxyTargets)
            if let dBProxyTargetsWrappedContainer = dBProxyTargetsWrappedContainer {
                let dBProxyTargetsContainer = try dBProxyTargetsWrappedContainer.decodeIfPresent([DBProxyTarget].self, forKey: .member)
                var dBProxyTargetsBuffer:[DBProxyTarget]? = nil
                if let dBProxyTargetsContainer = dBProxyTargetsContainer {
                    dBProxyTargetsBuffer = [DBProxyTarget]()
                    for structureContainer0 in dBProxyTargetsContainer {
                        dBProxyTargetsBuffer?.append(structureContainer0)
                    }
                }
                dBProxyTargets = dBProxyTargetsBuffer
            } else {
                dBProxyTargets = []
            }
        } else {
            dBProxyTargets = nil
        }
    }
}

public struct RemoveFromGlobalClusterInputBodyMiddleware: Middleware {
    public let id: String = "RemoveFromGlobalClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFromGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFromGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFromGlobalClusterInput>
    public typealias MOutput = OperationOutput<RemoveFromGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFromGlobalClusterOutputError>
}

extension RemoveFromGlobalClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFromGlobalClusterInput(dbClusterIdentifier: \(String(describing: dbClusterIdentifier)), globalClusterIdentifier: \(String(describing: globalClusterIdentifier)))"}
}

extension RemoveFromGlobalClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dbClusterIdentifier = dbClusterIdentifier {
            try container.encode(dbClusterIdentifier, forKey: Key("DbClusterIdentifier"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: Key("GlobalClusterIdentifier"))
        }
        try container.encode("RemoveFromGlobalCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RemoveFromGlobalClusterInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveFromGlobalClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFromGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFromGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFromGlobalClusterInput>
    public typealias MOutput = OperationOutput<RemoveFromGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFromGlobalClusterOutputError>
}

public struct RemoveFromGlobalClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveFromGlobalClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFromGlobalClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFromGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFromGlobalClusterInput>
    public typealias MOutput = OperationOutput<RemoveFromGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFromGlobalClusterOutputError>
}

public struct RemoveFromGlobalClusterInput: Equatable {
    /// <p>
    ///         The Amazon Resource Name (ARN) identifying the cluster that was detached from the Aurora global database cluster.
    ///       </p>
    public let dbClusterIdentifier: String?
    /// <p>
    ///         The cluster identifier to detach from the Aurora global database cluster.
    ///       </p>
    public let globalClusterIdentifier: String?

    public init (
        dbClusterIdentifier: String? = nil,
        globalClusterIdentifier: String? = nil
    )
    {
        self.dbClusterIdentifier = dbClusterIdentifier
        self.globalClusterIdentifier = globalClusterIdentifier
    }
}

extension RemoveFromGlobalClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveFromGlobalClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFromGlobalClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFromGlobalClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFromGlobalClusterOutputResponse(globalCluster: \(String(describing: globalCluster)))"}
}

extension RemoveFromGlobalClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveFromGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct RemoveFromGlobalClusterOutputResponse: Equatable {
    /// <p>A data type representing an Aurora global database.</p>
    public let globalCluster: GlobalCluster?

    public init (
        globalCluster: GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct RemoveFromGlobalClusterOutputResponseBody: Equatable {
    public let globalCluster: GlobalCluster?
}

extension RemoveFromGlobalClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RemoveFromGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

public struct RemoveRoleFromDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "RemoveRoleFromDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromDBClusterOutputError>
}

extension RemoveRoleFromDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRoleFromDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), featureName: \(String(describing: featureName)), roleArn: \(String(describing: roleArn)))"}
}

extension RemoveRoleFromDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        try container.encode("RemoveRoleFromDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RemoveRoleFromDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveRoleFromDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromDBClusterOutputError>
}

public struct RemoveRoleFromDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveRoleFromDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromDBClusterOutputError>
}

public struct RemoveRoleFromDBClusterInput: Equatable {
    /// <p>The name of the DB cluster to disassociate the IAM role from.</p>
    public let dBClusterIdentifier: String?
    /// <p>The name of the feature for the DB cluster that the IAM role is to be disassociated from.
    ///             For the list of supported feature names, see <a>DBEngineVersion</a>.</p>
    public let featureName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to disassociate from the Aurora DB cluster, for example
    ///         <code>arn:aws:iam::123456789012:role/AuroraAccessRole</code>.</p>
    public let roleArn: String?

    public init (
        dBClusterIdentifier: String? = nil,
        featureName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension RemoveRoleFromDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveRoleFromDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleNotFoundFault" : self = .dBClusterRoleNotFoundFault(try DBClusterRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRoleFromDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterRoleNotFoundFault(DBClusterRoleNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRoleFromDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRoleFromDBClusterOutputResponse()"}
}

extension RemoveRoleFromDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveRoleFromDBClusterOutputResponse: Equatable {

    public init() {}
}

struct RemoveRoleFromDBClusterOutputResponseBody: Equatable {
}

extension RemoveRoleFromDBClusterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveRoleFromDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "RemoveRoleFromDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromDBInstanceInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromDBInstanceOutputError>
}

extension RemoveRoleFromDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRoleFromDBInstanceInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), featureName: \(String(describing: featureName)), roleArn: \(String(describing: roleArn)))"}
}

extension RemoveRoleFromDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        try container.encode("RemoveRoleFromDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RemoveRoleFromDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveRoleFromDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromDBInstanceInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromDBInstanceOutputError>
}

public struct RemoveRoleFromDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveRoleFromDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromDBInstanceInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromDBInstanceOutputError>
}

public struct RemoveRoleFromDBInstanceInput: Equatable {
    /// <p>The name of the DB instance to disassociate the IAM role from.</p>
    public let dBInstanceIdentifier: String?
    /// <p>The name of the feature for the DB instance that the IAM role is to be disassociated from.
    ///             For the list of supported feature names, see <code>DBEngineVersion</code>.
    ///         </p>
    public let featureName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to disassociate from the DB instance,
    ///             for example, <code>arn:aws:iam::123456789012:role/AccessRole</code>.</p>
    public let roleArn: String?

    public init (
        dBInstanceIdentifier: String? = nil,
        featureName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension RemoveRoleFromDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveRoleFromDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceRoleNotFoundFault" : self = .dBInstanceRoleNotFoundFault(try DBInstanceRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRoleFromDBInstanceOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBInstanceRoleNotFoundFault(DBInstanceRoleNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRoleFromDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRoleFromDBInstanceOutputResponse()"}
}

extension RemoveRoleFromDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveRoleFromDBInstanceOutputResponse: Equatable {

    public init() {}
}

struct RemoveRoleFromDBInstanceOutputResponseBody: Equatable {
}

extension RemoveRoleFromDBInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveSourceIdentifierFromSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "RemoveSourceIdentifierFromSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

extension RemoveSourceIdentifierFromSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveSourceIdentifierFromSubscriptionInput(sourceIdentifier: \(String(describing: sourceIdentifier)), subscriptionName: \(String(describing: subscriptionName)))"}
}

extension RemoveSourceIdentifierFromSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: Key("SourceIdentifier"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("RemoveSourceIdentifierFromSubscription", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RemoveSourceIdentifierFromSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveSourceIdentifierFromSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

public struct RemoveSourceIdentifierFromSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveSourceIdentifierFromSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

/// <p></p>
public struct RemoveSourceIdentifierFromSubscriptionInput: Equatable {
    /// <p>
    ///             The source identifier to be removed from the subscription, such as the <b>DB instance identifier</b>
    ///             for a DB instance or the name of a security group.
    ///         </p>
    public let sourceIdentifier: String?
    /// <p>The name of the RDS event notification subscription you want to remove a source identifier from.</p>
    public let subscriptionName: String?

    public init (
        sourceIdentifier: String? = nil,
        subscriptionName: String? = nil
    )
    {
        self.sourceIdentifier = sourceIdentifier
        self.subscriptionName = subscriptionName
    }
}

extension RemoveSourceIdentifierFromSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveSourceIdentifierFromSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveSourceIdentifierFromSubscriptionOutputError: Equatable {
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveSourceIdentifierFromSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveSourceIdentifierFromSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct RemoveSourceIdentifierFromSubscriptionOutputResponse: Equatable {
    /// <p>Contains the results of a successful invocation of the <code>DescribeEventSubscriptions</code> action.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct RemoveSourceIdentifierFromSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RemoveSourceIdentifierFromSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceInput(resourceName: \(String(describing: resourceName)), tagKeys: \(String(describing: tagKeys)))"}
}

extension RemoveTagsFromResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RemoveTagsFromResource", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

/// <p></p>
public struct RemoveTagsFromResourceInput: Equatable {
    /// <p>The Amazon RDS resource that the tags are removed from. This value is an Amazon Resource Name (ARN). For information about
    ///             creating an ARN,
    ///             see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///                 Constructing an ARN for Amazon RDS</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let resourceName: String?
    /// <p>The tag key (name) of the tag to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceName: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceName = resourceName
        self.tagKeys = tagKeys
    }
}

extension RemoveTagsFromResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceOutputResponse()"}
}

extension RemoveTagsFromResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromResourceOutputResponse: Equatable {

    public init() {}
}

struct RemoveTagsFromResourceOutputResponseBody: Equatable {
}

extension RemoveTagsFromResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ReplicaMode {
    case mounted
    case openReadOnly
    case sdkUnknown(String)
}

extension ReplicaMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicaMode] {
        return [
            .mounted,
            .openReadOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .mounted: return "mounted"
        case .openReadOnly: return "open-read-only"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicaMode(rawValue: rawValue) ?? ReplicaMode.sdkUnknown(rawValue)
    }
}

extension ReservedDBInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "CurrencyCode"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceCount = "DBInstanceCount"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case leaseId = "LeaseId"
        case multiAZ = "MultiAZ"
        case offeringType = "OfferingType"
        case productDescription = "ProductDescription"
        case recurringCharges = "RecurringCharges"
        case reservedDBInstanceArn = "ReservedDBInstanceArn"
        case reservedDBInstanceId = "ReservedDBInstanceId"
        case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
        case startTime = "StartTime"
        case state = "State"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let currencyCode = currencyCode {
            try container.encode(currencyCode, forKey: Key("CurrencyCode"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if dBInstanceCount != 0 {
            try container.encode(dBInstanceCount, forKey: Key("DBInstanceCount"))
        }
        if duration != 0 {
            try container.encode(duration, forKey: Key("Duration"))
        }
        if fixedPrice != 0.0 {
            try container.encode(String(fixedPrice), forKey: Key("FixedPrice"))
        }
        if let leaseId = leaseId {
            try container.encode(leaseId, forKey: Key("LeaseId"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: Key("ProductDescription"))
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RecurringCharges"))
            for (index0, recurringcharge0) in recurringCharges.enumerated() {
                try recurringChargesContainer.encode(recurringcharge0, forKey: Key("RecurringCharge.\(index0.advanced(by: 1))"))
            }
        }
        if let reservedDBInstanceArn = reservedDBInstanceArn {
            try container.encode(reservedDBInstanceArn, forKey: Key("ReservedDBInstanceArn"))
        }
        if let reservedDBInstanceId = reservedDBInstanceId {
            try container.encode(reservedDBInstanceId, forKey: Key("ReservedDBInstanceId"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: Key("ReservedDBInstancesOfferingId"))
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
        if usagePrice != 0.0 {
            try container.encode(String(usagePrice), forKey: Key("UsagePrice"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedDBInstanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservedDBInstanceId)
        reservedDBInstanceId = reservedDBInstanceIdDecoded
        let reservedDBInstancesOfferingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservedDBInstancesOfferingId)
        reservedDBInstancesOfferingId = reservedDBInstancesOfferingIdDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        var startTimeBuffer:Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decode(Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decode(Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let dBInstanceCountDecoded = try containerValues.decode(Int.self, forKey: .dBInstanceCount)
        dBInstanceCount = dBInstanceCountDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let multiAZDecoded = try containerValues.decode(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.recurringCharges) {
            struct KeyVal0{struct RecurringCharge{}}
            let recurringChargesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RecurringCharge>.CodingKeys.self, forKey: .recurringCharges)
            if let recurringChargesWrappedContainer = recurringChargesWrappedContainer {
                let recurringChargesContainer = try recurringChargesWrappedContainer.decodeIfPresent([RecurringCharge].self, forKey: .member)
                var recurringChargesBuffer:[RecurringCharge]? = nil
                if let recurringChargesContainer = recurringChargesContainer {
                    recurringChargesBuffer = [RecurringCharge]()
                    for structureContainer0 in recurringChargesContainer {
                        recurringChargesBuffer?.append(structureContainer0)
                    }
                }
                recurringCharges = recurringChargesBuffer
            } else {
                recurringCharges = []
            }
        } else {
            recurringCharges = nil
        }
        let reservedDBInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservedDBInstanceArn)
        reservedDBInstanceArn = reservedDBInstanceArnDecoded
        let leaseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .leaseId)
        leaseId = leaseIdDecoded
    }
}

extension ReservedDBInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedDBInstance(currencyCode: \(String(describing: currencyCode)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceCount: \(String(describing: dBInstanceCount)), duration: \(String(describing: duration)), fixedPrice: \(String(describing: fixedPrice)), leaseId: \(String(describing: leaseId)), multiAZ: \(String(describing: multiAZ)), offeringType: \(String(describing: offeringType)), productDescription: \(String(describing: productDescription)), recurringCharges: \(String(describing: recurringCharges)), reservedDBInstanceArn: \(String(describing: reservedDBInstanceArn)), reservedDBInstanceId: \(String(describing: reservedDBInstanceId)), reservedDBInstancesOfferingId: \(String(describing: reservedDBInstancesOfferingId)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), usagePrice: \(String(describing: usagePrice)))"}
}

/// <p>
///             This data type is used as a response element in the
///             <code>DescribeReservedDBInstances</code> and
///             <code>PurchaseReservedDBInstancesOffering</code> actions.
///         </p>
public struct ReservedDBInstance: Equatable {
    /// <p>The currency code for the reserved DB instance.</p>
    public let currencyCode: String?
    /// <p>The DB instance class for the reserved DB instance.</p>
    public let dBInstanceClass: String?
    /// <p>The number of reserved DB instances.</p>
    public let dBInstanceCount: Int
    /// <p>The duration of the reservation in seconds.</p>
    public let duration: Int
    /// <p>The fixed price charged for this reserved DB instance.</p>
    public let fixedPrice: Double
    /// <p>The unique identifier for the lease associated with the reserved DB instance.</p>
    ///          <note>
    ///             <p>AWS Support might request the lease ID for an issue related to a reserved DB instance.</p>
    ///          </note>
    public let leaseId: String?
    /// <p>Indicates if the reservation applies to Multi-AZ deployments.</p>
    public let multiAZ: Bool
    /// <p>The offering type of this reserved DB instance.</p>
    public let offeringType: String?
    /// <p>The description of the reserved DB instance.</p>
    public let productDescription: String?
    /// <p>The recurring price charged to run this reserved DB instance.</p>
    public let recurringCharges: [RecurringCharge]?
    /// <p>The Amazon Resource Name (ARN) for the reserved DB instance.</p>
    public let reservedDBInstanceArn: String?
    /// <p>The unique identifier for the reservation.</p>
    public let reservedDBInstanceId: String?
    /// <p>The offering identifier.</p>
    public let reservedDBInstancesOfferingId: String?
    /// <p>The time the reservation started.</p>
    public let startTime: Date?
    /// <p>The state of the reserved DB instance.</p>
    public let state: String?
    /// <p>The hourly price charged for this reserved DB instance.</p>
    public let usagePrice: Double

    public init (
        currencyCode: String? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceCount: Int = 0,
        duration: Int = 0,
        fixedPrice: Double = 0.0,
        leaseId: String? = nil,
        multiAZ: Bool = false,
        offeringType: String? = nil,
        productDescription: String? = nil,
        recurringCharges: [RecurringCharge]? = nil,
        reservedDBInstanceArn: String? = nil,
        reservedDBInstanceId: String? = nil,
        reservedDBInstancesOfferingId: String? = nil,
        startTime: Date? = nil,
        state: String? = nil,
        usagePrice: Double = 0.0
    )
    {
        self.currencyCode = currencyCode
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceCount = dBInstanceCount
        self.duration = duration
        self.fixedPrice = fixedPrice
        self.leaseId = leaseId
        self.multiAZ = multiAZ
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.recurringCharges = recurringCharges
        self.reservedDBInstanceArn = reservedDBInstanceArn
        self.reservedDBInstanceId = reservedDBInstanceId
        self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
        self.startTime = startTime
        self.state = state
        self.usagePrice = usagePrice
    }
}

extension ReservedDBInstanceAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedDBInstanceAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension ReservedDBInstanceAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ReservedDBInstanceAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User already has a reservation with the given identifier.</p>
public struct ReservedDBInstanceAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstanceAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension ReservedDBInstanceAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedDBInstanceNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedDBInstanceNotFoundFault(message: \(String(describing: message)))"}
}

extension ReservedDBInstanceNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ReservedDBInstanceNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified reserved DB Instance not found.</p>
public struct ReservedDBInstanceNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstanceNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ReservedDBInstanceNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedDBInstanceQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedDBInstanceQuotaExceededFault(message: \(String(describing: message)))"}
}

extension ReservedDBInstanceQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ReservedDBInstanceQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would exceed the user's DB Instance quota.</p>
public struct ReservedDBInstanceQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstanceQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension ReservedDBInstanceQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedDBInstancesOffering: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "CurrencyCode"
        case dBInstanceClass = "DBInstanceClass"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case multiAZ = "MultiAZ"
        case offeringType = "OfferingType"
        case productDescription = "ProductDescription"
        case recurringCharges = "RecurringCharges"
        case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let currencyCode = currencyCode {
            try container.encode(currencyCode, forKey: Key("CurrencyCode"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if duration != 0 {
            try container.encode(duration, forKey: Key("Duration"))
        }
        if fixedPrice != 0.0 {
            try container.encode(String(fixedPrice), forKey: Key("FixedPrice"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: Key("ProductDescription"))
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RecurringCharges"))
            for (index0, recurringcharge0) in recurringCharges.enumerated() {
                try recurringChargesContainer.encode(recurringcharge0, forKey: Key("RecurringCharge.\(index0.advanced(by: 1))"))
            }
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: Key("ReservedDBInstancesOfferingId"))
        }
        if usagePrice != 0.0 {
            try container.encode(String(usagePrice), forKey: Key("UsagePrice"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedDBInstancesOfferingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservedDBInstancesOfferingId)
        reservedDBInstancesOfferingId = reservedDBInstancesOfferingIdDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decode(Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decode(Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let multiAZDecoded = try containerValues.decode(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        if containerValues.contains(.recurringCharges) {
            struct KeyVal0{struct RecurringCharge{}}
            let recurringChargesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RecurringCharge>.CodingKeys.self, forKey: .recurringCharges)
            if let recurringChargesWrappedContainer = recurringChargesWrappedContainer {
                let recurringChargesContainer = try recurringChargesWrappedContainer.decodeIfPresent([RecurringCharge].self, forKey: .member)
                var recurringChargesBuffer:[RecurringCharge]? = nil
                if let recurringChargesContainer = recurringChargesContainer {
                    recurringChargesBuffer = [RecurringCharge]()
                    for structureContainer0 in recurringChargesContainer {
                        recurringChargesBuffer?.append(structureContainer0)
                    }
                }
                recurringCharges = recurringChargesBuffer
            } else {
                recurringCharges = []
            }
        } else {
            recurringCharges = nil
        }
    }
}

extension ReservedDBInstancesOffering: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedDBInstancesOffering(currencyCode: \(String(describing: currencyCode)), dBInstanceClass: \(String(describing: dBInstanceClass)), duration: \(String(describing: duration)), fixedPrice: \(String(describing: fixedPrice)), multiAZ: \(String(describing: multiAZ)), offeringType: \(String(describing: offeringType)), productDescription: \(String(describing: productDescription)), recurringCharges: \(String(describing: recurringCharges)), reservedDBInstancesOfferingId: \(String(describing: reservedDBInstancesOfferingId)), usagePrice: \(String(describing: usagePrice)))"}
}

/// <p>
///             This data type is used as a response element in the <code>DescribeReservedDBInstancesOfferings</code> action.
///         </p>
public struct ReservedDBInstancesOffering: Equatable {
    /// <p>The currency code for the reserved DB instance offering.</p>
    public let currencyCode: String?
    /// <p>The DB instance class for the reserved DB instance.</p>
    public let dBInstanceClass: String?
    /// <p>The duration of the offering in seconds.</p>
    public let duration: Int
    /// <p>The fixed price charged for this offering.</p>
    public let fixedPrice: Double
    /// <p>Indicates if the offering applies to Multi-AZ deployments.</p>
    public let multiAZ: Bool
    /// <p>The offering type.</p>
    public let offeringType: String?
    /// <p>The database engine used by the offering.</p>
    public let productDescription: String?
    /// <p>The recurring price charged to run this reserved DB instance.</p>
    public let recurringCharges: [RecurringCharge]?
    /// <p>The offering identifier.</p>
    public let reservedDBInstancesOfferingId: String?
    /// <p>The hourly price charged for this offering.</p>
    public let usagePrice: Double

    public init (
        currencyCode: String? = nil,
        dBInstanceClass: String? = nil,
        duration: Int = 0,
        fixedPrice: Double = 0.0,
        multiAZ: Bool = false,
        offeringType: String? = nil,
        productDescription: String? = nil,
        recurringCharges: [RecurringCharge]? = nil,
        reservedDBInstancesOfferingId: String? = nil,
        usagePrice: Double = 0.0
    )
    {
        self.currencyCode = currencyCode
        self.dBInstanceClass = dBInstanceClass
        self.duration = duration
        self.fixedPrice = fixedPrice
        self.multiAZ = multiAZ
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.recurringCharges = recurringCharges
        self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
        self.usagePrice = usagePrice
    }
}

extension ReservedDBInstancesOfferingNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedDBInstancesOfferingNotFoundFault(message: \(String(describing: message)))"}
}

extension ReservedDBInstancesOfferingNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ReservedDBInstancesOfferingNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Specified offering does not exist.</p>
public struct ReservedDBInstancesOfferingNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstancesOfferingNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ReservedDBInstancesOfferingNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ResetDBClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "ResetDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBClusterParameterGroupOutputError>
}

extension ResetDBClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetDBClusterParameterGroupInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), parameters: \(String(describing: parameters)), resetAllParameters: \(String(describing: resetAllParameters)))"}
}

extension ResetDBClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: Key("ResetAllParameters"))
        }
        try container.encode("ResetDBClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ResetDBClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ResetDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBClusterParameterGroupOutputError>
}

public struct ResetDBClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBClusterParameterGroupOutputError>
}

/// <p></p>
public struct ResetDBClusterParameterGroupInput: Equatable {
    /// <p>The name of the DB cluster parameter group to reset.</p>
    public let dBClusterParameterGroupName: String?
    /// <p>A list of parameter names in the DB cluster parameter group to reset to the default values. You can't use this
    ///         parameter if the <code>ResetAllParameters</code> parameter is enabled.</p>
    public let parameters: [Parameter]?
    /// <p>A value that indicates whether to reset all parameters in the DB cluster parameter group
    ///         to their default values. You can't use this parameter if there
    ///         is a list of parameter names specified for the <code>Parameters</code> parameter.</p>
    public let resetAllParameters: Bool

    public init (
        dBClusterParameterGroupName: String? = nil,
        parameters: [Parameter]? = nil,
        resetAllParameters: Bool = false
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

extension ResetDBClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetDBClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetDBClusterParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDBClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetDBClusterParameterGroupOutputResponse(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)))"}
}

extension ResetDBClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResetDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterParameterGroupName = output.dBClusterParameterGroupName
        } else {
            self.dBClusterParameterGroupName = nil
        }
    }
}

/// <p></p>
public struct ResetDBClusterParameterGroupOutputResponse: Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBClusterParameterGroupName: String?

    public init (
        dBClusterParameterGroupName: String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

struct ResetDBClusterParameterGroupOutputResponseBody: Equatable {
    public let dBClusterParameterGroupName: String?
}

extension ResetDBClusterParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ResetDBClusterParameterGroupResult"))
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
    }
}

public struct ResetDBParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "ResetDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBParameterGroupOutputError>
}

extension ResetDBParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetDBParameterGroupInput(dBParameterGroupName: \(String(describing: dBParameterGroupName)), parameters: \(String(describing: parameters)), resetAllParameters: \(String(describing: resetAllParameters)))"}
}

extension ResetDBParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: Key("ResetAllParameters"))
        }
        try container.encode("ResetDBParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ResetDBParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ResetDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBParameterGroupOutputError>
}

public struct ResetDBParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBParameterGroupOutputError>
}

/// <p></p>
public struct ResetDBParameterGroupInput: Equatable {
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the name of an existing <code>DBParameterGroup</code>.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>To reset the entire DB parameter group, specify the <code>DBParameterGroup</code>
    ///             name and <code>ResetAllParameters</code> parameters. To reset specific parameters,
    ///             provide a list of the following: <code>ParameterName</code> and
    ///             <code>ApplyMethod</code>. A maximum of 20 parameters can be modified in a single
    ///             request.</p>
    ///          <p>
    ///             <b>MySQL</b>
    ///          </p>
    ///          <p>Valid Values (for Apply method): <code>immediate</code> | <code>pending-reboot</code>
    ///          </p>
    ///          <p>You can use the immediate value with dynamic parameters only. You can use
    ///             the <code>pending-reboot</code> value for both dynamic and static parameters, and changes
    ///             are applied when DB instance reboots.</p>
    ///          <p>
    ///             <b>MariaDB</b>
    ///          </p>
    ///          <p>Valid Values (for Apply method): <code>immediate</code> | <code>pending-reboot</code>
    ///          </p>
    ///          <p>You can use the immediate value with dynamic parameters only. You can use
    ///       the <code>pending-reboot</code> value for both dynamic and static parameters, and changes
    ///       are applied when DB instance reboots.</p>
    ///          <p>
    ///             <b>Oracle</b>
    ///          </p>
    ///          <p>Valid Values (for Apply method): <code>pending-reboot</code>
    ///          </p>
    public let parameters: [Parameter]?
    /// <p>
    ///           A value that indicates whether to reset all parameters in the DB parameter group to default values.
    ///           By default, all parameters in the DB parameter group are reset to default values.
    ///         </p>
    public let resetAllParameters: Bool

    public init (
        dBParameterGroupName: String? = nil,
        parameters: [Parameter]? = nil,
        resetAllParameters: Bool = false
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

extension ResetDBParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetDBParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetDBParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDBParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetDBParameterGroupOutputResponse(dBParameterGroupName: \(String(describing: dBParameterGroupName)))"}
}

extension ResetDBParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResetDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBParameterGroupName = output.dBParameterGroupName
        } else {
            self.dBParameterGroupName = nil
        }
    }
}

/// <p>
///         Contains the result of a successful invocation of the
///         <code>ModifyDBParameterGroup</code> or <code>ResetDBParameterGroup</code> action.
///         </p>
public struct ResetDBParameterGroupOutputResponse: Equatable {
    /// <p>The name of the DB parameter group.</p>
    public let dBParameterGroupName: String?

    public init (
        dBParameterGroupName: String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

struct ResetDBParameterGroupOutputResponseBody: Equatable {
    public let dBParameterGroupName: String?
}

extension ResetDBParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ResetDBParameterGroupResult"))
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
    }
}

extension ResourceNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundFault(message: \(String(describing: message)))"}
}

extension ResourceNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ResourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource ID was not found.</p>
public struct ResourceNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourcePendingMaintenanceActions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let pendingMaintenanceActionDetails = pendingMaintenanceActionDetails {
            var pendingMaintenanceActionDetailsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PendingMaintenanceActionDetails"))
            for (index0, pendingmaintenanceaction0) in pendingMaintenanceActionDetails.enumerated() {
                try pendingMaintenanceActionDetailsContainer.encode(pendingmaintenanceaction0, forKey: Key("PendingMaintenanceAction.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: Key("ResourceIdentifier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        if containerValues.contains(.pendingMaintenanceActionDetails) {
            struct KeyVal0{struct PendingMaintenanceAction{}}
            let pendingMaintenanceActionDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PendingMaintenanceAction>.CodingKeys.self, forKey: .pendingMaintenanceActionDetails)
            if let pendingMaintenanceActionDetailsWrappedContainer = pendingMaintenanceActionDetailsWrappedContainer {
                let pendingMaintenanceActionDetailsContainer = try pendingMaintenanceActionDetailsWrappedContainer.decodeIfPresent([PendingMaintenanceAction].self, forKey: .member)
                var pendingMaintenanceActionDetailsBuffer:[PendingMaintenanceAction]? = nil
                if let pendingMaintenanceActionDetailsContainer = pendingMaintenanceActionDetailsContainer {
                    pendingMaintenanceActionDetailsBuffer = [PendingMaintenanceAction]()
                    for structureContainer0 in pendingMaintenanceActionDetailsContainer {
                        pendingMaintenanceActionDetailsBuffer?.append(structureContainer0)
                    }
                }
                pendingMaintenanceActionDetails = pendingMaintenanceActionDetailsBuffer
            } else {
                pendingMaintenanceActionDetails = []
            }
        } else {
            pendingMaintenanceActionDetails = nil
        }
    }
}

extension ResourcePendingMaintenanceActions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourcePendingMaintenanceActions(pendingMaintenanceActionDetails: \(String(describing: pendingMaintenanceActionDetails)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

/// <p>Describes the pending maintenance actions for a resource.</p>
public struct ResourcePendingMaintenanceActions: Equatable {
    /// <p>A list that provides details about the pending maintenance actions for the resource.</p>
    public let pendingMaintenanceActionDetails: [PendingMaintenanceAction]?
    /// <p>The ARN of the resource that has pending maintenance actions.</p>
    public let resourceIdentifier: String?

    public init (
        pendingMaintenanceActionDetails: [PendingMaintenanceAction]? = nil,
        resourceIdentifier: String? = nil
    )
    {
        self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct RestoreDBClusterFromS3InputBodyMiddleware: Middleware {
    public let id: String = "RestoreDBClusterFromS3InputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterFromS3Input>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterFromS3Input>
    public typealias MOutput = OperationOutput<RestoreDBClusterFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterFromS3OutputError>
}

extension RestoreDBClusterFromS3Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBClusterFromS3Input(availabilityZones: \(String(describing: availabilityZones)), backtrackWindow: \(String(describing: backtrackWindow)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), characterSetName: \(String(describing: characterSetName)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), databaseName: \(String(describing: databaseName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), kmsKeyId: \(String(describing: kmsKeyId)), masterUserPassword: \(String(describing: masterUserPassword)), masterUsername: \(String(describing: masterUsername)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), s3BucketName: \(String(describing: s3BucketName)), s3IngestionRoleArn: \(String(describing: s3IngestionRoleArn)), s3Prefix: \(String(describing: s3Prefix)), sourceEngine: \(String(describing: sourceEngine)), sourceEngineVersion: \(String(describing: sourceEngineVersion)), storageEncrypted: \(String(describing: storageEncrypted)), tags: \(String(describing: tags)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBClusterFromS3Input: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: Key("S3BucketName"))
        }
        if let s3IngestionRoleArn = s3IngestionRoleArn {
            try container.encode(s3IngestionRoleArn, forKey: Key("S3IngestionRoleArn"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: Key("S3Prefix"))
        }
        if let sourceEngine = sourceEngine {
            try container.encode(sourceEngine, forKey: Key("SourceEngine"))
        }
        if let sourceEngineVersion = sourceEngineVersion {
            try container.encode(sourceEngineVersion, forKey: Key("SourceEngineVersion"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterFromS3", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RestoreDBClusterFromS3InputHeadersMiddleware: Middleware {
    public let id: String = "RestoreDBClusterFromS3InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterFromS3Input>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterFromS3Input>
    public typealias MOutput = OperationOutput<RestoreDBClusterFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterFromS3OutputError>
}

public struct RestoreDBClusterFromS3InputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreDBClusterFromS3InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterFromS3Input>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterFromS3Input>
    public typealias MOutput = OperationOutput<RestoreDBClusterFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterFromS3OutputError>
}

public struct RestoreDBClusterFromS3Input: Equatable {
    /// <p>A list of Availability Zones (AZs) where instances in the restored DB cluster can be created.</p>
    public let availabilityZones: [String]?
    /// <p>The target backtrack window, in seconds. To disable backtracking, set this value to
    ///             0.</p>
    ///         <note>
    ///             <p>Currently, Backtrack is only supported for Aurora MySQL DB clusters.</p>
    ///         </note>
    ///         <p>Default: 0</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>If specified, this value must be set to a number from 0 to 259,200 (72 hours).</p>
    ///             </li>
    ///          </ul>
    public let backtrackWindow: Int?
    /// <p>The number of days for which automated backups of the restored DB cluster are retained. You must specify a minimum value of 1.</p>
    ///         <p>Default: 1</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must be a value from 1 to 35</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Int?
    /// <p>A value that indicates that the restored DB cluster should be associated with the specified CharacterSet.</p>
    public let characterSetName: String?
    /// <p>A value that indicates whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The name of the DB cluster to create from the source data in the Amazon S3 bucket. This parameter isn't case-sensitive.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>my-cluster1</code>
    ///         </p>
    public let dBClusterIdentifier: String?
    /// <p>The name of the DB cluster parameter group to associate
    ///             with the restored DB cluster. If this argument is omitted, <code>default.aurora5.6</code> is used.
    ///         </p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?
    /// <p>A DB subnet group to associate with the restored DB cluster.</p>
    ///         <p>Constraints: If supplied, must match the name of an existing DBSubnetGroup.
    ///         </p>
    ///         <p>Example: <code>mySubnetgroup</code>
    ///         </p>
    public let dBSubnetGroupName: String?
    /// <p>The database name for the restored DB cluster.</p>
    public let databaseName: String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled.
    ///         </p>
    public let deletionProtection: Bool?
    /// <p>Specify the Active Directory directory ID to restore the DB cluster in.
    ///           The domain must be created prior to this operation.
    ///       </p>
    ///          <p>
    ///         For Amazon Aurora DB clusters, Amazon RDS can use Kerberos Authentication to authenticate users that connect to the DB cluster.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html">Kerberos Authentication</a>
    ///         in the <i>Amazon Aurora User Guide</i>.
    ///       </p>
    public let domain: String?
    /// <p>Specify the name of the IAM role to be used when making API calls to the Directory Service.</p>
    public let domainIAMRoleName: String?
    /// <p>The list of logs that the restored DB cluster is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs</a> in the <i>Amazon Aurora User Guide</i>.</p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>A value that indicates whether to enable mapping of AWS Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.</p>
    ///
    ///         <p>For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html">
    ///                 IAM Database Authentication</a> in the <i>Amazon Aurora User Guide.</i>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>The name of the database engine to be used for this DB cluster.</p>
    ///         <p>Valid Values: <code>aurora</code> (for MySQL 5.6-compatible Aurora), <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora), and <code>aurora-postgresql</code>
    ///         </p>
    public let engine: String?
    /// <p>The version number of the database engine to use.</p>
    ///         <p>To list all of the available engine versions for <code>aurora</code> (for MySQL 5.6-compatible Aurora), use the following command:</p>
    ///         <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    ///         <p>To list all of the available engine versions for <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora), use the following command:</p>
    ///         <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    ///         <p>To list all of the available engine versions for <code>aurora-postgresql</code>, use the following command:</p>
    ///         <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    ///         <p>
    ///             <b>Aurora MySQL</b>
    ///         </p>
    ///         <p>Example: <code>5.6.10a</code>, <code>5.6.mysql_aurora.1.19.2</code>, <code>5.7.12</code>, <code>5.7.mysql_aurora.2.04.5</code>
    ///         </p>
    ///         <p>
    ///             <b>Aurora PostgreSQL</b>
    ///         </p>
    ///         <p>Example: <code>9.6.3</code>, <code>10.7</code>
    ///         </p>
    public let engineVersion: String?
    /// <p>The AWS KMS key identifier for an encrypted DB cluster.</p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).
    ///             To use a CMK in a different AWS account, specify the key ARN or alias ARN.</p>
    ///         <p>If the StorageEncrypted parameter is enabled, and you do
    ///             not specify a value for the <code>KmsKeyId</code> parameter, then
    ///             Amazon RDS will use your default CMK. There is a
    ///             default CMK for your AWS account. Your AWS account has a different
    ///             default CMK for each AWS Region.</p>
    public let kmsKeyId: String?
    /// <p>The password for the master database user. This password can contain any printable ASCII character except "/", """, or "@".</p>
    ///         <p>Constraints: Must contain from 8 to 41 characters.</p>
    public let masterUserPassword: String?
    /// <p>The name of the master user for the restored DB cluster.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must be 1 to 16 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be a reserved word for the chosen database engine.</p>
    ///             </li>
    ///          </ul>
    public let masterUsername: String?
    /// <p>A value that indicates that the restored DB cluster should be associated with the specified option group.</p>
    ///         <p>Permanent options can't be removed from an option group. An option group can't be removed from a
    ///             DB cluster once it is associated with a DB cluster.</p>
    public let optionGroupName: String?
    /// <p>The port number on which the instances in the restored DB cluster accept connections.</p>
    ///         <p>
    ///             Default: <code>3306</code>
    ///         </p>
    public let port: Int?
    /// <p>The daily time range during which automated backups are created
    ///             if automated backups are enabled
    ///             using the <code>BackupRetentionPeriod</code> parameter.
    ///         </p>
    ///         <p>The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each AWS Region.
    ///             To view the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow">
    ///                 Backup window</a> in the <i>Amazon Aurora User Guide.</i>
    ///         </p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must be in the format <code>hh24:mi-hh24:mi</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Coordinated Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes.</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: String?
    /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
    ///         <p>Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///         </p>
    ///         <p>The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each AWS Region, occurring on a random day of the
    ///             week. To see the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora">
    ///                 Adjusting the Preferred Maintenance Window</a> in the <i>Amazon Aurora User Guide.</i>
    ///         </p>
    ///         <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    ///         <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The name of the Amazon S3 bucket that contains the data used to create the Amazon Aurora DB cluster.</p>
    public let s3BucketName: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes
    ///         Amazon RDS to access the Amazon S3 bucket on your behalf.</p>
    public let s3IngestionRoleArn: String?
    /// <p>The prefix for all of the file names that contain the data used to create the Amazon Aurora DB cluster.
    ///         If you do not specify a <b>SourceS3Prefix</b> value, then the Amazon Aurora DB cluster is
    ///         created by using all of the files in the Amazon S3 bucket.</p>
    public let s3Prefix: String?
    /// <p>The identifier for the database engine that was backed up to create the files stored in the
    ///             Amazon S3 bucket.
    ///         </p>
    ///         <p>Valid values: <code>mysql</code>
    ///          </p>
    public let sourceEngine: String?
    /// <p>The version of the database that the backup files were created from.</p>
    ///         <p>MySQL versions 5.5, 5.6, and 5.7 are supported.
    ///         </p>
    ///         <p>Example: <code>5.6.40</code>, <code>5.7.28</code>
    ///          </p>
    public let sourceEngineVersion: String?
    /// <p>A value that indicates whether the restored DB cluster is encrypted.</p>
    public let storageEncrypted: Bool?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?
    /// <p>A list of EC2 VPC security groups to associate with the restored DB cluster.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        availabilityZones: [String]? = nil,
        backtrackWindow: Int? = nil,
        backupRetentionPeriod: Int? = nil,
        characterSetName: String? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterParameterGroupName: String? = nil,
        dBSubnetGroupName: String? = nil,
        databaseName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        kmsKeyId: String? = nil,
        masterUserPassword: String? = nil,
        masterUsername: String? = nil,
        optionGroupName: String? = nil,
        port: Int? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        s3BucketName: String? = nil,
        s3IngestionRoleArn: String? = nil,
        s3Prefix: String? = nil,
        sourceEngine: String? = nil,
        sourceEngineVersion: String? = nil,
        storageEncrypted: Bool? = nil,
        tags: [Tag]? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backtrackWindow = backtrackWindow
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.optionGroupName = optionGroupName
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.s3BucketName = s3BucketName
        self.s3IngestionRoleArn = s3IngestionRoleArn
        self.s3Prefix = s3Prefix
        self.sourceEngine = sourceEngine
        self.sourceEngineVersion = sourceEngineVersion
        self.storageEncrypted = storageEncrypted
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBClusterFromS3OutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterFromS3OutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacityFault" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketFault" : self = .invalidS3BucketFault(try InvalidS3BucketFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterFromS3OutputError: Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidS3BucketFault(InvalidS3BucketFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterFromS3OutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBClusterFromS3OutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension RestoreDBClusterFromS3OutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreDBClusterFromS3OutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterFromS3OutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Aurora DB cluster.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusters</code>,
    ///         <code>StopDBCluster</code>, and <code>StartDBCluster</code> actions.
    ///       </p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterFromS3OutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension RestoreDBClusterFromS3OutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RestoreDBClusterFromS3Result"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct RestoreDBClusterFromSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "RestoreDBClusterFromSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterFromSnapshotOutputError>
}

extension RestoreDBClusterFromSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBClusterFromSnapshotInput(availabilityZones: \(String(describing: availabilityZones)), backtrackWindow: \(String(describing: backtrackWindow)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), databaseName: \(String(describing: databaseName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), engine: \(String(describing: engine)), engineMode: \(String(describing: engineMode)), engineVersion: \(String(describing: engineVersion)), kmsKeyId: \(String(describing: kmsKeyId)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), scalingConfiguration: \(String(describing: scalingConfiguration)), snapshotIdentifier: \(String(describing: snapshotIdentifier)), tags: \(String(describing: tags)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBClusterFromSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: Key("BacktrackWindow"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let scalingConfiguration = scalingConfiguration {
            try container.encode(scalingConfiguration, forKey: Key("ScalingConfiguration"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterFromSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RestoreDBClusterFromSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreDBClusterFromSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterFromSnapshotOutputError>
}

public struct RestoreDBClusterFromSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreDBClusterFromSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterFromSnapshotOutputError>
}

/// <p></p>
public struct RestoreDBClusterFromSnapshotInput: Equatable {
    /// <p>Provides the list of Availability Zones (AZs) where instances in the restored DB
    ///             cluster can be created.</p>
    public let availabilityZones: [String]?
    /// <p>The target backtrack window, in seconds. To disable backtracking, set this value to
    ///             0.</p>
    ///         <note>
    ///             <p>Currently, Backtrack is only supported for Aurora MySQL DB clusters.</p>
    ///         </note>
    ///         <p>Default: 0</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>If specified, this value must be set to a number from 0 to 259,200 (72 hours).</p>
    ///             </li>
    ///          </ul>
    public let backtrackWindow: Int?
    /// <p>A value that indicates whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The name of the DB cluster to create from the DB snapshot or DB cluster snapshot.
    ///             This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-snapshot-id</code>
    ///          </p>
    public let dBClusterIdentifier: String?
    /// <p>The name of the DB cluster parameter group to associate with this DB cluster. If this
    ///             argument is omitted, the default DB cluster parameter group for the specified engine is
    ///             used.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If supplied, must match the name of an existing default DB cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?
    /// <p>The name of the DB subnet group to use for the new DB cluster.</p>
    ///          <p>Constraints: If supplied, must match the name of an existing DB subnet group.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>The database name for the restored DB cluster.</p>
    public let databaseName: String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled.
    ///         </p>
    public let deletionProtection: Bool?
    /// <p>Specify the Active Directory directory ID to restore the DB cluster in.
    ///            The domain must be created prior to this operation. Currently, only MySQL, Microsoft SQL
    ///            Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///             Kerberos Authentication</a> in the <i>Amazon RDS User Guide</i>.
    ///        </p>
    public let domain: String?
    /// <p>Specify the name of the IAM role to be used when making API calls to the Directory Service.</p>
    public let domainIAMRoleName: String?
    /// <p>The list of logs that the restored DB cluster is to export to Amazon CloudWatch Logs.
    ///             The values in the list depend on the DB engine being used. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs </a> in the <i>Amazon
    ///                 Aurora User Guide</i>.</p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>A value that indicates whether to enable mapping of AWS Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.</p>
    ///
    ///         <p>For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html">
    ///                 IAM Database Authentication</a> in the <i>Amazon Aurora User Guide.</i>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>The database engine to use for the new DB cluster.</p>
    ///          <p>Default: The same as source</p>
    ///          <p>Constraint: Must be compatible with the engine of the source</p>
    public let engine: String?
    /// <p>The DB engine mode of the DB cluster, either <code>provisioned</code>, <code>serverless</code>,
    ///             <code>parallelquery</code>, <code>global</code>, or <code>multimaster</code>.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBCluster.html">
    ///             CreateDBCluster</a>.</p>
    public let engineMode: String?
    /// <p>The version of the database engine to use for the new DB cluster.</p>
    ///          <p>To list all of the available engine versions for <code>aurora</code> (for MySQL 5.6-compatible Aurora), use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    ///          <p>To list all of the available engine versions for <code>aurora-mysql</code> (for MySQL 5.7-compatible Aurora), use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    ///          <p>To list all of the available engine versions for <code>aurora-postgresql</code>, use the following command:</p>
    ///          <p>
    ///             <code>aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"</code>
    ///          </p>
    ///          <note>
    ///             <p>If you aren't using the default engine version, then you must specify the engine version.</p>
    ///          </note>
    ///          <p>
    ///             <b>Aurora MySQL</b>
    ///          </p>
    ///          <p>Example: <code>5.6.10a</code>, <code>5.6.mysql_aurora.1.19.2</code>, <code>5.7.12</code>, <code>5.7.mysql_aurora.2.04.5</code>
    ///          </p>
    ///          <p>
    ///             <b>Aurora PostgreSQL</b>
    ///          </p>
    ///          <p>Example: <code>9.6.3</code>, <code>10.7</code>
    ///          </p>
    public let engineVersion: String?
    /// <p>The AWS KMS key identifier to use when restoring an encrypted DB cluster from a DB
    ///             snapshot or DB cluster snapshot.</p>
    ///          <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).
    ///           To use a CMK in a different AWS account, specify the key ARN or alias ARN.</p>
    ///         <p>When you don't specify a value for the <code>KmsKeyId</code> parameter, then the
    ///             following occurs:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If the DB snapshot or DB cluster snapshot in
    ///                         <code>SnapshotIdentifier</code> is encrypted, then the restored DB cluster
    ///                     is encrypted using the AWS KMS CMK that was used to encrypt the DB snapshot or DB
    ///                     cluster snapshot.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If the DB snapshot or DB cluster snapshot in
    ///                     <code>SnapshotIdentifier</code> isn't encrypted, then the restored DB cluster
    ///                     isn't encrypted.</p>
    ///             </li>
    ///          </ul>
    public let kmsKeyId: String?
    /// <p>The name of the option group to use for the restored DB cluster.</p>
    public let optionGroupName: String?
    /// <p>The port number on which the new DB cluster accepts connections.</p>
    ///          <p>Constraints: This value must be <code>1150-65535</code>
    ///         </p>
    ///          <p>Default: The same port as the original DB cluster.</p>
    public let port: Int?
    /// <p>For DB clusters in <code>serverless</code> DB engine mode, the scaling properties of the DB cluster.</p>
    public let scalingConfiguration: ScalingConfiguration?
    /// <p>The identifier for the DB snapshot or DB cluster snapshot to restore from.</p>
    ///         <p>You can use either the name or the Amazon Resource Name (ARN) to specify a DB
    ///             cluster snapshot. However, you can use only the ARN to specify a DB snapshot.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing Snapshot.</p>
    ///             </li>
    ///          </ul>
    public let snapshotIdentifier: String?
    /// <p>The tags to be assigned to the restored DB cluster.</p>
    public let tags: [Tag]?
    /// <p>A list of VPC security groups that the new DB cluster will belong to.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        availabilityZones: [String]? = nil,
        backtrackWindow: Int? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterParameterGroupName: String? = nil,
        dBSubnetGroupName: String? = nil,
        databaseName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        engine: String? = nil,
        engineMode: String? = nil,
        engineVersion: String? = nil,
        kmsKeyId: String? = nil,
        optionGroupName: String? = nil,
        port: Int? = nil,
        scalingConfiguration: ScalingConfiguration? = nil,
        snapshotIdentifier: String? = nil,
        tags: [Tag]? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backtrackWindow = backtrackWindow
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineMode = engineMode
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.port = port
        self.scalingConfiguration = scalingConfiguration
        self.snapshotIdentifier = snapshotIdentifier
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBClusterFromSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterFromSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBClusterCapacityFault" : self = .insufficientDBClusterCapacityFault(try InsufficientDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacityFault" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotStateFault" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterFromSnapshotOutputError: Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientDBClusterCapacityFault(InsufficientDBClusterCapacityFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterFromSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBClusterFromSnapshotOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension RestoreDBClusterFromSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreDBClusterFromSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterFromSnapshotOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Aurora DB cluster.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusters</code>,
    ///         <code>StopDBCluster</code>, and <code>StartDBCluster</code> actions.
    ///       </p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterFromSnapshotOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension RestoreDBClusterFromSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RestoreDBClusterFromSnapshotResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct RestoreDBClusterToPointInTimeInputBodyMiddleware: Middleware {
    public let id: String = "RestoreDBClusterToPointInTimeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterToPointInTimeOutputError>
}

extension RestoreDBClusterToPointInTimeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBClusterToPointInTimeInput(backtrackWindow: \(String(describing: backtrackWindow)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), kmsKeyId: \(String(describing: kmsKeyId)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), restoreToTime: \(String(describing: restoreToTime)), restoreType: \(String(describing: restoreType)), sourceDBClusterIdentifier: \(String(describing: sourceDBClusterIdentifier)), tags: \(String(describing: tags)), useLatestRestorableTime: \(String(describing: useLatestRestorableTime)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBClusterToPointInTimeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: Key("BacktrackWindow"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let restoreToTime = restoreToTime {
            try container.encode(TimestampWrapper(restoreToTime, format: .dateTime), forKey: Key("restoreToTime"))
        }
        if let restoreType = restoreType {
            try container.encode(restoreType, forKey: Key("RestoreType"))
        }
        if let sourceDBClusterIdentifier = sourceDBClusterIdentifier {
            try container.encode(sourceDBClusterIdentifier, forKey: Key("SourceDBClusterIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if useLatestRestorableTime != false {
            try container.encode(useLatestRestorableTime, forKey: Key("UseLatestRestorableTime"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterToPointInTime", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RestoreDBClusterToPointInTimeInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreDBClusterToPointInTimeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterToPointInTimeOutputError>
}

public struct RestoreDBClusterToPointInTimeInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreDBClusterToPointInTimeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterToPointInTimeOutputError>
}

/// <p></p>
public struct RestoreDBClusterToPointInTimeInput: Equatable {
    /// <p>The target backtrack window, in seconds. To disable backtracking, set this value to
    ///             0.</p>
    ///         <note>
    ///             <p>Currently, Backtrack is only supported for Aurora MySQL DB clusters.</p>
    ///         </note>
    ///         <p>Default: 0</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>If specified, this value must be set to a number from 0 to 259,200 (72 hours).</p>
    ///             </li>
    ///          </ul>
    public let backtrackWindow: Int?
    /// <p>A value that indicates whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The name of the new DB cluster to be created.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>The name of the DB cluster parameter group to associate with this DB cluster.
    ///             If this argument is omitted, the default DB cluster parameter group for the specified engine is used.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If supplied, must match the name of an existing DB cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?
    /// <p>The DB subnet group name to use for the new DB cluster.</p>
    ///          <p>Constraints: If supplied, must match the name of an existing DBSubnetGroup.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled.
    ///         </p>
    public let deletionProtection: Bool?
    /// <p>Specify the Active Directory directory ID to restore the DB cluster in.
    ///           The domain must be created prior to this operation.
    ///       </p>
    ///          <p>
    ///         For Amazon Aurora DB clusters, Amazon RDS can use Kerberos Authentication to authenticate users that connect to the DB cluster.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html">Kerberos Authentication</a>
    ///         in the <i>Amazon Aurora User Guide</i>.
    ///       </p>
    public let domain: String?
    /// <p>Specify the name of the IAM role to be used when making API calls to the Directory Service.</p>
    public let domainIAMRoleName: String?
    /// <p>The list of logs that the restored DB cluster is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs</a> in the <i>Amazon Aurora User Guide</i>.</p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>A value that indicates whether to enable mapping of AWS Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.</p>
    ///
    ///         <p>For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html">
    ///                 IAM Database Authentication</a> in the <i>Amazon Aurora User Guide.</i>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>The AWS KMS key identifier to use when restoring an encrypted DB cluster from an encrypted DB cluster.</p>
    ///          <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).
    ///           To use a CMK in a different AWS account, specify the key ARN or alias ARN.</p>
    ///          <p>You can restore to a new DB cluster and encrypt the new DB cluster with a AWS KMS CMK that is different than the
    ///       AWS KMS key used to encrypt the source DB cluster. The new DB cluster is encrypted with the AWS KMS CMK
    ///       identified by the <code>KmsKeyId</code> parameter.</p>
    ///          <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then the following occurs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the DB cluster is encrypted, then the restored DB cluster is encrypted using the AWS KMS CMK that was used to encrypt the source DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the DB cluster isn't encrypted, then the restored DB cluster isn't encrypted.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If <code>DBClusterIdentifier</code> refers to a DB cluster that isn't encrypted, then the restore request
    ///       is rejected.</p>
    public let kmsKeyId: String?
    /// <p>The name of the option group for the new DB cluster.</p>
    public let optionGroupName: String?
    /// <p>The port number on which the new DB cluster accepts connections.</p>
    ///          <p>Constraints: A value from <code>1150-65535</code>.
    ///       </p>
    ///          <p>Default: The default port for the engine.</p>
    public let port: Int?
    /// <p>The date and time to restore the DB cluster to.</p>
    ///          <p>Valid Values: Value must be a time in Universal Coordinated Time (UTC) format</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be before the latest restorable time for the DB instance</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be specified if <code>UseLatestRestorableTime</code> parameter isn't provided</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be specified if the <code>UseLatestRestorableTime</code> parameter is enabled</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be specified if the <code>RestoreType</code> parameter is <code>copy-on-write</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>2015-03-07T23:45:00Z</code>
    ///          </p>
    public let restoreToTime: Date?
    /// <p>The type of restore to be performed. You can specify one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>full-copy</code> - The new DB cluster is restored as a full copy of the
    ///                 source DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>copy-on-write</code> - The new DB cluster is restored as a clone of the
    ///                 source DB cluster.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Constraints: You can't specify <code>copy-on-write</code> if the engine version of the source DB cluster is earlier than 1.11.</p>
    ///         <p>If you don't specify a <code>RestoreType</code> value, then the new DB cluster is
    ///             restored as a full copy of the source DB cluster.</p>
    public let restoreType: String?
    /// <p>The identifier of the source DB cluster from which to restore.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    public let sourceDBClusterIdentifier: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?
    /// <p>A value that indicates whether to restore the DB cluster to the latest
    ///             restorable backup time. By default, the DB cluster isn't restored to the latest
    ///             restorable backup time.
    ///       </p>
    ///          <p>Constraints: Can't be specified if <code>RestoreToTime</code> parameter is provided.</p>
    public let useLatestRestorableTime: Bool
    /// <p>A list of VPC security groups that the new DB cluster belongs to.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        backtrackWindow: Int? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterParameterGroupName: String? = nil,
        dBSubnetGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        kmsKeyId: String? = nil,
        optionGroupName: String? = nil,
        port: Int? = nil,
        restoreToTime: Date? = nil,
        restoreType: String? = nil,
        sourceDBClusterIdentifier: String? = nil,
        tags: [Tag]? = nil,
        useLatestRestorableTime: Bool = false,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.backtrackWindow = backtrackWindow
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.port = port
        self.restoreToTime = restoreToTime
        self.restoreType = restoreType
        self.sourceDBClusterIdentifier = sourceDBClusterIdentifier
        self.tags = tags
        self.useLatestRestorableTime = useLatestRestorableTime
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBClusterToPointInTimeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterToPointInTimeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBClusterCapacityFault" : self = .insufficientDBClusterCapacityFault(try InsufficientDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacityFault" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotStateFault" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterToPointInTimeOutputError: Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientDBClusterCapacityFault(InsufficientDBClusterCapacityFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterToPointInTimeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBClusterToPointInTimeOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension RestoreDBClusterToPointInTimeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreDBClusterToPointInTimeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterToPointInTimeOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Aurora DB cluster.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusters</code>,
    ///         <code>StopDBCluster</code>, and <code>StartDBCluster</code> actions.
    ///       </p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterToPointInTimeOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension RestoreDBClusterToPointInTimeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RestoreDBClusterToPointInTimeResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct RestoreDBInstanceFromDBSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "RestoreDBInstanceFromDBSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBInstanceFromDBSnapshotOutputError>
}

extension RestoreDBInstanceFromDBSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBInstanceFromDBSnapshotInput(autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), availabilityZone: \(String(describing: availabilityZone)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBName: \(String(describing: dBName)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), dBSnapshotIdentifier: \(String(describing: dBSnapshotIdentifier)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableCustomerOwnedIp: \(String(describing: enableCustomerOwnedIp)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), engine: \(String(describing: engine)), iops: \(String(describing: iops)), licenseModel: \(String(describing: licenseModel)), multiAZ: \(String(describing: multiAZ)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), processorFeatures: \(String(describing: processorFeatures)), publiclyAccessible: \(String(describing: publiclyAccessible)), storageType: \(String(describing: storageType)), tags: \(String(describing: tags)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), tdeCredentialPassword: \(String(describing: tdeCredentialPassword)), useDefaultProcessorFeatures: \(String(describing: useDefaultProcessorFeatures)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBInstanceFromDBSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: Key("DBSnapshotIdentifier"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: Key("TdeCredentialPassword"))
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBInstanceFromDBSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RestoreDBInstanceFromDBSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreDBInstanceFromDBSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBInstanceFromDBSnapshotOutputError>
}

public struct RestoreDBInstanceFromDBSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreDBInstanceFromDBSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBInstanceFromDBSnapshotOutputError>
}

/// <p></p>
public struct RestoreDBInstanceFromDBSnapshotInput: Equatable {
    /// <p>A value that indicates whether minor version upgrades are applied automatically to the DB instance during the maintenance window.</p>
    public let autoMinorVersionUpgrade: Bool?
    /// <p>The Availability Zone (AZ) where the DB instance will be created.</p>
    ///          <p>Default: A random, system-chosen Availability Zone.</p>
    ///          <p>Constraint: You can't specify the <code>AvailabilityZone</code> parameter if the DB instance is a Multi-AZ deployment.</p>
    ///          <p>Example: <code>us-east-1a</code>
    ///          </p>
    public let availabilityZone: String?
    /// <p>A value that indicates whether to copy all tags from the restored DB instance to snapshots of the DB instance. By default, tags are not copied.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The compute and memory capacity of the Amazon RDS DB instance, for example, <code>db.m4.large</code>.
    ///           Not all DB instance classes are available in all AWS Regions, or for all database engines.
    ///           For the full list of DB instance classes,
    ///           and availability for your engine, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance Class</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///          <p>Default: The same DBInstanceClass as the original DB instance.</p>
    public let dBInstanceClass: String?
    /// <p>Name of the DB instance to create from the DB snapshot. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 numbers, letters, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-snapshot-id</code>
    ///          </p>
    public let dBInstanceIdentifier: String?
    /// <p>The database name for the restored DB instance.</p>
    ///          <note>
    ///             <p>This parameter doesn't apply to the MySQL, PostgreSQL, or MariaDB engines.</p>
    ///          </note>
    public let dBName: String?
    /// <p>The name of the DB parameter group to associate with this DB instance.</p>
    ///         <p>If you do not specify a value for <code>DBParameterGroupName</code>, then the default <code>DBParameterGroup</code>
    ///             for the specified DB engine is used.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If supplied, must match the name of an existing DBParameterGroup.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>The identifier for the DB snapshot to restore from.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///               <p>Must match the identifier of an existing DBSnapshot.</p>
    ///             </li>
    ///             <li>
    ///               <p>If you are restoring from a shared manual DB snapshot, the <code>DBSnapshotIdentifier</code>
    ///               must be the ARN of the shared DB snapshot.</p>
    ///             </li>
    ///          </ul>
    public let dBSnapshotIdentifier: String?
    /// <p>The DB subnet group name to use for the new instance.</p>
    ///          <p>Constraints: If supplied, must match the name of an existing DBSubnetGroup.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance</a>.
    ///         </p>
    public let deletionProtection: Bool?
    /// <p>Specify the Active Directory directory ID to restore the DB instance in.
    ///            The domain must be created prior to this operation. Currently, only MySQL, Microsoft SQL
    ///            Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///            Kerberos Authentication</a> in the <i>Amazon RDS User Guide</i>.</p>
    public let domain: String?
    /// <p>Specify the name of the IAM role to be used when making API calls to the Directory Service.</p>
    public let domainIAMRoleName: String?
    /// <p>The list of logs that the restored DB instance is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs</a> in the <i>Amazon RDS User Guide</i>.</p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance.</p>
    ///         <p>A <i>CoIP</i> provides local or external connectivity to resources in
    ///             your Outpost subnets through your on-premises network. For some use cases, a CoIP can
    ///             provide lower latency for connections to the DB instance from outside of its virtual
    ///             private cloud (VPC) on your local network.</p>
    ///         <p>For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Working with Amazon RDS on AWS Outposts</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    ///         <p>For more information about CoIPs, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing">Customer-owned IP addresses</a>
    ///             in the <i>AWS Outposts User Guide</i>.</p>
    public let enableCustomerOwnedIp: Bool?
    /// <p>A value that indicates whether to enable mapping of AWS Identity and Access
    ///           Management (IAM) accounts to database accounts. By default, mapping is disabled.</p>
    ///
    ///          <p>For more information about IAM database authentication, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///               IAM Database Authentication for MySQL and PostgreSQL</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>The database engine to use for the new instance.</p>
    ///          <p>Default: The same as source</p>
    ///          <p>Constraint: Must be compatible with the engine of the source. For example, you can restore a MariaDB 10.1 DB instance from a MySQL 5.6 snapshot.</p>
    ///
    ///          <p>Valid Values:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>mariadb</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mysql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se2</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se1</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>postgres</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ex</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-web</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let engine: String?
    /// <p>Specifies the amount of provisioned IOPS for the DB instance, expressed in I/O operations per second.
    ///           If this parameter isn't specified, the IOPS value is taken from the backup.
    ///           If this parameter is set to 0, the new instance is converted to a non-PIOPS instance.
    ///           The conversion takes additional time, though your DB instance is available for connections before the conversion starts.
    ///       </p>
    ///          <p>The provisioned IOPS value must follow the requirements for your database engine.
    ///           For more information, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS">Amazon RDS Provisioned IOPS Storage to Improve Performance</a>
    ///           in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///          <p>Constraints: Must be an integer greater than 1000.</p>
    public let iops: Int?
    /// <p>License model information for the restored DB instance.</p>
    ///          <p>Default: Same as source.</p>
    ///          <p>
    ///             Valid values:  <code>license-included</code> | <code>bring-your-own-license</code> | <code>general-public-license</code>
    ///          </p>
    public let licenseModel: String?
    /// <p>A value that indicates whether the DB instance is a Multi-AZ deployment.</p>
    ///          <p>Constraint: You can't specify the <code>AvailabilityZone</code> parameter if the DB instance is a Multi-AZ deployment.</p>
    public let multiAZ: Bool?
    /// <p>The name of the option group to be used for the restored DB instance.</p>
    ///
    ///          <p>Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance once it is associated with a DB instance</p>
    public let optionGroupName: String?
    /// <p>The port number on which the database accepts connections.</p>
    ///          <p>Default: The same port as the original DB instance</p>
    ///          <p>Constraints: Value must be <code>1150-65535</code>
    ///          </p>
    public let port: Int?
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    public let processorFeatures: [ProcessorFeature]?
    /// <p>A value that indicates whether the DB instance is publicly accessible.</p>
    ///          <p>When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///           and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///           and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.</p>
    ///          <p>When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.</p>
    ///          <p>For more information, see <a>CreateDBInstance</a>.</p>
    public let publiclyAccessible: Bool?
    /// <p>Specifies the storage type to be associated with the DB instance.</p>
    ///          <p>
    ///             Valid values: <code>standard | gp2 | io1</code>
    ///          </p>
    ///          <p>
    ///             If you specify <code>io1</code>, you must also include a value for the
    ///             <code>Iops</code> parameter.
    ///         </p>
    ///          <p>
    ///             Default: <code>io1</code> if the <code>Iops</code> parameter
    ///             is specified, otherwise <code>gp2</code>
    ///          </p>
    public let storageType: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>The password for the given ARN from the key store in order to access the device.</p>
    public let tdeCredentialPassword: String?
    /// <p>A value that indicates whether the DB instance class of the DB instance uses its default
    ///             processor features.</p>
    public let useDefaultProcessorFeatures: Bool?
    /// <p>
    ///             A list of EC2 VPC security groups to associate with this DB instance.
    ///         </p>
    ///         <p>
    ///             Default: The default EC2 VPC security group for the DB subnet group's VPC.
    ///         </p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        autoMinorVersionUpgrade: Bool? = nil,
        availabilityZone: String? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBName: String? = nil,
        dBParameterGroupName: String? = nil,
        dBSnapshotIdentifier: String? = nil,
        dBSubnetGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableCustomerOwnedIp: Bool? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        engine: String? = nil,
        iops: Int? = nil,
        licenseModel: String? = nil,
        multiAZ: Bool? = nil,
        optionGroupName: String? = nil,
        port: Int? = nil,
        processorFeatures: [ProcessorFeature]? = nil,
        publiclyAccessible: Bool? = nil,
        storageType: String? = nil,
        tags: [Tag]? = nil,
        tdeCredentialArn: String? = nil,
        tdeCredentialPassword: String? = nil,
        useDefaultProcessorFeatures: Bool? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.iops = iops
        self.licenseModel = licenseModel
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.port = port
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.storageType = storageType
        self.tags = tags
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBInstanceFromDBSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBInstanceFromDBSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExistsFault" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceededFault" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacityFault" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotStateFault" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupportedFault" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBInstanceFromDBSnapshotOutputError: Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBInstanceFromDBSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBInstanceFromDBSnapshotOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension RestoreDBInstanceFromDBSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreDBInstanceFromDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RestoreDBInstanceFromDBSnapshotOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB instance.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
    ///       </p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RestoreDBInstanceFromDBSnapshotOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension RestoreDBInstanceFromDBSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RestoreDBInstanceFromDBSnapshotResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct RestoreDBInstanceFromS3InputBodyMiddleware: Middleware {
    public let id: String = "RestoreDBInstanceFromS3InputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBInstanceFromS3Input>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBInstanceFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBInstanceFromS3Input>
    public typealias MOutput = OperationOutput<RestoreDBInstanceFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBInstanceFromS3OutputError>
}

extension RestoreDBInstanceFromS3Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBInstanceFromS3Input(allocatedStorage: \(String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), availabilityZone: \(String(describing: availabilityZone)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBName: \(String(describing: dBName)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), dBSecurityGroups: \(String(describing: dBSecurityGroups)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), deletionProtection: \(String(describing: deletionProtection)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(String(describing: enablePerformanceInsights)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), iops: \(String(describing: iops)), kmsKeyId: \(String(describing: kmsKeyId)), licenseModel: \(String(describing: licenseModel)), masterUserPassword: \(String(describing: masterUserPassword)), masterUsername: \(String(describing: masterUsername)), maxAllocatedStorage: \(String(describing: maxAllocatedStorage)), monitoringInterval: \(String(describing: monitoringInterval)), monitoringRoleArn: \(String(describing: monitoringRoleArn)), multiAZ: \(String(describing: multiAZ)), optionGroupName: \(String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(String(describing: performanceInsightsKMSKeyId)), performanceInsightsRetentionPeriod: \(String(describing: performanceInsightsRetentionPeriod)), port: \(String(describing: port)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), processorFeatures: \(String(describing: processorFeatures)), publiclyAccessible: \(String(describing: publiclyAccessible)), s3BucketName: \(String(describing: s3BucketName)), s3IngestionRoleArn: \(String(describing: s3IngestionRoleArn)), s3Prefix: \(String(describing: s3Prefix)), sourceEngine: \(String(describing: sourceEngine)), sourceEngineVersion: \(String(describing: sourceEngineVersion)), storageEncrypted: \(String(describing: storageEncrypted)), storageType: \(String(describing: storageType)), tags: \(String(describing: tags)), useDefaultProcessorFeatures: \(String(describing: useDefaultProcessorFeatures)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBInstanceFromS3Input: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: Key("EnablePerformanceInsights"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: Key("S3BucketName"))
        }
        if let s3IngestionRoleArn = s3IngestionRoleArn {
            try container.encode(s3IngestionRoleArn, forKey: Key("S3IngestionRoleArn"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: Key("S3Prefix"))
        }
        if let sourceEngine = sourceEngine {
            try container.encode(sourceEngine, forKey: Key("SourceEngine"))
        }
        if let sourceEngineVersion = sourceEngineVersion {
            try container.encode(sourceEngineVersion, forKey: Key("SourceEngineVersion"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBInstanceFromS3", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RestoreDBInstanceFromS3InputHeadersMiddleware: Middleware {
    public let id: String = "RestoreDBInstanceFromS3InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBInstanceFromS3Input>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBInstanceFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBInstanceFromS3Input>
    public typealias MOutput = OperationOutput<RestoreDBInstanceFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBInstanceFromS3OutputError>
}

public struct RestoreDBInstanceFromS3InputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreDBInstanceFromS3InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBInstanceFromS3Input>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBInstanceFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBInstanceFromS3Input>
    public typealias MOutput = OperationOutput<RestoreDBInstanceFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBInstanceFromS3OutputError>
}

public struct RestoreDBInstanceFromS3Input: Equatable {
    /// <p>The amount of storage (in gigabytes) to allocate initially for the DB instance.
    ///             Follow the allocation rules specified in <code>CreateDBInstance</code>.
    ///         </p>
    ///
    ///         <note>
    ///             <p>Be sure to allocate enough memory for your new DB instance
    ///                 so that the restore operation can succeed.
    ///                 You can also allocate additional memory for future growth.
    ///             </p>
    ///         </note>
    public let allocatedStorage: Int?
    /// <p>A value that indicates whether minor engine upgrades are applied automatically
    ///             to the DB instance during the maintenance window. By default, minor engine upgrades
    ///             are not applied automatically.
    ///         </p>
    public let autoMinorVersionUpgrade: Bool?
    /// <p>The Availability Zone that the DB instance is created in.
    ///             For information about AWS Regions and Availability Zones, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html">Regions and Availability Zones</a> in the <i>Amazon RDS User Guide.</i>
    ///         </p>
    ///         <p>Default: A random, system-chosen Availability Zone in the endpoint's AWS Region.
    ///         </p>
    ///         <p>
    ///             Example: <code>us-east-1d</code>
    ///         </p>
    ///         <p>Constraint: The <code>AvailabilityZone</code> parameter can't be specified if the DB instance is a Multi-AZ deployment.
    ///             The specified Availability Zone must be in the same AWS Region as the current endpoint.
    ///         </p>
    public let availabilityZone: String?
    /// <p>The number of days for which automated backups are retained.
    ///             Setting this parameter to a positive number enables backups.
    ///             For more information, see <code>CreateDBInstance</code>.
    ///         </p>
    public let backupRetentionPeriod: Int?
    /// <p>A value that indicates whether to copy all tags from the DB instance to snapshots of the DB instance. By default, tags are not copied.
    ///         </p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The compute and memory capacity of the DB instance,
    ///             for example, <code>db.m4.large</code>.
    ///             Not all DB instance classes are available in all AWS Regions,
    ///             or for all database engines.
    ///             For the full list of DB instance classes,
    ///             and availability for your engine, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance Class</a> in the <i>Amazon RDS User Guide.</i>
    ///         </p>
    ///         <p>Importing from Amazon S3 isn't supported on the db.t2.micro DB instance class.
    ///         </p>
    public let dBInstanceClass: String?
    /// <p>The DB instance identifier. This parameter is stored as a lowercase string.
    ///         </p>
    ///
    ///         <p>Constraints:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>Example: <code>mydbinstance</code>
    ///         </p>
    public let dBInstanceIdentifier: String?
    /// <p>The name of the database to create when the DB instance is created.
    ///             Follow the naming rules specified in <code>CreateDBInstance</code>.
    ///         </p>
    public let dBName: String?
    /// <p>The name of the DB parameter group to associate with this DB instance.</p>
    ///         <p>If you do not specify a value for <code>DBParameterGroupName</code>, then the default <code>DBParameterGroup</code>
    ///             for the specified DB engine is used.</p>
    public let dBParameterGroupName: String?
    /// <p>A list of DB security groups to associate with this DB instance.</p>
    ///         <p>Default: The default DB security group for the database engine.</p>
    public let dBSecurityGroups: [String]?
    /// <p>A DB subnet group to associate with this DB instance.</p>
    public let dBSubnetGroupName: String?
    /// <p>A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance</a>.
    ///         </p>
    public let deletionProtection: Bool?
    /// <p>The list of logs that the restored DB instance is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs</a> in the <i>Amazon RDS User Guide</i>.</p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>A value that indicates whether to enable mapping of AWS Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.</p>
    ///
    ///          <p>For more information about IAM database authentication, see
    ///          <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///              IAM Database Authentication for MySQL and PostgreSQL</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>A value that indicates whether to enable Performance Insights for the DB instance.
    ///         </p>
    ///         <p>For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html">Using Amazon Performance Insights</a> in the <i>Amazon Relational Database Service
    ///                     User Guide</i>.
    ///         </p>
    public let enablePerformanceInsights: Bool?
    /// <p>The name of the database engine to be used for this instance.
    ///         </p>
    ///
    ///         <p>Valid Values:  <code>mysql</code>
    ///         </p>
    public let engine: String?
    /// <p>The version number of the database engine to use.
    ///             Choose the latest minor version of your database engine.
    ///             For information about engine versions, see <code>CreateDBInstance</code>, or call <code>DescribeDBEngineVersions</code>.
    ///         </p>
    public let engineVersion: String?
    /// <p>The amount of Provisioned IOPS (input/output operations per second)
    ///             to allocate initially for the DB instance.
    ///             For information about valid Iops values, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS">Amazon RDS Provisioned IOPS Storage to Improve Performance</a>
    ///             in the <i>Amazon RDS User Guide.</i>
    ///         </p>
    public let iops: Int?
    /// <p>The AWS KMS key identifier for an encrypted DB instance.
    ///         </p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).
    ///             To use a CMK in a different AWS account, specify the key ARN or alias ARN.</p>
    ///         <p>If the <code>StorageEncrypted</code> parameter is enabled,
    ///             and you do not specify a value for the <code>KmsKeyId</code> parameter,
    ///             then Amazon RDS will use your default CMK.
    ///             There is a default CMK for your AWS account.
    ///             Your AWS account has a different default CMK for each AWS Region.
    ///         </p>
    public let kmsKeyId: String?
    /// <p>The license model for this DB instance.
    ///             Use <code>general-public-license</code>.
    ///         </p>
    public let licenseModel: String?
    /// <p>The password for the master user.
    ///             The password can include any printable ASCII character except "/", """, or "@".
    ///         </p>
    ///
    ///         <p>Constraints: Must contain from 8 to 41 characters.</p>
    public let masterUserPassword: String?
    /// <p>The name for the master user.
    ///         </p>
    ///
    ///         <p>Constraints:
    ///         </p>
    ///         <ul>
    ///             <li>
    ///                <p>Must be 1 to 16 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be a reserved word for the chosen database engine.</p>
    ///             </li>
    ///          </ul>
    public let masterUsername: String?
    /// <p>The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.</p>
    ///         <p>For more information about this setting, including limitations that apply to it, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling">
    ///                 Managing capacity automatically with Amazon RDS storage autoscaling</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    public let maxAllocatedStorage: Int?
    /// <p>The interval, in seconds,
    ///             between points when Enhanced Monitoring metrics are collected for the DB instance.
    ///             To disable collecting Enhanced Monitoring metrics, specify 0.
    ///         </p>
    ///
    ///         <p>If <code>MonitoringRoleArn</code> is specified,
    ///             then you must also set <code>MonitoringInterval</code> to a value other than 0.
    ///         </p>
    ///
    ///         <p>Valid Values: 0, 1, 5, 10, 15, 30, 60
    ///         </p>
    ///         <p>Default: <code>0</code>
    ///         </p>
    public let monitoringInterval: Int?
    /// <p>The ARN for the IAM role that permits RDS
    ///             to send enhanced monitoring metrics to Amazon CloudWatch Logs.
    ///             For example, <code>arn:aws:iam:123456789012:role/emaccess</code>.
    ///             For information on creating a monitoring role, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling">Setting Up and Enabling Enhanced Monitoring</a>
    ///             in the <i>Amazon RDS User Guide.</i>
    ///         </p>
    ///         <p>If <code>MonitoringInterval</code> is set to a value other than 0,
    ///             then you must supply a <code>MonitoringRoleArn</code> value.
    ///         </p>
    public let monitoringRoleArn: String?
    /// <p>A value that indicates whether the DB instance is a Multi-AZ deployment.
    ///             If the DB instance is a Multi-AZ deployment, you can't set the <code>AvailabilityZone</code> parameter.
    ///         </p>
    public let multiAZ: Bool?
    /// <p>The name of the option group to associate with this DB instance.
    ///             If this argument is omitted, the default option group for the specified engine is used.
    ///         </p>
    public let optionGroupName: String?
    /// <p>The AWS KMS key identifier for encryption of Performance Insights data.</p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    ///         <p>If you do not specify a value for <code>PerformanceInsightsKMSKeyId</code>, then Amazon RDS
    ///             uses your default CMK. There is a default CMK for your AWS account.
    ///             Your AWS account has a different default CMK for each AWS Region.</p>
    public let performanceInsightsKMSKeyId: String?
    /// <p>The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years). </p>
    public let performanceInsightsRetentionPeriod: Int?
    /// <p>The port number on which the database accepts connections.
    ///         </p>
    ///         <p>Type: Integer
    ///         </p>
    ///         <p>Valid Values: <code>1150</code>-<code>65535</code>
    ///         </p>
    ///         <p>Default: <code>3306</code>
    ///         </p>
    public let port: Int?
    /// <p>The time range each day
    ///             during which automated backups are created
    ///             if automated backups are enabled.
    ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow">Backup window</a> in the <i>Amazon RDS User Guide.</i>
    ///         </p>
    ///
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must be in the format <code>hh24:mi-hh24:mi</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Coordinated Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes.</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: String?
    /// <p>The time range each week during which system maintenance can occur,
    ///             in Universal Coordinated Time (UTC).
    ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance">Amazon RDS Maintenance Window</a> in the <i>Amazon RDS User Guide.</i>
    ///         </p>
    ///
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must be in the format <code>ddd:hh24:mi-ddd:hh24:mi</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Coordinated Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred backup window.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes.</p>
    ///             </li>
    ///          </ul>
    public let preferredMaintenanceWindow: String?
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    public let processorFeatures: [ProcessorFeature]?
    /// <p>A value that indicates whether the DB instance is publicly accessible.</p>
    ///         <p>When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///             and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///             and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.</p>
    ///         <p>When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.</p>
    ///         <p>For more information, see <a>CreateDBInstance</a>.</p>
    public let publiclyAccessible: Bool?
    /// <p>The name of your Amazon S3 bucket
    ///             that contains your database backup file.
    ///         </p>
    public let s3BucketName: String?
    /// <p>An AWS Identity and Access Management (IAM) role to allow Amazon RDS to access your Amazon S3 bucket.
    ///         </p>
    public let s3IngestionRoleArn: String?
    /// <p>The prefix of your Amazon S3 bucket.
    ///         </p>
    public let s3Prefix: String?
    /// <p>The name of the engine of your source database.
    ///         </p>
    ///
    ///         <p>Valid Values:  <code>mysql</code>
    ///         </p>
    public let sourceEngine: String?
    /// <p>The version of the database that the backup files were created from.</p>
    ///         <p>MySQL versions 5.6 and 5.7 are supported.
    ///         </p>
    ///         <p>Example: <code>5.6.40</code>
    ///          </p>
    public let sourceEngineVersion: String?
    /// <p>A value that indicates whether the new DB instance is encrypted or not.
    ///         </p>
    public let storageEncrypted: Bool?
    /// <p>Specifies the storage type to be associated with the DB instance.
    ///         </p>
    ///         <p>Valid values: <code>standard</code> | <code>gp2</code> | <code>io1</code>
    ///         </p>
    ///         <p>If you specify <code>io1</code>,
    ///             you must also include a value for the <code>Iops</code> parameter.
    ///         </p>
    ///         <p>Default: <code>io1</code>
    ///             if the <code>Iops</code> parameter is specified;
    ///             otherwise <code>gp2</code>
    ///         </p>
    public let storageType: String?
    /// <p>A list of tags to associate with this DB instance.
    ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///         </p>
    public let tags: [Tag]?
    /// <p>A value that indicates whether the DB instance class of the DB instance uses its default
    ///             processor features.</p>
    public let useDefaultProcessorFeatures: Bool?
    /// <p>A list of VPC security groups to associate with this DB instance.
    ///         </p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        allocatedStorage: Int? = nil,
        autoMinorVersionUpgrade: Bool? = nil,
        availabilityZone: String? = nil,
        backupRetentionPeriod: Int? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBName: String? = nil,
        dBParameterGroupName: String? = nil,
        dBSecurityGroups: [String]? = nil,
        dBSubnetGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        enablePerformanceInsights: Bool? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        iops: Int? = nil,
        kmsKeyId: String? = nil,
        licenseModel: String? = nil,
        masterUserPassword: String? = nil,
        masterUsername: String? = nil,
        maxAllocatedStorage: Int? = nil,
        monitoringInterval: Int? = nil,
        monitoringRoleArn: String? = nil,
        multiAZ: Bool? = nil,
        optionGroupName: String? = nil,
        performanceInsightsKMSKeyId: String? = nil,
        performanceInsightsRetentionPeriod: Int? = nil,
        port: Int? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        processorFeatures: [ProcessorFeature]? = nil,
        publiclyAccessible: Bool? = nil,
        s3BucketName: String? = nil,
        s3IngestionRoleArn: String? = nil,
        s3Prefix: String? = nil,
        sourceEngine: String? = nil,
        sourceEngineVersion: String? = nil,
        storageEncrypted: Bool? = nil,
        storageType: String? = nil,
        tags: [Tag]? = nil,
        useDefaultProcessorFeatures: Bool? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupRetentionPeriod = backupRetentionPeriod
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engine = engine
        self.engineVersion = engineVersion
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.s3BucketName = s3BucketName
        self.s3IngestionRoleArn = s3IngestionRoleArn
        self.s3Prefix = s3Prefix
        self.sourceEngine = sourceEngine
        self.sourceEngineVersion = sourceEngineVersion
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tags = tags
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBInstanceFromS3OutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBInstanceFromS3OutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExistsFault" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceededFault" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacityFault" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketFault" : self = .invalidS3BucketFault(try InvalidS3BucketFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupportedFault" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBInstanceFromS3OutputError: Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidS3BucketFault(InvalidS3BucketFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBInstanceFromS3OutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBInstanceFromS3OutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension RestoreDBInstanceFromS3OutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreDBInstanceFromS3OutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RestoreDBInstanceFromS3OutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB instance.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
    ///       </p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RestoreDBInstanceFromS3OutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension RestoreDBInstanceFromS3OutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RestoreDBInstanceFromS3Result"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct RestoreDBInstanceToPointInTimeInputBodyMiddleware: Middleware {
    public let id: String = "RestoreDBInstanceToPointInTimeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBInstanceToPointInTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBInstanceToPointInTimeInput>
    public typealias MOutput = OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBInstanceToPointInTimeOutputError>
}

extension RestoreDBInstanceToPointInTimeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBInstanceToPointInTimeInput(autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), availabilityZone: \(String(describing: availabilityZone)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBName: \(String(describing: dBName)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableCustomerOwnedIp: \(String(describing: enableCustomerOwnedIp)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), engine: \(String(describing: engine)), iops: \(String(describing: iops)), licenseModel: \(String(describing: licenseModel)), maxAllocatedStorage: \(String(describing: maxAllocatedStorage)), multiAZ: \(String(describing: multiAZ)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), processorFeatures: \(String(describing: processorFeatures)), publiclyAccessible: \(String(describing: publiclyAccessible)), restoreTime: \(String(describing: restoreTime)), sourceDBInstanceAutomatedBackupsArn: \(String(describing: sourceDBInstanceAutomatedBackupsArn)), sourceDBInstanceIdentifier: \(String(describing: sourceDBInstanceIdentifier)), sourceDbiResourceId: \(String(describing: sourceDbiResourceId)), storageType: \(String(describing: storageType)), tags: \(String(describing: tags)), targetDBInstanceIdentifier: \(String(describing: targetDBInstanceIdentifier)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), tdeCredentialPassword: \(String(describing: tdeCredentialPassword)), useDefaultProcessorFeatures: \(String(describing: useDefaultProcessorFeatures)), useLatestRestorableTime: \(String(describing: useLatestRestorableTime)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBInstanceToPointInTimeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: Key("MaxAllocatedStorage"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let restoreTime = restoreTime {
            try container.encode(TimestampWrapper(restoreTime, format: .dateTime), forKey: Key("restoreTime"))
        }
        if let sourceDBInstanceAutomatedBackupsArn = sourceDBInstanceAutomatedBackupsArn {
            try container.encode(sourceDBInstanceAutomatedBackupsArn, forKey: Key("SourceDBInstanceAutomatedBackupsArn"))
        }
        if let sourceDBInstanceIdentifier = sourceDBInstanceIdentifier {
            try container.encode(sourceDBInstanceIdentifier, forKey: Key("SourceDBInstanceIdentifier"))
        }
        if let sourceDbiResourceId = sourceDbiResourceId {
            try container.encode(sourceDbiResourceId, forKey: Key("SourceDbiResourceId"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBInstanceIdentifier = targetDBInstanceIdentifier {
            try container.encode(targetDBInstanceIdentifier, forKey: Key("TargetDBInstanceIdentifier"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: Key("TdeCredentialPassword"))
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: Key("UseDefaultProcessorFeatures"))
        }
        if useLatestRestorableTime != false {
            try container.encode(useLatestRestorableTime, forKey: Key("UseLatestRestorableTime"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBInstanceToPointInTime", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RestoreDBInstanceToPointInTimeInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreDBInstanceToPointInTimeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBInstanceToPointInTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBInstanceToPointInTimeInput>
    public typealias MOutput = OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBInstanceToPointInTimeOutputError>
}

public struct RestoreDBInstanceToPointInTimeInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreDBInstanceToPointInTimeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBInstanceToPointInTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBInstanceToPointInTimeInput>
    public typealias MOutput = OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBInstanceToPointInTimeOutputError>
}

/// <p></p>
public struct RestoreDBInstanceToPointInTimeInput: Equatable {
    /// <p>A value that indicates whether minor version upgrades are applied automatically to the DB instance during the maintenance window.</p>
    public let autoMinorVersionUpgrade: Bool?
    /// <p>The Availability Zone (AZ) where the DB instance will be created.</p>
    ///          <p>Default: A random, system-chosen Availability Zone.</p>
    ///          <p>Constraint: You can't specify the <code>AvailabilityZone</code> parameter if the DB instance is a Multi-AZ deployment.</p>
    ///          <p>Example: <code>us-east-1a</code>
    ///          </p>
    public let availabilityZone: String?
    /// <p>A value that indicates whether to copy all tags from the restored DB instance to snapshots of the DB instance. By default, tags are not copied.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The compute and memory capacity of the Amazon RDS DB instance, for example, <code>db.m4.large</code>.
    ///           Not all DB instance classes are available in all AWS Regions, or for all database engines.
    ///           For the full list of DB instance classes,
    ///           and availability for your engine, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance Class</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    ///          <p>Default: The same DBInstanceClass as the original DB instance.</p>
    public let dBInstanceClass: String?
    /// <p>The database name for the restored DB instance.</p>
    ///          <note>
    ///             <p>This parameter isn't used for the MySQL or MariaDB engines.</p>
    ///          </note>
    public let dBName: String?
    /// <p>The name of the DB parameter group to associate with this DB instance.</p>
    ///         <p>If you do not specify a value for <code>DBParameterGroupName</code>, then the default <code>DBParameterGroup</code>
    ///                 for the specified DB engine is used.</p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If supplied, must match the name of an existing DBParameterGroup.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>The DB subnet group name to use for the new instance.</p>
    ///          <p>Constraints: If supplied, must match the name of an existing DBSubnetGroup.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance</a>.
    ///         </p>
    public let deletionProtection: Bool?
    /// <p>Specify the Active Directory directory ID to restore the DB instance in.
    ///           The domain must be created prior to this operation. Currently, only MySQL, Microsoft SQL
    ///           Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///           Kerberos Authentication</a> in the <i>Amazon RDS User Guide</i>.</p>
    public let domain: String?
    /// <p>Specify the name of the IAM role to be used when making API calls to the Directory Service.</p>
    public let domainIAMRoleName: String?
    /// <p>The list of logs that the restored DB instance is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs</a> in the <i>Amazon RDS User Guide</i>.</p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance.</p>
    ///         <p>A <i>CoIP</i> provides local or external connectivity to resources in
    ///             your Outpost subnets through your on-premises network. For some use cases, a CoIP can
    ///             provide lower latency for connections to the DB instance from outside of its virtual
    ///             private cloud (VPC) on your local network.</p>
    ///         <p>For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Working with Amazon RDS on AWS Outposts</a>
    ///             in the <i>Amazon RDS User Guide</i>.</p>
    ///         <p>For more information about CoIPs, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing">Customer-owned IP addresses</a>
    ///             in the <i>AWS Outposts User Guide</i>.</p>
    public let enableCustomerOwnedIp: Bool?
    /// <p>A value that indicates whether to enable mapping of AWS Identity and Access
    ///           Management (IAM) accounts to database accounts. By default, mapping is disabled.</p>
    ///
    ///          <p>For more information about IAM database authentication, see
    ///         <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///             IAM Database Authentication for MySQL and PostgreSQL</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>The database engine to use for the new instance.</p>
    ///          <p>Default: The same as source</p>
    ///          <p>Constraint: Must be compatible with the engine of the source</p>
    ///
    ///          <p>Valid Values:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>mariadb</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>mysql</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se2</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se1</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>oracle-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>postgres</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-se</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-ex</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>sqlserver-web</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let engine: String?
    /// <p>The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance.</p>
    ///          <p>Constraints: Must be an integer greater than 1000.</p>
    ///          <p>
    ///             <b>SQL Server</b>
    ///          </p>
    ///          <p>Setting the IOPS value for the SQL Server database engine isn't supported.</p>
    public let iops: Int?
    /// <p>License model information for the restored DB instance.</p>
    ///          <p>Default: Same as source.</p>
    ///          <p>
    ///             Valid values:  <code>license-included</code> | <code>bring-your-own-license</code> | <code>general-public-license</code>
    ///          </p>
    public let licenseModel: String?
    /// <p>The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.</p>
    ///          <p>For more information about this setting, including limitations that apply to it, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling">
    ///               Managing capacity automatically with Amazon RDS storage autoscaling</a>
    ///           in the <i>Amazon RDS User Guide</i>.</p>
    public let maxAllocatedStorage: Int?
    /// <p>A value that indicates whether the DB instance is a Multi-AZ deployment.</p>
    ///          <p>Constraint: You can't specify the <code>AvailabilityZone</code> parameter if the DB instance is a Multi-AZ deployment.</p>
    public let multiAZ: Bool?
    /// <p>The name of the option group to be used for the restored DB instance.</p>
    ///
    ///          <p>Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance once it is associated with a DB instance</p>
    public let optionGroupName: String?
    /// <p>The port number on which the database accepts connections.</p>
    ///          <p>Constraints: Value must be <code>1150-65535</code>
    ///          </p>
    ///          <p>Default: The same port as the original DB instance.</p>
    public let port: Int?
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    public let processorFeatures: [ProcessorFeature]?
    /// <p>A value that indicates whether the DB instance is publicly accessible.</p>
    ///          <p>When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///           and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///           and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.</p>
    ///          <p>When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.</p>
    ///          <p>For more information, see <a>CreateDBInstance</a>.</p>
    public let publiclyAccessible: Bool?
    /// <p>The date and time to restore from.</p>
    ///          <p>Valid Values: Value must be a time in Universal Coordinated Time (UTC) format</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be before the latest restorable time for the DB instance</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't be specified if the <code>UseLatestRestorableTime</code> parameter is enabled</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>2009-09-07T23:45:00Z</code>
    ///          </p>
    public let restoreTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the replicated automated backups from which to restore, for example,
    ///             <code>arn:aws:rds:useast-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE</code>.</p>
    public let sourceDBInstanceAutomatedBackupsArn: String?
    /// <p>The identifier of the source DB instance from which to restore.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DB instance.</p>
    ///             </li>
    ///          </ul>
    public let sourceDBInstanceIdentifier: String?
    /// <p>The resource ID of the source DB instance from which to restore.</p>
    public let sourceDbiResourceId: String?
    /// <p>Specifies the storage type to be associated with the DB instance.</p>
    ///          <p>
    ///             Valid values: <code>standard | gp2 | io1</code>
    ///          </p>
    ///          <p>
    ///             If you specify <code>io1</code>, you must also include a value for the
    ///             <code>Iops</code> parameter.
    ///         </p>
    ///          <p>
    ///             Default: <code>io1</code> if the <code>Iops</code> parameter
    ///             is specified, otherwise <code>gp2</code>
    ///          </p>
    public let storageType: String?
    /// <p>A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources</a> in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let tags: [Tag]?
    /// <p>The name of the new DB instance to be created.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let targetDBInstanceIdentifier: String?
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>The password for the given ARN from the key store in order to access the device.</p>
    public let tdeCredentialPassword: String?
    /// <p>A value that indicates whether the DB instance class of the DB instance uses its default processor features.</p>
    public let useDefaultProcessorFeatures: Bool?
    /// <p>
    ///           A value that indicates whether the DB instance is restored from the latest backup time. By default, the DB instance
    ///           isn't restored from the latest backup time.
    ///         </p>
    ///          <p>Constraints: Can't be specified if the <code>RestoreTime</code> parameter is provided.</p>
    public let useLatestRestorableTime: Bool
    /// <p>
    ///             A list of EC2 VPC security groups to associate with this DB instance.
    ///         </p>
    ///         <p>
    ///             Default: The default EC2 VPC security group for the DB subnet group's VPC.
    ///         </p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        autoMinorVersionUpgrade: Bool? = nil,
        availabilityZone: String? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBInstanceClass: String? = nil,
        dBName: String? = nil,
        dBParameterGroupName: String? = nil,
        dBSubnetGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableCustomerOwnedIp: Bool? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        engine: String? = nil,
        iops: Int? = nil,
        licenseModel: String? = nil,
        maxAllocatedStorage: Int? = nil,
        multiAZ: Bool? = nil,
        optionGroupName: String? = nil,
        port: Int? = nil,
        processorFeatures: [ProcessorFeature]? = nil,
        publiclyAccessible: Bool? = nil,
        restoreTime: Date? = nil,
        sourceDBInstanceAutomatedBackupsArn: String? = nil,
        sourceDBInstanceIdentifier: String? = nil,
        sourceDbiResourceId: String? = nil,
        storageType: String? = nil,
        tags: [Tag]? = nil,
        targetDBInstanceIdentifier: String? = nil,
        tdeCredentialArn: String? = nil,
        tdeCredentialPassword: String? = nil,
        useDefaultProcessorFeatures: Bool? = nil,
        useLatestRestorableTime: Bool = false,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.iops = iops
        self.licenseModel = licenseModel
        self.maxAllocatedStorage = maxAllocatedStorage
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.port = port
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.restoreTime = restoreTime
        self.sourceDBInstanceAutomatedBackupsArn = sourceDBInstanceAutomatedBackupsArn
        self.sourceDBInstanceIdentifier = sourceDBInstanceIdentifier
        self.sourceDbiResourceId = sourceDbiResourceId
        self.storageType = storageType
        self.tags = tags
        self.targetDBInstanceIdentifier = targetDBInstanceIdentifier
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.useLatestRestorableTime = useLatestRestorableTime
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBInstanceToPointInTimeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBInstanceToPointInTimeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExistsFault" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAutomatedBackupNotFoundFault" : self = .dBInstanceAutomatedBackupNotFoundFault(try DBInstanceAutomatedBackupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceededFault" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacityFault" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PointInTimeRestoreNotEnabledFault" : self = .pointInTimeRestoreNotEnabledFault(try PointInTimeRestoreNotEnabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupportedFault" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBInstanceToPointInTimeOutputError: Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBInstanceAutomatedBackupNotFoundFault(DBInstanceAutomatedBackupNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case pointInTimeRestoreNotEnabledFault(PointInTimeRestoreNotEnabledFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBInstanceToPointInTimeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBInstanceToPointInTimeOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension RestoreDBInstanceToPointInTimeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreDBInstanceToPointInTimeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RestoreDBInstanceToPointInTimeOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB instance.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
    ///       </p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RestoreDBInstanceToPointInTimeOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension RestoreDBInstanceToPointInTimeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RestoreDBInstanceToPointInTimeResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension RestoreWindow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case earliestTime = "EarliestTime"
        case latestTime = "LatestTime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let earliestTime = earliestTime {
            try container.encode(TimestampWrapper(earliestTime, format: .dateTime), forKey: Key("earliestTime"))
        }
        if let latestTime = latestTime {
            try container.encode(TimestampWrapper(latestTime, format: .dateTime), forKey: Key("latestTime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let earliestTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .earliestTime)
        var earliestTimeBuffer:Date? = nil
        if let earliestTimeDecoded = earliestTimeDecoded {
            earliestTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(earliestTimeDecoded, format: .dateTime)
        }
        earliestTime = earliestTimeBuffer
        let latestTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestTime)
        var latestTimeBuffer:Date? = nil
        if let latestTimeDecoded = latestTimeDecoded {
            latestTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(latestTimeDecoded, format: .dateTime)
        }
        latestTime = latestTimeBuffer
    }
}

extension RestoreWindow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreWindow(earliestTime: \(String(describing: earliestTime)), latestTime: \(String(describing: latestTime)))"}
}

/// <p>Earliest and latest time an instance can be restored to:</p>
public struct RestoreWindow: Equatable {
    /// <p>The earliest time you can restore an instance to.</p>
    public let earliestTime: Date?
    /// <p>The latest time you can restore an instance to.</p>
    public let latestTime: Date?

    public init (
        earliestTime: Date? = nil,
        latestTime: Date? = nil
    )
    {
        self.earliestTime = earliestTime
        self.latestTime = latestTime
    }
}

public struct RevokeDBSecurityGroupIngressInputBodyMiddleware: Middleware {
    public let id: String = "RevokeDBSecurityGroupIngressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeDBSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeDBSecurityGroupIngressOutputError>
}

extension RevokeDBSecurityGroupIngressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeDBSecurityGroupIngressInput(cIDRIP: \(String(describing: cIDRIP)), dBSecurityGroupName: \(String(describing: dBSecurityGroupName)), eC2SecurityGroupId: \(String(describing: eC2SecurityGroupId)), eC2SecurityGroupName: \(String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(String(describing: eC2SecurityGroupOwnerId)))"}
}

extension RevokeDBSecurityGroupIngressInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: Key("CIDRIP"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: Key("DBSecurityGroupName"))
        }
        if let eC2SecurityGroupId = eC2SecurityGroupId {
            try container.encode(eC2SecurityGroupId, forKey: Key("EC2SecurityGroupId"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: Key("EC2SecurityGroupOwnerId"))
        }
        try container.encode("RevokeDBSecurityGroupIngress", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RevokeDBSecurityGroupIngressInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeDBSecurityGroupIngressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeDBSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeDBSecurityGroupIngressOutputError>
}

public struct RevokeDBSecurityGroupIngressInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeDBSecurityGroupIngressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeDBSecurityGroupIngressInput>
    public typealias MOutput = OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeDBSecurityGroupIngressOutputError>
}

/// <p></p>
public struct RevokeDBSecurityGroupIngressInput: Equatable {
    /// <p>
    ///         The IP range to revoke access from.
    ///         Must be a valid CIDR range. If <code>CIDRIP</code> is specified,
    ///         <code>EC2SecurityGroupName</code>, <code>EC2SecurityGroupId</code> and <code>EC2SecurityGroupOwnerId</code>
    ///         can't be provided.
    ///         </p>
    public let cIDRIP: String?
    /// <p>The name of the DB security group to revoke ingress from.</p>
    public let dBSecurityGroupName: String?
    /// <p>
    ///         The id of the EC2 security group to revoke access from.
    ///         For VPC DB security groups, <code>EC2SecurityGroupId</code> must be provided.
    ///         Otherwise, EC2SecurityGroupOwnerId and either <code>EC2SecurityGroupName</code> or <code>EC2SecurityGroupId</code> must be provided.
    ///         </p>
    public let eC2SecurityGroupId: String?
    /// <p>
    ///         The name of the EC2 security group to revoke access from.
    ///         For VPC DB security groups, <code>EC2SecurityGroupId</code> must be provided.
    ///         Otherwise, EC2SecurityGroupOwnerId and either <code>EC2SecurityGroupName</code> or <code>EC2SecurityGroupId</code> must be provided.
    ///         </p>
    public let eC2SecurityGroupName: String?
    /// <p>
    ///         The AWS account number of the owner of the EC2 security group
    ///         specified in the <code>EC2SecurityGroupName</code> parameter.
    ///         The AWS access key ID isn't an acceptable value.
    ///         For VPC DB security groups, <code>EC2SecurityGroupId</code> must be provided.
    ///         Otherwise, EC2SecurityGroupOwnerId and either <code>EC2SecurityGroupName</code> or <code>EC2SecurityGroupId</code> must be provided.
    ///         </p>
    public let eC2SecurityGroupOwnerId: String?

    public init (
        cIDRIP: String? = nil,
        dBSecurityGroupName: String? = nil,
        eC2SecurityGroupId: String? = nil,
        eC2SecurityGroupName: String? = nil,
        eC2SecurityGroupOwnerId: String? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.dBSecurityGroupName = dBSecurityGroupName
        self.eC2SecurityGroupId = eC2SecurityGroupId
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
    }
}

extension RevokeDBSecurityGroupIngressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RevokeDBSecurityGroupIngressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupStateFault" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeDBSecurityGroupIngressOutputError: Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeDBSecurityGroupIngressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeDBSecurityGroupIngressOutputResponse(dBSecurityGroup: \(String(describing: dBSecurityGroup)))"}
}

extension RevokeDBSecurityGroupIngressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RevokeDBSecurityGroupIngressOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSecurityGroup = output.dBSecurityGroup
        } else {
            self.dBSecurityGroup = nil
        }
    }
}

public struct RevokeDBSecurityGroupIngressOutputResponse: Equatable {
    /// <p>Contains the details for an Amazon RDS DB security group.
    ///       </p>
    ///          <p>This data type is used as a response element
    ///           in the <code>DescribeDBSecurityGroups</code> action.
    ///       </p>
    public let dBSecurityGroup: DBSecurityGroup?

    public init (
        dBSecurityGroup: DBSecurityGroup? = nil
    )
    {
        self.dBSecurityGroup = dBSecurityGroup
    }
}

struct RevokeDBSecurityGroupIngressOutputResponseBody: Equatable {
    public let dBSecurityGroup: DBSecurityGroup?
}

extension RevokeDBSecurityGroupIngressOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSecurityGroup = "DBSecurityGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RevokeDBSecurityGroupIngressResult"))
        let dBSecurityGroupDecoded = try containerValues.decodeIfPresent(DBSecurityGroup.self, forKey: .dBSecurityGroup)
        dBSecurityGroup = dBSecurityGroupDecoded
    }
}

extension SNSInvalidTopicFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSInvalidTopicFault(message: \(String(describing: message)))"}
}

extension SNSInvalidTopicFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SNSInvalidTopicFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>SNS has responded that there is a problem with the SND topic specified.</p>
public struct SNSInvalidTopicFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SNSInvalidTopicFaultBody: Equatable {
    public let message: String?
}

extension SNSInvalidTopicFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSNoAuthorizationFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSNoAuthorizationFault(message: \(String(describing: message)))"}
}

extension SNSNoAuthorizationFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SNSNoAuthorizationFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have permission to publish to the SNS topic ARN.</p>
public struct SNSNoAuthorizationFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SNSNoAuthorizationFaultBody: Equatable {
    public let message: String?
}

extension SNSNoAuthorizationFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSTopicArnNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSTopicArnNotFoundFault(message: \(String(describing: message)))"}
}

extension SNSTopicArnNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SNSTopicArnNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The SNS topic ARN does not exist.</p>
public struct SNSTopicArnNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SNSTopicArnNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SNSTopicArnNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ScalingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoPause = "AutoPause"
        case maxCapacity = "MaxCapacity"
        case minCapacity = "MinCapacity"
        case secondsUntilAutoPause = "SecondsUntilAutoPause"
        case timeoutAction = "TimeoutAction"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let autoPause = autoPause {
            try container.encode(autoPause, forKey: Key("AutoPause"))
        }
        if let maxCapacity = maxCapacity {
            try container.encode(maxCapacity, forKey: Key("MaxCapacity"))
        }
        if let minCapacity = minCapacity {
            try container.encode(minCapacity, forKey: Key("MinCapacity"))
        }
        if let secondsUntilAutoPause = secondsUntilAutoPause {
            try container.encode(secondsUntilAutoPause, forKey: Key("SecondsUntilAutoPause"))
        }
        if let timeoutAction = timeoutAction {
            try container.encode(timeoutAction, forKey: Key("TimeoutAction"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minCapacity)
        minCapacity = minCapacityDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let autoPauseDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoPause)
        autoPause = autoPauseDecoded
        let secondsUntilAutoPauseDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .secondsUntilAutoPause)
        secondsUntilAutoPause = secondsUntilAutoPauseDecoded
        let timeoutActionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeoutAction)
        timeoutAction = timeoutActionDecoded
    }
}

extension ScalingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScalingConfiguration(autoPause: \(String(describing: autoPause)), maxCapacity: \(String(describing: maxCapacity)), minCapacity: \(String(describing: minCapacity)), secondsUntilAutoPause: \(String(describing: secondsUntilAutoPause)), timeoutAction: \(String(describing: timeoutAction)))"}
}

/// <p>Contains the scaling configuration of an Aurora Serverless DB cluster.</p>
///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html">Using Amazon Aurora Serverless</a> in the
///             <i>Amazon Aurora User Guide</i>.</p>
public struct ScalingConfiguration: Equatable {
    /// <p>A value that indicates whether to allow or disallow automatic pause for an Aurora DB cluster in <code>serverless</code> DB engine mode.
    ///             A DB cluster can be paused only when it's idle (it has no connections).</p>
    ///         <note>
    ///             <p>If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot.
    ///                 In this case, the DB cluster is restored when there is a request to connect to it. </p>
    ///         </note>
    public let autoPause: Bool?
    /// <p>The maximum capacity for an Aurora DB cluster in <code>serverless</code> DB engine mode.</p>
    ///         <p>For Aurora MySQL, valid capacity values are <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>, and <code>256</code>.</p>
    ///         <p>For Aurora PostgreSQL, valid capacity values are <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>192</code>, and <code>384</code>.</p>
    ///         <p>The maximum capacity must be greater than or equal to the minimum capacity.</p>
    public let maxCapacity: Int?
    /// <p>The minimum capacity for an Aurora DB cluster in <code>serverless</code> DB engine mode.</p>
    ///         <p>For Aurora MySQL, valid capacity values are <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>, and <code>256</code>.</p>
    ///         <p>For Aurora PostgreSQL, valid capacity values are <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>192</code>, and <code>384</code>.</p>
    ///         <p>The minimum capacity must be less than or equal to the maximum capacity.</p>
    public let minCapacity: Int?
    /// <p>The time, in seconds, before an Aurora DB cluster in <code>serverless</code> mode is paused.</p>
    ///         <p>Specify a value between 300 and 86,400 seconds.</p>
    public let secondsUntilAutoPause: Int?
    /// <p>The action to take when the timeout is reached, either <code>ForceApplyCapacityChange</code> or <code>RollbackCapacityChange</code>.</p>
    ///         <p>
    ///             <code>ForceApplyCapacityChange</code> sets the capacity to the specified value as soon as possible.</p>
    ///         <p>
    ///             <code>RollbackCapacityChange</code>, the default, ignores the capacity change if a scaling point isn't found in the timeout period.</p>
    ///         <important>
    ///             <p>If you specify <code>ForceApplyCapacityChange</code>, connections that
    ///                 prevent Aurora Serverless from finding a scaling point might be dropped.</p>
    ///         </important>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.how-it-works.auto-scaling">
    ///                     Autoscaling for Aurora Serverless</a> in the <i>Amazon Aurora User Guide</i>.</p>
    public let timeoutAction: String?

    public init (
        autoPause: Bool? = nil,
        maxCapacity: Int? = nil,
        minCapacity: Int? = nil,
        secondsUntilAutoPause: Int? = nil,
        timeoutAction: String? = nil
    )
    {
        self.autoPause = autoPause
        self.maxCapacity = maxCapacity
        self.minCapacity = minCapacity
        self.secondsUntilAutoPause = secondsUntilAutoPause
        self.timeoutAction = timeoutAction
    }
}

extension ScalingConfigurationInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoPause = "AutoPause"
        case maxCapacity = "MaxCapacity"
        case minCapacity = "MinCapacity"
        case secondsUntilAutoPause = "SecondsUntilAutoPause"
        case timeoutAction = "TimeoutAction"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let autoPause = autoPause {
            try container.encode(autoPause, forKey: Key("AutoPause"))
        }
        if let maxCapacity = maxCapacity {
            try container.encode(maxCapacity, forKey: Key("MaxCapacity"))
        }
        if let minCapacity = minCapacity {
            try container.encode(minCapacity, forKey: Key("MinCapacity"))
        }
        if let secondsUntilAutoPause = secondsUntilAutoPause {
            try container.encode(secondsUntilAutoPause, forKey: Key("SecondsUntilAutoPause"))
        }
        if let timeoutAction = timeoutAction {
            try container.encode(timeoutAction, forKey: Key("TimeoutAction"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minCapacity)
        minCapacity = minCapacityDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let autoPauseDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoPause)
        autoPause = autoPauseDecoded
        let secondsUntilAutoPauseDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .secondsUntilAutoPause)
        secondsUntilAutoPause = secondsUntilAutoPauseDecoded
        let timeoutActionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeoutAction)
        timeoutAction = timeoutActionDecoded
    }
}

extension ScalingConfigurationInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScalingConfigurationInfo(autoPause: \(String(describing: autoPause)), maxCapacity: \(String(describing: maxCapacity)), minCapacity: \(String(describing: minCapacity)), secondsUntilAutoPause: \(String(describing: secondsUntilAutoPause)), timeoutAction: \(String(describing: timeoutAction)))"}
}

/// <p>Shows the scaling configuration for an Aurora DB cluster in <code>serverless</code> DB engine mode.</p>
///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html">Using Amazon Aurora Serverless</a> in the
///             <i>Amazon Aurora User Guide</i>.</p>
public struct ScalingConfigurationInfo: Equatable {
    /// <p>A value that indicates whether automatic pause is allowed for the Aurora DB cluster
    ///             in <code>serverless</code> DB engine mode.</p>
    ///         <p>When the value is set to false for an Aurora Serverless DB cluster, the DB cluster automatically resumes.</p>
    public let autoPause: Bool?
    /// <p>The maximum capacity for an Aurora DB cluster in <code>serverless</code> DB engine mode.</p>
    public let maxCapacity: Int?
    /// <p>The maximum capacity for the Aurora DB cluster in <code>serverless</code> DB engine
    ///             mode.</p>
    public let minCapacity: Int?
    /// <p>The remaining amount of time, in seconds, before the Aurora DB cluster in
    ///                 <code>serverless</code> mode is paused. A DB cluster can be paused only when
    ///             it's idle (it has no connections).</p>
    public let secondsUntilAutoPause: Int?
    /// <p>The timeout action of a call to <code>ModifyCurrentDBClusterCapacity</code>, either
    ///                 <code>ForceApplyCapacityChange</code> or <code>RollbackCapacityChange</code>.</p>
    public let timeoutAction: String?

    public init (
        autoPause: Bool? = nil,
        maxCapacity: Int? = nil,
        minCapacity: Int? = nil,
        secondsUntilAutoPause: Int? = nil,
        timeoutAction: String? = nil
    )
    {
        self.autoPause = autoPause
        self.maxCapacity = maxCapacity
        self.minCapacity = minCapacity
        self.secondsUntilAutoPause = secondsUntilAutoPause
        self.timeoutAction = timeoutAction
    }
}

extension SharedSnapshotQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SharedSnapshotQuotaExceededFault(message: \(String(describing: message)))"}
}

extension SharedSnapshotQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SharedSnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.</p>
public struct SharedSnapshotQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SharedSnapshotQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension SharedSnapshotQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotQuotaExceededFault(message: \(String(describing: message)))"}
}

extension SnapshotQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed number of DB
///             snapshots.</p>
public struct SnapshotQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension SnapshotQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceNotFoundFault(message: \(String(describing: message)))"}
}

extension SourceNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested source could not be found.</p>
public struct SourceNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SourceNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SourceNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceRegion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoint = "Endpoint"
        case regionName = "RegionName"
        case status = "Status"
        case supportsDBInstanceAutomatedBackupsReplication = "SupportsDBInstanceAutomatedBackupsReplication"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let regionName = regionName {
            try container.encode(regionName, forKey: Key("RegionName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if supportsDBInstanceAutomatedBackupsReplication != false {
            try container.encode(supportsDBInstanceAutomatedBackupsReplication, forKey: Key("SupportsDBInstanceAutomatedBackupsReplication"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let supportsDBInstanceAutomatedBackupsReplicationDecoded = try containerValues.decode(Bool.self, forKey: .supportsDBInstanceAutomatedBackupsReplication)
        supportsDBInstanceAutomatedBackupsReplication = supportsDBInstanceAutomatedBackupsReplicationDecoded
    }
}

extension SourceRegion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceRegion(endpoint: \(String(describing: endpoint)), regionName: \(String(describing: regionName)), status: \(String(describing: status)), supportsDBInstanceAutomatedBackupsReplication: \(String(describing: supportsDBInstanceAutomatedBackupsReplication)))"}
}

/// <p>Contains an AWS Region name as the result of a successful call to the <code>DescribeSourceRegions</code> action.</p>
public struct SourceRegion: Equatable {
    /// <p>The endpoint for the source AWS Region endpoint.</p>
    public let endpoint: String?
    /// <p>The name of the source AWS Region.</p>
    public let regionName: String?
    /// <p>The status of the source AWS Region.</p>
    public let status: String?
    /// <p>Whether the source AWS Region supports replicating automated backups to the current AWS Region.</p>
    public let supportsDBInstanceAutomatedBackupsReplication: Bool

    public init (
        endpoint: String? = nil,
        regionName: String? = nil,
        status: String? = nil,
        supportsDBInstanceAutomatedBackupsReplication: Bool = false
    )
    {
        self.endpoint = endpoint
        self.regionName = regionName
        self.status = status
        self.supportsDBInstanceAutomatedBackupsReplication = supportsDBInstanceAutomatedBackupsReplication
    }
}

public enum SourceType {
    case dbCluster
    case dbClusterSnapshot
    case dbInstance
    case dbParameterGroup
    case dbSecurityGroup
    case dbSnapshot
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .dbCluster,
            .dbClusterSnapshot,
            .dbInstance,
            .dbParameterGroup,
            .dbSecurityGroup,
            .dbSnapshot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dbCluster: return "db-cluster"
        case .dbClusterSnapshot: return "db-cluster-snapshot"
        case .dbInstance: return "db-instance"
        case .dbParameterGroup: return "db-parameter-group"
        case .dbSecurityGroup: return "db-security-group"
        case .dbSnapshot: return "db-snapshot"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

public struct StartActivityStreamInputBodyMiddleware: Middleware {
    public let id: String = "StartActivityStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartActivityStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<StartActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartActivityStreamInput>
    public typealias MOutput = OperationOutput<StartActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartActivityStreamOutputError>
}

extension StartActivityStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartActivityStreamInput(applyImmediately: \(String(describing: applyImmediately)), kmsKeyId: \(String(describing: kmsKeyId)), mode: \(String(describing: mode)), resourceArn: \(String(describing: resourceArn)))"}
}

extension StartActivityStreamInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applyImmediately = applyImmediately {
            try container.encode(applyImmediately, forKey: Key("ApplyImmediately"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let mode = mode {
            try container.encode(mode, forKey: Key("Mode"))
        }
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: Key("ResourceArn"))
        }
        try container.encode("StartActivityStream", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct StartActivityStreamInputHeadersMiddleware: Middleware {
    public let id: String = "StartActivityStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartActivityStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<StartActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartActivityStreamInput>
    public typealias MOutput = OperationOutput<StartActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartActivityStreamOutputError>
}

public struct StartActivityStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "StartActivityStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartActivityStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<StartActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartActivityStreamInput>
    public typealias MOutput = OperationOutput<StartActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartActivityStreamOutputError>
}

public struct StartActivityStreamInput: Equatable {
    /// <p>Specifies whether or not the database activity stream is to start as soon as possible,
    ///             regardless of the maintenance window for the database.</p>
    public let applyImmediately: Bool?
    /// <p>The AWS KMS key identifier for encrypting messages in the database activity stream.
    ///             The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    public let kmsKeyId: String?
    /// <p>Specifies the mode of the database activity stream.
    ///             Database events such as a change or access generate an activity stream event.
    ///             The database session can handle these events either synchronously or asynchronously.
    ///         </p>
    public let mode: ActivityStreamMode?
    /// <p>The Amazon Resource Name (ARN) of the DB cluster,
    ///             for example, <code>arn:aws:rds:us-east-1:12345667890:cluster:das-cluster</code>.</p>
    public let resourceArn: String?

    public init (
        applyImmediately: Bool? = nil,
        kmsKeyId: String? = nil,
        mode: ActivityStreamMode? = nil,
        resourceArn: String? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.kmsKeyId = kmsKeyId
        self.mode = mode
        self.resourceArn = resourceArn
    }
}

extension StartActivityStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartActivityStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartActivityStreamOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartActivityStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartActivityStreamOutputResponse(applyImmediately: \(String(describing: applyImmediately)), kinesisStreamName: \(String(describing: kinesisStreamName)), kmsKeyId: \(String(describing: kmsKeyId)), mode: \(String(describing: mode)), status: \(String(describing: status)))"}
}

extension StartActivityStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartActivityStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applyImmediately = output.applyImmediately
            self.kinesisStreamName = output.kinesisStreamName
            self.kmsKeyId = output.kmsKeyId
            self.mode = output.mode
            self.status = output.status
        } else {
            self.applyImmediately = false
            self.kinesisStreamName = nil
            self.kmsKeyId = nil
            self.mode = nil
            self.status = nil
        }
    }
}

public struct StartActivityStreamOutputResponse: Equatable {
    /// <p>Indicates whether or not the database activity stream will start as soon as possible,
    ///             regardless of the maintenance window for the database.</p>
    public let applyImmediately: Bool
    /// <p>The name of the Amazon Kinesis data stream to be used for the database activity stream.</p>
    public let kinesisStreamName: String?
    /// <p>The AWS KMS key identifier for encryption of messages in the database activity stream.</p>
    public let kmsKeyId: String?
    /// <p>The mode of the database activity stream.</p>
    public let mode: ActivityStreamMode?
    /// <p>The status of the database activity stream.</p>
    public let status: ActivityStreamStatus?

    public init (
        applyImmediately: Bool = false,
        kinesisStreamName: String? = nil,
        kmsKeyId: String? = nil,
        mode: ActivityStreamMode? = nil,
        status: ActivityStreamStatus? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.kinesisStreamName = kinesisStreamName
        self.kmsKeyId = kmsKeyId
        self.mode = mode
        self.status = status
    }
}

struct StartActivityStreamOutputResponseBody: Equatable {
    public let kmsKeyId: String?
    public let kinesisStreamName: String?
    public let status: ActivityStreamStatus?
    public let mode: ActivityStreamMode?
    public let applyImmediately: Bool
}

extension StartActivityStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applyImmediately = "ApplyImmediately"
        case kinesisStreamName = "KinesisStreamName"
        case kmsKeyId = "KmsKeyId"
        case mode = "Mode"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("StartActivityStreamResult"))
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let kinesisStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kinesisStreamName)
        kinesisStreamName = kinesisStreamNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ActivityStreamStatus.self, forKey: .status)
        status = statusDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ActivityStreamMode.self, forKey: .mode)
        mode = modeDecoded
        let applyImmediatelyDecoded = try containerValues.decode(Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
    }
}

public struct StartDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "StartDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBClusterOutputError>
}

extension StartDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)))"}
}

extension StartDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        try container.encode("StartDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct StartDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "StartDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBClusterOutputError>
}

public struct StartDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBClusterOutputError>
}

public struct StartDBClusterInput: Equatable {
    /// <p>The DB cluster identifier of the Amazon Aurora DB cluster to be started. This parameter is stored as
    ///         a lowercase string.</p>
    public let dBClusterIdentifier: String?

    public init (
        dBClusterIdentifier: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension StartDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension StartDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct StartDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Aurora DB cluster.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusters</code>,
    ///         <code>StopDBCluster</code>, and <code>StartDBCluster</code> actions.
    ///       </p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct StartDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension StartDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("StartDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct StartDBInstanceAutomatedBackupsReplicationInputBodyMiddleware: Middleware {
    public let id: String = "StartDBInstanceAutomatedBackupsReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBInstanceAutomatedBackupsReplicationOutputError>
}

extension StartDBInstanceAutomatedBackupsReplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDBInstanceAutomatedBackupsReplicationInput(backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), kmsKeyId: \(String(describing: kmsKeyId)), preSignedUrl: \(String(describing: preSignedUrl)), sourceDBInstanceArn: \(String(describing: sourceDBInstanceArn)))"}
}

extension StartDBInstanceAutomatedBackupsReplicationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: Key("PreSignedUrl"))
        }
        if let sourceDBInstanceArn = sourceDBInstanceArn {
            try container.encode(sourceDBInstanceArn, forKey: Key("SourceDBInstanceArn"))
        }
        try container.encode("StartDBInstanceAutomatedBackupsReplication", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct StartDBInstanceAutomatedBackupsReplicationInputHeadersMiddleware: Middleware {
    public let id: String = "StartDBInstanceAutomatedBackupsReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBInstanceAutomatedBackupsReplicationOutputError>
}

public struct StartDBInstanceAutomatedBackupsReplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDBInstanceAutomatedBackupsReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBInstanceAutomatedBackupsReplicationOutputError>
}

public struct StartDBInstanceAutomatedBackupsReplicationInput: Equatable {
    /// <p>The retention period for the replicated automated backups.</p>
    public let backupRetentionPeriod: Int?
    /// <p>The AWS KMS key identifier for encryption of the replicated automated backups. The KMS key ID is the
    ///             Amazon Resource Name (ARN) for the KMS encryption key in the destination AWS Region, for example,
    ///             <code>arn:aws:kms:us-east-1:123456789012:key/AKIAIOSFODNN7EXAMPLE</code>.</p>
    public let kmsKeyId: String?
    /// <p>A URL that contains a Signature Version 4 signed request for the StartDBInstanceAutomatedBackupsReplication action to be
    ///             called in the AWS Region of the source DB instance. The presigned URL must be a valid request for the
    ///             StartDBInstanceAutomatedBackupsReplication API action that can be executed in the AWS Region that contains
    ///             the source DB instance.</p>
    public let preSignedUrl: String?
    /// <p>The Amazon Resource Name (ARN) of the source DB instance for the replicated automated backups, for example,
    ///             <code>arn:aws:rds:us-west-2:123456789012:db:mydatabase</code>.</p>
    public let sourceDBInstanceArn: String?

    public init (
        backupRetentionPeriod: Int? = nil,
        kmsKeyId: String? = nil,
        preSignedUrl: String? = nil,
        sourceDBInstanceArn: String? = nil
    )
    {
        self.backupRetentionPeriod = backupRetentionPeriod
        self.kmsKeyId = kmsKeyId
        self.preSignedUrl = preSignedUrl
        self.sourceDBInstanceArn = sourceDBInstanceArn
    }
}

extension StartDBInstanceAutomatedBackupsReplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartDBInstanceAutomatedBackupsReplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupQuotaExceededFault" : self = .dBInstanceAutomatedBackupQuotaExceededFault(try DBInstanceAutomatedBackupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupportedFault" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDBInstanceAutomatedBackupsReplicationOutputError: Equatable {
    case dBInstanceAutomatedBackupQuotaExceededFault(DBInstanceAutomatedBackupQuotaExceededFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDBInstanceAutomatedBackupsReplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDBInstanceAutomatedBackupsReplicationOutputResponse(dBInstanceAutomatedBackup: \(String(describing: dBInstanceAutomatedBackup)))"}
}

extension StartDBInstanceAutomatedBackupsReplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDBInstanceAutomatedBackupsReplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstanceAutomatedBackup = output.dBInstanceAutomatedBackup
        } else {
            self.dBInstanceAutomatedBackup = nil
        }
    }
}

public struct StartDBInstanceAutomatedBackupsReplicationOutputResponse: Equatable {
    /// <p>An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that
    ///             existed at the time you deleted the source instance.</p>
    public let dBInstanceAutomatedBackup: DBInstanceAutomatedBackup?

    public init (
        dBInstanceAutomatedBackup: DBInstanceAutomatedBackup? = nil
    )
    {
        self.dBInstanceAutomatedBackup = dBInstanceAutomatedBackup
    }
}

struct StartDBInstanceAutomatedBackupsReplicationOutputResponseBody: Equatable {
    public let dBInstanceAutomatedBackup: DBInstanceAutomatedBackup?
}

extension StartDBInstanceAutomatedBackupsReplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("StartDBInstanceAutomatedBackupsReplicationResult"))
        let dBInstanceAutomatedBackupDecoded = try containerValues.decodeIfPresent(DBInstanceAutomatedBackup.self, forKey: .dBInstanceAutomatedBackup)
        dBInstanceAutomatedBackup = dBInstanceAutomatedBackupDecoded
    }
}

public struct StartDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "StartDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBInstanceInput>
    public typealias MOutput = OperationOutput<StartDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBInstanceOutputError>
}

extension StartDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDBInstanceInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)))"}
}

extension StartDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        try container.encode("StartDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct StartDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "StartDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBInstanceInput>
    public typealias MOutput = OperationOutput<StartDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBInstanceOutputError>
}

public struct StartDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBInstanceInput>
    public typealias MOutput = OperationOutput<StartDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBInstanceOutputError>
}

public struct StartDBInstanceInput: Equatable {
    /// <p>
    ///             The user-supplied instance identifier.
    ///         </p>
    public let dBInstanceIdentifier: String?

    public init (
        dBInstanceIdentifier: String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
    }
}

extension StartDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacityFault" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDBInstanceOutputError: Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDBInstanceOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension StartDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct StartDBInstanceOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB instance.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
    ///       </p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct StartDBInstanceOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension StartDBInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("StartDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct StartExportTaskInputBodyMiddleware: Middleware {
    public let id: String = "StartExportTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExportTaskInput>
    public typealias MOutput = OperationOutput<StartExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExportTaskOutputError>
}

extension StartExportTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartExportTaskInput(exportOnly: \(String(describing: exportOnly)), exportTaskIdentifier: \(String(describing: exportTaskIdentifier)), iamRoleArn: \(String(describing: iamRoleArn)), kmsKeyId: \(String(describing: kmsKeyId)), s3BucketName: \(String(describing: s3BucketName)), s3Prefix: \(String(describing: s3Prefix)), sourceArn: \(String(describing: sourceArn)))"}
}

extension StartExportTaskInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let exportOnly = exportOnly {
            var exportOnlyContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExportOnly"))
            for (index0, string0) in exportOnly.enumerated() {
                try exportOnlyContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: Key("ExportTaskIdentifier"))
        }
        if let iamRoleArn = iamRoleArn {
            try container.encode(iamRoleArn, forKey: Key("IamRoleArn"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: Key("S3BucketName"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: Key("S3Prefix"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: Key("SourceArn"))
        }
        try container.encode("StartExportTask", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct StartExportTaskInputHeadersMiddleware: Middleware {
    public let id: String = "StartExportTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExportTaskInput>
    public typealias MOutput = OperationOutput<StartExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExportTaskOutputError>
}

public struct StartExportTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "StartExportTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExportTaskInput>
    public typealias MOutput = OperationOutput<StartExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExportTaskOutputError>
}

public struct StartExportTaskInput: Equatable {
    /// <p>The data to be exported from the snapshot.
    ///             If this parameter is not provided, all the snapshot data is exported.
    ///             Valid values are the following:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>database</code> - Export all the data from a specified database.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.table</code>
    ///                   <i>table-name</i> -
    ///                 Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.schema</code>
    ///                   <i>schema-name</i> - Export a database schema of the snapshot.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.schema.table</code>
    ///                   <i>table-name</i> - Export a table of the database schema.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p>
    ///             </li>
    ///          </ul>
    public let exportOnly: [String]?
    /// <p>A unique identifier for the snapshot export task. This ID isn't an identifier for
    ///             the Amazon S3 bucket where the snapshot is to be exported to. </p>
    public let exportTaskIdentifier: String?
    /// <p>The name of the IAM role to use for writing to the Amazon S3 bucket
    ///             when exporting a snapshot. </p>
    public let iamRoleArn: String?
    /// <p>The ID of the AWS KMS customer master key (CMK) to use to encrypt the snapshot exported to Amazon S3. The AWS KMS
    ///             key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).
    ///             The caller of this operation must be authorized to
    ///             execute the following operations. These can be set in the AWS KMS key policy: </p>
    ///         <ul>
    ///             <li>
    ///                <p>GrantOperation.Encrypt</p>
    ///             </li>
    ///             <li>
    ///                <p>GrantOperation.Decrypt</p>
    ///             </li>
    ///             <li>
    ///                <p>GrantOperation.GenerateDataKey</p>
    ///             </li>
    ///             <li>
    ///                <p>GrantOperation.GenerateDataKeyWithoutPlaintext</p>
    ///             </li>
    ///             <li>
    ///                <p>GrantOperation.ReEncryptFrom</p>
    ///             </li>
    ///             <li>
    ///                <p>GrantOperation.ReEncryptTo</p>
    ///             </li>
    ///             <li>
    ///                <p>GrantOperation.CreateGrant</p>
    ///             </li>
    ///             <li>
    ///                <p>GrantOperation.DescribeKey</p>
    ///             </li>
    ///             <li>
    ///                <p>GrantOperation.RetireGrant</p>
    ///             </li>
    ///          </ul>
    public let kmsKeyId: String?
    /// <p>The name of the Amazon S3 bucket to export the snapshot to.</p>
    public let s3BucketName: String?
    /// <p>The Amazon S3 bucket prefix to use as the file name and path of the exported snapshot.</p>
    public let s3Prefix: String?
    /// <p>The Amazon Resource Name (ARN) of the snapshot to export to Amazon S3.</p>
    public let sourceArn: String?

    public init (
        exportOnly: [String]? = nil,
        exportTaskIdentifier: String? = nil,
        iamRoleArn: String? = nil,
        kmsKeyId: String? = nil,
        s3BucketName: String? = nil,
        s3Prefix: String? = nil,
        sourceArn: String? = nil
    )
    {
        self.exportOnly = exportOnly
        self.exportTaskIdentifier = exportTaskIdentifier
        self.iamRoleArn = iamRoleArn
        self.kmsKeyId = kmsKeyId
        self.s3BucketName = s3BucketName
        self.s3Prefix = s3Prefix
        self.sourceArn = sourceArn
    }
}

extension StartExportTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartExportTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExportTaskAlreadyExistsFault" : self = .exportTaskAlreadyExistsFault(try ExportTaskAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IamRoleMissingPermissionsFault" : self = .iamRoleMissingPermissionsFault(try IamRoleMissingPermissionsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IamRoleNotFoundFault" : self = .iamRoleNotFoundFault(try IamRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExportOnlyFault" : self = .invalidExportOnlyFault(try InvalidExportOnlyFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExportSourceStateFault" : self = .invalidExportSourceStateFault(try InvalidExportSourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketFault" : self = .invalidS3BucketFault(try InvalidS3BucketFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartExportTaskOutputError: Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case exportTaskAlreadyExistsFault(ExportTaskAlreadyExistsFault)
    case iamRoleMissingPermissionsFault(IamRoleMissingPermissionsFault)
    case iamRoleNotFoundFault(IamRoleNotFoundFault)
    case invalidExportOnlyFault(InvalidExportOnlyFault)
    case invalidExportSourceStateFault(InvalidExportSourceStateFault)
    case invalidS3BucketFault(InvalidS3BucketFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExportTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartExportTaskOutputResponse(exportOnly: \(String(describing: exportOnly)), exportTaskIdentifier: \(String(describing: exportTaskIdentifier)), failureCause: \(String(describing: failureCause)), iamRoleArn: \(String(describing: iamRoleArn)), kmsKeyId: \(String(describing: kmsKeyId)), percentProgress: \(String(describing: percentProgress)), s3Bucket: \(String(describing: s3Bucket)), s3Prefix: \(String(describing: s3Prefix)), snapshotTime: \(String(describing: snapshotTime)), sourceArn: \(String(describing: sourceArn)), status: \(String(describing: status)), taskEndTime: \(String(describing: taskEndTime)), taskStartTime: \(String(describing: taskStartTime)), totalExtractedDataInGB: \(String(describing: totalExtractedDataInGB)), warningMessage: \(String(describing: warningMessage)))"}
}

extension StartExportTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartExportTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exportOnly = output.exportOnly
            self.exportTaskIdentifier = output.exportTaskIdentifier
            self.failureCause = output.failureCause
            self.iamRoleArn = output.iamRoleArn
            self.kmsKeyId = output.kmsKeyId
            self.percentProgress = output.percentProgress
            self.s3Bucket = output.s3Bucket
            self.s3Prefix = output.s3Prefix
            self.snapshotTime = output.snapshotTime
            self.sourceArn = output.sourceArn
            self.status = output.status
            self.taskEndTime = output.taskEndTime
            self.taskStartTime = output.taskStartTime
            self.totalExtractedDataInGB = output.totalExtractedDataInGB
            self.warningMessage = output.warningMessage
        } else {
            self.exportOnly = nil
            self.exportTaskIdentifier = nil
            self.failureCause = nil
            self.iamRoleArn = nil
            self.kmsKeyId = nil
            self.percentProgress = 0
            self.s3Bucket = nil
            self.s3Prefix = nil
            self.snapshotTime = nil
            self.sourceArn = nil
            self.status = nil
            self.taskEndTime = nil
            self.taskStartTime = nil
            self.totalExtractedDataInGB = 0
            self.warningMessage = nil
        }
    }
}

/// <p>Contains the details of a snapshot export to Amazon S3.
///         </p>
///         <p>This data type is used as a response element in the <code>DescribeExportTasks</code> action.
///         </p>
public struct StartExportTaskOutputResponse: Equatable {
    /// <p>The data exported from the snapshot. Valid values are the following:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>database</code> - Export all the data from a specified database.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.table</code>
    ///                   <i>table-name</i> -
    ///                 Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.schema</code>
    ///                   <i>schema-name</i> - Export a database schema of the snapshot.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>database.schema.table</code>
    ///                   <i>table-name</i> - Export a table of the database schema.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p>
    ///             </li>
    ///          </ul>
    public let exportOnly: [String]?
    /// <p>A unique identifier for the snapshot export task. This ID isn't an identifier for
    ///             the Amazon S3 bucket where the snapshot is exported to. </p>
    public let exportTaskIdentifier: String?
    /// <p>The reason the export failed, if it failed.</p>
    public let failureCause: String?
    /// <p>The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot. </p>
    public let iamRoleArn: String?
    /// <p>The key identifier of the AWS KMS customer master key (CMK) that is used to encrypt the snapshot when it's exported to
    ///             Amazon S3. The AWS KMS CMK identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the snapshot export
    ///             must have encryption and decryption permissions to use this AWS KMS CMK. </p>
    public let kmsKeyId: String?
    /// <p>The progress of the snapshot export task as a percentage.</p>
    public let percentProgress: Int
    /// <p>The Amazon S3 bucket that the snapshot is exported to.</p>
    public let s3Bucket: String?
    /// <p>The Amazon S3 bucket prefix that is the file name and path of the exported snapshot.</p>
    public let s3Prefix: String?
    /// <p>The time that the snapshot was created.</p>
    public let snapshotTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.</p>
    public let sourceArn: String?
    /// <p>The progress status of the export task.</p>
    public let status: String?
    /// <p>The time that the snapshot export task completed.</p>
    public let taskEndTime: Date?
    /// <p>The time that the snapshot export task started.</p>
    public let taskStartTime: Date?
    /// <p>The total amount of data exported, in gigabytes.</p>
    public let totalExtractedDataInGB: Int
    /// <p>A warning about the snapshot export task.</p>
    public let warningMessage: String?

    public init (
        exportOnly: [String]? = nil,
        exportTaskIdentifier: String? = nil,
        failureCause: String? = nil,
        iamRoleArn: String? = nil,
        kmsKeyId: String? = nil,
        percentProgress: Int = 0,
        s3Bucket: String? = nil,
        s3Prefix: String? = nil,
        snapshotTime: Date? = nil,
        sourceArn: String? = nil,
        status: String? = nil,
        taskEndTime: Date? = nil,
        taskStartTime: Date? = nil,
        totalExtractedDataInGB: Int = 0,
        warningMessage: String? = nil
    )
    {
        self.exportOnly = exportOnly
        self.exportTaskIdentifier = exportTaskIdentifier
        self.failureCause = failureCause
        self.iamRoleArn = iamRoleArn
        self.kmsKeyId = kmsKeyId
        self.percentProgress = percentProgress
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
        self.snapshotTime = snapshotTime
        self.sourceArn = sourceArn
        self.status = status
        self.taskEndTime = taskEndTime
        self.taskStartTime = taskStartTime
        self.totalExtractedDataInGB = totalExtractedDataInGB
        self.warningMessage = warningMessage
    }
}

struct StartExportTaskOutputResponseBody: Equatable {
    public let exportTaskIdentifier: String?
    public let sourceArn: String?
    public let exportOnly: [String]?
    public let snapshotTime: Date?
    public let taskStartTime: Date?
    public let taskEndTime: Date?
    public let s3Bucket: String?
    public let s3Prefix: String?
    public let iamRoleArn: String?
    public let kmsKeyId: String?
    public let status: String?
    public let percentProgress: Int
    public let totalExtractedDataInGB: Int
    public let failureCause: String?
    public let warningMessage: String?
}

extension StartExportTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportOnly = "ExportOnly"
        case exportTaskIdentifier = "ExportTaskIdentifier"
        case failureCause = "FailureCause"
        case iamRoleArn = "IamRoleArn"
        case kmsKeyId = "KmsKeyId"
        case percentProgress = "PercentProgress"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case snapshotTime = "SnapshotTime"
        case sourceArn = "SourceArn"
        case status = "Status"
        case taskEndTime = "TaskEndTime"
        case taskStartTime = "TaskStartTime"
        case totalExtractedDataInGB = "TotalExtractedDataInGB"
        case warningMessage = "WarningMessage"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("StartExportTaskResult"))
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        if containerValues.contains(.exportOnly) {
            struct KeyVal0{struct member{}}
            let exportOnlyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportOnly)
            if let exportOnlyWrappedContainer = exportOnlyWrappedContainer {
                let exportOnlyContainer = try exportOnlyWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var exportOnlyBuffer:[String]? = nil
                if let exportOnlyContainer = exportOnlyContainer {
                    exportOnlyBuffer = [String]()
                    for stringContainer0 in exportOnlyContainer {
                        exportOnlyBuffer?.append(stringContainer0)
                    }
                }
                exportOnly = exportOnlyBuffer
            } else {
                exportOnly = []
            }
        } else {
            exportOnly = nil
        }
        let snapshotTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotTime)
        var snapshotTimeBuffer:Date? = nil
        if let snapshotTimeDecoded = snapshotTimeDecoded {
            snapshotTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(snapshotTimeDecoded, format: .dateTime)
        }
        snapshotTime = snapshotTimeBuffer
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskStartTime)
        var taskStartTimeBuffer:Date? = nil
        if let taskStartTimeDecoded = taskStartTimeDecoded {
            taskStartTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(taskStartTimeDecoded, format: .dateTime)
        }
        taskStartTime = taskStartTimeBuffer
        let taskEndTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskEndTime)
        var taskEndTimeBuffer:Date? = nil
        if let taskEndTimeDecoded = taskEndTimeDecoded {
            taskEndTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(taskEndTimeDecoded, format: .dateTime)
        }
        taskEndTime = taskEndTimeBuffer
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decode(Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let totalExtractedDataInGBDecoded = try containerValues.decode(Int.self, forKey: .totalExtractedDataInGB)
        totalExtractedDataInGB = totalExtractedDataInGBDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
        let warningMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .warningMessage)
        warningMessage = warningMessageDecoded
    }
}

public struct StopActivityStreamInputBodyMiddleware: Middleware {
    public let id: String = "StopActivityStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopActivityStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<StopActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopActivityStreamInput>
    public typealias MOutput = OperationOutput<StopActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopActivityStreamOutputError>
}

extension StopActivityStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopActivityStreamInput(applyImmediately: \(String(describing: applyImmediately)), resourceArn: \(String(describing: resourceArn)))"}
}

extension StopActivityStreamInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applyImmediately = applyImmediately {
            try container.encode(applyImmediately, forKey: Key("ApplyImmediately"))
        }
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: Key("ResourceArn"))
        }
        try container.encode("StopActivityStream", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct StopActivityStreamInputHeadersMiddleware: Middleware {
    public let id: String = "StopActivityStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopActivityStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<StopActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopActivityStreamInput>
    public typealias MOutput = OperationOutput<StopActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopActivityStreamOutputError>
}

public struct StopActivityStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "StopActivityStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopActivityStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<StopActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopActivityStreamInput>
    public typealias MOutput = OperationOutput<StopActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopActivityStreamOutputError>
}

public struct StopActivityStreamInput: Equatable {
    /// <p>Specifies whether or not the database activity stream is to stop as soon as possible,
    ///             regardless of the maintenance window for the database.</p>
    public let applyImmediately: Bool?
    /// <p>The Amazon Resource Name (ARN) of the DB cluster for the database activity stream.
    ///             For example, <code>arn:aws:rds:us-east-1:12345667890:cluster:das-cluster</code>.
    ///         </p>
    public let resourceArn: String?

    public init (
        applyImmediately: Bool? = nil,
        resourceArn: String? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.resourceArn = resourceArn
    }
}

extension StopActivityStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopActivityStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopActivityStreamOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopActivityStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopActivityStreamOutputResponse(kinesisStreamName: \(String(describing: kinesisStreamName)), kmsKeyId: \(String(describing: kmsKeyId)), status: \(String(describing: status)))"}
}

extension StopActivityStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopActivityStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.kinesisStreamName = output.kinesisStreamName
            self.kmsKeyId = output.kmsKeyId
            self.status = output.status
        } else {
            self.kinesisStreamName = nil
            self.kmsKeyId = nil
            self.status = nil
        }
    }
}

public struct StopActivityStreamOutputResponse: Equatable {
    /// <p>The name of the Amazon Kinesis data stream used for the database activity stream.</p>
    public let kinesisStreamName: String?
    /// <p>The AWS KMS key identifier used for encrypting messages in the database activity stream.</p>
    ///         <p>The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the AWS KMS customer master key (CMK).</p>
    public let kmsKeyId: String?
    /// <p>The status of the database activity stream.</p>
    public let status: ActivityStreamStatus?

    public init (
        kinesisStreamName: String? = nil,
        kmsKeyId: String? = nil,
        status: ActivityStreamStatus? = nil
    )
    {
        self.kinesisStreamName = kinesisStreamName
        self.kmsKeyId = kmsKeyId
        self.status = status
    }
}

struct StopActivityStreamOutputResponseBody: Equatable {
    public let kmsKeyId: String?
    public let kinesisStreamName: String?
    public let status: ActivityStreamStatus?
}

extension StopActivityStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case kinesisStreamName = "KinesisStreamName"
        case kmsKeyId = "KmsKeyId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("StopActivityStreamResult"))
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let kinesisStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kinesisStreamName)
        kinesisStreamName = kinesisStreamNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ActivityStreamStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct StopDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "StopDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBClusterOutputError>
}

extension StopDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)))"}
}

extension StopDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        try container.encode("StopDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct StopDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "StopDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBClusterOutputError>
}

public struct StopDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "StopDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBClusterOutputError>
}

public struct StopDBClusterInput: Equatable {
    /// <p>The DB cluster identifier of the Amazon Aurora DB cluster to be stopped. This parameter is stored as
    ///         a lowercase string.</p>
    public let dBClusterIdentifier: String?

    public init (
        dBClusterIdentifier: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension StopDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension StopDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct StopDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Aurora DB cluster.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBClusters</code>,
    ///         <code>StopDBCluster</code>, and <code>StartDBCluster</code> actions.
    ///       </p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct StopDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension StopDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("StopDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct StopDBInstanceAutomatedBackupsReplicationInputBodyMiddleware: Middleware {
    public let id: String = "StopDBInstanceAutomatedBackupsReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBInstanceAutomatedBackupsReplicationOutputError>
}

extension StopDBInstanceAutomatedBackupsReplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDBInstanceAutomatedBackupsReplicationInput(sourceDBInstanceArn: \(String(describing: sourceDBInstanceArn)))"}
}

extension StopDBInstanceAutomatedBackupsReplicationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceDBInstanceArn = sourceDBInstanceArn {
            try container.encode(sourceDBInstanceArn, forKey: Key("SourceDBInstanceArn"))
        }
        try container.encode("StopDBInstanceAutomatedBackupsReplication", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct StopDBInstanceAutomatedBackupsReplicationInputHeadersMiddleware: Middleware {
    public let id: String = "StopDBInstanceAutomatedBackupsReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBInstanceAutomatedBackupsReplicationOutputError>
}

public struct StopDBInstanceAutomatedBackupsReplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "StopDBInstanceAutomatedBackupsReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBInstanceAutomatedBackupsReplicationOutputError>
}

public struct StopDBInstanceAutomatedBackupsReplicationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the source DB instance for which to stop replicating automated backups, for example,
    ///             <code>arn:aws:rds:us-west-2:123456789012:db:mydatabase</code>.</p>
    public let sourceDBInstanceArn: String?

    public init (
        sourceDBInstanceArn: String? = nil
    )
    {
        self.sourceDBInstanceArn = sourceDBInstanceArn
    }
}

extension StopDBInstanceAutomatedBackupsReplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopDBInstanceAutomatedBackupsReplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDBInstanceAutomatedBackupsReplicationOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDBInstanceAutomatedBackupsReplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDBInstanceAutomatedBackupsReplicationOutputResponse(dBInstanceAutomatedBackup: \(String(describing: dBInstanceAutomatedBackup)))"}
}

extension StopDBInstanceAutomatedBackupsReplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopDBInstanceAutomatedBackupsReplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstanceAutomatedBackup = output.dBInstanceAutomatedBackup
        } else {
            self.dBInstanceAutomatedBackup = nil
        }
    }
}

public struct StopDBInstanceAutomatedBackupsReplicationOutputResponse: Equatable {
    /// <p>An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that
    ///             existed at the time you deleted the source instance.</p>
    public let dBInstanceAutomatedBackup: DBInstanceAutomatedBackup?

    public init (
        dBInstanceAutomatedBackup: DBInstanceAutomatedBackup? = nil
    )
    {
        self.dBInstanceAutomatedBackup = dBInstanceAutomatedBackup
    }
}

struct StopDBInstanceAutomatedBackupsReplicationOutputResponseBody: Equatable {
    public let dBInstanceAutomatedBackup: DBInstanceAutomatedBackup?
}

extension StopDBInstanceAutomatedBackupsReplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("StopDBInstanceAutomatedBackupsReplicationResult"))
        let dBInstanceAutomatedBackupDecoded = try containerValues.decodeIfPresent(DBInstanceAutomatedBackup.self, forKey: .dBInstanceAutomatedBackup)
        dBInstanceAutomatedBackup = dBInstanceAutomatedBackupDecoded
    }
}

public struct StopDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "StopDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBInstanceInput>
    public typealias MOutput = OperationOutput<StopDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBInstanceOutputError>
}

extension StopDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDBInstanceInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBSnapshotIdentifier: \(String(describing: dBSnapshotIdentifier)))"}
}

extension StopDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: Key("DBSnapshotIdentifier"))
        }
        try container.encode("StopDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct StopDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "StopDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBInstanceInput>
    public typealias MOutput = OperationOutput<StopDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBInstanceOutputError>
}

public struct StopDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "StopDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBInstanceInput>
    public typealias MOutput = OperationOutput<StopDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBInstanceOutputError>
}

public struct StopDBInstanceInput: Equatable {
    /// <p>
    ///             The user-supplied instance identifier.
    ///         </p>
    public let dBInstanceIdentifier: String?
    /// <p>
    ///             The user-supplied instance identifier of the DB Snapshot created immediately before the DB instance is stopped.
    ///         </p>
    public let dBSnapshotIdentifier: String?

    public init (
        dBInstanceIdentifier: String? = nil,
        dBSnapshotIdentifier: String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
    }
}

extension StopDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExistsFault" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDBInstanceOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDBInstanceOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension StopDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct StopDBInstanceOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon RDS DB instance.
    ///       </p>
    ///          <p>This data type is used as a response element in the <code>DescribeDBInstances</code> action.
    ///       </p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct StopDBInstanceOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension StopDBInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("StopDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension StorageQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageQuotaExceededFault(message: \(String(describing: message)))"}
}

extension StorageQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<StorageQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request would result in the user exceeding the allowed amount of storage
///             available across all DB instances.</p>
public struct StorageQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StorageQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension StorageQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StorageTypeNotSupportedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageTypeNotSupportedFault(message: \(String(describing: message)))"}
}

extension StorageTypeNotSupportedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<StorageTypeNotSupportedFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Storage of the <code>StorageType</code> specified can't be associated
///             with the DB instance. </p>
public struct StorageTypeNotSupportedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StorageTypeNotSupportedFaultBody: Equatable {
    public let message: String?
}

extension StorageTypeNotSupportedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Subnet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetOutpost = "SubnetOutpost"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try container.encode(subnetAvailabilityZone, forKey: Key("SubnetAvailabilityZone"))
        }
        if let subnetIdentifier = subnetIdentifier {
            try container.encode(subnetIdentifier, forKey: Key("SubnetIdentifier"))
        }
        if let subnetOutpost = subnetOutpost {
            try container.encode(subnetOutpost, forKey: Key("SubnetOutpost"))
        }
        if let subnetStatus = subnetStatus {
            try container.encode(subnetStatus, forKey: Key("SubnetStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(AvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetOutpostDecoded = try containerValues.decodeIfPresent(Outpost.self, forKey: .subnetOutpost)
        subnetOutpost = subnetOutpostDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension Subnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subnet(subnetAvailabilityZone: \(String(describing: subnetAvailabilityZone)), subnetIdentifier: \(String(describing: subnetIdentifier)), subnetOutpost: \(String(describing: subnetOutpost)), subnetStatus: \(String(describing: subnetStatus)))"}
}

/// <p>
///         This data type is used as a response element for the <code>DescribeDBSubnetGroups</code> operation.
///         </p>
public struct Subnet: Equatable {
    /// <p>Contains Availability Zone information.</p>
    ///         <p> This data type is used as an element in the <code>OrderableDBInstanceOption</code>
    ///             data type.</p>
    public let subnetAvailabilityZone: AvailabilityZone?
    /// <p>The identifier of the subnet.</p>
    public let subnetIdentifier: String?
    /// <p>If the subnet is associated with an Outpost, this value specifies the Outpost.</p>
    ///         <p>For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Amazon RDS on AWS Outposts</a>
    ///             in the <i>Amazon RDS User Guide.</i>
    ///          </p>
    public let subnetOutpost: Outpost?
    /// <p>The status of the subnet.</p>
    public let subnetStatus: String?

    public init (
        subnetAvailabilityZone: AvailabilityZone? = nil,
        subnetIdentifier: String? = nil,
        subnetOutpost: Outpost? = nil,
        subnetStatus: String? = nil
    )
    {
        self.subnetAvailabilityZone = subnetAvailabilityZone
        self.subnetIdentifier = subnetIdentifier
        self.subnetOutpost = subnetOutpost
        self.subnetStatus = subnetStatus
    }
}

extension SubnetAlreadyInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetAlreadyInUse(message: \(String(describing: message)))"}
}

extension SubnetAlreadyInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubnetAlreadyInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB subnet is already in use in the Availability Zone.</p>
public struct SubnetAlreadyInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetAlreadyInUseBody: Equatable {
    public let message: String?
}

extension SubnetAlreadyInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionAlreadyExistFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionAlreadyExistFault(message: \(String(describing: message)))"}
}

extension SubscriptionAlreadyExistFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionAlreadyExistFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The supplied subscription name already exists.</p>
public struct SubscriptionAlreadyExistFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionAlreadyExistFaultBody: Equatable {
    public let message: String?
}

extension SubscriptionAlreadyExistFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionCategoryNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionCategoryNotFoundFault(message: \(String(describing: message)))"}
}

extension SubscriptionCategoryNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionCategoryNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The supplied category does not exist.</p>
public struct SubscriptionCategoryNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionCategoryNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SubscriptionCategoryNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionNotFoundFault(message: \(String(describing: message)))"}
}

extension SubscriptionNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The subscription name does not exist.</p>
public struct SubscriptionNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SubscriptionNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Metadata assigned to an Amazon RDS resource consisting of a key-value pair.</p>
public struct Tag: Equatable {
    /// <p>A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and can't be prefixed with "aws:" or "rds:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").</p>
    public let key: String?
    /// <p>A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and can't be prefixed with "aws:" or "rds:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TargetHealth: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case reason = "Reason"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let reason = reason {
            try container.encode(reason, forKey: Key("Reason"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(TargetState.self, forKey: .state)
        state = stateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(TargetHealthReason.self, forKey: .reason)
        reason = reasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension TargetHealth: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetHealth(description: \(String(describing: description)), reason: \(String(describing: reason)), state: \(String(describing: state)))"}
}

/// <p>Information about the connection health of an RDS Proxy target.</p>
public struct TargetHealth: Equatable {
    /// <p>A description of the health of the RDS Proxy target.
    ///             If the <code>State</code> is <code>AVAILABLE</code>, a description is not included.</p>
    public let description: String?
    /// <p>The reason for the current health <code>State</code> of the RDS Proxy target.</p>
    public let reason: TargetHealthReason?
    /// <p>The current state of the connection health lifecycle for the RDS Proxy target.
    ///            The following is a typical lifecycle example for the states of an RDS Proxy target:
    ///        </p>
    ///          <p>
    ///             <code>registering</code> > <code>unavailable</code> > <code>available</code> > <code>unavailable</code> > <code>available</code>
    ///          </p>
    public let state: TargetState?

    public init (
        description: String? = nil,
        reason: TargetHealthReason? = nil,
        state: TargetState? = nil
    )
    {
        self.description = description
        self.reason = reason
        self.state = state
    }
}

public enum TargetHealthReason {
    case authFailure
    case connectionFailed
    case invalidReplicationState
    case pendingProxyCapacity
    case unreachable
    case sdkUnknown(String)
}

extension TargetHealthReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetHealthReason] {
        return [
            .authFailure,
            .connectionFailed,
            .invalidReplicationState,
            .pendingProxyCapacity,
            .unreachable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authFailure: return "AUTH_FAILURE"
        case .connectionFailed: return "CONNECTION_FAILED"
        case .invalidReplicationState: return "INVALID_REPLICATION_STATE"
        case .pendingProxyCapacity: return "PENDING_PROXY_CAPACITY"
        case .unreachable: return "UNREACHABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetHealthReason(rawValue: rawValue) ?? TargetHealthReason.sdkUnknown(rawValue)
    }
}

public enum TargetRole {
    case readOnly
    case readWrite
    case unknown
    case sdkUnknown(String)
}

extension TargetRole : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetRole] {
        return [
            .readOnly,
            .readWrite,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .readOnly: return "READ_ONLY"
        case .readWrite: return "READ_WRITE"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetRole(rawValue: rawValue) ?? TargetRole.sdkUnknown(rawValue)
    }
}

public enum TargetState {
    case available
    case registering
    case unavailable
    case sdkUnknown(String)
}

extension TargetState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetState] {
        return [
            .available,
            .registering,
            .unavailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .registering: return "REGISTERING"
        case .unavailable: return "UNAVAILABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetState(rawValue: rawValue) ?? TargetState.sdkUnknown(rawValue)
    }
}

public enum TargetType {
    case rdsInstance
    case rdsServerlessEndpoint
    case trackedCluster
    case sdkUnknown(String)
}

extension TargetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetType] {
        return [
            .rdsInstance,
            .rdsServerlessEndpoint,
            .trackedCluster,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rdsInstance: return "RDS_INSTANCE"
        case .rdsServerlessEndpoint: return "RDS_SERVERLESS_ENDPOINT"
        case .trackedCluster: return "TRACKED_CLUSTER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
    }
}

extension Timezone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timezoneName = "TimezoneName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let timezoneName = timezoneName {
            try container.encode(timezoneName, forKey: Key("TimezoneName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timezoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezoneName)
        timezoneName = timezoneNameDecoded
    }
}

extension Timezone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Timezone(timezoneName: \(String(describing: timezoneName)))"}
}

/// <p>A time zone associated with a
///             <code>DBInstance</code>
///             or a <code>DBSnapshot</code>.
///             This data type is an element in the response to
///             the <code>DescribeDBInstances</code>,
///             the <code>DescribeDBSnapshots</code>,
///             and the <code>DescribeDBEngineVersions</code>
///             actions.
///         </p>
public struct Timezone: Equatable {
    /// <p>The name of the time zone.</p>
    public let timezoneName: String?

    public init (
        timezoneName: String? = nil
    )
    {
        self.timezoneName = timezoneName
    }
}

extension UpgradeTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoUpgrade = "AutoUpgrade"
        case description = "Description"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case isMajorVersionUpgrade = "IsMajorVersionUpgrade"
        case supportedEngineModes = "SupportedEngineModes"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsParallelQuery = "SupportsParallelQuery"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if autoUpgrade != false {
            try container.encode(autoUpgrade, forKey: Key("AutoUpgrade"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if isMajorVersionUpgrade != false {
            try container.encode(isMajorVersionUpgrade, forKey: Key("IsMajorVersionUpgrade"))
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportsGlobalDatabases = supportsGlobalDatabases {
            try container.encode(supportsGlobalDatabases, forKey: Key("SupportsGlobalDatabases"))
        }
        if let supportsParallelQuery = supportsParallelQuery {
            try container.encode(supportsParallelQuery, forKey: Key("SupportsParallelQuery"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let autoUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoUpgrade)
        autoUpgrade = autoUpgradeDecoded
        let isMajorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .isMajorVersionUpgrade)
        isMajorVersionUpgrade = isMajorVersionUpgradeDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var supportedEngineModesBuffer:[String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        let supportsParallelQueryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .supportsParallelQuery)
        supportsParallelQuery = supportsParallelQueryDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
    }
}

extension UpgradeTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpgradeTarget(autoUpgrade: \(String(describing: autoUpgrade)), description: \(String(describing: description)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), isMajorVersionUpgrade: \(String(describing: isMajorVersionUpgrade)), supportedEngineModes: \(String(describing: supportedEngineModes)), supportsGlobalDatabases: \(String(describing: supportsGlobalDatabases)), supportsParallelQuery: \(String(describing: supportsParallelQuery)))"}
}

/// <p>The version of the database engine that a DB instance can be upgraded to.</p>
public struct UpgradeTarget: Equatable {
    /// <p>A value that indicates whether the target version is applied to any source DB instances that have <code>AutoMinorVersionUpgrade</code> set to true.</p>
    public let autoUpgrade: Bool
    /// <p>The version of the database engine that a DB instance can be upgraded to.</p>
    public let description: String?
    /// <p>The name of the upgrade target database engine.</p>
    public let engine: String?
    /// <p>The version number of the upgrade target database engine.</p>
    public let engineVersion: String?
    /// <p>A value that indicates whether upgrading to the target version requires upgrading the major version of the database engine.</p>
    public let isMajorVersionUpgrade: Bool
    /// <p>A list of the supported DB engine modes for the target engine version.</p>
    public let supportedEngineModes: [String]?
    /// <p>A value that indicates whether you can use Aurora global databases with the target engine version.</p>
    public let supportsGlobalDatabases: Bool?
    /// <p>A value that indicates whether you can use Aurora parallel query with the target engine version.</p>
    public let supportsParallelQuery: Bool?

    public init (
        autoUpgrade: Bool = false,
        description: String? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        isMajorVersionUpgrade: Bool = false,
        supportedEngineModes: [String]? = nil,
        supportsGlobalDatabases: Bool? = nil,
        supportsParallelQuery: Bool? = nil
    )
    {
        self.autoUpgrade = autoUpgrade
        self.description = description
        self.engine = engine
        self.engineVersion = engineVersion
        self.isMajorVersionUpgrade = isMajorVersionUpgrade
        self.supportedEngineModes = supportedEngineModes
        self.supportsGlobalDatabases = supportsGlobalDatabases
        self.supportsParallelQuery = supportsParallelQuery
    }
}

extension UserAuthConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authScheme = "AuthScheme"
        case description = "Description"
        case iAMAuth = "IAMAuth"
        case secretArn = "SecretArn"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let authScheme = authScheme {
            try container.encode(authScheme, forKey: Key("AuthScheme"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let iAMAuth = iAMAuth {
            try container.encode(iAMAuth, forKey: Key("IAMAuth"))
        }
        if let secretArn = secretArn {
            try container.encode(secretArn, forKey: Key("SecretArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let authSchemeDecoded = try containerValues.decodeIfPresent(AuthScheme.self, forKey: .authScheme)
        authScheme = authSchemeDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let iAMAuthDecoded = try containerValues.decodeIfPresent(IAMAuthMode.self, forKey: .iAMAuth)
        iAMAuth = iAMAuthDecoded
    }
}

extension UserAuthConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserAuthConfig(authScheme: \(String(describing: authScheme)), description: \(String(describing: description)), iAMAuth: \(String(describing: iAMAuth)), secretArn: \(String(describing: secretArn)), userName: \(String(describing: userName)))"}
}

/// <p>Specifies the details of authentication used by a proxy to log in as a specific database user.</p>
public struct UserAuthConfig: Equatable {
    /// <p>The type of authentication that the proxy uses for connections from the proxy to the underlying database.</p>
    public let authScheme: AuthScheme?
    /// <p>A user-specified description about the authentication used by a proxy to log in as a specific database user.</p>
    public let description: String?
    /// <p>Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy.</p>
    public let iAMAuth: IAMAuthMode?
    /// <p>The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate
    ///         to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.</p>
    public let secretArn: String?
    /// <p>The name of the database user to which the proxy connects.</p>
    public let userName: String?

    public init (
        authScheme: AuthScheme? = nil,
        description: String? = nil,
        iAMAuth: IAMAuthMode? = nil,
        secretArn: String? = nil,
        userName: String? = nil
    )
    {
        self.authScheme = authScheme
        self.description = description
        self.iAMAuth = iAMAuth
        self.secretArn = secretArn
        self.userName = userName
    }
}

extension UserAuthConfigInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authScheme = "AuthScheme"
        case description = "Description"
        case iAMAuth = "IAMAuth"
        case secretArn = "SecretArn"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let authScheme = authScheme {
            try container.encode(authScheme, forKey: Key("AuthScheme"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let iAMAuth = iAMAuth {
            try container.encode(iAMAuth, forKey: Key("IAMAuth"))
        }
        if let secretArn = secretArn {
            try container.encode(secretArn, forKey: Key("SecretArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: Key("UserName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let authSchemeDecoded = try containerValues.decodeIfPresent(AuthScheme.self, forKey: .authScheme)
        authScheme = authSchemeDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let iAMAuthDecoded = try containerValues.decodeIfPresent(IAMAuthMode.self, forKey: .iAMAuth)
        iAMAuth = iAMAuthDecoded
    }
}

extension UserAuthConfigInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserAuthConfigInfo(authScheme: \(String(describing: authScheme)), description: \(String(describing: description)), iAMAuth: \(String(describing: iAMAuth)), secretArn: \(String(describing: secretArn)), userName: \(String(describing: userName)))"}
}

/// <p>Returns the details of authentication used by a proxy to log in as a specific database user.</p>
public struct UserAuthConfigInfo: Equatable {
    /// <p>The type of authentication that the proxy uses for connections from the proxy to the underlying database.</p>
    public let authScheme: AuthScheme?
    /// <p>A user-specified description about the authentication used by a proxy to log in as a specific database user.</p>
    public let description: String?
    /// <p>Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy.</p>
    public let iAMAuth: IAMAuthMode?
    /// <p>The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate
    ///         to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.</p>
    public let secretArn: String?
    /// <p>The name of the database user to which the proxy connects.</p>
    public let userName: String?

    public init (
        authScheme: AuthScheme? = nil,
        description: String? = nil,
        iAMAuth: IAMAuthMode? = nil,
        secretArn: String? = nil,
        userName: String? = nil
    )
    {
        self.authScheme = authScheme
        self.description = description
        self.iAMAuth = iAMAuth
        self.secretArn = secretArn
        self.userName = userName
    }
}

extension ValidDBInstanceModificationsMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case storage = "Storage"
        case validProcessorFeatures = "ValidProcessorFeatures"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let storage = storage {
            var storageContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Storage"))
            for (index0, validstorageoptions0) in storage.enumerated() {
                try storageContainer.encode(validstorageoptions0, forKey: Key("ValidStorageOptions.\(index0.advanced(by: 1))"))
            }
        }
        if let validProcessorFeatures = validProcessorFeatures {
            var validProcessorFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValidProcessorFeatures"))
            for (index0, availableprocessorfeature0) in validProcessorFeatures.enumerated() {
                try validProcessorFeaturesContainer.encode(availableprocessorfeature0, forKey: Key("AvailableProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.storage) {
            struct KeyVal0{struct ValidStorageOptions{}}
            let storageWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ValidStorageOptions>.CodingKeys.self, forKey: .storage)
            if let storageWrappedContainer = storageWrappedContainer {
                let storageContainer = try storageWrappedContainer.decodeIfPresent([ValidStorageOptions].self, forKey: .member)
                var storageBuffer:[ValidStorageOptions]? = nil
                if let storageContainer = storageContainer {
                    storageBuffer = [ValidStorageOptions]()
                    for structureContainer0 in storageContainer {
                        storageBuffer?.append(structureContainer0)
                    }
                }
                storage = storageBuffer
            } else {
                storage = []
            }
        } else {
            storage = nil
        }
        if containerValues.contains(.validProcessorFeatures) {
            struct KeyVal0{struct AvailableProcessorFeature{}}
            let validProcessorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailableProcessorFeature>.CodingKeys.self, forKey: .validProcessorFeatures)
            if let validProcessorFeaturesWrappedContainer = validProcessorFeaturesWrappedContainer {
                let validProcessorFeaturesContainer = try validProcessorFeaturesWrappedContainer.decodeIfPresent([AvailableProcessorFeature].self, forKey: .member)
                var validProcessorFeaturesBuffer:[AvailableProcessorFeature]? = nil
                if let validProcessorFeaturesContainer = validProcessorFeaturesContainer {
                    validProcessorFeaturesBuffer = [AvailableProcessorFeature]()
                    for structureContainer0 in validProcessorFeaturesContainer {
                        validProcessorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                validProcessorFeatures = validProcessorFeaturesBuffer
            } else {
                validProcessorFeatures = []
            }
        } else {
            validProcessorFeatures = nil
        }
    }
}

extension ValidDBInstanceModificationsMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidDBInstanceModificationsMessage(storage: \(String(describing: storage)), validProcessorFeatures: \(String(describing: validProcessorFeatures)))"}
}

/// <p>Information about valid modifications that you can make to your DB instance.
///             Contains the result of a successful call to the
///             <code>DescribeValidDBInstanceModifications</code> action.
///             You can use this information when you call
///             <code>ModifyDBInstance</code>.
///         </p>
public struct ValidDBInstanceModificationsMessage: Equatable {
    /// <p>Valid storage options for your DB instance.
    ///         </p>
    public let storage: [ValidStorageOptions]?
    /// <p>Valid processor features for your DB instance.
    ///         </p>
    public let validProcessorFeatures: [AvailableProcessorFeature]?

    public init (
        storage: [ValidStorageOptions]? = nil,
        validProcessorFeatures: [AvailableProcessorFeature]? = nil
    )
    {
        self.storage = storage
        self.validProcessorFeatures = validProcessorFeatures
    }
}

extension ValidStorageOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iopsToStorageRatio = "IopsToStorageRatio"
        case provisionedIops = "ProvisionedIops"
        case storageSize = "StorageSize"
        case storageType = "StorageType"
        case supportsStorageAutoscaling = "SupportsStorageAutoscaling"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let iopsToStorageRatio = iopsToStorageRatio {
            var iopsToStorageRatioContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("IopsToStorageRatio"))
            for (index0, doublerange0) in iopsToStorageRatio.enumerated() {
                try iopsToStorageRatioContainer.encode(doublerange0, forKey: Key("DoubleRange.\(index0.advanced(by: 1))"))
            }
        }
        if let provisionedIops = provisionedIops {
            var provisionedIopsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProvisionedIops"))
            for (index0, range0) in provisionedIops.enumerated() {
                try provisionedIopsContainer.encode(range0, forKey: Key("Range.\(index0.advanced(by: 1))"))
            }
        }
        if let storageSize = storageSize {
            var storageSizeContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StorageSize"))
            for (index0, range0) in storageSize.enumerated() {
                try storageSizeContainer.encode(range0, forKey: Key("Range.\(index0.advanced(by: 1))"))
            }
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if supportsStorageAutoscaling != false {
            try container.encode(supportsStorageAutoscaling, forKey: Key("SupportsStorageAutoscaling"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        if containerValues.contains(.storageSize) {
            struct KeyVal0{struct Range{}}
            let storageSizeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Range>.CodingKeys.self, forKey: .storageSize)
            if let storageSizeWrappedContainer = storageSizeWrappedContainer {
                let storageSizeContainer = try storageSizeWrappedContainer.decodeIfPresent([Range].self, forKey: .member)
                var storageSizeBuffer:[Range]? = nil
                if let storageSizeContainer = storageSizeContainer {
                    storageSizeBuffer = [Range]()
                    for structureContainer0 in storageSizeContainer {
                        storageSizeBuffer?.append(structureContainer0)
                    }
                }
                storageSize = storageSizeBuffer
            } else {
                storageSize = []
            }
        } else {
            storageSize = nil
        }
        if containerValues.contains(.provisionedIops) {
            struct KeyVal0{struct Range{}}
            let provisionedIopsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Range>.CodingKeys.self, forKey: .provisionedIops)
            if let provisionedIopsWrappedContainer = provisionedIopsWrappedContainer {
                let provisionedIopsContainer = try provisionedIopsWrappedContainer.decodeIfPresent([Range].self, forKey: .member)
                var provisionedIopsBuffer:[Range]? = nil
                if let provisionedIopsContainer = provisionedIopsContainer {
                    provisionedIopsBuffer = [Range]()
                    for structureContainer0 in provisionedIopsContainer {
                        provisionedIopsBuffer?.append(structureContainer0)
                    }
                }
                provisionedIops = provisionedIopsBuffer
            } else {
                provisionedIops = []
            }
        } else {
            provisionedIops = nil
        }
        if containerValues.contains(.iopsToStorageRatio) {
            struct KeyVal0{struct DoubleRange{}}
            let iopsToStorageRatioWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DoubleRange>.CodingKeys.self, forKey: .iopsToStorageRatio)
            if let iopsToStorageRatioWrappedContainer = iopsToStorageRatioWrappedContainer {
                let iopsToStorageRatioContainer = try iopsToStorageRatioWrappedContainer.decodeIfPresent([DoubleRange].self, forKey: .member)
                var iopsToStorageRatioBuffer:[DoubleRange]? = nil
                if let iopsToStorageRatioContainer = iopsToStorageRatioContainer {
                    iopsToStorageRatioBuffer = [DoubleRange]()
                    for structureContainer0 in iopsToStorageRatioContainer {
                        iopsToStorageRatioBuffer?.append(structureContainer0)
                    }
                }
                iopsToStorageRatio = iopsToStorageRatioBuffer
            } else {
                iopsToStorageRatio = []
            }
        } else {
            iopsToStorageRatio = nil
        }
        let supportsStorageAutoscalingDecoded = try containerValues.decode(Bool.self, forKey: .supportsStorageAutoscaling)
        supportsStorageAutoscaling = supportsStorageAutoscalingDecoded
    }
}

extension ValidStorageOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidStorageOptions(iopsToStorageRatio: \(String(describing: iopsToStorageRatio)), provisionedIops: \(String(describing: provisionedIops)), storageSize: \(String(describing: storageSize)), storageType: \(String(describing: storageType)), supportsStorageAutoscaling: \(String(describing: supportsStorageAutoscaling)))"}
}

/// <p>Information about valid modifications that you can make to your DB instance.
///             Contains the result of a successful call to the
///             <code>DescribeValidDBInstanceModifications</code> action.
///         </p>
public struct ValidStorageOptions: Equatable {
    /// <p>The valid range of Provisioned IOPS to gibibytes of storage multiplier.
    ///             For example, 3-10,
    ///             which means that provisioned IOPS can be between 3 and 10 times storage.
    ///         </p>
    public let iopsToStorageRatio: [DoubleRange]?
    /// <p>The valid range of provisioned IOPS.
    ///             For example, 1000-20000.
    ///         </p>
    public let provisionedIops: [Range]?
    /// <p>The valid range of storage in gibibytes.
    ///             For example, 100 to 16384.
    ///         </p>
    public let storageSize: [Range]?
    /// <p>The valid storage types for your DB instance.
    ///             For example, gp2, io1.
    ///         </p>
    public let storageType: String?
    /// <p>Whether or not Amazon RDS can automatically scale storage for DB instances that use the new instance class.</p>
    public let supportsStorageAutoscaling: Bool

    public init (
        iopsToStorageRatio: [DoubleRange]? = nil,
        provisionedIops: [Range]? = nil,
        storageSize: [Range]? = nil,
        storageType: String? = nil,
        supportsStorageAutoscaling: Bool = false
    )
    {
        self.iopsToStorageRatio = iopsToStorageRatio
        self.provisionedIops = provisionedIops
        self.storageSize = storageSize
        self.storageType = storageType
        self.supportsStorageAutoscaling = supportsStorageAutoscaling
    }
}

extension VpcSecurityGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let vpcSecurityGroupId = vpcSecurityGroupId {
            try container.encode(vpcSecurityGroupId, forKey: Key("VpcSecurityGroupId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension VpcSecurityGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcSecurityGroupMembership(status: \(String(describing: status)), vpcSecurityGroupId: \(String(describing: vpcSecurityGroupId)))"}
}

/// <p>This data type is used as a response element for queries on VPC security group membership.</p>
public struct VpcSecurityGroupMembership: Equatable {
    /// <p>The status of the VPC security group.</p>
    public let status: String?
    /// <p>The name of the VPC security group.</p>
    public let vpcSecurityGroupId: String?

    public init (
        status: String? = nil,
        vpcSecurityGroupId: String? = nil
    )
    {
        self.status = status
        self.vpcSecurityGroupId = vpcSecurityGroupId
    }
}

extension VpnDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case vpnGatewayIp = "VpnGatewayIp"
        case vpnId = "VpnId"
        case vpnName = "VpnName"
        case vpnPSK = "VpnPSK"
        case vpnState = "VpnState"
        case vpnTunnelOriginatorIP = "VpnTunnelOriginatorIP"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let vpnGatewayIp = vpnGatewayIp {
            try container.encode(vpnGatewayIp, forKey: Key("VpnGatewayIp"))
        }
        if let vpnId = vpnId {
            try container.encode(vpnId, forKey: Key("VpnId"))
        }
        if let vpnName = vpnName {
            try container.encode(vpnName, forKey: Key("VpnName"))
        }
        if let vpnPSK = vpnPSK {
            try container.encode(vpnPSK, forKey: Key("VpnPSK"))
        }
        if let vpnState = vpnState {
            try container.encode(vpnState, forKey: Key("VpnState"))
        }
        if let vpnTunnelOriginatorIP = vpnTunnelOriginatorIP {
            try container.encode(vpnTunnelOriginatorIP, forKey: Key("VpnTunnelOriginatorIP"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpnIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpnId)
        vpnId = vpnIdDecoded
        let vpnTunnelOriginatorIPDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpnTunnelOriginatorIP)
        vpnTunnelOriginatorIP = vpnTunnelOriginatorIPDecoded
        let vpnGatewayIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpnGatewayIp)
        vpnGatewayIp = vpnGatewayIpDecoded
        let vpnPSKDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpnPSK)
        vpnPSK = vpnPSKDecoded
        let vpnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpnName)
        vpnName = vpnNameDecoded
        let vpnStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpnState)
        vpnState = vpnStateDecoded
    }
}

extension VpnDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpnDetails(vpnGatewayIp: \(String(describing: vpnGatewayIp)), vpnId: \(String(describing: vpnId)), vpnName: \(String(describing: vpnName)), vpnPSK: \(String(describing: vpnPSK)), vpnState: \(String(describing: vpnState)), vpnTunnelOriginatorIP: \(String(describing: vpnTunnelOriginatorIP)))"}
}

/// <p>Information about the virtual private network (VPN) between the VMware vSphere cluster and the AWS website.</p>
///         <p>For more information about RDS on VMware, see the
///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html">
///                 RDS on VMware User Guide.</a>
///          </p>
public struct VpnDetails: Equatable {
    /// <p>The IP address of network traffic from AWS to your on-premises data center.</p>
    public let vpnGatewayIp: String?
    /// <p>The ID of the VPN.</p>
    public let vpnId: String?
    /// <p>The name of the VPN.</p>
    public let vpnName: String?
    /// <p>The preshared key (PSK) for the VPN.</p>
    public let vpnPSK: String?
    /// <p>The state of the VPN.</p>
    public let vpnState: String?
    /// <p>The IP address of network traffic from your on-premises data center. A custom AZ receives the network traffic.</p>
    public let vpnTunnelOriginatorIP: String?

    public init (
        vpnGatewayIp: String? = nil,
        vpnId: String? = nil,
        vpnName: String? = nil,
        vpnPSK: String? = nil,
        vpnState: String? = nil,
        vpnTunnelOriginatorIP: String? = nil
    )
    {
        self.vpnGatewayIp = vpnGatewayIp
        self.vpnId = vpnId
        self.vpnName = vpnName
        self.vpnPSK = vpnPSK
        self.vpnState = vpnState
        self.vpnTunnelOriginatorIP = vpnTunnelOriginatorIP
    }
}

public enum WriteForwardingStatus {
    case disabled
    case disabling
    case enabled
    case enabling
    case unknown
    case sdkUnknown(String)
}

extension WriteForwardingStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WriteForwardingStatus] {
        return [
            .disabled,
            .disabling,
            .enabled,
            .enabling,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "disabled"
        case .disabling: return "disabling"
        case .enabled: return "enabled"
        case .enabling: return "enabling"
        case .unknown: return "unknown"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WriteForwardingStatus(rawValue: rawValue) ?? WriteForwardingStatus.sdkUnknown(rawValue)
    }
}
