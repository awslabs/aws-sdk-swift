// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AppflowClientTypes.AggregationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationType = aggregationType {
            try encodeContainer.encode(aggregationType.rawValue, forKey: .aggregationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
    }
}

extension AppflowClientTypes.AggregationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AggregationConfig(aggregationType: \(Swift.String(describing: aggregationType)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// The aggregation settings that you can use to customize the output format of your flow data.
    /// </p>
    public struct AggregationConfig: Swift.Equatable {
        /// <p>
        ///  Specifies whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated.
        /// </p>
        public let aggregationType: AppflowClientTypes.AggregationType?

        public init (
            aggregationType: AppflowClientTypes.AggregationType? = nil
        )
        {
            self.aggregationType = aggregationType
        }
    }

}

extension AppflowClientTypes {
    public enum AggregationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case singleFile
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationType] {
            return [
                .none,
                .singleFile,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .singleFile: return "SingleFile"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationType(rawValue: rawValue) ?? AggregationType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum AmplitudeConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case sdkUnknown(Swift.String)

        public static var allCases: [AmplitudeConnectorOperator] {
            return [
                .between,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AmplitudeConnectorOperator(rawValue: rawValue) ?? AmplitudeConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.AmplitudeConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
        case secretKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let secretKey = secretKey {
            try encodeContainer.encode(secretKey, forKey: .secretKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let secretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretKey)
        secretKey = secretKeyDecoded
    }
}

extension AppflowClientTypes.AmplitudeConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AmplitudeConnectorProfileCredentials(apiKey: \(Swift.String(describing: apiKey)), secretKey: \(Swift.String(describing: secretKey)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific credentials required when using Amplitude.
    /// </p>
    public struct AmplitudeConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// </p>
        public let apiKey: Swift.String?
        /// <p>
        ///   The Secret Access Key portion of the credentials.
        /// </p>
        public let secretKey: Swift.String?

        public init (
            apiKey: Swift.String? = nil,
            secretKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.secretKey = secretKey
        }
    }

}

extension AppflowClientTypes.AmplitudeConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.AmplitudeConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AmplitudeConnectorProfileProperties()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required when using Amplitude.
    /// </p>
    public struct AmplitudeConnectorProfileProperties: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.AmplitudeMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.AmplitudeMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AmplitudeMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Amplitude.
    /// </p>
    public struct AmplitudeMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.AmplitudeSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.AmplitudeSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AmplitudeSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Amplitude is being used as a source.
    /// </p>
    public struct AmplitudeSourceProperties: Swift.Equatable {
        /// <p>
        /// The object specified in the Amplitude flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///   There was a conflict when processing the request (for example, a flow with the given name already exists within the account. Check for conflicting resource names and try again.
/// </p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum ConnectionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionMode] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "Private"
            case .public: return "Public"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionMode(rawValue: rawValue) ?? ConnectionMode.sdkUnknown(rawValue)
        }
    }
}

extension ConnectorAuthenticationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorAuthenticationException(message: \(Swift.String(describing: message)))"}
}

extension ConnectorAuthenticationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConnectorAuthenticationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///  An error occurred when authenticating with the connector endpoint.
/// </p>
public struct ConnectorAuthenticationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectorAuthenticationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConnectorAuthenticationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes.ConnectorConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canUseAsDestination
        case canUseAsSource
        case connectorMetadata
        case isPrivateLinkEnabled
        case isPrivateLinkEndpointUrlRequired
        case supportedDestinationConnectors
        case supportedSchedulingFrequencies
        case supportedTriggerTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if canUseAsDestination != false {
            try encodeContainer.encode(canUseAsDestination, forKey: .canUseAsDestination)
        }
        if canUseAsSource != false {
            try encodeContainer.encode(canUseAsSource, forKey: .canUseAsSource)
        }
        if let connectorMetadata = connectorMetadata {
            try encodeContainer.encode(connectorMetadata, forKey: .connectorMetadata)
        }
        if isPrivateLinkEnabled != false {
            try encodeContainer.encode(isPrivateLinkEnabled, forKey: .isPrivateLinkEnabled)
        }
        if isPrivateLinkEndpointUrlRequired != false {
            try encodeContainer.encode(isPrivateLinkEndpointUrlRequired, forKey: .isPrivateLinkEndpointUrlRequired)
        }
        if let supportedDestinationConnectors = supportedDestinationConnectors {
            var supportedDestinationConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDestinationConnectors)
            for connectortypelist0 in supportedDestinationConnectors {
                try supportedDestinationConnectorsContainer.encode(connectortypelist0.rawValue)
            }
        }
        if let supportedSchedulingFrequencies = supportedSchedulingFrequencies {
            var supportedSchedulingFrequenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedSchedulingFrequencies)
            for schedulingfrequencytypelist0 in supportedSchedulingFrequencies {
                try supportedSchedulingFrequenciesContainer.encode(schedulingfrequencytypelist0.rawValue)
            }
        }
        if let supportedTriggerTypes = supportedTriggerTypes {
            var supportedTriggerTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedTriggerTypes)
            for triggertypelist0 in supportedTriggerTypes {
                try supportedTriggerTypesContainer.encode(triggertypelist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canUseAsSourceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .canUseAsSource)
        canUseAsSource = canUseAsSourceDecoded
        let canUseAsDestinationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .canUseAsDestination)
        canUseAsDestination = canUseAsDestinationDecoded
        let supportedDestinationConnectorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorType?].self, forKey: .supportedDestinationConnectors)
        var supportedDestinationConnectorsDecoded0:[AppflowClientTypes.ConnectorType]? = nil
        if let supportedDestinationConnectorsContainer = supportedDestinationConnectorsContainer {
            supportedDestinationConnectorsDecoded0 = [AppflowClientTypes.ConnectorType]()
            for string0 in supportedDestinationConnectorsContainer {
                if let string0 = string0 {
                    supportedDestinationConnectorsDecoded0?.append(string0)
                }
            }
        }
        supportedDestinationConnectors = supportedDestinationConnectorsDecoded0
        let supportedSchedulingFrequenciesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ScheduleFrequencyType?].self, forKey: .supportedSchedulingFrequencies)
        var supportedSchedulingFrequenciesDecoded0:[AppflowClientTypes.ScheduleFrequencyType]? = nil
        if let supportedSchedulingFrequenciesContainer = supportedSchedulingFrequenciesContainer {
            supportedSchedulingFrequenciesDecoded0 = [AppflowClientTypes.ScheduleFrequencyType]()
            for string0 in supportedSchedulingFrequenciesContainer {
                if let string0 = string0 {
                    supportedSchedulingFrequenciesDecoded0?.append(string0)
                }
            }
        }
        supportedSchedulingFrequencies = supportedSchedulingFrequenciesDecoded0
        let isPrivateLinkEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isPrivateLinkEnabled)
        isPrivateLinkEnabled = isPrivateLinkEnabledDecoded
        let isPrivateLinkEndpointUrlRequiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isPrivateLinkEndpointUrlRequired)
        isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequiredDecoded
        let supportedTriggerTypesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.TriggerType?].self, forKey: .supportedTriggerTypes)
        var supportedTriggerTypesDecoded0:[AppflowClientTypes.TriggerType]? = nil
        if let supportedTriggerTypesContainer = supportedTriggerTypesContainer {
            supportedTriggerTypesDecoded0 = [AppflowClientTypes.TriggerType]()
            for string0 in supportedTriggerTypesContainer {
                if let string0 = string0 {
                    supportedTriggerTypesDecoded0?.append(string0)
                }
            }
        }
        supportedTriggerTypes = supportedTriggerTypesDecoded0
        let connectorMetadataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorMetadata.self, forKey: .connectorMetadata)
        connectorMetadata = connectorMetadataDecoded
    }
}

extension AppflowClientTypes.ConnectorConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorConfiguration(canUseAsDestination: \(Swift.String(describing: canUseAsDestination)), canUseAsSource: \(Swift.String(describing: canUseAsSource)), connectorMetadata: \(Swift.String(describing: connectorMetadata)), isPrivateLinkEnabled: \(Swift.String(describing: isPrivateLinkEnabled)), isPrivateLinkEndpointUrlRequired: \(Swift.String(describing: isPrivateLinkEndpointUrlRequired)), supportedDestinationConnectors: \(Swift.String(describing: supportedDestinationConnectors)), supportedSchedulingFrequencies: \(Swift.String(describing: supportedSchedulingFrequencies)), supportedTriggerTypes: \(Swift.String(describing: supportedTriggerTypes)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// The configuration settings related to a given connector.
    /// </p>
    public struct ConnectorConfiguration: Swift.Equatable {
        /// <p>
        /// Specifies whether the connector can be used as a destination.
        /// </p>
        public let canUseAsDestination: Swift.Bool
        /// <p>
        ///   Specifies whether the connector can be used as a source.
        /// </p>
        public let canUseAsSource: Swift.Bool
        /// <p>
        /// Specifies connector-specific metadata such as <code>oAuthScopes</code>, <code>supportedRegions</code>, <code>privateLinkServiceUrl</code>, and so on.
        /// </p>
        public let connectorMetadata: AppflowClientTypes.ConnectorMetadata?
        /// <p>
        /// Specifies if PrivateLink is enabled for that connector.
        /// </p>
        public let isPrivateLinkEnabled: Swift.Bool
        /// <p>
        /// Specifies if a PrivateLink endpoint URL is required.
        /// </p>
        public let isPrivateLinkEndpointUrlRequired: Swift.Bool
        /// <p>
        /// Lists the connectors that are available for use as destinations.
        /// </p>
        public let supportedDestinationConnectors: [AppflowClientTypes.ConnectorType]?
        /// <p>
        ///     Specifies the supported flow frequency for that connector.
        ///     </p>
        public let supportedSchedulingFrequencies: [AppflowClientTypes.ScheduleFrequencyType]?
        /// <p>
        /// Specifies the supported trigger types for the flow.
        /// </p>
        public let supportedTriggerTypes: [AppflowClientTypes.TriggerType]?

        public init (
            canUseAsDestination: Swift.Bool = false,
            canUseAsSource: Swift.Bool = false,
            connectorMetadata: AppflowClientTypes.ConnectorMetadata? = nil,
            isPrivateLinkEnabled: Swift.Bool = false,
            isPrivateLinkEndpointUrlRequired: Swift.Bool = false,
            supportedDestinationConnectors: [AppflowClientTypes.ConnectorType]? = nil,
            supportedSchedulingFrequencies: [AppflowClientTypes.ScheduleFrequencyType]? = nil,
            supportedTriggerTypes: [AppflowClientTypes.TriggerType]? = nil
        )
        {
            self.canUseAsDestination = canUseAsDestination
            self.canUseAsSource = canUseAsSource
            self.connectorMetadata = connectorMetadata
            self.isPrivateLinkEnabled = isPrivateLinkEnabled
            self.isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequired
            self.supportedDestinationConnectors = supportedDestinationConnectors
            self.supportedSchedulingFrequencies = supportedSchedulingFrequencies
            self.supportedTriggerTypes = supportedTriggerTypes
        }
    }

}

extension AppflowClientTypes.ConnectorEntity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hasNestedEntities
        case label
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hasNestedEntities != false {
            try encodeContainer.encode(hasNestedEntities, forKey: .hasNestedEntities)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let hasNestedEntitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .hasNestedEntities)
        hasNestedEntities = hasNestedEntitiesDecoded
    }
}

extension AppflowClientTypes.ConnectorEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorEntity(hasNestedEntities: \(Swift.String(describing: hasNestedEntities)), label: \(Swift.String(describing: label)), name: \(Swift.String(describing: name)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// The high-level entity that can be queried in Amazon AppFlow. For example, a Salesforce entity might be an <i>Account</i> or <i>Opportunity</i>, whereas a ServiceNow entity might be an <i>Incident</i>.
    ///
    /// </p>
    public struct ConnectorEntity: Swift.Equatable {
        /// <p>
        /// Specifies whether the connector entity is a parent or a category and has more entities nested underneath it. If another call is made with <code>entitiesPath = "the_current_entity_name_with_hasNestedEntities_true"</code>, then it returns the nested entities underneath it. This provides a way to retrieve all supported entities in a recursive fashion.
        /// </p>
        public let hasNestedEntities: Swift.Bool
        /// <p>
        /// The label applied to the connector entity.
        /// </p>
        public let label: Swift.String?
        /// <p>
        /// The name of the connector entity.
        /// </p>
        public let name: Swift.String?

        public init (
            hasNestedEntities: Swift.Bool = false,
            label: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.hasNestedEntities = hasNestedEntities
            self.label = label
            self.name = name
        }
    }

}

extension AppflowClientTypes.ConnectorEntityField: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationProperties
        case identifier
        case label
        case sourceProperties
        case supportedFieldTypeDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationProperties = destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let sourceProperties = sourceProperties {
            try encodeContainer.encode(sourceProperties, forKey: .sourceProperties)
        }
        if let supportedFieldTypeDetails = supportedFieldTypeDetails {
            try encodeContainer.encode(supportedFieldTypeDetails, forKey: .supportedFieldTypeDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let supportedFieldTypeDetailsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SupportedFieldTypeDetails.self, forKey: .supportedFieldTypeDetails)
        supportedFieldTypeDetails = supportedFieldTypeDetailsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFieldProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DestinationFieldProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
    }
}

extension AppflowClientTypes.ConnectorEntityField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorEntityField(description: \(Swift.String(describing: description)), destinationProperties: \(Swift.String(describing: destinationProperties)), identifier: \(Swift.String(describing: identifier)), label: \(Swift.String(describing: label)), sourceProperties: \(Swift.String(describing: sourceProperties)), supportedFieldTypeDetails: \(Swift.String(describing: supportedFieldTypeDetails)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// Describes the data model of a connector field. For example, for an <i>account</i> entity, the fields would be <i>account name</i>, <i>account ID</i>, and so on.
    /// </p>
    public struct ConnectorEntityField: Swift.Equatable {
        /// <p>
        ///   A description of the connector entity field.
        /// </p>
        public let description: Swift.String?
        /// <p>
        ///   The properties applied to a field when the connector is being used as a destination.
        /// </p>
        public let destinationProperties: AppflowClientTypes.DestinationFieldProperties?
        /// <p>
        /// The unique identifier of the connector field.
        /// </p>
        public let identifier: Swift.String?
        /// <p>
        /// The label applied to a connector entity field.
        /// </p>
        public let label: Swift.String?
        /// <p>
        ///   The properties that can be applied to a field when the connector is being used as a source.
        /// </p>
        public let sourceProperties: AppflowClientTypes.SourceFieldProperties?
        /// <p>
        ///  Contains details regarding the supported <code>FieldType</code>, including the corresponding <code>filterOperators</code> and <code>supportedValues</code>.
        /// </p>
        public let supportedFieldTypeDetails: AppflowClientTypes.SupportedFieldTypeDetails?

        public init (
            description: Swift.String? = nil,
            destinationProperties: AppflowClientTypes.DestinationFieldProperties? = nil,
            identifier: Swift.String? = nil,
            label: Swift.String? = nil,
            sourceProperties: AppflowClientTypes.SourceFieldProperties? = nil,
            supportedFieldTypeDetails: AppflowClientTypes.SupportedFieldTypeDetails? = nil
        )
        {
            self.description = description
            self.destinationProperties = destinationProperties
            self.identifier = identifier
            self.label = label
            self.sourceProperties = sourceProperties
            self.supportedFieldTypeDetails = supportedFieldTypeDetails
        }
    }

}

extension AppflowClientTypes.ConnectorMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case customerProfiles = "CustomerProfiles"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case eventBridge = "EventBridge"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case redshift = "Redshift"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case upsolver = "Upsolver"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let customerProfiles = customerProfiles {
            try encodeContainer.encode(customerProfiles, forKey: .customerProfiles)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let eventBridge = eventBridge {
            try encodeContainer.encode(eventBridge, forKey: .eventBridge)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let upsolver = upsolver {
            try encodeContainer.encode(upsolver, forKey: .upsolver)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeMetadata.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogMetadata.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceMetadata.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsMetadata.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusMetadata.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoMetadata.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftMetadata.self, forKey: .redshift)
        redshift = redshiftDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3Metadata.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceMetadata.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowMetadata.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularMetadata.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackMetadata.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeMetadata.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroMetadata.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaMetadata.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskMetadata.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let eventBridgeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.EventBridgeMetadata.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
        let upsolverDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.UpsolverMetadata.self, forKey: .upsolver)
        upsolver = upsolverDecoded
        let customerProfilesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CustomerProfilesMetadata.self, forKey: .customerProfiles)
        customerProfiles = customerProfilesDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeMetadata.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
    }
}

extension AppflowClientTypes.ConnectorMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorMetadata(amplitude: \(Swift.String(describing: amplitude)), customerProfiles: \(Swift.String(describing: customerProfiles)), datadog: \(Swift.String(describing: datadog)), dynatrace: \(Swift.String(describing: dynatrace)), eventBridge: \(Swift.String(describing: eventBridge)), googleAnalytics: \(Swift.String(describing: googleAnalytics)), honeycode: \(Swift.String(describing: honeycode)), inforNexus: \(Swift.String(describing: inforNexus)), marketo: \(Swift.String(describing: marketo)), redshift: \(Swift.String(describing: redshift)), s3: \(Swift.String(describing: s3)), salesforce: \(Swift.String(describing: salesforce)), serviceNow: \(Swift.String(describing: serviceNow)), singular: \(Swift.String(describing: singular)), slack: \(Swift.String(describing: slack)), snowflake: \(Swift.String(describing: snowflake)), trendmicro: \(Swift.String(describing: trendmicro)), upsolver: \(Swift.String(describing: upsolver)), veeva: \(Swift.String(describing: veeva)), zendesk: \(Swift.String(describing: zendesk)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   A structure to specify connector-specific metadata such as <code>oAuthScopes</code>, <code>supportedRegions</code>, <code>privateLinkServiceUrl</code>, and so on.
    /// </p>
    public struct ConnectorMetadata: Swift.Equatable {
        /// <p>
        ///  The connector metadata specific to Amplitude.
        /// </p>
        public let amplitude: AppflowClientTypes.AmplitudeMetadata?
        /// <p>
        ///       The connector metadata specific to Amazon Connect Customer Profiles.
        ///     </p>
        public let customerProfiles: AppflowClientTypes.CustomerProfilesMetadata?
        /// <p>
        ///   The connector metadata specific to Datadog.
        /// </p>
        public let datadog: AppflowClientTypes.DatadogMetadata?
        /// <p>
        ///   The connector metadata specific to Dynatrace.
        /// </p>
        public let dynatrace: AppflowClientTypes.DynatraceMetadata?
        /// <p>
        ///       The connector metadata specific to Amazon EventBridge.
        ///     </p>
        public let eventBridge: AppflowClientTypes.EventBridgeMetadata?
        /// <p>
        ///   The connector metadata specific to Google Analytics.
        /// </p>
        public let googleAnalytics: AppflowClientTypes.GoogleAnalyticsMetadata?
        /// <p>
        ///       The connector metadata specific to Amazon Honeycode.
        ///     </p>
        public let honeycode: AppflowClientTypes.HoneycodeMetadata?
        /// <p>
        ///   The connector metadata specific to Infor Nexus.
        /// </p>
        public let inforNexus: AppflowClientTypes.InforNexusMetadata?
        /// <p>
        ///   The connector metadata specific to Marketo.
        /// </p>
        public let marketo: AppflowClientTypes.MarketoMetadata?
        /// <p>
        ///   The connector metadata specific to Amazon Redshift.
        /// </p>
        public let redshift: AppflowClientTypes.RedshiftMetadata?
        /// <p>
        ///   The connector metadata specific to Amazon S3.
        /// </p>
        public let s3: AppflowClientTypes.S3Metadata?
        /// <p>
        ///   The connector metadata specific to Salesforce.
        /// </p>
        public let salesforce: AppflowClientTypes.SalesforceMetadata?
        /// <p>
        ///   The connector metadata specific to ServiceNow.
        /// </p>
        public let serviceNow: AppflowClientTypes.ServiceNowMetadata?
        /// <p>
        ///   The connector metadata specific to Singular.
        /// </p>
        public let singular: AppflowClientTypes.SingularMetadata?
        /// <p>
        ///   The connector metadata specific to Slack.
        /// </p>
        public let slack: AppflowClientTypes.SlackMetadata?
        /// <p>
        ///   The connector metadata specific to Snowflake.
        /// </p>
        public let snowflake: AppflowClientTypes.SnowflakeMetadata?
        /// <p>
        ///   The connector metadata specific to Trend Micro.
        /// </p>
        public let trendmicro: AppflowClientTypes.TrendmicroMetadata?
        /// <p>
        ///       The connector metadata specific to Upsolver.
        ///     </p>
        public let upsolver: AppflowClientTypes.UpsolverMetadata?
        /// <p>
        ///   The connector metadata specific to Veeva.
        /// </p>
        public let veeva: AppflowClientTypes.VeevaMetadata?
        /// <p>
        ///   The connector metadata specific to Zendesk.
        /// </p>
        public let zendesk: AppflowClientTypes.ZendeskMetadata?

        public init (
            amplitude: AppflowClientTypes.AmplitudeMetadata? = nil,
            customerProfiles: AppflowClientTypes.CustomerProfilesMetadata? = nil,
            datadog: AppflowClientTypes.DatadogMetadata? = nil,
            dynatrace: AppflowClientTypes.DynatraceMetadata? = nil,
            eventBridge: AppflowClientTypes.EventBridgeMetadata? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsMetadata? = nil,
            honeycode: AppflowClientTypes.HoneycodeMetadata? = nil,
            inforNexus: AppflowClientTypes.InforNexusMetadata? = nil,
            marketo: AppflowClientTypes.MarketoMetadata? = nil,
            redshift: AppflowClientTypes.RedshiftMetadata? = nil,
            s3: AppflowClientTypes.S3Metadata? = nil,
            salesforce: AppflowClientTypes.SalesforceMetadata? = nil,
            serviceNow: AppflowClientTypes.ServiceNowMetadata? = nil,
            singular: AppflowClientTypes.SingularMetadata? = nil,
            slack: AppflowClientTypes.SlackMetadata? = nil,
            snowflake: AppflowClientTypes.SnowflakeMetadata? = nil,
            trendmicro: AppflowClientTypes.TrendmicroMetadata? = nil,
            upsolver: AppflowClientTypes.UpsolverMetadata? = nil,
            veeva: AppflowClientTypes.VeevaMetadata? = nil,
            zendesk: AppflowClientTypes.ZendeskMetadata? = nil
        )
        {
            self.amplitude = amplitude
            self.customerProfiles = customerProfiles
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.eventBridge = eventBridge
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.upsolver = upsolver
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.ConnectorOAuthRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authCode
        case redirectUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authCode = authCode {
            try encodeContainer.encode(authCode, forKey: .authCode)
        }
        if let redirectUri = redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authCode)
        authCode = authCodeDecoded
        let redirectUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
    }
}

extension AppflowClientTypes.ConnectorOAuthRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorOAuthRequest(authCode: \(Swift.String(describing: authCode)), redirectUri: \(Swift.String(describing: redirectUri)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///  Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
    /// </p>
    public struct ConnectorOAuthRequest: Swift.Equatable {
        /// <p>
        ///  The code provided by the connector when it has been authenticated via the connected app.
        /// </p>
        public let authCode: Swift.String?
        /// <p>
        ///       The URL to which the authentication server redirects the browser after authorization has been granted.
        ///     </p>
        public let redirectUri: Swift.String?

        public init (
            authCode: Swift.String? = nil,
            redirectUri: Swift.String? = nil
        )
        {
            self.authCode = authCode
            self.redirectUri = redirectUri
        }
    }

}

extension AppflowClientTypes.ConnectorOperator: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude.rawValue, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog.rawValue, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace.rawValue, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics.rawValue, forKey: .googleAnalytics)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus.rawValue, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo.rawValue, forKey: .marketo)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3.rawValue, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce.rawValue, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow.rawValue, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular.rawValue, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack.rawValue, forKey: .slack)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro.rawValue, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva.rawValue, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk.rawValue, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeConnectorOperator.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogConnectorOperator.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceConnectorOperator.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsConnectorOperator.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusConnectorOperator.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoConnectorOperator.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3ConnectorOperator.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceConnectorOperator.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowConnectorOperator.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularConnectorOperator.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackConnectorOperator.self, forKey: .slack)
        slack = slackDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroConnectorOperator.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaConnectorOperator.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskConnectorOperator.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension AppflowClientTypes.ConnectorOperator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorOperator(amplitude: \(Swift.String(describing: amplitude)), datadog: \(Swift.String(describing: datadog)), dynatrace: \(Swift.String(describing: dynatrace)), googleAnalytics: \(Swift.String(describing: googleAnalytics)), inforNexus: \(Swift.String(describing: inforNexus)), marketo: \(Swift.String(describing: marketo)), s3: \(Swift.String(describing: s3)), salesforce: \(Swift.String(describing: salesforce)), serviceNow: \(Swift.String(describing: serviceNow)), singular: \(Swift.String(describing: singular)), slack: \(Swift.String(describing: slack)), trendmicro: \(Swift.String(describing: trendmicro)), veeva: \(Swift.String(describing: veeva)), zendesk: \(Swift.String(describing: zendesk)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// The operation to be performed on the provided source fields.
    /// </p>
    public struct ConnectorOperator: Swift.Equatable {
        /// <p>
        ///       The operation to be performed on the provided Amplitude source fields.
        ///     </p>
        public let amplitude: AppflowClientTypes.AmplitudeConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Datadog source fields.
        /// </p>
        public let datadog: AppflowClientTypes.DatadogConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Dynatrace source fields.
        /// </p>
        public let dynatrace: AppflowClientTypes.DynatraceConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Google Analytics source fields.
        /// </p>
        public let googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Infor Nexus source fields.
        /// </p>
        public let inforNexus: AppflowClientTypes.InforNexusConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Marketo source fields.
        /// </p>
        public let marketo: AppflowClientTypes.MarketoConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Amazon S3 source fields.
        /// </p>
        public let s3: AppflowClientTypes.S3ConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Salesforce source fields.
        /// </p>
        public let salesforce: AppflowClientTypes.SalesforceConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided ServiceNow source fields.
        /// </p>
        public let serviceNow: AppflowClientTypes.ServiceNowConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Singular source fields.
        /// </p>
        public let singular: AppflowClientTypes.SingularConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Slack source fields.
        /// </p>
        public let slack: AppflowClientTypes.SlackConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Trend Micro source fields.
        /// </p>
        public let trendmicro: AppflowClientTypes.TrendmicroConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Veeva source fields.
        /// </p>
        public let veeva: AppflowClientTypes.VeevaConnectorOperator?
        /// <p>
        ///   The operation to be performed on the provided Zendesk source fields.
        /// </p>
        public let zendesk: AppflowClientTypes.ZendeskConnectorOperator?

        public init (
            amplitude: AppflowClientTypes.AmplitudeConnectorOperator? = nil,
            datadog: AppflowClientTypes.DatadogConnectorOperator? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorOperator? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorOperator? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorOperator? = nil,
            marketo: AppflowClientTypes.MarketoConnectorOperator? = nil,
            s3: AppflowClientTypes.S3ConnectorOperator? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorOperator? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorOperator? = nil,
            singular: AppflowClientTypes.SingularConnectorOperator? = nil,
            slack: AppflowClientTypes.SlackConnectorOperator? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorOperator? = nil,
            veeva: AppflowClientTypes.VeevaConnectorOperator? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorOperator? = nil
        )
        {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.ConnectorProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionMode
        case connectorProfileArn
        case connectorProfileName
        case connectorProfileProperties
        case connectorType
        case createdAt
        case credentialsArn
        case lastUpdatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionMode = connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorProfileArn = connectorProfileArn {
            try encodeContainer.encode(connectorProfileArn, forKey: .connectorProfileArn)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorProfileProperties = connectorProfileProperties {
            try encodeContainer.encode(connectorProfileProperties, forKey: .connectorProfileProperties)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let connectorProfilePropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileProperties.self, forKey: .connectorProfileProperties)
        connectorProfileProperties = connectorProfilePropertiesDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AppflowClientTypes.ConnectorProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorProfile(connectionMode: \(Swift.String(describing: connectionMode)), connectorProfileArn: \(Swift.String(describing: connectorProfileArn)), connectorProfileName: \(Swift.String(describing: connectorProfileName)), connectorProfileProperties: \(Swift.String(describing: connectorProfileProperties)), connectorType: \(Swift.String(describing: connectorType)), createdAt: \(Swift.String(describing: createdAt)), credentialsArn: \(Swift.String(describing: credentialsArn)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   Describes an instance of a connector. This includes the provided name, credentials ARN, connection-mode, and so on. To keep the API intuitive and extensible, the fields that are common to all types of connector profiles are explicitly specified at the top level. The rest of the connector-specific properties are available via  the <code>connectorProfileProperties</code> field.
    /// </p>
    public struct ConnectorProfile: Swift.Equatable {
        /// <p>
        ///   Indicates the connection mode and if it is public or private.
        /// </p>
        public let connectionMode: AppflowClientTypes.ConnectionMode?
        /// <p>
        /// The Amazon Resource Name (ARN) of the connector profile.
        /// </p>
        public let connectorProfileArn: Swift.String?
        /// <p>
        ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in the AWS account.
        /// </p>
        public let connectorProfileName: Swift.String?
        /// <p>
        /// The connector-specific properties of the profile configuration.
        /// </p>
        public let connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties?
        /// <p>
        ///   The type of connector, such as Salesforce, Amplitude, and so on.
        /// </p>
        public let connectorType: AppflowClientTypes.ConnectorType?
        /// <p>
        ///   Specifies when the connector profile was created.
        /// </p>
        public let createdAt: ClientRuntime.Date?
        /// <p>
        ///   The Amazon Resource Name (ARN) of the connector profile credentials.
        /// </p>
        public let credentialsArn: Swift.String?
        /// <p>
        ///   Specifies when the connector profile was last updated.
        /// </p>
        public let lastUpdatedAt: ClientRuntime.Date?

        public init (
            connectionMode: AppflowClientTypes.ConnectionMode? = nil,
            connectorProfileArn: Swift.String? = nil,
            connectorProfileName: Swift.String? = nil,
            connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            createdAt: ClientRuntime.Date? = nil,
            credentialsArn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil
        )
        {
            self.connectionMode = connectionMode
            self.connectorProfileArn = connectorProfileArn
            self.connectorProfileName = connectorProfileName
            self.connectorProfileProperties = connectorProfileProperties
            self.connectorType = connectorType
            self.createdAt = createdAt
            self.credentialsArn = credentialsArn
            self.lastUpdatedAt = lastUpdatedAt
        }
    }

}

extension AppflowClientTypes.ConnectorProfileConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileCredentials
        case connectorProfileProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileCredentials = connectorProfileCredentials {
            try encodeContainer.encode(connectorProfileCredentials, forKey: .connectorProfileCredentials)
        }
        if let connectorProfileProperties = connectorProfileProperties {
            try encodeContainer.encode(connectorProfileProperties, forKey: .connectorProfileProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfilePropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileProperties.self, forKey: .connectorProfileProperties)
        connectorProfileProperties = connectorProfilePropertiesDecoded
        let connectorProfileCredentialsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileCredentials.self, forKey: .connectorProfileCredentials)
        connectorProfileCredentials = connectorProfileCredentialsDecoded
    }
}

extension AppflowClientTypes.ConnectorProfileConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorProfileConfig(connectorProfileCredentials: \(Swift.String(describing: connectorProfileCredentials)), connectorProfileProperties: \(Swift.String(describing: connectorProfileProperties)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   Defines the connector-specific configuration and credentials for the connector profile.
    /// </p>
    public struct ConnectorProfileConfig: Swift.Equatable {
        /// <p>
        ///  The connector-specific credentials required by each connector.
        /// </p>
        public let connectorProfileCredentials: AppflowClientTypes.ConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific properties of the profile configuration.
        /// </p>
        public let connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties?

        public init (
            connectorProfileCredentials: AppflowClientTypes.ConnectorProfileCredentials? = nil,
            connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties? = nil
        )
        {
            self.connectorProfileCredentials = connectorProfileCredentials
            self.connectorProfileProperties = connectorProfileProperties
        }
    }

}

extension AppflowClientTypes.ConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case redshift = "Redshift"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeConnectorProfileCredentials.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogConnectorProfileCredentials.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceConnectorProfileCredentials.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeConnectorProfileCredentials.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusConnectorProfileCredentials.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoConnectorProfileCredentials.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftConnectorProfileCredentials.self, forKey: .redshift)
        redshift = redshiftDecoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceConnectorProfileCredentials.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowConnectorProfileCredentials.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularConnectorProfileCredentials.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackConnectorProfileCredentials.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeConnectorProfileCredentials.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroConnectorProfileCredentials.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaConnectorProfileCredentials.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskConnectorProfileCredentials.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension AppflowClientTypes.ConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorProfileCredentials(amplitude: \(Swift.String(describing: amplitude)), datadog: \(Swift.String(describing: datadog)), dynatrace: \(Swift.String(describing: dynatrace)), googleAnalytics: \(Swift.String(describing: googleAnalytics)), honeycode: \(Swift.String(describing: honeycode)), inforNexus: \(Swift.String(describing: inforNexus)), marketo: \(Swift.String(describing: marketo)), redshift: \(Swift.String(describing: redshift)), salesforce: \(Swift.String(describing: salesforce)), serviceNow: \(Swift.String(describing: serviceNow)), singular: \(Swift.String(describing: singular)), slack: \(Swift.String(describing: slack)), snowflake: \(Swift.String(describing: snowflake)), trendmicro: \(Swift.String(describing: trendmicro)), veeva: \(Swift.String(describing: veeva)), zendesk: \(Swift.String(describing: zendesk)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///  The connector-specific credentials required by a connector.
    /// </p>
    public struct ConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   The connector-specific credentials required when using Amplitude.
        /// </p>
        public let amplitude: AppflowClientTypes.AmplitudeConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Datadog.
        /// </p>
        public let datadog: AppflowClientTypes.DatadogConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Dynatrace.
        /// </p>
        public let dynatrace: AppflowClientTypes.DynatraceConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Google Analytics.
        /// </p>
        public let googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials?
        /// <p>
        ///       The connector-specific credentials required when using Amazon Honeycode.
        ///     </p>
        public let honeycode: AppflowClientTypes.HoneycodeConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Infor Nexus.
        /// </p>
        public let inforNexus: AppflowClientTypes.InforNexusConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Marketo.
        /// </p>
        public let marketo: AppflowClientTypes.MarketoConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Amazon Redshift.
        /// </p>
        public let redshift: AppflowClientTypes.RedshiftConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Salesforce.
        /// </p>
        public let salesforce: AppflowClientTypes.SalesforceConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using ServiceNow.
        /// </p>
        public let serviceNow: AppflowClientTypes.ServiceNowConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Singular.
        /// </p>
        public let singular: AppflowClientTypes.SingularConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Slack.
        /// </p>
        public let slack: AppflowClientTypes.SlackConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Snowflake.
        /// </p>
        public let snowflake: AppflowClientTypes.SnowflakeConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Trend Micro.
        /// </p>
        public let trendmicro: AppflowClientTypes.TrendmicroConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Veeva.
        /// </p>
        public let veeva: AppflowClientTypes.VeevaConnectorProfileCredentials?
        /// <p>
        ///   The connector-specific credentials required when using Zendesk.
        /// </p>
        public let zendesk: AppflowClientTypes.ZendeskConnectorProfileCredentials?

        public init (
            amplitude: AppflowClientTypes.AmplitudeConnectorProfileCredentials? = nil,
            datadog: AppflowClientTypes.DatadogConnectorProfileCredentials? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorProfileCredentials? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials? = nil,
            honeycode: AppflowClientTypes.HoneycodeConnectorProfileCredentials? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorProfileCredentials? = nil,
            marketo: AppflowClientTypes.MarketoConnectorProfileCredentials? = nil,
            redshift: AppflowClientTypes.RedshiftConnectorProfileCredentials? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorProfileCredentials? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorProfileCredentials? = nil,
            singular: AppflowClientTypes.SingularConnectorProfileCredentials? = nil,
            slack: AppflowClientTypes.SlackConnectorProfileCredentials? = nil,
            snowflake: AppflowClientTypes.SnowflakeConnectorProfileCredentials? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorProfileCredentials? = nil,
            veeva: AppflowClientTypes.VeevaConnectorProfileCredentials? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorProfileCredentials? = nil
        )
        {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.ConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case redshift = "Redshift"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeConnectorProfileProperties.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogConnectorProfileProperties.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceConnectorProfileProperties.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeConnectorProfileProperties.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusConnectorProfileProperties.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoConnectorProfileProperties.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftConnectorProfileProperties.self, forKey: .redshift)
        redshift = redshiftDecoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceConnectorProfileProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowConnectorProfileProperties.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularConnectorProfileProperties.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackConnectorProfileProperties.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeConnectorProfileProperties.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroConnectorProfileProperties.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaConnectorProfileProperties.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskConnectorProfileProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension AppflowClientTypes.ConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorProfileProperties(amplitude: \(Swift.String(describing: amplitude)), datadog: \(Swift.String(describing: datadog)), dynatrace: \(Swift.String(describing: dynatrace)), googleAnalytics: \(Swift.String(describing: googleAnalytics)), honeycode: \(Swift.String(describing: honeycode)), inforNexus: \(Swift.String(describing: inforNexus)), marketo: \(Swift.String(describing: marketo)), redshift: \(Swift.String(describing: redshift)), salesforce: \(Swift.String(describing: salesforce)), serviceNow: \(Swift.String(describing: serviceNow)), singular: \(Swift.String(describing: singular)), slack: \(Swift.String(describing: slack)), snowflake: \(Swift.String(describing: snowflake)), trendmicro: \(Swift.String(describing: trendmicro)), veeva: \(Swift.String(describing: veeva)), zendesk: \(Swift.String(describing: zendesk)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required by each connector.
    /// </p>
    public struct ConnectorProfileProperties: Swift.Equatable {
        /// <p>
        ///   The connector-specific properties required by Amplitude.
        /// </p>
        public let amplitude: AppflowClientTypes.AmplitudeConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by Datadog.
        /// </p>
        public let datadog: AppflowClientTypes.DatadogConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by Dynatrace.
        /// </p>
        public let dynatrace: AppflowClientTypes.DynatraceConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required Google Analytics.
        /// </p>
        public let googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties?
        /// <p>
        ///       The connector-specific properties required by Amazon Honeycode.
        ///     </p>
        public let honeycode: AppflowClientTypes.HoneycodeConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by Infor Nexus.
        /// </p>
        public let inforNexus: AppflowClientTypes.InforNexusConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by Marketo.
        /// </p>
        public let marketo: AppflowClientTypes.MarketoConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by Amazon Redshift.
        /// </p>
        public let redshift: AppflowClientTypes.RedshiftConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by Salesforce.
        /// </p>
        public let salesforce: AppflowClientTypes.SalesforceConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by serviceNow.
        /// </p>
        public let serviceNow: AppflowClientTypes.ServiceNowConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by Singular.
        /// </p>
        public let singular: AppflowClientTypes.SingularConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by Slack.
        /// </p>
        public let slack: AppflowClientTypes.SlackConnectorProfileProperties?
        /// <p>
        /// The connector-specific properties required by Snowflake.
        /// </p>
        public let snowflake: AppflowClientTypes.SnowflakeConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by Trend Micro.
        /// </p>
        public let trendmicro: AppflowClientTypes.TrendmicroConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by Veeva.
        /// </p>
        public let veeva: AppflowClientTypes.VeevaConnectorProfileProperties?
        /// <p>
        ///   The connector-specific properties required by Zendesk.
        /// </p>
        public let zendesk: AppflowClientTypes.ZendeskConnectorProfileProperties?

        public init (
            amplitude: AppflowClientTypes.AmplitudeConnectorProfileProperties? = nil,
            datadog: AppflowClientTypes.DatadogConnectorProfileProperties? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorProfileProperties? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties? = nil,
            honeycode: AppflowClientTypes.HoneycodeConnectorProfileProperties? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorProfileProperties? = nil,
            marketo: AppflowClientTypes.MarketoConnectorProfileProperties? = nil,
            redshift: AppflowClientTypes.RedshiftConnectorProfileProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorProfileProperties? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorProfileProperties? = nil,
            singular: AppflowClientTypes.SingularConnectorProfileProperties? = nil,
            slack: AppflowClientTypes.SlackConnectorProfileProperties? = nil,
            snowflake: AppflowClientTypes.SnowflakeConnectorProfileProperties? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorProfileProperties? = nil,
            veeva: AppflowClientTypes.VeevaConnectorProfileProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorProfileProperties? = nil
        )
        {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension ConnectorServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectorServerException(message: \(Swift.String(describing: message)))"}
}

extension ConnectorServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConnectorServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///  An error occurred when retrieving data from the connector endpoint.
/// </p>
public struct ConnectorServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectorServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConnectorServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum ConnectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amplitude
        case customerprofiles
        case datadog
        case dynatrace
        case eventbridge
        case googleanalytics
        case honeycode
        case infornexus
        case lookoutmetrics
        case marketo
        case redshift
        case s3
        case salesforce
        case servicenow
        case singular
        case slack
        case snowflake
        case trendmicro
        case upsolver
        case veeva
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorType] {
            return [
                .amplitude,
                .customerprofiles,
                .datadog,
                .dynatrace,
                .eventbridge,
                .googleanalytics,
                .honeycode,
                .infornexus,
                .lookoutmetrics,
                .marketo,
                .redshift,
                .s3,
                .salesforce,
                .servicenow,
                .singular,
                .slack,
                .snowflake,
                .trendmicro,
                .upsolver,
                .veeva,
                .zendesk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amplitude: return "Amplitude"
            case .customerprofiles: return "CustomerProfiles"
            case .datadog: return "Datadog"
            case .dynatrace: return "Dynatrace"
            case .eventbridge: return "EventBridge"
            case .googleanalytics: return "Googleanalytics"
            case .honeycode: return "Honeycode"
            case .infornexus: return "Infornexus"
            case .lookoutmetrics: return "LookoutMetrics"
            case .marketo: return "Marketo"
            case .redshift: return "Redshift"
            case .s3: return "S3"
            case .salesforce: return "Salesforce"
            case .servicenow: return "Servicenow"
            case .singular: return "Singular"
            case .slack: return "Slack"
            case .snowflake: return "Snowflake"
            case .trendmicro: return "Trendmicro"
            case .upsolver: return "Upsolver"
            case .veeva: return "Veeva"
            case .zendesk: return "Zendesk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectorType(rawValue: rawValue) ?? ConnectorType.sdkUnknown(rawValue)
        }
    }
}

public struct CreateConnectorProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectorProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectorProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectorProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectorProfileOutputError>
}

extension CreateConnectorProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectorProfileInput(connectionMode: \(Swift.String(describing: connectionMode)), connectorProfileConfig: \(Swift.String(describing: connectorProfileConfig)), connectorProfileName: \(Swift.String(describing: connectorProfileName)), connectorType: \(Swift.String(describing: connectorType)), kmsArn: \(Swift.String(describing: kmsArn)))"}
}

extension CreateConnectorProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
        case connectorType
        case kmsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionMode = connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorProfileConfig = connectorProfileConfig {
            try encodeContainer.encode(connectorProfileConfig, forKey: .connectorProfileConfig)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let kmsArn = kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
    }
}

public struct CreateConnectorProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectorProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectorProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectorProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectorProfileOutputError>
}

public struct CreateConnectorProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectorProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectorProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectorProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectorProfileOutputError>
}

public struct CreateConnectorProfileInput: Swift.Equatable {
    /// <p>
    ///   Indicates the connection mode and specifies whether it is public or private. Private flows use AWS PrivateLink to route data over AWS infrastructure without exposing it to the public internet.
    /// </p>
    public let connectionMode: AppflowClientTypes.ConnectionMode?
    /// <p>
    /// Defines the connector-specific configuration and credentials.
    /// </p>
    public let connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
    /// <p>
    ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in your AWS account.
    /// </p>
    public let connectorProfileName: Swift.String?
    /// <p>
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorType: AppflowClientTypes.ConnectorType?
    /// <p>
    ///   The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    /// </p>
    public let kmsArn: Swift.String?

    public init (
        connectionMode: AppflowClientTypes.ConnectionMode? = nil,
        connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        kmsArn: Swift.String? = nil
    )
    {
        self.connectionMode = connectionMode
        self.connectorProfileConfig = connectorProfileConfig
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.kmsArn = kmsArn
    }
}

struct CreateConnectorProfileInputBody: Swift.Equatable {
    public let connectorProfileName: Swift.String?
    public let kmsArn: Swift.String?
    public let connectorType: AppflowClientTypes.ConnectorType?
    public let connectionMode: AppflowClientTypes.ConnectionMode?
    public let connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
}

extension CreateConnectorProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
        case connectorType
        case kmsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let connectorProfileConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileConfig.self, forKey: .connectorProfileConfig)
        connectorProfileConfig = connectorProfileConfigDecoded
    }
}

extension CreateConnectorProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectorProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectorProfileOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectorProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectorProfileOutputResponse(connectorProfileArn: \(Swift.String(describing: connectorProfileArn)))"}
}

extension CreateConnectorProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectorProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileArn = output.connectorProfileArn
        } else {
            self.connectorProfileArn = nil
        }
    }
}

public struct CreateConnectorProfileOutputResponse: Swift.Equatable {
    /// <p>
    ///   The Amazon Resource Name (ARN) of the connector profile.
    /// </p>
    public let connectorProfileArn: Swift.String?

    public init (
        connectorProfileArn: Swift.String? = nil
    )
    {
        self.connectorProfileArn = connectorProfileArn
    }
}

struct CreateConnectorProfileOutputResponseBody: Swift.Equatable {
    public let connectorProfileArn: Swift.String?
}

extension CreateConnectorProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
    }
}

public struct CreateFlowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFlowOutputError>
}

extension CreateFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFlowInput(description: \(Swift.String(describing: description)), destinationFlowConfigList: \(Swift.String(describing: destinationFlowConfigList)), flowName: \(Swift.String(describing: flowName)), kmsArn: \(Swift.String(describing: kmsArn)), sourceFlowConfig: \(Swift.String(describing: sourceFlowConfig)), tags: \(Swift.String(describing: tags)), tasks: \(Swift.String(describing: tasks)), triggerConfig: \(Swift.String(describing: triggerConfig)))"}
}

extension CreateFlowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case kmsArn
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationFlowConfigList = destinationFlowConfigList {
            var destinationFlowConfigListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationFlowConfigList)
            for destinationflowconfiglist0 in destinationFlowConfigList {
                try destinationFlowConfigListContainer.encode(destinationflowconfiglist0)
            }
        }
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let kmsArn = kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let sourceFlowConfig = sourceFlowConfig {
            try encodeContainer.encode(sourceFlowConfig, forKey: .sourceFlowConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tasks = tasks {
            var tasksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tasks)
            for tasks0 in tasks {
                try tasksContainer.encode(tasks0)
            }
        }
        if let triggerConfig = triggerConfig {
            try encodeContainer.encode(triggerConfig, forKey: .triggerConfig)
        }
    }
}

public struct CreateFlowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFlowOutputError>
}

public struct CreateFlowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFlowOutputError>
}

public struct CreateFlowInput: Swift.Equatable {
    /// <p>
    ///  A description of the flow you want to create.
    /// </p>
    public let description: Swift.String?
    /// <p>
    /// The configuration that controls how Amazon AppFlow places data in the destination connector.
    /// </p>
    public let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// <p>
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: Swift.String?
    /// <p>
    ///   The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    /// </p>
    public let kmsArn: Swift.String?
    /// <p>
    /// The configuration that controls how Amazon AppFlow retrieves data from the source connector.
    /// </p>
    public let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// <p>
    /// The tags used to organize, track, or control access for your flow.
    /// </p>
    public let tags: [Swift.String:Swift.String]?
    /// <p>
    ///  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// </p>
    public let tasks: [AppflowClientTypes.Task]?
    /// <p>
    ///  The trigger settings that determine how and when the flow runs.
    /// </p>
    public let triggerConfig: AppflowClientTypes.TriggerConfig?

    public init (
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowName: Swift.String? = nil,
        kmsArn: Swift.String? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowName = flowName
        self.kmsArn = kmsArn
        self.sourceFlowConfig = sourceFlowConfig
        self.tags = tags
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct CreateFlowInputBody: Swift.Equatable {
    public let flowName: Swift.String?
    public let description: Swift.String?
    public let kmsArn: Swift.String?
    public let triggerConfig: AppflowClientTypes.TriggerConfig?
    public let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    public let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    public let tasks: [AppflowClientTypes.Task]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case kmsArn
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([AppflowClientTypes.DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[AppflowClientTypes.DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [AppflowClientTypes.DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let tasksContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Task?].self, forKey: .tasks)
        var tasksDecoded0:[AppflowClientTypes.Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [AppflowClientTypes.Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFlowOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFlowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFlowOutputResponse(flowArn: \(Swift.String(describing: flowArn)), flowStatus: \(Swift.String(describing: flowStatus)))"}
}

extension CreateFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct CreateFlowOutputResponse: Swift.Equatable {
    /// <p>
    /// The flow's Amazon Resource Name (ARN).
    /// </p>
    public let flowArn: Swift.String?
    /// <p>
    ///       Indicates the current status of the flow.
    ///     </p>
    public let flowStatus: AppflowClientTypes.FlowStatus?

    public init (
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct CreateFlowOutputResponseBody: Swift.Equatable {
    public let flowArn: Swift.String?
    public let flowStatus: AppflowClientTypes.FlowStatus?
}

extension CreateFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn
        case flowStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

extension AppflowClientTypes.CustomerProfilesDestinationProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
        case objectTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let objectTypeName = objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
    }
}

extension AppflowClientTypes.CustomerProfilesDestinationProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerProfilesDestinationProperties(domainName: \(Swift.String(describing: domainName)), objectTypeName: \(Swift.String(describing: objectTypeName)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The properties that are applied when Amazon Connect Customer Profiles is used as a destination.
    ///     </p>
    public struct CustomerProfilesDestinationProperties: Swift.Equatable {
        /// <p>
        ///       The unique name of the Amazon Connect Customer Profiles domain.
        ///     </p>
        public let domainName: Swift.String?
        /// <p>
        ///       The object specified in the Amazon Connect Customer Profiles flow destination.
        ///     </p>
        public let objectTypeName: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            objectTypeName: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
        }
    }

}

extension AppflowClientTypes.CustomerProfilesMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.CustomerProfilesMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerProfilesMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The connector metadata specific to Amazon Connect Customer Profiles.
    ///     </p>
    public struct CustomerProfilesMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes {
    public enum DataPullMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [DataPullMode] {
            return [
                .complete,
                .incremental,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .incremental: return "Incremental"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataPullMode(rawValue: rawValue) ?? DataPullMode.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum DatadogConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [DatadogConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatadogConnectorOperator(rawValue: rawValue) ?? DatadogConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.DatadogConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
        case applicationKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let applicationKey = applicationKey {
            try encodeContainer.encode(applicationKey, forKey: .applicationKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let applicationKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationKey)
        applicationKey = applicationKeyDecoded
    }
}

extension AppflowClientTypes.DatadogConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatadogConnectorProfileCredentials(apiKey: \(Swift.String(describing: apiKey)), applicationKey: \(Swift.String(describing: applicationKey)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific credentials required by Datadog.
    /// </p>
    public struct DatadogConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// </p>
        public let apiKey: Swift.String?
        /// <p>
        ///   Application keys, in conjunction with your API key, give you full access to Datadogs programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
        /// </p>
        public let applicationKey: Swift.String?

        public init (
            apiKey: Swift.String? = nil,
            applicationKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.applicationKey = applicationKey
        }
    }

}

extension AppflowClientTypes.DatadogConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes.DatadogConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatadogConnectorProfileProperties(instanceUrl: \(Swift.String(describing: instanceUrl)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required by Datadog.
    /// </p>
    public struct DatadogConnectorProfileProperties: Swift.Equatable {
        /// <p>
        ///  The location of the Datadog resource.
        /// </p>
        public let instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.DatadogMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.DatadogMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatadogMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Datadog.
    /// </p>
    public struct DatadogMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.DatadogSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.DatadogSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatadogSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Datadog is being used as a source.
    /// </p>
    public struct DatadogSourceProperties: Swift.Equatable {
        /// <p>
        ///   The object specified in the Datadog flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

public struct DeleteConnectorProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectorProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectorProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectorProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectorProfileOutputError>
}

extension DeleteConnectorProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectorProfileInput(connectorProfileName: \(Swift.String(describing: connectorProfileName)), forceDelete: \(Swift.String(describing: forceDelete)))"}
}

extension DeleteConnectorProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case forceDelete
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

public struct DeleteConnectorProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectorProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectorProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectorProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectorProfileOutputError>
}

public struct DeleteConnectorProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectorProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectorProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectorProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectorProfileOutputError>
}

public struct DeleteConnectorProfileInput: Swift.Equatable {
    /// <p>
    ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in your account.
    /// </p>
    public let connectorProfileName: Swift.String?
    /// <p>
    /// Indicates whether Amazon AppFlow should delete the profile, even if it is currently in use in one or more flows.
    /// </p>
    public let forceDelete: Swift.Bool

    public init (
        connectorProfileName: Swift.String? = nil,
        forceDelete: Swift.Bool = false
    )
    {
        self.connectorProfileName = connectorProfileName
        self.forceDelete = forceDelete
    }
}

struct DeleteConnectorProfileInputBody: Swift.Equatable {
    public let connectorProfileName: Swift.String?
    public let forceDelete: Swift.Bool
}

extension DeleteConnectorProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case forceDelete
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let forceDeleteDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteConnectorProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectorProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectorProfileOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectorProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectorProfileOutputResponse()"}
}

extension DeleteConnectorProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectorProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteConnectorProfileOutputResponseBody: Swift.Equatable {
}

extension DeleteConnectorProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteFlowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFlowOutputError>
}

extension DeleteFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFlowInput(flowName: \(Swift.String(describing: flowName)), forceDelete: \(Swift.String(describing: forceDelete)))"}
}

extension DeleteFlowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case forceDelete
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

public struct DeleteFlowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFlowOutputError>
}

public struct DeleteFlowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFlowOutputError>
}

public struct DeleteFlowInput: Swift.Equatable {
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: Swift.String?
    /// <p>
    ///   Indicates whether Amazon AppFlow should delete the flow, even if it is currently in use.
    /// </p>
    public let forceDelete: Swift.Bool

    public init (
        flowName: Swift.String? = nil,
        forceDelete: Swift.Bool = false
    )
    {
        self.flowName = flowName
        self.forceDelete = forceDelete
    }
}

struct DeleteFlowInputBody: Swift.Equatable {
    public let flowName: Swift.String?
    public let forceDelete: Swift.Bool
}

extension DeleteFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case forceDelete
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let forceDeleteDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFlowOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFlowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFlowOutputResponse()"}
}

extension DeleteFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFlowOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFlowOutputResponseBody: Swift.Equatable {
}

extension DeleteFlowOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeConnectorEntityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectorEntityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectorEntityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectorEntityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectorEntityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectorEntityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectorEntityOutputError>
}

extension DescribeConnectorEntityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConnectorEntityInput(connectorEntityName: \(Swift.String(describing: connectorEntityName)), connectorProfileName: \(Swift.String(describing: connectorProfileName)), connectorType: \(Swift.String(describing: connectorType)))"}
}

extension DescribeConnectorEntityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorEntityName
        case connectorProfileName
        case connectorType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorEntityName = connectorEntityName {
            try encodeContainer.encode(connectorEntityName, forKey: .connectorEntityName)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
    }
}

public struct DescribeConnectorEntityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectorEntityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectorEntityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectorEntityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectorEntityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectorEntityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectorEntityOutputError>
}

public struct DescribeConnectorEntityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectorEntityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectorEntityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectorEntityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectorEntityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectorEntityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectorEntityOutputError>
}

public struct DescribeConnectorEntityInput: Swift.Equatable {
    /// <p>
    ///  The entity name for that connector.
    /// </p>
    public let connectorEntityName: Swift.String?
    /// <p>
    ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in the AWS account.
    /// </p>
    public let connectorProfileName: Swift.String?
    /// <p>
    ///   The type of connector application, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorType: AppflowClientTypes.ConnectorType?

    public init (
        connectorEntityName: Swift.String? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil
    )
    {
        self.connectorEntityName = connectorEntityName
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
    }
}

struct DescribeConnectorEntityInputBody: Swift.Equatable {
    public let connectorEntityName: Swift.String?
    public let connectorType: AppflowClientTypes.ConnectorType?
    public let connectorProfileName: Swift.String?
}

extension DescribeConnectorEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorEntityName
        case connectorProfileName
        case connectorType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorEntityName)
        connectorEntityName = connectorEntityNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
    }
}

extension DescribeConnectorEntityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectorEntityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectorEntityOutputError: Swift.Error, Swift.Equatable {
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectorEntityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConnectorEntityOutputResponse(connectorEntityFields: \(Swift.String(describing: connectorEntityFields)))"}
}

extension DescribeConnectorEntityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectorEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorEntityFields = output.connectorEntityFields
        } else {
            self.connectorEntityFields = nil
        }
    }
}

public struct DescribeConnectorEntityOutputResponse: Swift.Equatable {
    /// <p>
    ///   Describes the fields for that connector entity. For example, for an <i>account</i> entity, the fields would be <i>account name</i>, <i>account ID</i>, and so on.
    /// </p>
    public let connectorEntityFields: [AppflowClientTypes.ConnectorEntityField]?

    public init (
        connectorEntityFields: [AppflowClientTypes.ConnectorEntityField]? = nil
    )
    {
        self.connectorEntityFields = connectorEntityFields
    }
}

struct DescribeConnectorEntityOutputResponseBody: Swift.Equatable {
    public let connectorEntityFields: [AppflowClientTypes.ConnectorEntityField]?
}

extension DescribeConnectorEntityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorEntityFields
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityFieldsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorEntityField?].self, forKey: .connectorEntityFields)
        var connectorEntityFieldsDecoded0:[AppflowClientTypes.ConnectorEntityField]? = nil
        if let connectorEntityFieldsContainer = connectorEntityFieldsContainer {
            connectorEntityFieldsDecoded0 = [AppflowClientTypes.ConnectorEntityField]()
            for structure0 in connectorEntityFieldsContainer {
                if let structure0 = structure0 {
                    connectorEntityFieldsDecoded0?.append(structure0)
                }
            }
        }
        connectorEntityFields = connectorEntityFieldsDecoded0
    }
}

public struct DescribeConnectorProfilesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectorProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectorProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectorProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectorProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectorProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectorProfilesOutputError>
}

extension DescribeConnectorProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConnectorProfilesInput(connectorProfileNames: \(Swift.String(describing: connectorProfileNames)), connectorType: \(Swift.String(describing: connectorType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeConnectorProfilesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileNames
        case connectorType
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileNames = connectorProfileNames {
            var connectorProfileNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorProfileNames)
            for connectorprofilenamelist0 in connectorProfileNames {
                try connectorProfileNamesContainer.encode(connectorprofilenamelist0)
            }
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeConnectorProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectorProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectorProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectorProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectorProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectorProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectorProfilesOutputError>
}

public struct DescribeConnectorProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectorProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectorProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectorProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectorProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectorProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectorProfilesOutputError>
}

public struct DescribeConnectorProfilesInput: Swift.Equatable {
    /// <p>
    ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in the AWS account.
    /// </p>
    public let connectorProfileNames: [Swift.String]?
    /// <p>
    ///   The type of connector, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorType: AppflowClientTypes.ConnectorType?
    /// <p>
    ///        Specifies the maximum number of items that should be returned in the result set. The default for <code>maxResults</code> is 20 (for all paginated API operations).
    ///     </p>
    public let maxResults: Swift.Int?
    /// <p>
    /// The pagination token for the next page of data.
    /// </p>
    public let nextToken: Swift.String?

    public init (
        connectorProfileNames: [Swift.String]? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorProfileNames = connectorProfileNames
        self.connectorType = connectorType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeConnectorProfilesInputBody: Swift.Equatable {
    public let connectorProfileNames: [Swift.String]?
    public let connectorType: AppflowClientTypes.ConnectorType?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeConnectorProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileNames
        case connectorType
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .connectorProfileNames)
        var connectorProfileNamesDecoded0:[Swift.String]? = nil
        if let connectorProfileNamesContainer = connectorProfileNamesContainer {
            connectorProfileNamesDecoded0 = [Swift.String]()
            for string0 in connectorProfileNamesContainer {
                if let string0 = string0 {
                    connectorProfileNamesDecoded0?.append(string0)
                }
            }
        }
        connectorProfileNames = connectorProfileNamesDecoded0
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectorProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectorProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectorProfilesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectorProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConnectorProfilesOutputResponse(connectorProfileDetails: \(Swift.String(describing: connectorProfileDetails)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeConnectorProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectorProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileDetails = output.connectorProfileDetails
            self.nextToken = output.nextToken
        } else {
            self.connectorProfileDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectorProfilesOutputResponse: Swift.Equatable {
    /// <p>
    /// Returns information about the connector profiles associated with the flow.
    /// </p>
    public let connectorProfileDetails: [AppflowClientTypes.ConnectorProfile]?
    /// <p>
    ///   The pagination token for the next page of data. If <code>nextToken=null</code>, this means that all records have been fetched.
    /// </p>
    public let nextToken: Swift.String?

    public init (
        connectorProfileDetails: [AppflowClientTypes.ConnectorProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorProfileDetails = connectorProfileDetails
        self.nextToken = nextToken
    }
}

struct DescribeConnectorProfilesOutputResponseBody: Swift.Equatable {
    public let connectorProfileDetails: [AppflowClientTypes.ConnectorProfile]?
    public let nextToken: Swift.String?
}

extension DescribeConnectorProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileDetails
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileDetailsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorProfile?].self, forKey: .connectorProfileDetails)
        var connectorProfileDetailsDecoded0:[AppflowClientTypes.ConnectorProfile]? = nil
        if let connectorProfileDetailsContainer = connectorProfileDetailsContainer {
            connectorProfileDetailsDecoded0 = [AppflowClientTypes.ConnectorProfile]()
            for structure0 in connectorProfileDetailsContainer {
                if let structure0 = structure0 {
                    connectorProfileDetailsDecoded0?.append(structure0)
                }
            }
        }
        connectorProfileDetails = connectorProfileDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeConnectorsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectorsOutputError>
}

extension DescribeConnectorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConnectorsInput(connectorTypes: \(Swift.String(describing: connectorTypes)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeConnectorsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorTypes
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorTypes = connectorTypes {
            var connectorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorTypes)
            for connectortypelist0 in connectorTypes {
                try connectorTypesContainer.encode(connectortypelist0.rawValue)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeConnectorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectorsOutputError>
}

public struct DescribeConnectorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectorsOutputError>
}

public struct DescribeConnectorsInput: Swift.Equatable {
    /// <p>
    ///   The type of connector, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorTypes: [AppflowClientTypes.ConnectorType]?
    /// <p>
    /// The pagination token for the next page of data.
    /// </p>
    public let nextToken: Swift.String?

    public init (
        connectorTypes: [AppflowClientTypes.ConnectorType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorTypes = connectorTypes
        self.nextToken = nextToken
    }
}

struct DescribeConnectorsInputBody: Swift.Equatable {
    public let connectorTypes: [AppflowClientTypes.ConnectorType]?
    public let nextToken: Swift.String?
}

extension DescribeConnectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorTypes
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorType?].self, forKey: .connectorTypes)
        var connectorTypesDecoded0:[AppflowClientTypes.ConnectorType]? = nil
        if let connectorTypesContainer = connectorTypesContainer {
            connectorTypesDecoded0 = [AppflowClientTypes.ConnectorType]()
            for string0 in connectorTypesContainer {
                if let string0 = string0 {
                    connectorTypesDecoded0?.append(string0)
                }
            }
        }
        connectorTypes = connectorTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectorsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConnectorsOutputResponse(connectorConfigurations: \(Swift.String(describing: connectorConfigurations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeConnectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorConfigurations = output.connectorConfigurations
            self.nextToken = output.nextToken
        } else {
            self.connectorConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectorsOutputResponse: Swift.Equatable {
    /// <p>
    ///   The configuration that is applied to the connectors used in the flow.
    /// </p>
    public let connectorConfigurations: [Swift.String:AppflowClientTypes.ConnectorConfiguration]?
    /// <p>
    /// The pagination token for the next page of data.
    /// </p>
    public let nextToken: Swift.String?

    public init (
        connectorConfigurations: [Swift.String:AppflowClientTypes.ConnectorConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorConfigurations = connectorConfigurations
        self.nextToken = nextToken
    }
}

struct DescribeConnectorsOutputResponseBody: Swift.Equatable {
    public let connectorConfigurations: [Swift.String:AppflowClientTypes.ConnectorConfiguration]?
    public let nextToken: Swift.String?
}

extension DescribeConnectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorConfigurations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorConfigurationsContainer = try containerValues.decodeIfPresent([Swift.String: AppflowClientTypes.ConnectorConfiguration?].self, forKey: .connectorConfigurations)
        var connectorConfigurationsDecoded0: [Swift.String:AppflowClientTypes.ConnectorConfiguration]? = nil
        if let connectorConfigurationsContainer = connectorConfigurationsContainer {
            connectorConfigurationsDecoded0 = [Swift.String:AppflowClientTypes.ConnectorConfiguration]()
            for (key0, connectorconfiguration0) in connectorConfigurationsContainer {
                if let connectorconfiguration0 = connectorconfiguration0 {
                    connectorConfigurationsDecoded0?[key0] = connectorconfiguration0
                }
            }
        }
        connectorConfigurations = connectorConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeFlowExecutionRecordsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFlowExecutionRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFlowExecutionRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFlowExecutionRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFlowExecutionRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFlowExecutionRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFlowExecutionRecordsOutputError>
}

extension DescribeFlowExecutionRecordsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFlowExecutionRecordsInput(flowName: \(Swift.String(describing: flowName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeFlowExecutionRecordsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeFlowExecutionRecordsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFlowExecutionRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFlowExecutionRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFlowExecutionRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFlowExecutionRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFlowExecutionRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFlowExecutionRecordsOutputError>
}

public struct DescribeFlowExecutionRecordsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFlowExecutionRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFlowExecutionRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFlowExecutionRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFlowExecutionRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFlowExecutionRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFlowExecutionRecordsOutputError>
}

public struct DescribeFlowExecutionRecordsInput: Swift.Equatable {
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: Swift.String?
    /// <p>
    ///     Specifies the maximum number of items that should be returned in the result set. The default for <code>maxResults</code> is 20 (for all paginated API operations).
    ///   </p>
    public let maxResults: Swift.Int?
    /// <p>
    /// The pagination token for the next page of data.
    /// </p>
    public let nextToken: Swift.String?

    public init (
        flowName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowName = flowName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeFlowExecutionRecordsInputBody: Swift.Equatable {
    public let flowName: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeFlowExecutionRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFlowExecutionRecordsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFlowExecutionRecordsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFlowExecutionRecordsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFlowExecutionRecordsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFlowExecutionRecordsOutputResponse(flowExecutions: \(Swift.String(describing: flowExecutions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeFlowExecutionRecordsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFlowExecutionRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowExecutions = output.flowExecutions
            self.nextToken = output.nextToken
        } else {
            self.flowExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFlowExecutionRecordsOutputResponse: Swift.Equatable {
    /// <p>
    /// Returns a list of all instances when this flow was run.
    /// </p>
    public let flowExecutions: [AppflowClientTypes.ExecutionRecord]?
    /// <p>
    ///  The pagination token for the next page of data.
    /// </p>
    public let nextToken: Swift.String?

    public init (
        flowExecutions: [AppflowClientTypes.ExecutionRecord]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowExecutions = flowExecutions
        self.nextToken = nextToken
    }
}

struct DescribeFlowExecutionRecordsOutputResponseBody: Swift.Equatable {
    public let flowExecutions: [AppflowClientTypes.ExecutionRecord]?
    public let nextToken: Swift.String?
}

extension DescribeFlowExecutionRecordsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowExecutions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowExecutionsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ExecutionRecord?].self, forKey: .flowExecutions)
        var flowExecutionsDecoded0:[AppflowClientTypes.ExecutionRecord]? = nil
        if let flowExecutionsContainer = flowExecutionsContainer {
            flowExecutionsDecoded0 = [AppflowClientTypes.ExecutionRecord]()
            for structure0 in flowExecutionsContainer {
                if let structure0 = structure0 {
                    flowExecutionsDecoded0?.append(structure0)
                }
            }
        }
        flowExecutions = flowExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeFlowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFlowOutputError>
}

extension DescribeFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFlowInput(flowName: \(Swift.String(describing: flowName)))"}
}

extension DescribeFlowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

public struct DescribeFlowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFlowOutputError>
}

public struct DescribeFlowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFlowOutputError>
}

public struct DescribeFlowInput: Swift.Equatable {
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: Swift.String?

    public init (
        flowName: Swift.String? = nil
    )
    {
        self.flowName = flowName
    }
}

struct DescribeFlowInputBody: Swift.Equatable {
    public let flowName: Swift.String?
}

extension DescribeFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension DescribeFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFlowOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFlowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFlowOutputResponse(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), description: \(Swift.String(describing: description)), destinationFlowConfigList: \(Swift.String(describing: destinationFlowConfigList)), flowArn: \(Swift.String(describing: flowArn)), flowName: \(Swift.String(describing: flowName)), flowStatus: \(Swift.String(describing: flowStatus)), flowStatusMessage: \(Swift.String(describing: flowStatusMessage)), kmsArn: \(Swift.String(describing: kmsArn)), lastRunExecutionDetails: \(Swift.String(describing: lastRunExecutionDetails)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), lastUpdatedBy: \(Swift.String(describing: lastUpdatedBy)), sourceFlowConfig: \(Swift.String(describing: sourceFlowConfig)), tags: \(Swift.String(describing: tags)), tasks: \(Swift.String(describing: tasks)), triggerConfig: \(Swift.String(describing: triggerConfig)))"}
}

extension DescribeFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.destinationFlowConfigList = output.destinationFlowConfigList
            self.flowArn = output.flowArn
            self.flowName = output.flowName
            self.flowStatus = output.flowStatus
            self.flowStatusMessage = output.flowStatusMessage
            self.kmsArn = output.kmsArn
            self.lastRunExecutionDetails = output.lastRunExecutionDetails
            self.lastUpdatedAt = output.lastUpdatedAt
            self.lastUpdatedBy = output.lastUpdatedBy
            self.sourceFlowConfig = output.sourceFlowConfig
            self.tags = output.tags
            self.tasks = output.tasks
            self.triggerConfig = output.triggerConfig
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.destinationFlowConfigList = nil
            self.flowArn = nil
            self.flowName = nil
            self.flowStatus = nil
            self.flowStatusMessage = nil
            self.kmsArn = nil
            self.lastRunExecutionDetails = nil
            self.lastUpdatedAt = nil
            self.lastUpdatedBy = nil
            self.sourceFlowConfig = nil
            self.tags = nil
            self.tasks = nil
            self.triggerConfig = nil
        }
    }
}

public struct DescribeFlowOutputResponse: Swift.Equatable {
    /// <p>
    /// Specifies when the flow was created.
    /// </p>
    public let createdAt: ClientRuntime.Date?
    /// <p>
    ///   The ARN of the user who created the flow.
    /// </p>
    public let createdBy: Swift.String?
    /// <p>
    ///   A description of the flow.
    /// </p>
    public let description: Swift.String?
    /// <p>
    ///   The configuration that controls how Amazon AppFlow transfers data to the destination connector.
    /// </p>
    public let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// <p>
    ///   The flow's Amazon Resource Name (ARN).
    /// </p>
    public let flowArn: Swift.String?
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: Swift.String?
    /// <p>
    ///       Indicates the current status of the flow.
    ///     </p>
    public let flowStatus: AppflowClientTypes.FlowStatus?
    /// <p>
    ///       Contains an error message if the flow status is in a suspended or error state. This applies only to scheduled or event-triggered flows.
    ///     </p>
    public let flowStatusMessage: Swift.String?
    /// <p>
    ///   The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    /// </p>
    public let kmsArn: Swift.String?
    /// <p>
    /// Describes the details of the most recent flow run.
    /// </p>
    public let lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails?
    /// <p>
    ///   Specifies when the flow was last updated.
    /// </p>
    public let lastUpdatedAt: ClientRuntime.Date?
    /// <p>
    /// Specifies the user name of the account that performed the most recent update.
    /// </p>
    public let lastUpdatedBy: Swift.String?
    /// <p>
    ///   The configuration that controls how Amazon AppFlow retrieves data from the source connector.
    /// </p>
    public let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// <p>
    ///   The tags used to organize, track, or control access for your flow.
    /// </p>
    public let tags: [Swift.String:Swift.String]?
    /// <p>
    ///   A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// </p>
    public let tasks: [AppflowClientTypes.Task]?
    /// <p>
    ///   The trigger settings that determine how and when the flow runs.
    /// </p>
    public let triggerConfig: AppflowClientTypes.TriggerConfig?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowArn: Swift.String? = nil,
        flowName: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil,
        flowStatusMessage: Swift.String? = nil,
        kmsArn: Swift.String? = nil,
        lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        lastUpdatedBy: Swift.String? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowArn = flowArn
        self.flowName = flowName
        self.flowStatus = flowStatus
        self.flowStatusMessage = flowStatusMessage
        self.kmsArn = kmsArn
        self.lastRunExecutionDetails = lastRunExecutionDetails
        self.lastUpdatedAt = lastUpdatedAt
        self.lastUpdatedBy = lastUpdatedBy
        self.sourceFlowConfig = sourceFlowConfig
        self.tags = tags
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct DescribeFlowOutputResponseBody: Swift.Equatable {
    public let flowArn: Swift.String?
    public let description: Swift.String?
    public let flowName: Swift.String?
    public let kmsArn: Swift.String?
    public let flowStatus: AppflowClientTypes.FlowStatus?
    public let flowStatusMessage: Swift.String?
    public let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    public let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    public let lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails?
    public let triggerConfig: AppflowClientTypes.TriggerConfig?
    public let tasks: [AppflowClientTypes.Task]?
    public let createdAt: ClientRuntime.Date?
    public let lastUpdatedAt: ClientRuntime.Date?
    public let createdBy: Swift.String?
    public let lastUpdatedBy: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case destinationFlowConfigList
        case flowArn
        case flowName
        case flowStatus
        case flowStatusMessage
        case kmsArn
        case lastRunExecutionDetails
        case lastUpdatedAt
        case lastUpdatedBy
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let flowStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowStatusMessage)
        flowStatusMessage = flowStatusMessageDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([AppflowClientTypes.DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[AppflowClientTypes.DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [AppflowClientTypes.DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let lastRunExecutionDetailsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionDetails.self, forKey: .lastRunExecutionDetails)
        lastRunExecutionDetails = lastRunExecutionDetailsDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let tasksContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Task?].self, forKey: .tasks)
        var tasksDecoded0:[AppflowClientTypes.Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [AppflowClientTypes.Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AppflowClientTypes.DestinationConnectorProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerProfiles = "CustomerProfiles"
        case eventBridge = "EventBridge"
        case honeycode = "Honeycode"
        case lookoutMetrics = "LookoutMetrics"
        case redshift = "Redshift"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case snowflake = "Snowflake"
        case upsolver = "Upsolver"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerProfiles = customerProfiles {
            try encodeContainer.encode(customerProfiles, forKey: .customerProfiles)
        }
        if let eventBridge = eventBridge {
            try encodeContainer.encode(eventBridge, forKey: .eventBridge)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let lookoutMetrics = lookoutMetrics {
            try encodeContainer.encode(lookoutMetrics, forKey: .lookoutMetrics)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let upsolver = upsolver {
            try encodeContainer.encode(upsolver, forKey: .upsolver)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftDestinationProperties.self, forKey: .redshift)
        redshift = redshiftDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3DestinationProperties.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceDestinationProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeDestinationProperties.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let eventBridgeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.EventBridgeDestinationProperties.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
        let lookoutMetricsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.LookoutMetricsDestinationProperties.self, forKey: .lookoutMetrics)
        lookoutMetrics = lookoutMetricsDecoded
        let upsolverDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.UpsolverDestinationProperties.self, forKey: .upsolver)
        upsolver = upsolverDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeDestinationProperties.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let customerProfilesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CustomerProfilesDestinationProperties.self, forKey: .customerProfiles)
        customerProfiles = customerProfilesDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskDestinationProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension AppflowClientTypes.DestinationConnectorProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DestinationConnectorProperties(customerProfiles: \(Swift.String(describing: customerProfiles)), eventBridge: \(Swift.String(describing: eventBridge)), honeycode: \(Swift.String(describing: honeycode)), lookoutMetrics: \(Swift.String(describing: lookoutMetrics)), redshift: \(Swift.String(describing: redshift)), s3: \(Swift.String(describing: s3)), salesforce: \(Swift.String(describing: salesforce)), snowflake: \(Swift.String(describing: snowflake)), upsolver: \(Swift.String(describing: upsolver)), zendesk: \(Swift.String(describing: zendesk)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   This stores the information that is required to query a particular connector.
    /// </p>
    public struct DestinationConnectorProperties: Swift.Equatable {
        /// <p>
        ///       The properties required to query Amazon Connect Customer Profiles.
        ///     </p>
        public let customerProfiles: AppflowClientTypes.CustomerProfilesDestinationProperties?
        /// <p>
        ///       The properties required to query Amazon EventBridge.
        ///     </p>
        public let eventBridge: AppflowClientTypes.EventBridgeDestinationProperties?
        /// <p>
        ///       The properties required to query Amazon Honeycode.
        ///     </p>
        public let honeycode: AppflowClientTypes.HoneycodeDestinationProperties?
        /// <p>
        ///       The properties required to query Amazon Lookout for Metrics.
        ///     </p>
        public let lookoutMetrics: AppflowClientTypes.LookoutMetricsDestinationProperties?
        /// <p>
        ///   The properties required to query Amazon Redshift.
        /// </p>
        public let redshift: AppflowClientTypes.RedshiftDestinationProperties?
        /// <p>
        ///   The properties required to query Amazon S3.
        /// </p>
        public let s3: AppflowClientTypes.S3DestinationProperties?
        /// <p>
        ///   The properties required to query Salesforce.
        /// </p>
        public let salesforce: AppflowClientTypes.SalesforceDestinationProperties?
        /// <p>
        ///   The properties required to query Snowflake.
        /// </p>
        public let snowflake: AppflowClientTypes.SnowflakeDestinationProperties?
        /// <p>
        ///       The properties required to query Upsolver.
        ///     </p>
        public let upsolver: AppflowClientTypes.UpsolverDestinationProperties?
        public let zendesk: AppflowClientTypes.ZendeskDestinationProperties?

        public init (
            customerProfiles: AppflowClientTypes.CustomerProfilesDestinationProperties? = nil,
            eventBridge: AppflowClientTypes.EventBridgeDestinationProperties? = nil,
            honeycode: AppflowClientTypes.HoneycodeDestinationProperties? = nil,
            lookoutMetrics: AppflowClientTypes.LookoutMetricsDestinationProperties? = nil,
            redshift: AppflowClientTypes.RedshiftDestinationProperties? = nil,
            s3: AppflowClientTypes.S3DestinationProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceDestinationProperties? = nil,
            snowflake: AppflowClientTypes.SnowflakeDestinationProperties? = nil,
            upsolver: AppflowClientTypes.UpsolverDestinationProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskDestinationProperties? = nil
        )
        {
            self.customerProfiles = customerProfiles
            self.eventBridge = eventBridge
            self.honeycode = honeycode
            self.lookoutMetrics = lookoutMetrics
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.snowflake = snowflake
            self.upsolver = upsolver
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.DestinationFieldProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isCreatable
        case isNullable
        case isUpdatable
        case isUpsertable
        case supportedWriteOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isCreatable != false {
            try encodeContainer.encode(isCreatable, forKey: .isCreatable)
        }
        if isNullable != false {
            try encodeContainer.encode(isNullable, forKey: .isNullable)
        }
        if isUpdatable != false {
            try encodeContainer.encode(isUpdatable, forKey: .isUpdatable)
        }
        if isUpsertable != false {
            try encodeContainer.encode(isUpsertable, forKey: .isUpsertable)
        }
        if let supportedWriteOperations = supportedWriteOperations {
            var supportedWriteOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedWriteOperations)
            for supportedwriteoperationlist0 in supportedWriteOperations {
                try supportedWriteOperationsContainer.encode(supportedwriteoperationlist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isCreatableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isCreatable)
        isCreatable = isCreatableDecoded
        let isNullableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isNullable)
        isNullable = isNullableDecoded
        let isUpsertableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isUpsertable)
        isUpsertable = isUpsertableDecoded
        let isUpdatableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isUpdatable)
        isUpdatable = isUpdatableDecoded
        let supportedWriteOperationsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.WriteOperationType?].self, forKey: .supportedWriteOperations)
        var supportedWriteOperationsDecoded0:[AppflowClientTypes.WriteOperationType]? = nil
        if let supportedWriteOperationsContainer = supportedWriteOperationsContainer {
            supportedWriteOperationsDecoded0 = [AppflowClientTypes.WriteOperationType]()
            for string0 in supportedWriteOperationsContainer {
                if let string0 = string0 {
                    supportedWriteOperationsDecoded0?.append(string0)
                }
            }
        }
        supportedWriteOperations = supportedWriteOperationsDecoded0
    }
}

extension AppflowClientTypes.DestinationFieldProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DestinationFieldProperties(isCreatable: \(Swift.String(describing: isCreatable)), isNullable: \(Swift.String(describing: isNullable)), isUpdatable: \(Swift.String(describing: isUpdatable)), isUpsertable: \(Swift.String(describing: isUpsertable)), supportedWriteOperations: \(Swift.String(describing: supportedWriteOperations)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that can be applied to a field when connector is being used as a destination.
    /// </p>
    public struct DestinationFieldProperties: Swift.Equatable {
        /// <p>
        ///   Specifies if the destination field can be created by the current user.
        /// </p>
        public let isCreatable: Swift.Bool
        /// <p>
        ///   Specifies if the destination field can have a null value.
        /// </p>
        public let isNullable: Swift.Bool
        /// <p>
        ///       Specifies whether the field can be updated during an <code>UPDATE</code> or <code>UPSERT</code> write operation.
        ///     </p>
        public let isUpdatable: Swift.Bool
        /// <p>
        ///       Specifies if the flow run can either insert new rows in the destination field if they do not already exist, or update them if they do.
        ///     </p>
        public let isUpsertable: Swift.Bool
        /// <p>
        ///       A list of supported write operations. For each write operation listed, this field can be used in <code>idFieldNames</code> when that write operation is present as a destination option.
        ///     </p>
        public let supportedWriteOperations: [AppflowClientTypes.WriteOperationType]?

        public init (
            isCreatable: Swift.Bool = false,
            isNullable: Swift.Bool = false,
            isUpdatable: Swift.Bool = false,
            isUpsertable: Swift.Bool = false,
            supportedWriteOperations: [AppflowClientTypes.WriteOperationType]? = nil
        )
        {
            self.isCreatable = isCreatable
            self.isNullable = isNullable
            self.isUpdatable = isUpdatable
            self.isUpsertable = isUpsertable
            self.supportedWriteOperations = supportedWriteOperations
        }
    }

}

extension AppflowClientTypes.DestinationFlowConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case connectorType
        case destinationConnectorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let destinationConnectorProperties = destinationConnectorProperties {
            try encodeContainer.encode(destinationConnectorProperties, forKey: .destinationConnectorProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let destinationConnectorPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DestinationConnectorProperties.self, forKey: .destinationConnectorProperties)
        destinationConnectorProperties = destinationConnectorPropertiesDecoded
    }
}

extension AppflowClientTypes.DestinationFlowConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DestinationFlowConfig(connectorProfileName: \(Swift.String(describing: connectorProfileName)), connectorType: \(Swift.String(describing: connectorType)), destinationConnectorProperties: \(Swift.String(describing: destinationConnectorProperties)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   Contains information about the configuration of destination connectors present in the flow.
    /// </p>
    public struct DestinationFlowConfig: Swift.Equatable {
        /// <p>
        ///   The name of the connector profile. This name must be unique for each connector profile in the AWS account.
        /// </p>
        public let connectorProfileName: Swift.String?
        /// <p>
        ///   The type of connector, such as Salesforce, Amplitude, and so on.
        /// </p>
        public let connectorType: AppflowClientTypes.ConnectorType?
        /// <p>
        ///   This stores the information that is required to query a particular connector.
        /// </p>
        public let destinationConnectorProperties: AppflowClientTypes.DestinationConnectorProperties?

        public init (
            connectorProfileName: Swift.String? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            destinationConnectorProperties: AppflowClientTypes.DestinationConnectorProperties? = nil
        )
        {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.destinationConnectorProperties = destinationConnectorProperties
        }
    }

}

extension AppflowClientTypes {
    public enum DynatraceConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [DynatraceConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DynatraceConnectorOperator(rawValue: rawValue) ?? DynatraceConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.DynatraceConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiToken = apiToken {
            try encodeContainer.encode(apiToken, forKey: .apiToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiToken)
        apiToken = apiTokenDecoded
    }
}

extension AppflowClientTypes.DynatraceConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DynatraceConnectorProfileCredentials(apiToken: \(Swift.String(describing: apiToken)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required by Dynatrace.
    /// </p>
    public struct DynatraceConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   The API tokens used by Dynatrace API to authenticate various API calls.
        /// </p>
        public let apiToken: Swift.String?

        public init (
            apiToken: Swift.String? = nil
        )
        {
            self.apiToken = apiToken
        }
    }

}

extension AppflowClientTypes.DynatraceConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes.DynatraceConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DynatraceConnectorProfileProperties(instanceUrl: \(Swift.String(describing: instanceUrl)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required by Dynatrace.
    /// </p>
    public struct DynatraceConnectorProfileProperties: Swift.Equatable {
        /// <p>
        ///   The location of the Dynatrace resource.
        /// </p>
        public let instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.DynatraceMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.DynatraceMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DynatraceMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Dynatrace.
    /// </p>
    public struct DynatraceMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.DynatraceSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.DynatraceSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DynatraceSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Dynatrace is being used as a source.
    /// </p>
    public struct DynatraceSourceProperties: Swift.Equatable {
        /// <p>
        ///   The object specified in the Dynatrace flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.ErrorHandlingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case failOnFirstDestinationError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if failOnFirstDestinationError != false {
            try encodeContainer.encode(failOnFirstDestinationError, forKey: .failOnFirstDestinationError)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failOnFirstDestinationErrorDecoded = try containerValues.decode(Swift.Bool.self, forKey: .failOnFirstDestinationError)
        failOnFirstDestinationError = failOnFirstDestinationErrorDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension AppflowClientTypes.ErrorHandlingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ErrorHandlingConfig(bucketName: \(Swift.String(describing: bucketName)), bucketPrefix: \(Swift.String(describing: bucketPrefix)), failOnFirstDestinationError: \(Swift.String(describing: failOnFirstDestinationError)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
    ///
    /// </p>
    public struct ErrorHandlingConfig: Swift.Equatable {
        /// <p>
        /// Specifies the name of the Amazon S3 bucket.
        /// </p>
        public let bucketName: Swift.String?
        /// <p>
        /// Specifies the Amazon S3 bucket prefix.
        /// </p>
        public let bucketPrefix: Swift.String?
        /// <p>
        /// Specifies if the flow should fail after the first instance of a failure when attempting to place data in the destination.
        /// </p>
        public let failOnFirstDestinationError: Swift.Bool

        public init (
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            failOnFirstDestinationError: Swift.Bool = false
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.failOnFirstDestinationError = failOnFirstDestinationError
        }
    }

}

extension AppflowClientTypes.ErrorInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionMessage
        case putFailuresCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionMessage = executionMessage {
            try encodeContainer.encode(executionMessage, forKey: .executionMessage)
        }
        if let putFailuresCount = putFailuresCount {
            try encodeContainer.encode(putFailuresCount, forKey: .putFailuresCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let putFailuresCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .putFailuresCount)
        putFailuresCount = putFailuresCountDecoded
        let executionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionMessage)
        executionMessage = executionMessageDecoded
    }
}

extension AppflowClientTypes.ErrorInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ErrorInfo(executionMessage: \(Swift.String(describing: executionMessage)), putFailuresCount: \(Swift.String(describing: putFailuresCount)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// Provides details in the event of a failed flow, including the failure count and the related error messages.
    /// </p>
    public struct ErrorInfo: Swift.Equatable {
        /// <p>
        /// Specifies the error message that appears if a flow fails.
        /// </p>
        public let executionMessage: Swift.String?
        /// <p>
        /// Specifies the failure count for the attempted flow.
        /// </p>
        public let putFailuresCount: Swift.Int?

        public init (
            executionMessage: Swift.String? = nil,
            putFailuresCount: Swift.Int? = nil
        )
        {
            self.executionMessage = executionMessage
            self.putFailuresCount = putFailuresCount
        }
    }

}

extension AppflowClientTypes.EventBridgeDestinationProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes.EventBridgeDestinationProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventBridgeDestinationProperties(errorHandlingConfig: \(Swift.String(describing: errorHandlingConfig)), object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The properties that are applied when Amazon EventBridge is being used as a destination.
    ///     </p>
    public struct EventBridgeDestinationProperties: Swift.Equatable {
        /// <p>
        ///   The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
        ///
        /// </p>
        public let errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// <p>
        ///       The object specified in the Amazon EventBridge flow destination.
        ///     </p>
        public let object: Swift.String?

        public init (
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            object: Swift.String? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }
    }

}

extension AppflowClientTypes.EventBridgeMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.EventBridgeMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventBridgeMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The connector metadata specific to Amazon EventBridge.
    ///     </p>
    public struct EventBridgeMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.ExecutionDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mostRecentExecutionMessage
        case mostRecentExecutionStatus
        case mostRecentExecutionTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mostRecentExecutionMessage = mostRecentExecutionMessage {
            try encodeContainer.encode(mostRecentExecutionMessage, forKey: .mostRecentExecutionMessage)
        }
        if let mostRecentExecutionStatus = mostRecentExecutionStatus {
            try encodeContainer.encode(mostRecentExecutionStatus.rawValue, forKey: .mostRecentExecutionStatus)
        }
        if let mostRecentExecutionTime = mostRecentExecutionTime {
            try encodeContainer.encode(mostRecentExecutionTime.timeIntervalSince1970, forKey: .mostRecentExecutionTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mostRecentExecutionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mostRecentExecutionMessage)
        mostRecentExecutionMessage = mostRecentExecutionMessageDecoded
        let mostRecentExecutionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .mostRecentExecutionTime)
        mostRecentExecutionTime = mostRecentExecutionTimeDecoded
        let mostRecentExecutionStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionStatus.self, forKey: .mostRecentExecutionStatus)
        mostRecentExecutionStatus = mostRecentExecutionStatusDecoded
    }
}

extension AppflowClientTypes.ExecutionDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionDetails(mostRecentExecutionMessage: \(Swift.String(describing: mostRecentExecutionMessage)), mostRecentExecutionStatus: \(Swift.String(describing: mostRecentExecutionStatus)), mostRecentExecutionTime: \(Swift.String(describing: mostRecentExecutionTime)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   Describes the details of the flow run, including the timestamp, status, and message.
    /// </p>
    public struct ExecutionDetails: Swift.Equatable {
        /// <p>
        ///   Describes the details of the most recent flow run.
        /// </p>
        public let mostRecentExecutionMessage: Swift.String?
        /// <p>
        ///   Specifies the status of the most recent flow run.
        /// </p>
        public let mostRecentExecutionStatus: AppflowClientTypes.ExecutionStatus?
        /// <p>
        ///   Specifies the time of the most recent flow run.
        /// </p>
        public let mostRecentExecutionTime: ClientRuntime.Date?

        public init (
            mostRecentExecutionMessage: Swift.String? = nil,
            mostRecentExecutionStatus: AppflowClientTypes.ExecutionStatus? = nil,
            mostRecentExecutionTime: ClientRuntime.Date? = nil
        )
        {
            self.mostRecentExecutionMessage = mostRecentExecutionMessage
            self.mostRecentExecutionStatus = mostRecentExecutionStatus
            self.mostRecentExecutionTime = mostRecentExecutionTime
        }
    }

}

extension AppflowClientTypes.ExecutionRecord: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPullEndTime
        case dataPullStartTime
        case executionId
        case executionResult
        case executionStatus
        case lastUpdatedAt
        case startedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPullEndTime = dataPullEndTime {
            try encodeContainer.encode(dataPullEndTime.timeIntervalSince1970, forKey: .dataPullEndTime)
        }
        if let dataPullStartTime = dataPullStartTime {
            try encodeContainer.encode(dataPullStartTime.timeIntervalSince1970, forKey: .dataPullStartTime)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let executionResult = executionResult {
            try encodeContainer.encode(executionResult, forKey: .executionResult)
        }
        if let executionStatus = executionStatus {
            try encodeContainer.encode(executionStatus.rawValue, forKey: .executionStatus)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let executionStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionStatus.self, forKey: .executionStatus)
        executionStatus = executionStatusDecoded
        let executionResultDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionResult.self, forKey: .executionResult)
        executionResult = executionResultDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let dataPullStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dataPullStartTime)
        dataPullStartTime = dataPullStartTimeDecoded
        let dataPullEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dataPullEndTime)
        dataPullEndTime = dataPullEndTimeDecoded
    }
}

extension AppflowClientTypes.ExecutionRecord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionRecord(dataPullEndTime: \(Swift.String(describing: dataPullEndTime)), dataPullStartTime: \(Swift.String(describing: dataPullStartTime)), executionId: \(Swift.String(describing: executionId)), executionResult: \(Swift.String(describing: executionResult)), executionStatus: \(Swift.String(describing: executionStatus)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), startedAt: \(Swift.String(describing: startedAt)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// Specifies information about the past flow run instances for a given flow.
    /// </p>
    public struct ExecutionRecord: Swift.Equatable {
        /// <p>
        /// The timestamp that indicates the last new or updated record to be transferred in the flow run.
        /// </p>
        public let dataPullEndTime: ClientRuntime.Date?
        /// <p>
        /// The timestamp that determines the first new or updated record to be transferred in the flow run.
        /// </p>
        public let dataPullStartTime: ClientRuntime.Date?
        /// <p>
        /// Specifies the identifier of the given flow run.
        /// </p>
        public let executionId: Swift.String?
        /// <p>
        /// Describes the result of the given flow run.
        /// </p>
        public let executionResult: AppflowClientTypes.ExecutionResult?
        /// <p>
        /// Specifies the flow run status and whether it is in progress, has completed successfully, or has failed.
        /// </p>
        public let executionStatus: AppflowClientTypes.ExecutionStatus?
        /// <p>
        ///   Specifies the time of the most recent update.
        /// </p>
        public let lastUpdatedAt: ClientRuntime.Date?
        /// <p>
        /// Specifies the start time of the flow run.
        /// </p>
        public let startedAt: ClientRuntime.Date?

        public init (
            dataPullEndTime: ClientRuntime.Date? = nil,
            dataPullStartTime: ClientRuntime.Date? = nil,
            executionId: Swift.String? = nil,
            executionResult: AppflowClientTypes.ExecutionResult? = nil,
            executionStatus: AppflowClientTypes.ExecutionStatus? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            startedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataPullEndTime = dataPullEndTime
            self.dataPullStartTime = dataPullStartTime
            self.executionId = executionId
            self.executionResult = executionResult
            self.executionStatus = executionStatus
            self.lastUpdatedAt = lastUpdatedAt
            self.startedAt = startedAt
        }
    }

}

extension AppflowClientTypes.ExecutionResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesProcessed
        case bytesWritten
        case errorInfo
        case recordsProcessed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesProcessed = bytesProcessed {
            try encodeContainer.encode(bytesProcessed, forKey: .bytesProcessed)
        }
        if let bytesWritten = bytesWritten {
            try encodeContainer.encode(bytesWritten, forKey: .bytesWritten)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let recordsProcessed = recordsProcessed {
            try encodeContainer.encode(recordsProcessed, forKey: .recordsProcessed)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorInfoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let bytesProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesProcessed)
        bytesProcessed = bytesProcessedDecoded
        let bytesWrittenDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesWritten)
        bytesWritten = bytesWrittenDecoded
        let recordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsProcessed)
        recordsProcessed = recordsProcessedDecoded
    }
}

extension AppflowClientTypes.ExecutionResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionResult(bytesProcessed: \(Swift.String(describing: bytesProcessed)), bytesWritten: \(Swift.String(describing: bytesWritten)), errorInfo: \(Swift.String(describing: errorInfo)), recordsProcessed: \(Swift.String(describing: recordsProcessed)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// Specifies the end result of the flow run.
    /// </p>
    public struct ExecutionResult: Swift.Equatable {
        /// <p>
        ///   The total number of bytes processed by the flow run.
        /// </p>
        public let bytesProcessed: Swift.Int?
        /// <p>
        ///   The total number of bytes written as a result of the flow run.
        /// </p>
        public let bytesWritten: Swift.Int?
        /// <p>
        /// Provides any error message information related to the flow run.
        /// </p>
        public let errorInfo: AppflowClientTypes.ErrorInfo?
        /// <p>
        /// The number of records processed in the flow run.
        /// </p>
        public let recordsProcessed: Swift.Int?

        public init (
            bytesProcessed: Swift.Int? = nil,
            bytesWritten: Swift.Int? = nil,
            errorInfo: AppflowClientTypes.ErrorInfo? = nil,
            recordsProcessed: Swift.Int? = nil
        )
        {
            self.bytesProcessed = bytesProcessed
            self.bytesWritten = bytesWritten
            self.errorInfo = errorInfo
            self.recordsProcessed = recordsProcessed
        }
    }

}

extension AppflowClientTypes {
    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .error,
                .inprogress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "Error"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.FieldTypeDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldType
        case filterOperators
        case supportedValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldType = fieldType {
            try encodeContainer.encode(fieldType, forKey: .fieldType)
        }
        if let filterOperators = filterOperators {
            var filterOperatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterOperators)
            for filteroperatorlist0 in filterOperators {
                try filterOperatorsContainer.encode(filteroperatorlist0.rawValue)
            }
        }
        if let supportedValues = supportedValues {
            var supportedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedValues)
            for supportedvaluelist0 in supportedValues {
                try supportedValuesContainer.encode(supportedvaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldType)
        fieldType = fieldTypeDecoded
        let filterOperatorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Operator?].self, forKey: .filterOperators)
        var filterOperatorsDecoded0:[AppflowClientTypes.Operator]? = nil
        if let filterOperatorsContainer = filterOperatorsContainer {
            filterOperatorsDecoded0 = [AppflowClientTypes.Operator]()
            for string0 in filterOperatorsContainer {
                if let string0 = string0 {
                    filterOperatorsDecoded0?.append(string0)
                }
            }
        }
        filterOperators = filterOperatorsDecoded0
        let supportedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedValues)
        var supportedValuesDecoded0:[Swift.String]? = nil
        if let supportedValuesContainer = supportedValuesContainer {
            supportedValuesDecoded0 = [Swift.String]()
            for string0 in supportedValuesContainer {
                if let string0 = string0 {
                    supportedValuesDecoded0?.append(string0)
                }
            }
        }
        supportedValues = supportedValuesDecoded0
    }
}

extension AppflowClientTypes.FieldTypeDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldTypeDetails(fieldType: \(Swift.String(describing: fieldType)), filterOperators: \(Swift.String(describing: filterOperators)), supportedValues: \(Swift.String(describing: supportedValues)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///  Contains details regarding the supported field type and the operators that can be applied for filtering.
    /// </p>
    public struct FieldTypeDetails: Swift.Equatable {
        /// <p>
        /// The type of field, such as string, integer, date, and so on.
        /// </p>
        public let fieldType: Swift.String?
        /// <p>
        /// The list of operators supported by a field.
        /// </p>
        public let filterOperators: [AppflowClientTypes.Operator]?
        /// <p>
        ///  The list of values that a field can contain. For example, a Boolean <code>fieldType</code> can have two values: "true" and "false".
        /// </p>
        public let supportedValues: [Swift.String]?

        public init (
            fieldType: Swift.String? = nil,
            filterOperators: [AppflowClientTypes.Operator]? = nil,
            supportedValues: [Swift.String]? = nil
        )
        {
            self.fieldType = fieldType
            self.filterOperators = filterOperators
            self.supportedValues = supportedValues
        }
    }

}

extension AppflowClientTypes {
    public enum FileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [FileType] {
            return [
                .csv,
                .json,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileType(rawValue: rawValue) ?? FileType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.FlowDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case destinationConnectorType
        case flowArn
        case flowName
        case flowStatus
        case lastRunExecutionDetails
        case lastUpdatedAt
        case lastUpdatedBy
        case sourceConnectorType
        case tags
        case triggerType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConnectorType = destinationConnectorType {
            try encodeContainer.encode(destinationConnectorType.rawValue, forKey: .destinationConnectorType)
        }
        if let flowArn = flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let flowStatus = flowStatus {
            try encodeContainer.encode(flowStatus.rawValue, forKey: .flowStatus)
        }
        if let lastRunExecutionDetails = lastRunExecutionDetails {
            try encodeContainer.encode(lastRunExecutionDetails, forKey: .lastRunExecutionDetails)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let lastUpdatedBy = lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let sourceConnectorType = sourceConnectorType {
            try encodeContainer.encode(sourceConnectorType.rawValue, forKey: .sourceConnectorType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let sourceConnectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .sourceConnectorType)
        sourceConnectorType = sourceConnectorTypeDecoded
        let destinationConnectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .destinationConnectorType)
        destinationConnectorType = destinationConnectorTypeDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastRunExecutionDetailsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionDetails.self, forKey: .lastRunExecutionDetails)
        lastRunExecutionDetails = lastRunExecutionDetailsDecoded
    }
}

extension AppflowClientTypes.FlowDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FlowDefinition(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), description: \(Swift.String(describing: description)), destinationConnectorType: \(Swift.String(describing: destinationConnectorType)), flowArn: \(Swift.String(describing: flowArn)), flowName: \(Swift.String(describing: flowName)), flowStatus: \(Swift.String(describing: flowStatus)), lastRunExecutionDetails: \(Swift.String(describing: lastRunExecutionDetails)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), lastUpdatedBy: \(Swift.String(describing: lastUpdatedBy)), sourceConnectorType: \(Swift.String(describing: sourceConnectorType)), tags: \(Swift.String(describing: tags)), triggerType: \(Swift.String(describing: triggerType)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// The properties of the flow, such as its source, destination, trigger type, and so on.
    /// </p>
    public struct FlowDefinition: Swift.Equatable {
        /// <p>
        ///   Specifies when the flow was created.
        /// </p>
        public let createdAt: ClientRuntime.Date?
        /// <p>
        ///   The ARN of the user who created the flow.
        /// </p>
        public let createdBy: Swift.String?
        /// <p>
        ///   A user-entered description of the flow.
        /// </p>
        public let description: Swift.String?
        /// <p>
        ///   Specifies the destination connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        /// </p>
        public let destinationConnectorType: AppflowClientTypes.ConnectorType?
        /// <p>
        ///   The flow's Amazon Resource Name (ARN).
        /// </p>
        public let flowArn: Swift.String?
        /// <p>
        ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        /// </p>
        public let flowName: Swift.String?
        /// <p>
        ///   Indicates the current status of the flow.
        /// </p>
        public let flowStatus: AppflowClientTypes.FlowStatus?
        /// <p>
        ///   Describes the details of the most recent flow run.
        /// </p>
        public let lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails?
        /// <p>
        ///   Specifies when the flow was last updated.
        /// </p>
        public let lastUpdatedAt: ClientRuntime.Date?
        /// <p>
        ///   Specifies the account user name that most recently updated the flow.
        /// </p>
        public let lastUpdatedBy: Swift.String?
        /// <p>
        ///   Specifies the source connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        /// </p>
        public let sourceConnectorType: AppflowClientTypes.ConnectorType?
        /// <p>
        /// The tags used to organize, track, or control access for your flow.
        /// </p>
        public let tags: [Swift.String:Swift.String]?
        /// <p>
        ///   Specifies the type of flow trigger. This can be <code>OnDemand</code>, <code>Scheduled</code>, or <code>Event</code>.
        /// </p>
        public let triggerType: AppflowClientTypes.TriggerType?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            destinationConnectorType: AppflowClientTypes.ConnectorType? = nil,
            flowArn: Swift.String? = nil,
            flowName: Swift.String? = nil,
            flowStatus: AppflowClientTypes.FlowStatus? = nil,
            lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            sourceConnectorType: AppflowClientTypes.ConnectorType? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            triggerType: AppflowClientTypes.TriggerType? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.destinationConnectorType = destinationConnectorType
            self.flowArn = flowArn
            self.flowName = flowName
            self.flowStatus = flowStatus
            self.lastRunExecutionDetails = lastRunExecutionDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.sourceConnectorType = sourceConnectorType
            self.tags = tags
            self.triggerType = triggerType
        }
    }

}

extension AppflowClientTypes {
    public enum FlowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case deprecated
        case draft
        case errored
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowStatus] {
            return [
                .active,
                .deleted,
                .deprecated,
                .draft,
                .errored,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleted: return "Deleted"
            case .deprecated: return "Deprecated"
            case .draft: return "Draft"
            case .errored: return "Errored"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FlowStatus(rawValue: rawValue) ?? FlowStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum GoogleAnalyticsConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case projection
        case sdkUnknown(Swift.String)

        public static var allCases: [GoogleAnalyticsConnectorOperator] {
            return [
                .between,
                .projection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .projection: return "PROJECTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GoogleAnalyticsConnectorOperator(rawValue: rawValue) ?? GoogleAnalyticsConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GoogleAnalyticsConnectorProfileCredentials(accessToken: \(Swift.String(describing: accessToken)), clientId: \(Swift.String(describing: clientId)), clientSecret: \(Swift.String(describing: clientSecret)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required by Google Analytics.
    /// </p>
    public struct GoogleAnalyticsConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        /// The credentials used to access protected Google Analytics resources.
        /// </p>
        public let accessToken: Swift.String?
        /// <p>
        ///   The identifier for the desired client.
        /// </p>
        public let clientId: Swift.String?
        /// <p>
        ///   The client secret used by the OAuth client to authenticate to the authorization server.
        /// </p>
        public let clientSecret: Swift.String?
        /// <p>
        ///   The OAuth requirement needed to request security tokens from the connector endpoint.
        /// </p>
        public let oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// <p>
        ///   The credentials used to acquire new access tokens. This is required only for OAuth2 access tokens, and is not required for OAuth1 access tokens.
        /// </p>
        public let refreshToken: Swift.String?

        public init (
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GoogleAnalyticsConnectorProfileProperties()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required by Google Analytics.
    /// </p>
    public struct GoogleAnalyticsConnectorProfileProperties: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.GoogleAnalyticsMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes.GoogleAnalyticsMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GoogleAnalyticsMetadata(oAuthScopes: \(Swift.String(describing: oAuthScopes)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Google Analytics.
    /// </p>
    public struct GoogleAnalyticsMetadata: Swift.Equatable {
        /// <p>
        ///   The desired authorization scope for the Google Analytics account.
        /// </p>
        public let oAuthScopes: [Swift.String]?

        public init (
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.GoogleAnalyticsSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.GoogleAnalyticsSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GoogleAnalyticsSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Google Analytics is being used as a source.
    /// </p>
    public struct GoogleAnalyticsSourceProperties: Swift.Equatable {
        /// <p>
        ///   The object specified in the Google Analytics flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.HoneycodeConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.HoneycodeConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HoneycodeConnectorProfileCredentials(accessToken: \(Swift.String(describing: accessToken)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The connector-specific credentials required when using Amazon Honeycode.
    ///     </p>
    public struct HoneycodeConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///       The credentials used to access protected Amazon Honeycode resources.
        ///     </p>
        public let accessToken: Swift.String?
        /// <p>
        ///  Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
        /// </p>
        public let oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// <p>
        ///       The credentials used to acquire new access tokens.
        ///     </p>
        public let refreshToken: Swift.String?

        public init (
            accessToken: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.HoneycodeConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.HoneycodeConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HoneycodeConnectorProfileProperties()"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The connector-specific properties required when using Amazon Honeycode.
    ///     </p>
    public struct HoneycodeConnectorProfileProperties: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.HoneycodeDestinationProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes.HoneycodeDestinationProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HoneycodeDestinationProperties(errorHandlingConfig: \(Swift.String(describing: errorHandlingConfig)), object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The properties that are applied when Amazon Honeycode is used as a destination.
    ///     </p>
    public struct HoneycodeDestinationProperties: Swift.Equatable {
        /// <p>
        ///   The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
        ///
        /// </p>
        public let errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// <p>
        ///       The object specified in the Amazon Honeycode flow destination.
        ///     </p>
        public let object: Swift.String?

        public init (
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            object: Swift.String? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }
    }

}

extension AppflowClientTypes.HoneycodeMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes.HoneycodeMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HoneycodeMetadata(oAuthScopes: \(Swift.String(describing: oAuthScopes)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The connector metadata specific to Amazon Honeycode.
    ///     </p>
    public struct HoneycodeMetadata: Swift.Equatable {
        /// <p>
        ///       The desired authorization scope for the Amazon Honeycode account.
        ///     </p>
        public let oAuthScopes: [Swift.String]?

        public init (
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.IncrementalPullConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datetimeTypeFieldName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datetimeTypeFieldName = datetimeTypeFieldName {
            try encodeContainer.encode(datetimeTypeFieldName, forKey: .datetimeTypeFieldName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datetimeTypeFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datetimeTypeFieldName)
        datetimeTypeFieldName = datetimeTypeFieldNameDecoded
    }
}

extension AppflowClientTypes.IncrementalPullConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncrementalPullConfig(datetimeTypeFieldName: \(Swift.String(describing: datetimeTypeFieldName)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// Specifies the configuration used when importing incremental records from the source.
    /// </p>
    public struct IncrementalPullConfig: Swift.Equatable {
        /// <p>
        ///       A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        ///     </p>
        public let datetimeTypeFieldName: Swift.String?

        public init (
            datetimeTypeFieldName: Swift.String? = nil
        )
        {
            self.datetimeTypeFieldName = datetimeTypeFieldName
        }
    }

}

extension AppflowClientTypes {
    public enum InforNexusConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [InforNexusConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InforNexusConnectorOperator(rawValue: rawValue) ?? InforNexusConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.InforNexusConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId
        case datakey
        case secretAccessKey
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let datakey = datakey {
            try encodeContainer.encode(datakey, forKey: .datakey)
        }
        if let secretAccessKey = secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let datakeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datakey)
        datakey = datakeyDecoded
    }
}

extension AppflowClientTypes.InforNexusConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InforNexusConnectorProfileCredentials(accessKeyId: \(Swift.String(describing: accessKeyId)), datakey: \(Swift.String(describing: datakey)), secretAccessKey: \(Swift.String(describing: secretAccessKey)), userId: \(Swift.String(describing: userId)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required by Infor Nexus.
    /// </p>
    public struct InforNexusConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   The Access Key portion of the credentials.
        /// </p>
        public let accessKeyId: Swift.String?
        /// <p>
        ///   The encryption keys used to encrypt data.
        /// </p>
        public let datakey: Swift.String?
        /// <p>
        ///   The secret key used to sign requests.
        /// </p>
        public let secretAccessKey: Swift.String?
        /// <p>
        ///   The identifier for the user.
        /// </p>
        public let userId: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            datakey: Swift.String? = nil,
            secretAccessKey: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.datakey = datakey
            self.secretAccessKey = secretAccessKey
            self.userId = userId
        }
    }

}

extension AppflowClientTypes.InforNexusConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes.InforNexusConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InforNexusConnectorProfileProperties(instanceUrl: \(Swift.String(describing: instanceUrl)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required by Infor Nexus.
    /// </p>
    public struct InforNexusConnectorProfileProperties: Swift.Equatable {
        /// <p>
        ///   The location of the Infor Nexus resource.
        /// </p>
        public let instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.InforNexusMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.InforNexusMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InforNexusMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Infor Nexus.
    /// </p>
    public struct InforNexusMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.InforNexusSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.InforNexusSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InforNexusSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Infor Nexus is being used as a source.
    /// </p>
    public struct InforNexusSourceProperties: Swift.Equatable {
        /// <p>
        ///   The object specified in the Infor Nexus flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///  An internal service error occurred during the processing of your request. Try again later.
/// </p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListConnectorEntitiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectorEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectorEntitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectorEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectorEntitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectorEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectorEntitiesOutputError>
}

extension ListConnectorEntitiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConnectorEntitiesInput(connectorProfileName: \(Swift.String(describing: connectorProfileName)), connectorType: \(Swift.String(describing: connectorType)), entitiesPath: \(Swift.String(describing: entitiesPath)))"}
}

extension ListConnectorEntitiesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case connectorType
        case entitiesPath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let entitiesPath = entitiesPath {
            try encodeContainer.encode(entitiesPath, forKey: .entitiesPath)
        }
    }
}

public struct ListConnectorEntitiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectorEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectorEntitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectorEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectorEntitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectorEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectorEntitiesOutputError>
}

public struct ListConnectorEntitiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectorEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectorEntitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectorEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectorEntitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectorEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectorEntitiesOutputError>
}

public struct ListConnectorEntitiesInput: Swift.Equatable {
    /// <p>
    ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in the AWS account, and is used to query the downstream connector.
    /// </p>
    public let connectorProfileName: Swift.String?
    /// <p>
    ///   The type of connector, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorType: AppflowClientTypes.ConnectorType?
    /// <p>
    ///   This optional parameter is specific to connector implementation. Some connectors support multiple levels or categories of entities. You can find out the list of roots for such providers by sending a request without the <code>entitiesPath</code> parameter. If the connector supports entities at different roots, this initial request returns the list of roots. Otherwise, this request returns all entities supported by the provider.
    /// </p>
    public let entitiesPath: Swift.String?

    public init (
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        entitiesPath: Swift.String? = nil
    )
    {
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.entitiesPath = entitiesPath
    }
}

struct ListConnectorEntitiesInputBody: Swift.Equatable {
    public let connectorProfileName: Swift.String?
    public let connectorType: AppflowClientTypes.ConnectorType?
    public let entitiesPath: Swift.String?
}

extension ListConnectorEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case connectorType
        case entitiesPath
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let entitiesPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitiesPath)
        entitiesPath = entitiesPathDecoded
    }
}

extension ListConnectorEntitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectorEntitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectorEntitiesOutputError: Swift.Error, Swift.Equatable {
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectorEntitiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConnectorEntitiesOutputResponse(connectorEntityMap: \(Swift.String(describing: connectorEntityMap)))"}
}

extension ListConnectorEntitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConnectorEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorEntityMap = output.connectorEntityMap
        } else {
            self.connectorEntityMap = nil
        }
    }
}

public struct ListConnectorEntitiesOutputResponse: Swift.Equatable {
    /// <p>
    ///  The response of <code>ListConnectorEntities</code> lists entities grouped by category. This map's key represents the group name, and its value contains the list of entities belonging to that group.
    /// </p>
    public let connectorEntityMap: [Swift.String:[AppflowClientTypes.ConnectorEntity]]?

    public init (
        connectorEntityMap: [Swift.String:[AppflowClientTypes.ConnectorEntity]]? = nil
    )
    {
        self.connectorEntityMap = connectorEntityMap
    }
}

struct ListConnectorEntitiesOutputResponseBody: Swift.Equatable {
    public let connectorEntityMap: [Swift.String:[AppflowClientTypes.ConnectorEntity]]?
}

extension ListConnectorEntitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorEntityMap
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityMapContainer = try containerValues.decodeIfPresent([Swift.String: [AppflowClientTypes.ConnectorEntity?]?].self, forKey: .connectorEntityMap)
        var connectorEntityMapDecoded0: [Swift.String:[AppflowClientTypes.ConnectorEntity]]? = nil
        if let connectorEntityMapContainer = connectorEntityMapContainer {
            connectorEntityMapDecoded0 = [Swift.String:[AppflowClientTypes.ConnectorEntity]]()
            for (key0, connectorentitylist0) in connectorEntityMapContainer {
                var connectorentitylist0Decoded0: [AppflowClientTypes.ConnectorEntity]? = nil
                if let connectorentitylist0 = connectorentitylist0 {
                    connectorentitylist0Decoded0 = [AppflowClientTypes.ConnectorEntity]()
                    for structure1 in connectorentitylist0 {
                        if let structure1 = structure1 {
                            connectorentitylist0Decoded0?.append(structure1)
                        }
                    }
                }
                connectorEntityMapDecoded0?[key0] = connectorentitylist0Decoded0
            }
        }
        connectorEntityMap = connectorEntityMapDecoded0
    }
}

public struct ListFlowsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFlowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFlowsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFlowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFlowsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFlowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFlowsOutputError>
}

extension ListFlowsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFlowsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFlowsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFlowsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFlowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFlowsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFlowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFlowsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFlowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFlowsOutputError>
}

public struct ListFlowsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFlowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFlowsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFlowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFlowsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFlowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFlowsOutputError>
}

public struct ListFlowsInput: Swift.Equatable {
    /// <p>
    ///       Specifies the maximum number of items that should be returned in the result set.
    ///     </p>
    public let maxResults: Swift.Int?
    /// <p>
    ///  The pagination token for next page of data.
    /// </p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFlowsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListFlowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFlowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFlowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFlowsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFlowsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFlowsOutputResponse(flows: \(Swift.String(describing: flows)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFlowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFlowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flows = output.flows
            self.nextToken = output.nextToken
        } else {
            self.flows = nil
            self.nextToken = nil
        }
    }
}

public struct ListFlowsOutputResponse: Swift.Equatable {
    /// <p>
    /// The list of flows associated with your account.
    /// </p>
    public let flows: [AppflowClientTypes.FlowDefinition]?
    /// <p>
    /// The pagination token for next page of data.
    /// </p>
    public let nextToken: Swift.String?

    public init (
        flows: [AppflowClientTypes.FlowDefinition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flows = flows
        self.nextToken = nextToken
    }
}

struct ListFlowsOutputResponseBody: Swift.Equatable {
    public let flows: [AppflowClientTypes.FlowDefinition]?
    public let nextToken: Swift.String?
}

extension ListFlowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flows
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.FlowDefinition?].self, forKey: .flows)
        var flowsDecoded0:[AppflowClientTypes.FlowDefinition]? = nil
        if let flowsContainer = flowsContainer {
            flowsDecoded0 = [AppflowClientTypes.FlowDefinition]()
            for structure0 in flowsContainer {
                if let structure0 = structure0 {
                    flowsDecoded0?.append(structure0)
                }
            }
        }
        flows = flowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>
    ///   The Amazon Resource Name (ARN) of the specified flow.
    /// </p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>
    ///  The tags used to organize, track, or control access for your flow.
    /// </p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AppflowClientTypes.LookoutMetricsDestinationProperties: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.LookoutMetricsDestinationProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LookoutMetricsDestinationProperties()"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The properties that are applied when Amazon Lookout for Metrics is used as a destination.
    ///     </p>
    public struct LookoutMetricsDestinationProperties: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes {
    public enum MarketoConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case greaterThan
        case lessThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketoConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .greaterThan,
                .lessThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MarketoConnectorOperator(rawValue: rawValue) ?? MarketoConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.MarketoConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.MarketoConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MarketoConnectorProfileCredentials(accessToken: \(Swift.String(describing: accessToken)), clientId: \(Swift.String(describing: clientId)), clientSecret: \(Swift.String(describing: clientSecret)), oAuthRequest: \(Swift.String(describing: oAuthRequest)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required by Marketo.
    /// </p>
    public struct MarketoConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   The credentials used to access protected Marketo resources.
        /// </p>
        public let accessToken: Swift.String?
        /// <p>
        ///   The identifier for the desired client.
        /// </p>
        public let clientId: Swift.String?
        /// <p>
        ///   The client secret used by the OAuth client to authenticate to the authorization server.
        /// </p>
        public let clientSecret: Swift.String?
        /// <p>
        ///   The OAuth requirement needed to request security tokens from the connector endpoint.
        /// </p>
        public let oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init (
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }

}

extension AppflowClientTypes.MarketoConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes.MarketoConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MarketoConnectorProfileProperties(instanceUrl: \(Swift.String(describing: instanceUrl)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required when using Marketo.
    /// </p>
    public struct MarketoConnectorProfileProperties: Swift.Equatable {
        /// <p>
        ///   The location of the Marketo resource.
        /// </p>
        public let instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.MarketoMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.MarketoMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MarketoMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Marketo.
    /// </p>
    public struct MarketoMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.MarketoSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.MarketoSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MarketoSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Marketo is being used as a source.
    /// </p>
    public struct MarketoSourceProperties: Swift.Equatable {
        /// <p>
        ///   The object specified in the Marketo flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes {
    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum OperatorPropertiesKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concatFormat
        case dataType
        case destinationDataType
        case lowerBound
        case maskLength
        case maskValue
        case mathOperationFieldsOrder
        case sourceDataType
        case subfieldCategoryMap
        case truncateLength
        case upperBound
        case validationAction
        case value
        case values
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatorPropertiesKeys] {
            return [
                .concatFormat,
                .dataType,
                .destinationDataType,
                .lowerBound,
                .maskLength,
                .maskValue,
                .mathOperationFieldsOrder,
                .sourceDataType,
                .subfieldCategoryMap,
                .truncateLength,
                .upperBound,
                .validationAction,
                .value,
                .values,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concatFormat: return "CONCAT_FORMAT"
            case .dataType: return "DATA_TYPE"
            case .destinationDataType: return "DESTINATION_DATA_TYPE"
            case .lowerBound: return "LOWER_BOUND"
            case .maskLength: return "MASK_LENGTH"
            case .maskValue: return "MASK_VALUE"
            case .mathOperationFieldsOrder: return "MATH_OPERATION_FIELDS_ORDER"
            case .sourceDataType: return "SOURCE_DATA_TYPE"
            case .subfieldCategoryMap: return "SUBFIELD_CATEGORY_MAP"
            case .truncateLength: return "TRUNCATE_LENGTH"
            case .upperBound: return "UPPER_BOUND"
            case .validationAction: return "VALIDATION_ACTION"
            case .value: return "VALUE"
            case .values: return "VALUES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatorPropertiesKeys(rawValue: rawValue) ?? OperatorPropertiesKeys.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.PrefixConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case prefixFormat
        case prefixType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prefixFormat = prefixFormat {
            try encodeContainer.encode(prefixFormat.rawValue, forKey: .prefixFormat)
        }
        if let prefixType = prefixType {
            try encodeContainer.encode(prefixType.rawValue, forKey: .prefixType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixType.self, forKey: .prefixType)
        prefixType = prefixTypeDecoded
        let prefixFormatDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixFormat.self, forKey: .prefixFormat)
        prefixFormat = prefixFormatDecoded
    }
}

extension AppflowClientTypes.PrefixConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrefixConfig(prefixFormat: \(Swift.String(describing: prefixFormat)), prefixType: \(Swift.String(describing: prefixType)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// Determines the prefix that Amazon AppFlow applies to the destination folder name. You can name your destination folders according to the flow frequency and date.
    ///     </p>
    public struct PrefixConfig: Swift.Equatable {
        /// <p>
        ///       Determines the level of granularity that's included in the prefix.
        ///     </p>
        public let prefixFormat: AppflowClientTypes.PrefixFormat?
        /// <p>
        ///       Determines the format of the prefix, and whether it applies to the file name, file path, or both.
        ///     </p>
        public let prefixType: AppflowClientTypes.PrefixType?

        public init (
            prefixFormat: AppflowClientTypes.PrefixFormat? = nil,
            prefixType: AppflowClientTypes.PrefixType? = nil
        )
        {
            self.prefixFormat = prefixFormat
            self.prefixType = prefixType
        }
    }

}

extension AppflowClientTypes {
    public enum PrefixFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case hour
        case minute
        case month
        case year
        case sdkUnknown(Swift.String)

        public static var allCases: [PrefixFormat] {
            return [
                .day,
                .hour,
                .minute,
                .month,
                .year,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .minute: return "MINUTE"
            case .month: return "MONTH"
            case .year: return "YEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrefixFormat(rawValue: rawValue) ?? PrefixFormat.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum PrefixType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filename
        case path
        case pathAndFilename
        case sdkUnknown(Swift.String)

        public static var allCases: [PrefixType] {
            return [
                .filename,
                .path,
                .pathAndFilename,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filename: return "FILENAME"
            case .path: return "PATH"
            case .pathAndFilename: return "PATH_AND_FILENAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrefixType(rawValue: rawValue) ?? PrefixType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.RedshiftConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes.RedshiftConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftConnectorProfileCredentials(password: \(Swift.String(describing: password)), username: \(Swift.String(describing: username)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required when using Amazon Redshift.
    /// </p>
    public struct RedshiftConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   The password that corresponds to the user name.
        /// </p>
        public let password: Swift.String?
        /// <p>
        ///   The name of the user.
        /// </p>
        public let username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.RedshiftConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case databaseUrl
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let databaseUrl = databaseUrl {
            try encodeContainer.encode(databaseUrl, forKey: .databaseUrl)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseUrl)
        databaseUrl = databaseUrlDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AppflowClientTypes.RedshiftConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftConnectorProfileProperties(bucketName: \(Swift.String(describing: bucketName)), bucketPrefix: \(Swift.String(describing: bucketPrefix)), databaseUrl: \(Swift.String(describing: databaseUrl)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties when using Amazon Redshift.
    /// </p>
    public struct RedshiftConnectorProfileProperties: Swift.Equatable {
        /// <p>
        ///   A name for the associated Amazon S3 bucket.
        /// </p>
        public let bucketName: Swift.String?
        /// <p>
        ///   The object key for the destination bucket in which Amazon AppFlow places the files.
        /// </p>
        public let bucketPrefix: Swift.String?
        /// <p>
        /// The JDBC URL of the Amazon Redshift cluster.
        /// </p>
        public let databaseUrl: Swift.String?
        /// <p>
        ///   The Amazon Resource Name (ARN) of the IAM role.
        /// </p>
        public let roleArn: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            databaseUrl: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.databaseUrl = databaseUrl
            self.roleArn = roleArn
        }
    }

}

extension AppflowClientTypes.RedshiftDestinationProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketPrefix
        case errorHandlingConfig
        case intermediateBucketName
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let intermediateBucketName = intermediateBucketName {
            try encodeContainer.encode(intermediateBucketName, forKey: .intermediateBucketName)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let intermediateBucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intermediateBucketName)
        intermediateBucketName = intermediateBucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes.RedshiftDestinationProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftDestinationProperties(bucketPrefix: \(Swift.String(describing: bucketPrefix)), errorHandlingConfig: \(Swift.String(describing: errorHandlingConfig)), intermediateBucketName: \(Swift.String(describing: intermediateBucketName)), object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Amazon Redshift is being used as a destination.
    /// </p>
    public struct RedshiftDestinationProperties: Swift.Equatable {
        /// <p>
        ///   The object key for the bucket in which Amazon AppFlow places the destination files.
        /// </p>
        public let bucketPrefix: Swift.String?
        /// <p>
        ///   The settings that determine how Amazon AppFlow handles an error when placing data in the Amazon Redshift destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
        /// </p>
        public let errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// <p>
        ///  The intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
        /// </p>
        public let intermediateBucketName: Swift.String?
        /// <p>
        ///   The object specified in the Amazon Redshift flow destination.
        /// </p>
        public let object: Swift.String?

        public init (
            bucketPrefix: Swift.String? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            intermediateBucketName: Swift.String? = nil,
            object: Swift.String? = nil
        )
        {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }
    }

}

extension AppflowClientTypes.RedshiftMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.RedshiftMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Amazon Redshift.
    /// </p>
    public struct RedshiftMetadata: Swift.Equatable {

        public init() {}
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///   The resource specified in the request (such as the source or destination connector profile) is not found.
/// </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum S3ConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ConnectorOperator(rawValue: rawValue) ?? S3ConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.S3DestinationProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case s3OutputFormatConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let s3OutputFormatConfig = s3OutputFormatConfig {
            try encodeContainer.encode(s3OutputFormatConfig, forKey: .s3OutputFormatConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let s3OutputFormatConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3OutputFormatConfig.self, forKey: .s3OutputFormatConfig)
        s3OutputFormatConfig = s3OutputFormatConfigDecoded
    }
}

extension AppflowClientTypes.S3DestinationProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3DestinationProperties(bucketName: \(Swift.String(describing: bucketName)), bucketPrefix: \(Swift.String(describing: bucketPrefix)), s3OutputFormatConfig: \(Swift.String(describing: s3OutputFormatConfig)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Amazon S3 is used as a destination.
    /// </p>
    public struct S3DestinationProperties: Swift.Equatable {
        /// <p>
        ///   The Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        /// </p>
        public let bucketName: Swift.String?
        /// <p>
        ///   The object key for the destination bucket in which Amazon AppFlow places the files.
        /// </p>
        public let bucketPrefix: Swift.String?
        /// <p>
        /// The configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination.
        ///     </p>
        public let s3OutputFormatConfig: AppflowClientTypes.S3OutputFormatConfig?

        public init (
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            s3OutputFormatConfig: AppflowClientTypes.S3OutputFormatConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }
    }

}

extension AppflowClientTypes.S3Metadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.S3Metadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Metadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Amazon S3.
    /// </p>
    public struct S3Metadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.S3OutputFormatConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationConfig
        case fileType
        case prefixConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationConfig = aggregationConfig {
            try encodeContainer.encode(aggregationConfig, forKey: .aggregationConfig)
        }
        if let fileType = fileType {
            try encodeContainer.encode(fileType.rawValue, forKey: .fileType)
        }
        if let prefixConfig = prefixConfig {
            try encodeContainer.encode(prefixConfig, forKey: .prefixConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let prefixConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixConfig.self, forKey: .prefixConfig)
        prefixConfig = prefixConfigDecoded
        let aggregationConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AggregationConfig.self, forKey: .aggregationConfig)
        aggregationConfig = aggregationConfigDecoded
    }
}

extension AppflowClientTypes.S3OutputFormatConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3OutputFormatConfig(aggregationConfig: \(Swift.String(describing: aggregationConfig)), fileType: \(Swift.String(describing: fileType)), prefixConfig: \(Swift.String(describing: prefixConfig)))"}
}

extension AppflowClientTypes {
    /// <p>
    /// The configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination.
    ///     </p>
    public struct S3OutputFormatConfig: Swift.Equatable {
        /// <p>
        /// The aggregation settings that you can use to customize the output format of your flow data.
        /// </p>
        public let aggregationConfig: AppflowClientTypes.AggregationConfig?
        /// <p>
        /// Indicates the file type that Amazon AppFlow places in the Amazon S3 bucket.
        ///     </p>
        public let fileType: AppflowClientTypes.FileType?
        /// <p>
        ///       Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date.
        ///     </p>
        public let prefixConfig: AppflowClientTypes.PrefixConfig?

        public init (
            aggregationConfig: AppflowClientTypes.AggregationConfig? = nil,
            fileType: AppflowClientTypes.FileType? = nil,
            prefixConfig: AppflowClientTypes.PrefixConfig? = nil
        )
        {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
        }
    }

}

extension AppflowClientTypes.S3SourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
    }
}

extension AppflowClientTypes.S3SourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3SourceProperties(bucketName: \(Swift.String(describing: bucketName)), bucketPrefix: \(Swift.String(describing: bucketPrefix)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Amazon S3 is being used as the flow source.
    /// </p>
    public struct S3SourceProperties: Swift.Equatable {
        /// <p>
        ///   The Amazon S3 bucket name where the source files are stored.
        /// </p>
        public let bucketName: Swift.String?
        /// <p>
        ///   The object key for the Amazon S3 bucket in which the source files are stored.
        /// </p>
        public let bucketPrefix: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
        }
    }

}

extension AppflowClientTypes {
    public enum SalesforceConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SalesforceConnectorOperator(rawValue: rawValue) ?? SalesforceConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SalesforceConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientCredentialsArn
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientCredentialsArn = clientCredentialsArn {
            try encodeContainer.encode(clientCredentialsArn, forKey: .clientCredentialsArn)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
        let clientCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCredentialsArn)
        clientCredentialsArn = clientCredentialsArnDecoded
    }
}

extension AppflowClientTypes.SalesforceConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceConnectorProfileCredentials(accessToken: \(Swift.String(describing: accessToken)), clientCredentialsArn: \(Swift.String(describing: clientCredentialsArn)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required when using Salesforce.
    /// </p>
    public struct SalesforceConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   The credentials used to access protected Salesforce resources.
        /// </p>
        public let accessToken: Swift.String?
        /// <p>
        ///       The secret manager ARN, which contains the client ID and client secret of the connected app.
        ///     </p>
        public let clientCredentialsArn: Swift.String?
        /// <p>
        ///   The OAuth requirement needed to request security tokens from the connector endpoint.
        /// </p>
        public let oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// <p>
        ///   The credentials used to acquire new access tokens.
        /// </p>
        public let refreshToken: Swift.String?

        public init (
            accessToken: Swift.String? = nil,
            clientCredentialsArn: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientCredentialsArn = clientCredentialsArn
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.SalesforceConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
        case isSandboxEnvironment
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
        if isSandboxEnvironment != false {
            try encodeContainer.encode(isSandboxEnvironment, forKey: .isSandboxEnvironment)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
        let isSandboxEnvironmentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isSandboxEnvironment)
        isSandboxEnvironment = isSandboxEnvironmentDecoded
    }
}

extension AppflowClientTypes.SalesforceConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceConnectorProfileProperties(instanceUrl: \(Swift.String(describing: instanceUrl)), isSandboxEnvironment: \(Swift.String(describing: isSandboxEnvironment)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required when using Salesforce.
    /// </p>
    public struct SalesforceConnectorProfileProperties: Swift.Equatable {
        /// <p>
        ///   The location of the Salesforce resource.
        /// </p>
        public let instanceUrl: Swift.String?
        /// <p>
        ///  Indicates whether the connector profile applies to a sandbox or production environment.
        /// </p>
        public let isSandboxEnvironment: Swift.Bool

        public init (
            instanceUrl: Swift.String? = nil,
            isSandboxEnvironment: Swift.Bool = false
        )
        {
            self.instanceUrl = instanceUrl
            self.isSandboxEnvironment = isSandboxEnvironment
        }
    }

}

extension AppflowClientTypes.SalesforceDestinationProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case idFieldNames
        case object
        case writeOperationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let idFieldNames = idFieldNames {
            var idFieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idFieldNames)
            for idfieldnamelist0 in idFieldNames {
                try idFieldNamesContainer.encode(idfieldnamelist0)
            }
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let writeOperationType = writeOperationType {
            try encodeContainer.encode(writeOperationType.rawValue, forKey: .writeOperationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let idFieldNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .idFieldNames)
        var idFieldNamesDecoded0:[Swift.String]? = nil
        if let idFieldNamesContainer = idFieldNamesContainer {
            idFieldNamesDecoded0 = [Swift.String]()
            for string0 in idFieldNamesContainer {
                if let string0 = string0 {
                    idFieldNamesDecoded0?.append(string0)
                }
            }
        }
        idFieldNames = idFieldNamesDecoded0
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
        let writeOperationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.WriteOperationType.self, forKey: .writeOperationType)
        writeOperationType = writeOperationTypeDecoded
    }
}

extension AppflowClientTypes.SalesforceDestinationProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceDestinationProperties(errorHandlingConfig: \(Swift.String(describing: errorHandlingConfig)), idFieldNames: \(Swift.String(describing: idFieldNames)), object: \(Swift.String(describing: object)), writeOperationType: \(Swift.String(describing: writeOperationType)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Salesforce is being used as a destination.
    /// </p>
    public struct SalesforceDestinationProperties: Swift.Equatable {
        /// <p>
        ///   The settings that determine how Amazon AppFlow handles an error when placing data in the Salesforce destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
        /// </p>
        public let errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// <p>
        ///       The name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        ///     </p>
        public let idFieldNames: [Swift.String]?
        /// <p>
        ///   The object specified in the Salesforce flow destination.
        /// </p>
        public let object: Swift.String?
        /// <p>
        ///       This specifies the type of write operation to be performed in Salesforce. When the value is <code>UPSERT</code>, then <code>idFieldNames</code> is required.
        ///     </p>
        public let writeOperationType: AppflowClientTypes.WriteOperationType?

        public init (
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            object: Swift.String? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }
    }

}

extension AppflowClientTypes.SalesforceMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes.SalesforceMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceMetadata(oAuthScopes: \(Swift.String(describing: oAuthScopes)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Salesforce.
    /// </p>
    public struct SalesforceMetadata: Swift.Equatable {
        /// <p>
        ///     The desired authorization scope for the Salesforce account.
        /// </p>
        public let oAuthScopes: [Swift.String]?

        public init (
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.SalesforceSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableDynamicFieldUpdate
        case includeDeletedRecords
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableDynamicFieldUpdate != false {
            try encodeContainer.encode(enableDynamicFieldUpdate, forKey: .enableDynamicFieldUpdate)
        }
        if includeDeletedRecords != false {
            try encodeContainer.encode(includeDeletedRecords, forKey: .includeDeletedRecords)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let enableDynamicFieldUpdateDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableDynamicFieldUpdate)
        enableDynamicFieldUpdate = enableDynamicFieldUpdateDecoded
        let includeDeletedRecordsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeDeletedRecords)
        includeDeletedRecords = includeDeletedRecordsDecoded
    }
}

extension AppflowClientTypes.SalesforceSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceSourceProperties(enableDynamicFieldUpdate: \(Swift.String(describing: enableDynamicFieldUpdate)), includeDeletedRecords: \(Swift.String(describing: includeDeletedRecords)), object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Salesforce is being used as a source.
    /// </p>
    public struct SalesforceSourceProperties: Swift.Equatable {
        /// <p>
        /// The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        ///      </p>
        public let enableDynamicFieldUpdate: Swift.Bool
        /// <p>
        ///  Indicates whether Amazon AppFlow includes deleted files in the flow run.
        ///     </p>
        public let includeDeletedRecords: Swift.Bool
        /// <p>
        ///   The object specified in the Salesforce flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            enableDynamicFieldUpdate: Swift.Bool = false,
            includeDeletedRecords: Swift.Bool = false,
            object: Swift.String? = nil
        )
        {
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }
    }

}

extension AppflowClientTypes {
    public enum ScheduleFrequencyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case byminute
        case daily
        case hourly
        case monthly
        case once
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleFrequencyType] {
            return [
                .byminute,
                .daily,
                .hourly,
                .monthly,
                .once,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .byminute: return "BYMINUTE"
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case .once: return "ONCE"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduleFrequencyType(rawValue: rawValue) ?? ScheduleFrequencyType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.ScheduledTriggerProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPullMode
        case firstExecutionFrom
        case scheduleEndTime
        case scheduleExpression
        case scheduleOffset
        case scheduleStartTime
        case timezone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPullMode = dataPullMode {
            try encodeContainer.encode(dataPullMode.rawValue, forKey: .dataPullMode)
        }
        if let firstExecutionFrom = firstExecutionFrom {
            try encodeContainer.encode(firstExecutionFrom.timeIntervalSince1970, forKey: .firstExecutionFrom)
        }
        if let scheduleEndTime = scheduleEndTime {
            try encodeContainer.encode(scheduleEndTime.timeIntervalSince1970, forKey: .scheduleEndTime)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleStartTime = scheduleStartTime {
            try encodeContainer.encode(scheduleStartTime.timeIntervalSince1970, forKey: .scheduleStartTime)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let dataPullModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DataPullMode.self, forKey: .dataPullMode)
        dataPullMode = dataPullModeDecoded
        let scheduleStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduleStartTime)
        scheduleStartTime = scheduleStartTimeDecoded
        let scheduleEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduleEndTime)
        scheduleEndTime = scheduleEndTimeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let firstExecutionFromDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .firstExecutionFrom)
        firstExecutionFrom = firstExecutionFromDecoded
    }
}

extension AppflowClientTypes.ScheduledTriggerProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduledTriggerProperties(dataPullMode: \(Swift.String(describing: dataPullMode)), firstExecutionFrom: \(Swift.String(describing: firstExecutionFrom)), scheduleEndTime: \(Swift.String(describing: scheduleEndTime)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), scheduleStartTime: \(Swift.String(describing: scheduleStartTime)), timezone: \(Swift.String(describing: timezone)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the <code>Scheduled</code> trigger type.
    /// </p>
    public struct ScheduledTriggerProperties: Swift.Equatable {
        /// <p>
        ///  Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        /// </p>
        public let dataPullMode: AppflowClientTypes.DataPullMode?
        /// <p>
        ///       Specifies the date range for the records to import from the connector in the first flow run.
        ///     </p>
        public let firstExecutionFrom: ClientRuntime.Date?
        /// <p>
        ///  Specifies the scheduled end time for a schedule-triggered flow.
        /// </p>
        public let scheduleEndTime: ClientRuntime.Date?
        /// <p>
        ///   The scheduling expression that determines the rate at which the schedule will run, for example <code>rate(5minutes)</code>.
        /// </p>
        public let scheduleExpression: Swift.String?
        /// <p>
        /// Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        /// </p>
        public let scheduleOffset: Swift.Int
        /// <p>
        /// Specifies the scheduled start time for a schedule-triggered flow.
        /// </p>
        public let scheduleStartTime: ClientRuntime.Date?
        /// <p>
        ///   Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as <code>America/New_York</code>.
        /// </p>
        public let timezone: Swift.String?

        public init (
            dataPullMode: AppflowClientTypes.DataPullMode? = nil,
            firstExecutionFrom: ClientRuntime.Date? = nil,
            scheduleEndTime: ClientRuntime.Date? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleOffset: Swift.Int = 0,
            scheduleStartTime: ClientRuntime.Date? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.dataPullMode = dataPullMode
            self.firstExecutionFrom = firstExecutionFrom
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }
    }

}

extension AppflowClientTypes {
    public enum ServiceNowConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNowConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceNowConnectorOperator(rawValue: rawValue) ?? ServiceNowConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.ServiceNowConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes.ServiceNowConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNowConnectorProfileCredentials(password: \(Swift.String(describing: password)), username: \(Swift.String(describing: username)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required when using ServiceNow.
    /// </p>
    public struct ServiceNowConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   The password that corresponds to the user name.
        /// </p>
        public let password: Swift.String?
        /// <p>
        ///   The name of the user.
        /// </p>
        public let username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.ServiceNowConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes.ServiceNowConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNowConnectorProfileProperties(instanceUrl: \(Swift.String(describing: instanceUrl)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required when using ServiceNow.
    /// </p>
    public struct ServiceNowConnectorProfileProperties: Swift.Equatable {
        /// <p>
        ///   The location of the ServiceNow resource.
        /// </p>
        public let instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.ServiceNowMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.ServiceNowMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNowMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to ServiceNow.
    /// </p>
    public struct ServiceNowMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.ServiceNowSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.ServiceNowSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNowSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when ServiceNow is being used as a source.
    /// </p>
    public struct ServiceNowSourceProperties: Swift.Equatable {
        /// <p>
        ///   The object specified in the ServiceNow flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
/// The request would cause a service quota (such as the number of flows) to be exceeded.
/// </p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum SingularConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SingularConnectorOperator] {
            return [
                .addition,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SingularConnectorOperator(rawValue: rawValue) ?? SingularConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SingularConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

extension AppflowClientTypes.SingularConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SingularConnectorProfileCredentials(apiKey: \(Swift.String(describing: apiKey)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required when using Singular.
    /// </p>
    public struct SingularConnectorProfileCredentials: Swift.Equatable {
        /// <p>  A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// </p>
        public let apiKey: Swift.String?

        public init (
            apiKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
        }
    }

}

extension AppflowClientTypes.SingularConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.SingularConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SingularConnectorProfileProperties()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required when using Singular.
    /// </p>
    public struct SingularConnectorProfileProperties: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.SingularMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.SingularMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SingularMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Singular.
    /// </p>
    public struct SingularMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.SingularSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.SingularSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SingularSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Singular is being used as a source.
    /// </p>
    public struct SingularSourceProperties: Swift.Equatable {
        /// <p>
        ///   The object specified in the Singular flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes {
    public enum SlackConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SlackConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlackConnectorOperator(rawValue: rawValue) ?? SlackConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SlackConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.SlackConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SlackConnectorProfileCredentials(accessToken: \(Swift.String(describing: accessToken)), clientId: \(Swift.String(describing: clientId)), clientSecret: \(Swift.String(describing: clientSecret)), oAuthRequest: \(Swift.String(describing: oAuthRequest)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required when using Slack.
    /// </p>
    public struct SlackConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   The credentials used to access protected Slack resources.
        /// </p>
        public let accessToken: Swift.String?
        /// <p>
        ///   The identifier for the client.
        /// </p>
        public let clientId: Swift.String?
        /// <p>
        ///   The client secret used by the OAuth client to authenticate to the authorization server.
        /// </p>
        public let clientSecret: Swift.String?
        /// <p>
        ///   The OAuth requirement needed to request security tokens from the connector endpoint.
        /// </p>
        public let oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init (
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }

}

extension AppflowClientTypes.SlackConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes.SlackConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SlackConnectorProfileProperties(instanceUrl: \(Swift.String(describing: instanceUrl)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required when using Slack.
    /// </p>
    public struct SlackConnectorProfileProperties: Swift.Equatable {
        /// <p>
        ///   The location of the Slack resource.
        /// </p>
        public let instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.SlackMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes.SlackMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SlackMetadata(oAuthScopes: \(Swift.String(describing: oAuthScopes)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Slack.
    /// </p>
    public struct SlackMetadata: Swift.Equatable {
        /// <p>
        /// The desired authorization scope for the Slack account.
        /// </p>
        public let oAuthScopes: [Swift.String]?

        public init (
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.SlackSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.SlackSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SlackSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Slack is being used as a source.
    /// </p>
    public struct SlackSourceProperties: Swift.Equatable {
        /// <p>
        ///   The object specified in the Slack flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.SnowflakeConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes.SnowflakeConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnowflakeConnectorProfileCredentials(password: \(Swift.String(describing: password)), username: \(Swift.String(describing: username)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required when using Snowflake.
    /// </p>
    public struct SnowflakeConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        /// The password that corresponds to the user name.
        /// </p>
        public let password: Swift.String?
        /// <p>
        ///   The name of the user.
        /// </p>
        public let username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.SnowflakeConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountName
        case bucketName
        case bucketPrefix
        case privateLinkServiceName
        case region
        case stage
        case warehouse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let privateLinkServiceName = privateLinkServiceName {
            try encodeContainer.encode(privateLinkServiceName, forKey: .privateLinkServiceName)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
        if let warehouse = warehouse {
            try encodeContainer.encode(warehouse, forKey: .warehouse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let warehouseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warehouse)
        warehouse = warehouseDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let privateLinkServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateLinkServiceName)
        privateLinkServiceName = privateLinkServiceNameDecoded
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension AppflowClientTypes.SnowflakeConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnowflakeConnectorProfileProperties(accountName: \(Swift.String(describing: accountName)), bucketName: \(Swift.String(describing: bucketName)), bucketPrefix: \(Swift.String(describing: bucketPrefix)), privateLinkServiceName: \(Swift.String(describing: privateLinkServiceName)), region: \(Swift.String(describing: region)), stage: \(Swift.String(describing: stage)), warehouse: \(Swift.String(describing: warehouse)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required when using Snowflake.
    /// </p>
    public struct SnowflakeConnectorProfileProperties: Swift.Equatable {
        /// <p>
        /// The name of the account.
        /// </p>
        public let accountName: Swift.String?
        /// <p>
        ///   The name of the Amazon S3 bucket associated with Snowflake.
        /// </p>
        public let bucketName: Swift.String?
        /// <p>
        ///   The bucket path that refers to the Amazon S3 bucket associated with Snowflake.
        /// </p>
        public let bucketPrefix: Swift.String?
        /// <p>
        /// The Snowflake Private Link service name to be used for private data transfers.
        /// </p>
        public let privateLinkServiceName: Swift.String?
        /// <p>
        /// The AWS Region of the Snowflake account.
        /// </p>
        public let region: Swift.String?
        /// <p>
        ///   The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: < Database>< Schema><Stage Name>.
        /// </p>
        public let stage: Swift.String?
        /// <p>
        /// The name of the Snowflake warehouse.
        /// </p>
        public let warehouse: Swift.String?

        public init (
            accountName: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            privateLinkServiceName: Swift.String? = nil,
            region: Swift.String? = nil,
            stage: Swift.String? = nil,
            warehouse: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.privateLinkServiceName = privateLinkServiceName
            self.region = region
            self.stage = stage
            self.warehouse = warehouse
        }
    }

}

extension AppflowClientTypes.SnowflakeDestinationProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketPrefix
        case errorHandlingConfig
        case intermediateBucketName
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let intermediateBucketName = intermediateBucketName {
            try encodeContainer.encode(intermediateBucketName, forKey: .intermediateBucketName)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let intermediateBucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intermediateBucketName)
        intermediateBucketName = intermediateBucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes.SnowflakeDestinationProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnowflakeDestinationProperties(bucketPrefix: \(Swift.String(describing: bucketPrefix)), errorHandlingConfig: \(Swift.String(describing: errorHandlingConfig)), intermediateBucketName: \(Swift.String(describing: intermediateBucketName)), object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when Snowflake is being used as a destination.
    /// </p>
    public struct SnowflakeDestinationProperties: Swift.Equatable {
        /// <p>
        ///   The object key for the destination bucket in which Amazon AppFlow places the files.
        /// </p>
        public let bucketPrefix: Swift.String?
        /// <p>
        ///   The settings that determine how Amazon AppFlow handles an error when placing data in the Snowflake destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
        /// </p>
        public let errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// <p>
        ///  The intermediate bucket that Amazon AppFlow uses when moving data into Snowflake.
        /// </p>
        public let intermediateBucketName: Swift.String?
        /// <p>
        ///   The object specified in the Snowflake flow destination.
        /// </p>
        public let object: Swift.String?

        public init (
            bucketPrefix: Swift.String? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            intermediateBucketName: Swift.String? = nil,
            object: Swift.String? = nil
        )
        {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }
    }

}

extension AppflowClientTypes.SnowflakeMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case supportedRegions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let supportedRegions = supportedRegions {
            var supportedRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedRegions)
            for regionlist0 in supportedRegions {
                try supportedRegionsContainer.encode(regionlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportedRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedRegions)
        var supportedRegionsDecoded0:[Swift.String]? = nil
        if let supportedRegionsContainer = supportedRegionsContainer {
            supportedRegionsDecoded0 = [Swift.String]()
            for string0 in supportedRegionsContainer {
                if let string0 = string0 {
                    supportedRegionsDecoded0?.append(string0)
                }
            }
        }
        supportedRegions = supportedRegionsDecoded0
    }
}

extension AppflowClientTypes.SnowflakeMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnowflakeMetadata(supportedRegions: \(Swift.String(describing: supportedRegions)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Snowflake.
    /// </p>
    public struct SnowflakeMetadata: Swift.Equatable {
        /// <p>
        /// Specifies the supported AWS Regions when using Snowflake.
        /// </p>
        public let supportedRegions: [Swift.String]?

        public init (
            supportedRegions: [Swift.String]? = nil
        )
        {
            self.supportedRegions = supportedRegions
        }
    }

}

extension AppflowClientTypes.SourceConnectorProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeSourceProperties.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogSourceProperties.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceSourceProperties.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsSourceProperties.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusSourceProperties.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoSourceProperties.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3SourceProperties.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceSourceProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowSourceProperties.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularSourceProperties.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackSourceProperties.self, forKey: .slack)
        slack = slackDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroSourceProperties.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaSourceProperties.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskSourceProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension AppflowClientTypes.SourceConnectorProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceConnectorProperties(amplitude: \(Swift.String(describing: amplitude)), datadog: \(Swift.String(describing: datadog)), dynatrace: \(Swift.String(describing: dynatrace)), googleAnalytics: \(Swift.String(describing: googleAnalytics)), inforNexus: \(Swift.String(describing: inforNexus)), marketo: \(Swift.String(describing: marketo)), s3: \(Swift.String(describing: s3)), salesforce: \(Swift.String(describing: salesforce)), serviceNow: \(Swift.String(describing: serviceNow)), singular: \(Swift.String(describing: singular)), slack: \(Swift.String(describing: slack)), trendmicro: \(Swift.String(describing: trendmicro)), veeva: \(Swift.String(describing: veeva)), zendesk: \(Swift.String(describing: zendesk)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///  Specifies the information that is required to query a particular connector.
    /// </p>
    public struct SourceConnectorProperties: Swift.Equatable {
        /// <p>
        ///   Specifies the information that is required for querying Amplitude.
        /// </p>
        public let amplitude: AppflowClientTypes.AmplitudeSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Datadog.
        /// </p>
        public let datadog: AppflowClientTypes.DatadogSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Dynatrace.
        /// </p>
        public let dynatrace: AppflowClientTypes.DynatraceSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Google Analytics.
        /// </p>
        public let googleAnalytics: AppflowClientTypes.GoogleAnalyticsSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Infor Nexus.
        /// </p>
        public let inforNexus: AppflowClientTypes.InforNexusSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Marketo.
        /// </p>
        public let marketo: AppflowClientTypes.MarketoSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Amazon S3.
        /// </p>
        public let s3: AppflowClientTypes.S3SourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Salesforce.
        /// </p>
        public let salesforce: AppflowClientTypes.SalesforceSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying ServiceNow.
        /// </p>
        public let serviceNow: AppflowClientTypes.ServiceNowSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Singular.
        /// </p>
        public let singular: AppflowClientTypes.SingularSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Slack.
        /// </p>
        public let slack: AppflowClientTypes.SlackSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Trend Micro.
        /// </p>
        public let trendmicro: AppflowClientTypes.TrendmicroSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Veeva.
        /// </p>
        public let veeva: AppflowClientTypes.VeevaSourceProperties?
        /// <p>
        ///   Specifies the information that is required for querying Zendesk.
        /// </p>
        public let zendesk: AppflowClientTypes.ZendeskSourceProperties?

        public init (
            amplitude: AppflowClientTypes.AmplitudeSourceProperties? = nil,
            datadog: AppflowClientTypes.DatadogSourceProperties? = nil,
            dynatrace: AppflowClientTypes.DynatraceSourceProperties? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsSourceProperties? = nil,
            inforNexus: AppflowClientTypes.InforNexusSourceProperties? = nil,
            marketo: AppflowClientTypes.MarketoSourceProperties? = nil,
            s3: AppflowClientTypes.S3SourceProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceSourceProperties? = nil,
            serviceNow: AppflowClientTypes.ServiceNowSourceProperties? = nil,
            singular: AppflowClientTypes.SingularSourceProperties? = nil,
            slack: AppflowClientTypes.SlackSourceProperties? = nil,
            trendmicro: AppflowClientTypes.TrendmicroSourceProperties? = nil,
            veeva: AppflowClientTypes.VeevaSourceProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskSourceProperties? = nil
        )
        {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.SourceFieldProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isQueryable
        case isRetrievable
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isQueryable != false {
            try encodeContainer.encode(isQueryable, forKey: .isQueryable)
        }
        if isRetrievable != false {
            try encodeContainer.encode(isRetrievable, forKey: .isRetrievable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isRetrievableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isRetrievable)
        isRetrievable = isRetrievableDecoded
        let isQueryableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isQueryable)
        isQueryable = isQueryableDecoded
    }
}

extension AppflowClientTypes.SourceFieldProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceFieldProperties(isQueryable: \(Swift.String(describing: isQueryable)), isRetrievable: \(Swift.String(describing: isRetrievable)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that can be applied to a field when the connector is being used as a source.
    /// </p>
    public struct SourceFieldProperties: Swift.Equatable {
        /// <p>
        ///  Indicates if the field can be queried.
        /// </p>
        public let isQueryable: Swift.Bool
        /// <p>
        /// Indicates whether the field can be returned in a search result.
        /// </p>
        public let isRetrievable: Swift.Bool

        public init (
            isQueryable: Swift.Bool = false,
            isRetrievable: Swift.Bool = false
        )
        {
            self.isQueryable = isQueryable
            self.isRetrievable = isRetrievable
        }
    }

}

extension AppflowClientTypes.SourceFlowConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case connectorType
        case incrementalPullConfig
        case sourceConnectorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let incrementalPullConfig = incrementalPullConfig {
            try encodeContainer.encode(incrementalPullConfig, forKey: .incrementalPullConfig)
        }
        if let sourceConnectorProperties = sourceConnectorProperties {
            try encodeContainer.encode(sourceConnectorProperties, forKey: .sourceConnectorProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let sourceConnectorPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceConnectorProperties.self, forKey: .sourceConnectorProperties)
        sourceConnectorProperties = sourceConnectorPropertiesDecoded
        let incrementalPullConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.IncrementalPullConfig.self, forKey: .incrementalPullConfig)
        incrementalPullConfig = incrementalPullConfigDecoded
    }
}

extension AppflowClientTypes.SourceFlowConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceFlowConfig(connectorProfileName: \(Swift.String(describing: connectorProfileName)), connectorType: \(Swift.String(describing: connectorType)), incrementalPullConfig: \(Swift.String(describing: incrementalPullConfig)), sourceConnectorProperties: \(Swift.String(describing: sourceConnectorProperties)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///  Contains information about the configuration of the source connector used in the flow.
    /// </p>
    public struct SourceFlowConfig: Swift.Equatable {
        /// <p>
        ///   The name of the connector profile. This name must be unique for each connector profile in the AWS account.
        /// </p>
        public let connectorProfileName: Swift.String?
        /// <p>
        ///   The type of connector, such as Salesforce, Amplitude, and so on.
        /// </p>
        public let connectorType: AppflowClientTypes.ConnectorType?
        /// <p>
        ///       Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        ///     </p>
        public let incrementalPullConfig: AppflowClientTypes.IncrementalPullConfig?
        /// <p>
        ///   Specifies the information that is required to query a particular source connector.
        /// </p>
        public let sourceConnectorProperties: AppflowClientTypes.SourceConnectorProperties?

        public init (
            connectorProfileName: Swift.String? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            incrementalPullConfig: AppflowClientTypes.IncrementalPullConfig? = nil,
            sourceConnectorProperties: AppflowClientTypes.SourceConnectorProperties? = nil
        )
        {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.incrementalPullConfig = incrementalPullConfig
            self.sourceConnectorProperties = sourceConnectorProperties
        }
    }

}

public struct StartFlowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFlowOutputError>
}

extension StartFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFlowInput(flowName: \(Swift.String(describing: flowName)))"}
}

extension StartFlowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

public struct StartFlowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFlowOutputError>
}

public struct StartFlowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFlowOutputError>
}

public struct StartFlowInput: Swift.Equatable {
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: Swift.String?

    public init (
        flowName: Swift.String? = nil
    )
    {
        self.flowName = flowName
    }
}

struct StartFlowInputBody: Swift.Equatable {
    public let flowName: Swift.String?
}

extension StartFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension StartFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFlowOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFlowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFlowOutputResponse(executionId: \(Swift.String(describing: executionId)), flowArn: \(Swift.String(describing: flowArn)), flowStatus: \(Swift.String(describing: flowStatus)))"}
}

extension StartFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executionId = output.executionId
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.executionId = nil
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct StartFlowOutputResponse: Swift.Equatable {
    /// <p>
    ///       Returns the internal execution ID of an on-demand flow when the flow is started. For scheduled or event-triggered flows, this value is null.
    ///     </p>
    public let executionId: Swift.String?
    /// <p>
    ///   The flow's Amazon Resource Name (ARN).
    /// </p>
    public let flowArn: Swift.String?
    /// <p>
    ///   Indicates the current status of the flow.
    ///
    /// </p>
    public let flowStatus: AppflowClientTypes.FlowStatus?

    public init (
        executionId: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.executionId = executionId
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct StartFlowOutputResponseBody: Swift.Equatable {
    public let flowArn: Swift.String?
    public let flowStatus: AppflowClientTypes.FlowStatus?
    public let executionId: Swift.String?
}

extension StartFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId
        case flowArn
        case flowStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
    }
}

public struct StopFlowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopFlowOutputError>
}

extension StopFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopFlowInput(flowName: \(Swift.String(describing: flowName)))"}
}

extension StopFlowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

public struct StopFlowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopFlowOutputError>
}

public struct StopFlowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopFlowOutputError>
}

public struct StopFlowInput: Swift.Equatable {
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: Swift.String?

    public init (
        flowName: Swift.String? = nil
    )
    {
        self.flowName = flowName
    }
}

struct StopFlowInputBody: Swift.Equatable {
    public let flowName: Swift.String?
}

extension StopFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension StopFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopFlowOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopFlowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopFlowOutputResponse(flowArn: \(Swift.String(describing: flowArn)), flowStatus: \(Swift.String(describing: flowStatus)))"}
}

extension StopFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct StopFlowOutputResponse: Swift.Equatable {
    /// <p>
    ///   The flow's Amazon Resource Name (ARN).
    /// </p>
    public let flowArn: Swift.String?
    /// <p>
    ///   Indicates the current status of the flow.
    /// </p>
    public let flowStatus: AppflowClientTypes.FlowStatus?

    public init (
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct StopFlowOutputResponseBody: Swift.Equatable {
    public let flowArn: Swift.String?
    public let flowStatus: AppflowClientTypes.FlowStatus?
}

extension StopFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn
        case flowStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

extension AppflowClientTypes.SupportedFieldTypeDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case v1
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let v1 = v1 {
            try encodeContainer.encode(v1, forKey: .v1)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let v1Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.FieldTypeDetails.self, forKey: .v1)
        v1 = v1Decoded
    }
}

extension AppflowClientTypes.SupportedFieldTypeDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SupportedFieldTypeDetails(v1: \(Swift.String(describing: v1)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///  Contains details regarding all the supported <code>FieldTypes</code> and their corresponding <code>filterOperators</code> and <code>supportedValues</code>.
    /// </p>
    public struct SupportedFieldTypeDetails: Swift.Equatable {
        /// <p>
        ///  The initial supported version for <code>fieldType</code>. If this is later changed to a different version, v2 will be introduced.
        /// </p>
        public let v1: AppflowClientTypes.FieldTypeDetails?

        public init (
            v1: AppflowClientTypes.FieldTypeDetails? = nil
        )
        {
            self.v1 = v1
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>
    ///   The Amazon Resource Name (ARN) of the flow that you want to tag.
    /// </p>
    public let resourceArn: Swift.String?
    /// <p>
    ///   The tags used to organize, track, or control access for your flow.
    /// </p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.Task: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorOperator
        case destinationField
        case sourceFields
        case taskProperties
        case taskType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorOperator = connectorOperator {
            try encodeContainer.encode(connectorOperator, forKey: .connectorOperator)
        }
        if let destinationField = destinationField {
            try encodeContainer.encode(destinationField, forKey: .destinationField)
        }
        if let sourceFields = sourceFields {
            var sourceFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceFields)
            for sourcefields0 in sourceFields {
                try sourceFieldsContainer.encode(sourcefields0)
            }
        }
        if let taskProperties = taskProperties {
            var taskPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskProperties)
            for (dictKey0, taskpropertiesmap0) in taskProperties {
                try taskPropertiesContainer.encode(taskpropertiesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFieldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceFields)
        var sourceFieldsDecoded0:[Swift.String]? = nil
        if let sourceFieldsContainer = sourceFieldsContainer {
            sourceFieldsDecoded0 = [Swift.String]()
            for string0 in sourceFieldsContainer {
                if let string0 = string0 {
                    sourceFieldsDecoded0?.append(string0)
                }
            }
        }
        sourceFields = sourceFieldsDecoded0
        let connectorOperatorDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOperator.self, forKey: .connectorOperator)
        connectorOperator = connectorOperatorDecoded
        let destinationFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationField)
        destinationField = destinationFieldDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .taskProperties)
        var taskPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let taskPropertiesContainer = taskPropertiesContainer {
            taskPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, property0) in taskPropertiesContainer {
                if let property0 = property0 {
                    taskPropertiesDecoded0?[key0] = property0
                }
            }
        }
        taskProperties = taskPropertiesDecoded0
    }
}

extension AppflowClientTypes.Task: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Task(connectorOperator: \(Swift.String(describing: connectorOperator)), destinationField: \(Swift.String(describing: destinationField)), sourceFields: \(Swift.String(describing: sourceFields)), taskProperties: \(Swift.String(describing: taskProperties)), taskType: \(Swift.String(describing: taskType)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   A class for modeling different type of tasks. Task implementation varies based on the <code>TaskType</code>.
    /// </p>
    public struct Task: Swift.Equatable {
        /// <p>
        /// The operation to be performed on the provided source fields.
        /// </p>
        public let connectorOperator: AppflowClientTypes.ConnectorOperator?
        /// <p>
        ///   A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        /// </p>
        public let destinationField: Swift.String?
        /// <p>
        /// The source fields to which a particular task is applied.
        /// </p>
        public let sourceFields: [Swift.String]?
        /// <p>
        ///  A map used to store task-related information. The execution service looks for particular information based on the <code>TaskType</code>.
        /// </p>
        public let taskProperties: [Swift.String:Swift.String]?
        /// <p>
        /// Specifies the particular task implementation that Amazon AppFlow performs.
        /// </p>
        public let taskType: AppflowClientTypes.TaskType?

        public init (
            connectorOperator: AppflowClientTypes.ConnectorOperator? = nil,
            destinationField: Swift.String? = nil,
            sourceFields: [Swift.String]? = nil,
            taskProperties: [Swift.String:Swift.String]? = nil,
            taskType: AppflowClientTypes.TaskType? = nil
        )
        {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }
    }

}

extension AppflowClientTypes {
    public enum TaskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arithmetic
        case filter
        case map
        case mask
        case merge
        case truncate
        case validate
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskType] {
            return [
                .arithmetic,
                .filter,
                .map,
                .mask,
                .merge,
                .truncate,
                .validate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arithmetic: return "Arithmetic"
            case .filter: return "Filter"
            case .map: return "Map"
            case .mask: return "Mask"
            case .merge: return "Merge"
            case .truncate: return "Truncate"
            case .validate: return "Validate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskType(rawValue: rawValue) ?? TaskType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum TrendmicroConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [TrendmicroConnectorOperator] {
            return [
                .addition,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrendmicroConnectorOperator(rawValue: rawValue) ?? TrendmicroConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.TrendmicroConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiSecretKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiSecretKey = apiSecretKey {
            try encodeContainer.encode(apiSecretKey, forKey: .apiSecretKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiSecretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSecretKey)
        apiSecretKey = apiSecretKeyDecoded
    }
}

extension AppflowClientTypes.TrendmicroConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrendmicroConnectorProfileCredentials(apiSecretKey: \(Swift.String(describing: apiSecretKey)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required when using Trend Micro.
    /// </p>
    public struct TrendmicroConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   The Secret Access Key portion of the credentials.
        /// </p>
        public let apiSecretKey: Swift.String?

        public init (
            apiSecretKey: Swift.String? = nil
        )
        {
            self.apiSecretKey = apiSecretKey
        }
    }

}

extension AppflowClientTypes.TrendmicroConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.TrendmicroConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrendmicroConnectorProfileProperties()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required when using Trend Micro.
    /// </p>
    public struct TrendmicroConnectorProfileProperties: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.TrendmicroMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.TrendmicroMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrendmicroMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Trend Micro.
    /// </p>
    public struct TrendmicroMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.TrendmicroSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.TrendmicroSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrendmicroSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when using Trend Micro as a flow source.
    /// </p>
    public struct TrendmicroSourceProperties: Swift.Equatable {
        /// <p>
        ///   The object specified in the Trend Micro flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.TriggerConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case triggerProperties
        case triggerType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerProperties = triggerProperties {
            try encodeContainer.encode(triggerProperties, forKey: .triggerProperties)
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerProperties.self, forKey: .triggerProperties)
        triggerProperties = triggerPropertiesDecoded
    }
}

extension AppflowClientTypes.TriggerConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TriggerConfig(triggerProperties: \(Swift.String(describing: triggerProperties)), triggerType: \(Swift.String(describing: triggerType)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The trigger settings that determine how and when Amazon AppFlow runs the specified flow.
    ///
    ///
    /// </p>
    public struct TriggerConfig: Swift.Equatable {
        /// <p>
        ///   Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the <code>Scheduled</code> trigger type.
        /// </p>
        public let triggerProperties: AppflowClientTypes.TriggerProperties?
        /// <p>
        ///   Specifies the type of flow trigger. This can be <code>OnDemand</code>, <code>Scheduled</code>, or <code>Event</code>.
        /// </p>
        public let triggerType: AppflowClientTypes.TriggerType?

        public init (
            triggerProperties: AppflowClientTypes.TriggerProperties? = nil,
            triggerType: AppflowClientTypes.TriggerType? = nil
        )
        {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }
    }

}

extension AppflowClientTypes.TriggerProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduled = "Scheduled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduled = scheduled {
            try encodeContainer.encode(scheduled, forKey: .scheduled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ScheduledTriggerProperties.self, forKey: .scheduled)
        scheduled = scheduledDecoded
    }
}

extension AppflowClientTypes.TriggerProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TriggerProperties(scheduled: \(Swift.String(describing: scheduled)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   Specifies the configuration details that control the trigger for a flow. Currently, these settings only apply to the <code>Scheduled</code> trigger type.
    /// </p>
    public struct TriggerProperties: Swift.Equatable {
        /// <p>
        ///   Specifies the configuration details of a schedule-triggered flow as defined by the user.
        /// </p>
        public let scheduled: AppflowClientTypes.ScheduledTriggerProperties?

        public init (
            scheduled: AppflowClientTypes.ScheduledTriggerProperties? = nil
        )
        {
            self.scheduled = scheduled
        }
    }

}

extension AppflowClientTypes {
    public enum TriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case event
        case ondemand
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .event,
                .ondemand,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .event: return "Event"
            case .ondemand: return "OnDemand"
            case .scheduled: return "Scheduled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedOperationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedOperationException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedOperationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///  The requested operation is not supported for the current flow.
/// </p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>
    ///   The Amazon Resource Name (ARN) of the flow that you want to untag.
    /// </p>
    public let resourceArn: Swift.String?
    /// <p>
    /// The tag keys associated with the tag that you want to remove from your flow.
    /// </p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateConnectorProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectorProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectorProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectorProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectorProfileOutputError>
}

extension UpdateConnectorProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectorProfileInput(connectionMode: \(Swift.String(describing: connectionMode)), connectorProfileConfig: \(Swift.String(describing: connectorProfileConfig)), connectorProfileName: \(Swift.String(describing: connectorProfileName)))"}
}

extension UpdateConnectorProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionMode = connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorProfileConfig = connectorProfileConfig {
            try encodeContainer.encode(connectorProfileConfig, forKey: .connectorProfileConfig)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
    }
}

public struct UpdateConnectorProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectorProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectorProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectorProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectorProfileOutputError>
}

public struct UpdateConnectorProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectorProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectorProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectorProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectorProfileOutputError>
}

public struct UpdateConnectorProfileInput: Swift.Equatable {
    /// <p>
    ///   Indicates the connection mode and if it is public or private.
    /// </p>
    public let connectionMode: AppflowClientTypes.ConnectionMode?
    /// <p>
    ///   Defines the connector-specific profile configuration and credentials.
    /// </p>
    public let connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
    /// <p>
    ///   The name of the connector profile and is unique for each <code>ConnectorProfile</code> in the AWS Account.
    /// </p>
    public let connectorProfileName: Swift.String?

    public init (
        connectionMode: AppflowClientTypes.ConnectionMode? = nil,
        connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig? = nil,
        connectorProfileName: Swift.String? = nil
    )
    {
        self.connectionMode = connectionMode
        self.connectorProfileConfig = connectorProfileConfig
        self.connectorProfileName = connectorProfileName
    }
}

struct UpdateConnectorProfileInputBody: Swift.Equatable {
    public let connectorProfileName: Swift.String?
    public let connectionMode: AppflowClientTypes.ConnectionMode?
    public let connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
}

extension UpdateConnectorProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let connectorProfileConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileConfig.self, forKey: .connectorProfileConfig)
        connectorProfileConfig = connectorProfileConfigDecoded
    }
}

extension UpdateConnectorProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectorProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectorProfileOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectorProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectorProfileOutputResponse(connectorProfileArn: \(Swift.String(describing: connectorProfileArn)))"}
}

extension UpdateConnectorProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConnectorProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileArn = output.connectorProfileArn
        } else {
            self.connectorProfileArn = nil
        }
    }
}

public struct UpdateConnectorProfileOutputResponse: Swift.Equatable {
    /// <p>
    ///   The Amazon Resource Name (ARN) of the connector profile.
    /// </p>
    public let connectorProfileArn: Swift.String?

    public init (
        connectorProfileArn: Swift.String? = nil
    )
    {
        self.connectorProfileArn = connectorProfileArn
    }
}

struct UpdateConnectorProfileOutputResponseBody: Swift.Equatable {
    public let connectorProfileArn: Swift.String?
}

extension UpdateConnectorProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
    }
}

public struct UpdateFlowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFlowOutputError>
}

extension UpdateFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFlowInput(description: \(Swift.String(describing: description)), destinationFlowConfigList: \(Swift.String(describing: destinationFlowConfigList)), flowName: \(Swift.String(describing: flowName)), sourceFlowConfig: \(Swift.String(describing: sourceFlowConfig)), tasks: \(Swift.String(describing: tasks)), triggerConfig: \(Swift.String(describing: triggerConfig)))"}
}

extension UpdateFlowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case sourceFlowConfig
        case tasks
        case triggerConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationFlowConfigList = destinationFlowConfigList {
            var destinationFlowConfigListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationFlowConfigList)
            for destinationflowconfiglist0 in destinationFlowConfigList {
                try destinationFlowConfigListContainer.encode(destinationflowconfiglist0)
            }
        }
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let sourceFlowConfig = sourceFlowConfig {
            try encodeContainer.encode(sourceFlowConfig, forKey: .sourceFlowConfig)
        }
        if let tasks = tasks {
            var tasksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tasks)
            for tasks0 in tasks {
                try tasksContainer.encode(tasks0)
            }
        }
        if let triggerConfig = triggerConfig {
            try encodeContainer.encode(triggerConfig, forKey: .triggerConfig)
        }
    }
}

public struct UpdateFlowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFlowOutputError>
}

public struct UpdateFlowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFlowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFlowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFlowOutputError>
}

public struct UpdateFlowInput: Swift.Equatable {
    /// <p>
    ///   A description of the flow.
    /// </p>
    public let description: Swift.String?
    /// <p>
    ///   The configuration that controls how Amazon AppFlow transfers data to the destination connector.
    /// </p>
    public let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: Swift.String?
    /// <p>
    ///  Contains information about the configuration of the source connector used in the flow.
    /// </p>
    public let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// <p>
    ///   A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// </p>
    public let tasks: [AppflowClientTypes.Task]?
    /// <p>
    ///   The trigger settings that determine how and when the flow runs.
    /// </p>
    public let triggerConfig: AppflowClientTypes.TriggerConfig?

    public init (
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowName: Swift.String? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowName = flowName
        self.sourceFlowConfig = sourceFlowConfig
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct UpdateFlowInputBody: Swift.Equatable {
    public let flowName: Swift.String?
    public let description: Swift.String?
    public let triggerConfig: AppflowClientTypes.TriggerConfig?
    public let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    public let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    public let tasks: [AppflowClientTypes.Task]?
}

extension UpdateFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case sourceFlowConfig
        case tasks
        case triggerConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([AppflowClientTypes.DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[AppflowClientTypes.DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [AppflowClientTypes.DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let tasksContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Task?].self, forKey: .tasks)
        var tasksDecoded0:[AppflowClientTypes.Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [AppflowClientTypes.Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
    }
}

extension UpdateFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFlowOutputResponse(flowStatus: \(Swift.String(describing: flowStatus)))"}
}

extension UpdateFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowStatus = output.flowStatus
        } else {
            self.flowStatus = nil
        }
    }
}

public struct UpdateFlowOutputResponse: Swift.Equatable {
    /// <p>Indicates the current status of the flow.
    /// </p>
    public let flowStatus: AppflowClientTypes.FlowStatus?

    public init (
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowStatus = flowStatus
    }
}

struct UpdateFlowOutputResponseBody: Swift.Equatable {
    public let flowStatus: AppflowClientTypes.FlowStatus?
}

extension UpdateFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

extension AppflowClientTypes.UpsolverDestinationProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case s3OutputFormatConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let s3OutputFormatConfig = s3OutputFormatConfig {
            try encodeContainer.encode(s3OutputFormatConfig, forKey: .s3OutputFormatConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let s3OutputFormatConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.UpsolverS3OutputFormatConfig.self, forKey: .s3OutputFormatConfig)
        s3OutputFormatConfig = s3OutputFormatConfigDecoded
    }
}

extension AppflowClientTypes.UpsolverDestinationProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpsolverDestinationProperties(bucketName: \(Swift.String(describing: bucketName)), bucketPrefix: \(Swift.String(describing: bucketPrefix)), s3OutputFormatConfig: \(Swift.String(describing: s3OutputFormatConfig)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The properties that are applied when Upsolver is used as a destination.
    ///     </p>
    public struct UpsolverDestinationProperties: Swift.Equatable {
        /// <p>
        ///       The Upsolver Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        ///     </p>
        public let bucketName: Swift.String?
        /// <p>
        ///       The object key for the destination Upsolver Amazon S3 bucket in which Amazon AppFlow places the files.
        ///     </p>
        public let bucketPrefix: Swift.String?
        /// <p>
        ///       The configuration that determines how data is formatted when Upsolver is used as the flow destination.
        ///     </p>
        public let s3OutputFormatConfig: AppflowClientTypes.UpsolverS3OutputFormatConfig?

        public init (
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            s3OutputFormatConfig: AppflowClientTypes.UpsolverS3OutputFormatConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }
    }

}

extension AppflowClientTypes.UpsolverMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.UpsolverMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpsolverMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The connector metadata specific to Upsolver.
    ///     </p>
    public struct UpsolverMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.UpsolverS3OutputFormatConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationConfig
        case fileType
        case prefixConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationConfig = aggregationConfig {
            try encodeContainer.encode(aggregationConfig, forKey: .aggregationConfig)
        }
        if let fileType = fileType {
            try encodeContainer.encode(fileType.rawValue, forKey: .fileType)
        }
        if let prefixConfig = prefixConfig {
            try encodeContainer.encode(prefixConfig, forKey: .prefixConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let prefixConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixConfig.self, forKey: .prefixConfig)
        prefixConfig = prefixConfigDecoded
        let aggregationConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AggregationConfig.self, forKey: .aggregationConfig)
        aggregationConfig = aggregationConfigDecoded
    }
}

extension AppflowClientTypes.UpsolverS3OutputFormatConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpsolverS3OutputFormatConfig(aggregationConfig: \(Swift.String(describing: aggregationConfig)), fileType: \(Swift.String(describing: fileType)), prefixConfig: \(Swift.String(describing: prefixConfig)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///       The configuration that determines how Amazon AppFlow formats the flow output data when Upsolver is used as the destination.
    ///     </p>
    public struct UpsolverS3OutputFormatConfig: Swift.Equatable {
        /// <p>
        /// The aggregation settings that you can use to customize the output format of your flow data.
        /// </p>
        public let aggregationConfig: AppflowClientTypes.AggregationConfig?
        /// <p>
        ///       Indicates the file type that Amazon AppFlow places in the Upsolver Amazon S3 bucket.
        ///     </p>
        public let fileType: AppflowClientTypes.FileType?
        /// <p>
        /// Determines the prefix that Amazon AppFlow applies to the destination folder name. You can name your destination folders according to the flow frequency and date.
        ///     </p>
        public let prefixConfig: AppflowClientTypes.PrefixConfig?

        public init (
            aggregationConfig: AppflowClientTypes.AggregationConfig? = nil,
            fileType: AppflowClientTypes.FileType? = nil,
            prefixConfig: AppflowClientTypes.PrefixConfig? = nil
        )
        {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
/// The request has invalid or missing parameters.
/// </p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum VeevaConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [VeevaConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VeevaConnectorOperator(rawValue: rawValue) ?? VeevaConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.VeevaConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes.VeevaConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VeevaConnectorProfileCredentials(password: \(Swift.String(describing: password)), username: \(Swift.String(describing: username)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required when using Veeva.
    /// </p>
    public struct VeevaConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   The password that corresponds to the user name.
        /// </p>
        public let password: Swift.String?
        /// <p>
        ///   The name of the user.
        /// </p>
        public let username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.VeevaConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes.VeevaConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VeevaConnectorProfileProperties(instanceUrl: \(Swift.String(describing: instanceUrl)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required when using Veeva.
    /// </p>
    public struct VeevaConnectorProfileProperties: Swift.Equatable {
        /// <p>
        ///   The location of the Veeva resource.
        /// </p>
        public let instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.VeevaMetadata: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes.VeevaMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VeevaMetadata()"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Veeva.
    /// </p>
    public struct VeevaMetadata: Swift.Equatable {

        public init() {}
    }

}

extension AppflowClientTypes.VeevaSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.VeevaSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VeevaSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when using Veeva as a flow source.
    /// </p>
    public struct VeevaSourceProperties: Swift.Equatable {
        /// <p>
        ///   The object specified in the Veeva flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes {
    /// <p>
    ///       The possible write operations in the destination connector. When this value is not provided, this defaults to the <code>INSERT</code> operation.
    ///     </p>
    public enum WriteOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insert
        case update
        case upsert
        case sdkUnknown(Swift.String)

        public static var allCases: [WriteOperationType] {
            return [
                .insert,
                .update,
                .upsert,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insert: return "INSERT"
            case .update: return "UPDATE"
            case .upsert: return "UPSERT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WriteOperationType(rawValue: rawValue) ?? WriteOperationType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum ZendeskConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case division
        case greaterThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ZendeskConnectorOperator] {
            return [
                .addition,
                .division,
                .greaterThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ZendeskConnectorOperator(rawValue: rawValue) ?? ZendeskConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.ZendeskConnectorProfileCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.ZendeskConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ZendeskConnectorProfileCredentials(accessToken: \(Swift.String(describing: accessToken)), clientId: \(Swift.String(describing: clientId)), clientSecret: \(Swift.String(describing: clientSecret)), oAuthRequest: \(Swift.String(describing: oAuthRequest)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile credentials required when using Zendesk.
    /// </p>
    public struct ZendeskConnectorProfileCredentials: Swift.Equatable {
        /// <p>
        ///   The credentials used to access protected Zendesk resources.
        /// </p>
        public let accessToken: Swift.String?
        /// <p>
        ///   The identifier for the desired client.
        /// </p>
        public let clientId: Swift.String?
        /// <p>
        ///  The client secret used by the OAuth client to authenticate to the authorization server.
        /// </p>
        public let clientSecret: Swift.String?
        /// <p>
        ///  The OAuth requirement needed to request security tokens from the connector endpoint.
        /// </p>
        public let oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init (
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }

}

extension AppflowClientTypes.ZendeskConnectorProfileProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes.ZendeskConnectorProfileProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ZendeskConnectorProfileProperties(instanceUrl: \(Swift.String(describing: instanceUrl)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector-specific profile properties required when using Zendesk.
    /// </p>
    public struct ZendeskConnectorProfileProperties: Swift.Equatable {
        /// <p>
        ///   The location of the Zendesk resource.
        /// </p>
        public let instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.ZendeskDestinationProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case idFieldNames
        case object
        case writeOperationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let idFieldNames = idFieldNames {
            var idFieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idFieldNames)
            for idfieldnamelist0 in idFieldNames {
                try idFieldNamesContainer.encode(idfieldnamelist0)
            }
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let writeOperationType = writeOperationType {
            try encodeContainer.encode(writeOperationType.rawValue, forKey: .writeOperationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let idFieldNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .idFieldNames)
        var idFieldNamesDecoded0:[Swift.String]? = nil
        if let idFieldNamesContainer = idFieldNamesContainer {
            idFieldNamesDecoded0 = [Swift.String]()
            for string0 in idFieldNamesContainer {
                if let string0 = string0 {
                    idFieldNamesDecoded0?.append(string0)
                }
            }
        }
        idFieldNames = idFieldNamesDecoded0
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
        let writeOperationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.WriteOperationType.self, forKey: .writeOperationType)
        writeOperationType = writeOperationTypeDecoded
    }
}

extension AppflowClientTypes.ZendeskDestinationProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ZendeskDestinationProperties(errorHandlingConfig: \(Swift.String(describing: errorHandlingConfig)), idFieldNames: \(Swift.String(describing: idFieldNames)), object: \(Swift.String(describing: object)), writeOperationType: \(Swift.String(describing: writeOperationType)))"}
}

extension AppflowClientTypes {
    public struct ZendeskDestinationProperties: Swift.Equatable {
        /// <p>
        ///   The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
        ///
        /// </p>
        public let errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// <p>
        ///       A list of field names that can be used as an ID field when performing a write operation.
        ///     </p>
        public let idFieldNames: [Swift.String]?
        public let object: Swift.String?
        /// <p>
        ///       The possible write operations in the destination connector. When this value is not provided, this defaults to the <code>INSERT</code> operation.
        ///     </p>
        public let writeOperationType: AppflowClientTypes.WriteOperationType?

        public init (
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            object: Swift.String? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }
    }

}

extension AppflowClientTypes.ZendeskMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes.ZendeskMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ZendeskMetadata(oAuthScopes: \(Swift.String(describing: oAuthScopes)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The connector metadata specific to Zendesk.
    /// </p>
    public struct ZendeskMetadata: Swift.Equatable {
        /// <p>
        ///       The desired authorization scope for the Zendesk account.
        ///     </p>
        public let oAuthScopes: [Swift.String]?

        public init (
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.ZendeskSourceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes.ZendeskSourceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ZendeskSourceProperties(object: \(Swift.String(describing: object)))"}
}

extension AppflowClientTypes {
    /// <p>
    ///   The properties that are applied when using Zendesk as a flow source.
    /// </p>
    public struct ZendeskSourceProperties: Swift.Equatable {
        /// <p>
        ///   The object specified in the Zendesk flow source.
        /// </p>
        public let object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}
