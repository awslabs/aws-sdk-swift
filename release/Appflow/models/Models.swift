// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AggregationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregationType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationType = aggregationType {
            try encodeContainer.encode(aggregationType.rawValue, forKey: .aggregationType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(AggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
    }
}

extension AggregationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregationConfig(aggregationType: \(String(describing: aggregationType)))"}
}

/// <p>
/// The aggregation settings that you can use to customize the output format of your flow data.
/// </p>
public struct AggregationConfig: Equatable {
    /// <p>
    ///  Specifies whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated.
    /// </p>
    public let aggregationType: AggregationType?

    public init (
        aggregationType: AggregationType? = nil
    )
    {
        self.aggregationType = aggregationType
    }
}

public enum AggregationType {
    case `none`
    case singleFile
    case sdkUnknown(String)
}

extension AggregationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AggregationType] {
        return [
            .none,
            .singleFile,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "None"
        case .singleFile: return "SingleFile"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AggregationType(rawValue: rawValue) ?? AggregationType.sdkUnknown(rawValue)
    }
}

public enum AmplitudeConnectorOperator {
    case between
    case sdkUnknown(String)
}

extension AmplitudeConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AmplitudeConnectorOperator] {
        return [
            .between,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .between: return "BETWEEN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AmplitudeConnectorOperator(rawValue: rawValue) ?? AmplitudeConnectorOperator.sdkUnknown(rawValue)
    }
}

extension AmplitudeConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKey
        case secretKey
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let secretKey = secretKey {
            try encodeContainer.encode(secretKey, forKey: .secretKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let secretKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretKey)
        secretKey = secretKeyDecoded
    }
}

extension AmplitudeConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AmplitudeConnectorProfileCredentials(apiKey: \(String(describing: apiKey)), secretKey: \(String(describing: secretKey)))"}
}

/// <p>
///   The connector-specific credentials required when using Amplitude.
/// </p>
public struct AmplitudeConnectorProfileCredentials: Equatable {
    /// <p>
    ///   A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
    /// </p>
    public let apiKey: String?
    /// <p>
    ///   The Secret Access Key portion of the credentials.
    /// </p>
    public let secretKey: String?

    public init (
        apiKey: String? = nil,
        secretKey: String? = nil
    )
    {
        self.apiKey = apiKey
        self.secretKey = secretKey
    }
}

extension AmplitudeConnectorProfileProperties: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension AmplitudeConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AmplitudeConnectorProfileProperties()"}
}

/// <p>
///   The connector-specific profile properties required when using Amplitude.
/// </p>
public struct AmplitudeConnectorProfileProperties: Equatable {

    public init() {}
}

extension AmplitudeMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension AmplitudeMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AmplitudeMetadata()"}
}

/// <p>
///   The connector metadata specific to Amplitude.
/// </p>
public struct AmplitudeMetadata: Equatable {

    public init() {}
}

extension AmplitudeSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AmplitudeSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AmplitudeSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when Amplitude is being used as a source.
/// </p>
public struct AmplitudeSourceProperties: Equatable {
    /// <p>
    /// The object specified in the Amplitude flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///   There was a conflict when processing the request (for example, a flow with the given name already exists within the account. Check for conflicting resource names and try again.
/// </p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ConnectionMode {
    case `private`
    case `public`
    case sdkUnknown(String)
}

extension ConnectionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionMode] {
        return [
            .private,
            .public,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .private: return "Private"
        case .public: return "Public"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionMode(rawValue: rawValue) ?? ConnectionMode.sdkUnknown(rawValue)
    }
}

extension ConnectorAuthenticationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorAuthenticationException(message: \(String(describing: message)))"}
}

extension ConnectorAuthenticationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConnectorAuthenticationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///  An error occurred when authenticating with the connector endpoint.
/// </p>
public struct ConnectorAuthenticationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectorAuthenticationExceptionBody: Equatable {
    public let message: String?
}

extension ConnectorAuthenticationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectorConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case canUseAsDestination
        case canUseAsSource
        case connectorMetadata
        case isPrivateLinkEnabled
        case isPrivateLinkEndpointUrlRequired
        case supportedDestinationConnectors
        case supportedSchedulingFrequencies
        case supportedTriggerTypes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if canUseAsDestination != false {
            try encodeContainer.encode(canUseAsDestination, forKey: .canUseAsDestination)
        }
        if canUseAsSource != false {
            try encodeContainer.encode(canUseAsSource, forKey: .canUseAsSource)
        }
        if let connectorMetadata = connectorMetadata {
            try encodeContainer.encode(connectorMetadata, forKey: .connectorMetadata)
        }
        if isPrivateLinkEnabled != false {
            try encodeContainer.encode(isPrivateLinkEnabled, forKey: .isPrivateLinkEnabled)
        }
        if isPrivateLinkEndpointUrlRequired != false {
            try encodeContainer.encode(isPrivateLinkEndpointUrlRequired, forKey: .isPrivateLinkEndpointUrlRequired)
        }
        if let supportedDestinationConnectors = supportedDestinationConnectors {
            var supportedDestinationConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDestinationConnectors)
            for connectortypelist0 in supportedDestinationConnectors {
                try supportedDestinationConnectorsContainer.encode(connectortypelist0.rawValue)
            }
        }
        if let supportedSchedulingFrequencies = supportedSchedulingFrequencies {
            var supportedSchedulingFrequenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedSchedulingFrequencies)
            for schedulingfrequencytypelist0 in supportedSchedulingFrequencies {
                try supportedSchedulingFrequenciesContainer.encode(schedulingfrequencytypelist0.rawValue)
            }
        }
        if let supportedTriggerTypes = supportedTriggerTypes {
            var supportedTriggerTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedTriggerTypes)
            for triggertypelist0 in supportedTriggerTypes {
                try supportedTriggerTypesContainer.encode(triggertypelist0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canUseAsSourceDecoded = try containerValues.decode(Bool.self, forKey: .canUseAsSource)
        canUseAsSource = canUseAsSourceDecoded
        let canUseAsDestinationDecoded = try containerValues.decode(Bool.self, forKey: .canUseAsDestination)
        canUseAsDestination = canUseAsDestinationDecoded
        let supportedDestinationConnectorsContainer = try containerValues.decodeIfPresent([ConnectorType?].self, forKey: .supportedDestinationConnectors)
        var supportedDestinationConnectorsDecoded0:[ConnectorType]? = nil
        if let supportedDestinationConnectorsContainer = supportedDestinationConnectorsContainer {
            supportedDestinationConnectorsDecoded0 = [ConnectorType]()
            for string0 in supportedDestinationConnectorsContainer {
                if let string0 = string0 {
                    supportedDestinationConnectorsDecoded0?.append(string0)
                }
            }
        }
        supportedDestinationConnectors = supportedDestinationConnectorsDecoded0
        let supportedSchedulingFrequenciesContainer = try containerValues.decodeIfPresent([ScheduleFrequencyType?].self, forKey: .supportedSchedulingFrequencies)
        var supportedSchedulingFrequenciesDecoded0:[ScheduleFrequencyType]? = nil
        if let supportedSchedulingFrequenciesContainer = supportedSchedulingFrequenciesContainer {
            supportedSchedulingFrequenciesDecoded0 = [ScheduleFrequencyType]()
            for string0 in supportedSchedulingFrequenciesContainer {
                if let string0 = string0 {
                    supportedSchedulingFrequenciesDecoded0?.append(string0)
                }
            }
        }
        supportedSchedulingFrequencies = supportedSchedulingFrequenciesDecoded0
        let isPrivateLinkEnabledDecoded = try containerValues.decode(Bool.self, forKey: .isPrivateLinkEnabled)
        isPrivateLinkEnabled = isPrivateLinkEnabledDecoded
        let isPrivateLinkEndpointUrlRequiredDecoded = try containerValues.decode(Bool.self, forKey: .isPrivateLinkEndpointUrlRequired)
        isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequiredDecoded
        let supportedTriggerTypesContainer = try containerValues.decodeIfPresent([TriggerType?].self, forKey: .supportedTriggerTypes)
        var supportedTriggerTypesDecoded0:[TriggerType]? = nil
        if let supportedTriggerTypesContainer = supportedTriggerTypesContainer {
            supportedTriggerTypesDecoded0 = [TriggerType]()
            for string0 in supportedTriggerTypesContainer {
                if let string0 = string0 {
                    supportedTriggerTypesDecoded0?.append(string0)
                }
            }
        }
        supportedTriggerTypes = supportedTriggerTypesDecoded0
        let connectorMetadataDecoded = try containerValues.decodeIfPresent(ConnectorMetadata.self, forKey: .connectorMetadata)
        connectorMetadata = connectorMetadataDecoded
    }
}

extension ConnectorConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorConfiguration(canUseAsDestination: \(String(describing: canUseAsDestination)), canUseAsSource: \(String(describing: canUseAsSource)), connectorMetadata: \(String(describing: connectorMetadata)), isPrivateLinkEnabled: \(String(describing: isPrivateLinkEnabled)), isPrivateLinkEndpointUrlRequired: \(String(describing: isPrivateLinkEndpointUrlRequired)), supportedDestinationConnectors: \(String(describing: supportedDestinationConnectors)), supportedSchedulingFrequencies: \(String(describing: supportedSchedulingFrequencies)), supportedTriggerTypes: \(String(describing: supportedTriggerTypes)))"}
}

/// <p>
/// The configuration settings related to a given connector.
/// </p>
public struct ConnectorConfiguration: Equatable {
    /// <p>
    /// Specifies whether the connector can be used as a destination.
    /// </p>
    public let canUseAsDestination: Bool
    /// <p>
    ///   Specifies whether the connector can be used as a source.
    /// </p>
    public let canUseAsSource: Bool
    /// <p>
    /// Specifies connector-specific metadata such as <code>oAuthScopes</code>, <code>supportedRegions</code>, <code>privateLinkServiceUrl</code>, and so on.
    /// </p>
    public let connectorMetadata: ConnectorMetadata?
    /// <p>
    /// Specifies if PrivateLink is enabled for that connector.
    /// </p>
    public let isPrivateLinkEnabled: Bool
    /// <p>
    /// Specifies if a PrivateLink endpoint URL is required.
    /// </p>
    public let isPrivateLinkEndpointUrlRequired: Bool
    /// <p>
    /// Lists the connectors that are available for use as destinations.
    /// </p>
    public let supportedDestinationConnectors: [ConnectorType]?
    /// <p>
    ///     Specifies the supported flow frequency for that connector.
    ///     </p>
    public let supportedSchedulingFrequencies: [ScheduleFrequencyType]?
    /// <p>
    /// Specifies the supported trigger types for the flow.
    /// </p>
    public let supportedTriggerTypes: [TriggerType]?

    public init (
        canUseAsDestination: Bool = false,
        canUseAsSource: Bool = false,
        connectorMetadata: ConnectorMetadata? = nil,
        isPrivateLinkEnabled: Bool = false,
        isPrivateLinkEndpointUrlRequired: Bool = false,
        supportedDestinationConnectors: [ConnectorType]? = nil,
        supportedSchedulingFrequencies: [ScheduleFrequencyType]? = nil,
        supportedTriggerTypes: [TriggerType]? = nil
    )
    {
        self.canUseAsDestination = canUseAsDestination
        self.canUseAsSource = canUseAsSource
        self.connectorMetadata = connectorMetadata
        self.isPrivateLinkEnabled = isPrivateLinkEnabled
        self.isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequired
        self.supportedDestinationConnectors = supportedDestinationConnectors
        self.supportedSchedulingFrequencies = supportedSchedulingFrequencies
        self.supportedTriggerTypes = supportedTriggerTypes
    }
}

extension ConnectorEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hasNestedEntities
        case label
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hasNestedEntities != false {
            try encodeContainer.encode(hasNestedEntities, forKey: .hasNestedEntities)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
        let hasNestedEntitiesDecoded = try containerValues.decode(Bool.self, forKey: .hasNestedEntities)
        hasNestedEntities = hasNestedEntitiesDecoded
    }
}

extension ConnectorEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorEntity(hasNestedEntities: \(String(describing: hasNestedEntities)), label: \(String(describing: label)), name: \(String(describing: name)))"}
}

/// <p>
/// The high-level entity that can be queried in Amazon AppFlow. For example, a Salesforce entity might be an <i>Account</i> or <i>Opportunity</i>, whereas a ServiceNow entity might be an <i>Incident</i>.
///
/// </p>
public struct ConnectorEntity: Equatable {
    /// <p>
    /// Specifies whether the connector entity is a parent or a category and has more entities nested underneath it. If another call is made with <code>entitiesPath = "the_current_entity_name_with_hasNestedEntities_true"</code>, then it returns the nested entities underneath it. This provides a way to retrieve all supported entities in a recursive fashion.
    /// </p>
    public let hasNestedEntities: Bool
    /// <p>
    /// The label applied to the connector entity.
    /// </p>
    public let label: String?
    /// <p>
    /// The name of the connector entity.
    /// </p>
    public let name: String?

    public init (
        hasNestedEntities: Bool = false,
        label: String? = nil,
        name: String? = nil
    )
    {
        self.hasNestedEntities = hasNestedEntities
        self.label = label
        self.name = name
    }
}

extension ConnectorEntityField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case destinationProperties
        case identifier
        case label
        case sourceProperties
        case supportedFieldTypeDetails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationProperties = destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let sourceProperties = sourceProperties {
            try encodeContainer.encode(sourceProperties, forKey: .sourceProperties)
        }
        if let supportedFieldTypeDetails = supportedFieldTypeDetails {
            try encodeContainer.encode(supportedFieldTypeDetails, forKey: .supportedFieldTypeDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
        let supportedFieldTypeDetailsDecoded = try containerValues.decodeIfPresent(SupportedFieldTypeDetails.self, forKey: .supportedFieldTypeDetails)
        supportedFieldTypeDetails = supportedFieldTypeDetailsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(SourceFieldProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(DestinationFieldProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
    }
}

extension ConnectorEntityField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorEntityField(description: \(String(describing: description)), destinationProperties: \(String(describing: destinationProperties)), identifier: \(String(describing: identifier)), label: \(String(describing: label)), sourceProperties: \(String(describing: sourceProperties)), supportedFieldTypeDetails: \(String(describing: supportedFieldTypeDetails)))"}
}

/// <p>
/// Describes the data model of a connector field. For example, for an <i>account</i> entity, the fields would be <i>account name</i>, <i>account ID</i>, and so on.
/// </p>
public struct ConnectorEntityField: Equatable {
    /// <p>
    ///   A description of the connector entity field.
    /// </p>
    public let description: String?
    /// <p>
    ///   The properties applied to a field when the connector is being used as a destination.
    /// </p>
    public let destinationProperties: DestinationFieldProperties?
    /// <p>
    /// The unique identifier of the connector field.
    /// </p>
    public let identifier: String?
    /// <p>
    /// The label applied to a connector entity field.
    /// </p>
    public let label: String?
    /// <p>
    ///   The properties that can be applied to a field when the connector is being used as a source.
    /// </p>
    public let sourceProperties: SourceFieldProperties?
    /// <p>
    ///  Contains details regarding the supported <code>FieldType</code>, including the corresponding <code>filterOperators</code> and <code>supportedValues</code>.
    /// </p>
    public let supportedFieldTypeDetails: SupportedFieldTypeDetails?

    public init (
        description: String? = nil,
        destinationProperties: DestinationFieldProperties? = nil,
        identifier: String? = nil,
        label: String? = nil,
        sourceProperties: SourceFieldProperties? = nil,
        supportedFieldTypeDetails: SupportedFieldTypeDetails? = nil
    )
    {
        self.description = description
        self.destinationProperties = destinationProperties
        self.identifier = identifier
        self.label = label
        self.sourceProperties = sourceProperties
        self.supportedFieldTypeDetails = supportedFieldTypeDetails
    }
}

extension ConnectorMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amplitude = "Amplitude"
        case customerProfiles = "CustomerProfiles"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case eventBridge = "EventBridge"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case redshift = "Redshift"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case upsolver = "Upsolver"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let customerProfiles = customerProfiles {
            try encodeContainer.encode(customerProfiles, forKey: .customerProfiles)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let eventBridge = eventBridge {
            try encodeContainer.encode(eventBridge, forKey: .eventBridge)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let upsolver = upsolver {
            try encodeContainer.encode(upsolver, forKey: .upsolver)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AmplitudeMetadata.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(DatadogMetadata.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(DynatraceMetadata.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(GoogleAnalyticsMetadata.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(InforNexusMetadata.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(MarketoMetadata.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(RedshiftMetadata.self, forKey: .redshift)
        redshift = redshiftDecoded
        let s3Decoded = try containerValues.decodeIfPresent(S3Metadata.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(SalesforceMetadata.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(ServiceNowMetadata.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(SingularMetadata.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(SlackMetadata.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(SnowflakeMetadata.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(TrendmicroMetadata.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(VeevaMetadata.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(ZendeskMetadata.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let eventBridgeDecoded = try containerValues.decodeIfPresent(EventBridgeMetadata.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
        let upsolverDecoded = try containerValues.decodeIfPresent(UpsolverMetadata.self, forKey: .upsolver)
        upsolver = upsolverDecoded
        let customerProfilesDecoded = try containerValues.decodeIfPresent(CustomerProfilesMetadata.self, forKey: .customerProfiles)
        customerProfiles = customerProfilesDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(HoneycodeMetadata.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
    }
}

extension ConnectorMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorMetadata(amplitude: \(String(describing: amplitude)), customerProfiles: \(String(describing: customerProfiles)), datadog: \(String(describing: datadog)), dynatrace: \(String(describing: dynatrace)), eventBridge: \(String(describing: eventBridge)), googleAnalytics: \(String(describing: googleAnalytics)), honeycode: \(String(describing: honeycode)), inforNexus: \(String(describing: inforNexus)), marketo: \(String(describing: marketo)), redshift: \(String(describing: redshift)), s3: \(String(describing: s3)), salesforce: \(String(describing: salesforce)), serviceNow: \(String(describing: serviceNow)), singular: \(String(describing: singular)), slack: \(String(describing: slack)), snowflake: \(String(describing: snowflake)), trendmicro: \(String(describing: trendmicro)), upsolver: \(String(describing: upsolver)), veeva: \(String(describing: veeva)), zendesk: \(String(describing: zendesk)))"}
}

/// <p>
///   A structure to specify connector-specific metadata such as <code>oAuthScopes</code>, <code>supportedRegions</code>, <code>privateLinkServiceUrl</code>, and so on.
/// </p>
public struct ConnectorMetadata: Equatable {
    /// <p>
    ///  The connector metadata specific to Amplitude.
    /// </p>
    public let amplitude: AmplitudeMetadata?
    /// <p>
    ///       The connector metadata specific to Amazon Connect Customer Profiles.
    ///     </p>
    public let customerProfiles: CustomerProfilesMetadata?
    /// <p>
    ///   The connector metadata specific to Datadog.
    /// </p>
    public let datadog: DatadogMetadata?
    /// <p>
    ///   The connector metadata specific to Dynatrace.
    /// </p>
    public let dynatrace: DynatraceMetadata?
    /// <p>
    ///       The connector metadata specific to Amazon EventBridge.
    ///     </p>
    public let eventBridge: EventBridgeMetadata?
    /// <p>
    ///   The connector metadata specific to Google Analytics.
    /// </p>
    public let googleAnalytics: GoogleAnalyticsMetadata?
    /// <p>
    ///       The connector metadata specific to Amazon Honeycode.
    ///     </p>
    public let honeycode: HoneycodeMetadata?
    /// <p>
    ///   The connector metadata specific to Infor Nexus.
    /// </p>
    public let inforNexus: InforNexusMetadata?
    /// <p>
    ///   The connector metadata specific to Marketo.
    /// </p>
    public let marketo: MarketoMetadata?
    /// <p>
    ///   The connector metadata specific to Amazon Redshift.
    /// </p>
    public let redshift: RedshiftMetadata?
    /// <p>
    ///   The connector metadata specific to Amazon S3.
    /// </p>
    public let s3: S3Metadata?
    /// <p>
    ///   The connector metadata specific to Salesforce.
    /// </p>
    public let salesforce: SalesforceMetadata?
    /// <p>
    ///   The connector metadata specific to ServiceNow.
    /// </p>
    public let serviceNow: ServiceNowMetadata?
    /// <p>
    ///   The connector metadata specific to Singular.
    /// </p>
    public let singular: SingularMetadata?
    /// <p>
    ///   The connector metadata specific to Slack.
    /// </p>
    public let slack: SlackMetadata?
    /// <p>
    ///   The connector metadata specific to Snowflake.
    /// </p>
    public let snowflake: SnowflakeMetadata?
    /// <p>
    ///   The connector metadata specific to Trend Micro.
    /// </p>
    public let trendmicro: TrendmicroMetadata?
    /// <p>
    ///       The connector metadata specific to Upsolver.
    ///     </p>
    public let upsolver: UpsolverMetadata?
    /// <p>
    ///   The connector metadata specific to Veeva.
    /// </p>
    public let veeva: VeevaMetadata?
    /// <p>
    ///   The connector metadata specific to Zendesk.
    /// </p>
    public let zendesk: ZendeskMetadata?

    public init (
        amplitude: AmplitudeMetadata? = nil,
        customerProfiles: CustomerProfilesMetadata? = nil,
        datadog: DatadogMetadata? = nil,
        dynatrace: DynatraceMetadata? = nil,
        eventBridge: EventBridgeMetadata? = nil,
        googleAnalytics: GoogleAnalyticsMetadata? = nil,
        honeycode: HoneycodeMetadata? = nil,
        inforNexus: InforNexusMetadata? = nil,
        marketo: MarketoMetadata? = nil,
        redshift: RedshiftMetadata? = nil,
        s3: S3Metadata? = nil,
        salesforce: SalesforceMetadata? = nil,
        serviceNow: ServiceNowMetadata? = nil,
        singular: SingularMetadata? = nil,
        slack: SlackMetadata? = nil,
        snowflake: SnowflakeMetadata? = nil,
        trendmicro: TrendmicroMetadata? = nil,
        upsolver: UpsolverMetadata? = nil,
        veeva: VeevaMetadata? = nil,
        zendesk: ZendeskMetadata? = nil
    )
    {
        self.amplitude = amplitude
        self.customerProfiles = customerProfiles
        self.datadog = datadog
        self.dynatrace = dynatrace
        self.eventBridge = eventBridge
        self.googleAnalytics = googleAnalytics
        self.honeycode = honeycode
        self.inforNexus = inforNexus
        self.marketo = marketo
        self.redshift = redshift
        self.s3 = s3
        self.salesforce = salesforce
        self.serviceNow = serviceNow
        self.singular = singular
        self.slack = slack
        self.snowflake = snowflake
        self.trendmicro = trendmicro
        self.upsolver = upsolver
        self.veeva = veeva
        self.zendesk = zendesk
    }
}

extension ConnectorOAuthRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authCode
        case redirectUri
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authCode = authCode {
            try encodeContainer.encode(authCode, forKey: .authCode)
        }
        if let redirectUri = redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authCode)
        authCode = authCodeDecoded
        let redirectUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
    }
}

extension ConnectorOAuthRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorOAuthRequest(authCode: \(String(describing: authCode)), redirectUri: \(String(describing: redirectUri)))"}
}

/// <p>
///  Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
/// </p>
public struct ConnectorOAuthRequest: Equatable {
    /// <p>
    ///  The code provided by the connector when it has been authenticated via the connected app.
    /// </p>
    public let authCode: String?
    /// <p>
    ///       The URL to which the authentication server redirects the browser after authorization has been granted.
    ///     </p>
    public let redirectUri: String?

    public init (
        authCode: String? = nil,
        redirectUri: String? = nil
    )
    {
        self.authCode = authCode
        self.redirectUri = redirectUri
    }
}

extension ConnectorOperator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude.rawValue, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog.rawValue, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace.rawValue, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics.rawValue, forKey: .googleAnalytics)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus.rawValue, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo.rawValue, forKey: .marketo)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3.rawValue, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce.rawValue, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow.rawValue, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular.rawValue, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack.rawValue, forKey: .slack)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro.rawValue, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva.rawValue, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk.rawValue, forKey: .zendesk)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AmplitudeConnectorOperator.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(DatadogConnectorOperator.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(DynatraceConnectorOperator.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(GoogleAnalyticsConnectorOperator.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(InforNexusConnectorOperator.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(MarketoConnectorOperator.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(S3ConnectorOperator.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(SalesforceConnectorOperator.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(ServiceNowConnectorOperator.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(SingularConnectorOperator.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(SlackConnectorOperator.self, forKey: .slack)
        slack = slackDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(TrendmicroConnectorOperator.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(VeevaConnectorOperator.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(ZendeskConnectorOperator.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension ConnectorOperator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorOperator(amplitude: \(String(describing: amplitude)), datadog: \(String(describing: datadog)), dynatrace: \(String(describing: dynatrace)), googleAnalytics: \(String(describing: googleAnalytics)), inforNexus: \(String(describing: inforNexus)), marketo: \(String(describing: marketo)), s3: \(String(describing: s3)), salesforce: \(String(describing: salesforce)), serviceNow: \(String(describing: serviceNow)), singular: \(String(describing: singular)), slack: \(String(describing: slack)), trendmicro: \(String(describing: trendmicro)), veeva: \(String(describing: veeva)), zendesk: \(String(describing: zendesk)))"}
}

/// <p>
/// The operation to be performed on the provided source fields.
/// </p>
public struct ConnectorOperator: Equatable {
    /// <p>
    ///       The operation to be performed on the provided Amplitude source fields.
    ///     </p>
    public let amplitude: AmplitudeConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Datadog source fields.
    /// </p>
    public let datadog: DatadogConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Dynatrace source fields.
    /// </p>
    public let dynatrace: DynatraceConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Google Analytics source fields.
    /// </p>
    public let googleAnalytics: GoogleAnalyticsConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Infor Nexus source fields.
    /// </p>
    public let inforNexus: InforNexusConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Marketo source fields.
    /// </p>
    public let marketo: MarketoConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Amazon S3 source fields.
    /// </p>
    public let s3: S3ConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Salesforce source fields.
    /// </p>
    public let salesforce: SalesforceConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided ServiceNow source fields.
    /// </p>
    public let serviceNow: ServiceNowConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Singular source fields.
    /// </p>
    public let singular: SingularConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Slack source fields.
    /// </p>
    public let slack: SlackConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Trend Micro source fields.
    /// </p>
    public let trendmicro: TrendmicroConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Veeva source fields.
    /// </p>
    public let veeva: VeevaConnectorOperator?
    /// <p>
    ///   The operation to be performed on the provided Zendesk source fields.
    /// </p>
    public let zendesk: ZendeskConnectorOperator?

    public init (
        amplitude: AmplitudeConnectorOperator? = nil,
        datadog: DatadogConnectorOperator? = nil,
        dynatrace: DynatraceConnectorOperator? = nil,
        googleAnalytics: GoogleAnalyticsConnectorOperator? = nil,
        inforNexus: InforNexusConnectorOperator? = nil,
        marketo: MarketoConnectorOperator? = nil,
        s3: S3ConnectorOperator? = nil,
        salesforce: SalesforceConnectorOperator? = nil,
        serviceNow: ServiceNowConnectorOperator? = nil,
        singular: SingularConnectorOperator? = nil,
        slack: SlackConnectorOperator? = nil,
        trendmicro: TrendmicroConnectorOperator? = nil,
        veeva: VeevaConnectorOperator? = nil,
        zendesk: ZendeskConnectorOperator? = nil
    )
    {
        self.amplitude = amplitude
        self.datadog = datadog
        self.dynatrace = dynatrace
        self.googleAnalytics = googleAnalytics
        self.inforNexus = inforNexus
        self.marketo = marketo
        self.s3 = s3
        self.salesforce = salesforce
        self.serviceNow = serviceNow
        self.singular = singular
        self.slack = slack
        self.trendmicro = trendmicro
        self.veeva = veeva
        self.zendesk = zendesk
    }
}

extension ConnectorProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionMode
        case connectorProfileArn
        case connectorProfileName
        case connectorProfileProperties
        case connectorType
        case createdAt
        case credentialsArn
        case lastUpdatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionMode = connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorProfileArn = connectorProfileArn {
            try encodeContainer.encode(connectorProfileArn, forKey: .connectorProfileArn)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorProfileProperties = connectorProfileProperties {
            try encodeContainer.encode(connectorProfileProperties, forKey: .connectorProfileProperties)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let connectorProfilePropertiesDecoded = try containerValues.decodeIfPresent(ConnectorProfileProperties.self, forKey: .connectorProfileProperties)
        connectorProfileProperties = connectorProfilePropertiesDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension ConnectorProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorProfile(connectionMode: \(String(describing: connectionMode)), connectorProfileArn: \(String(describing: connectorProfileArn)), connectorProfileName: \(String(describing: connectorProfileName)), connectorProfileProperties: \(String(describing: connectorProfileProperties)), connectorType: \(String(describing: connectorType)), createdAt: \(String(describing: createdAt)), credentialsArn: \(String(describing: credentialsArn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)))"}
}

/// <p>
///   Describes an instance of a connector. This includes the provided name, credentials ARN, connection-mode, and so on. To keep the API intuitive and extensible, the fields that are common to all types of connector profiles are explicitly specified at the top level. The rest of the connector-specific properties are available via  the <code>connectorProfileProperties</code> field.
/// </p>
public struct ConnectorProfile: Equatable {
    /// <p>
    ///   Indicates the connection mode and if it is public or private.
    /// </p>
    public let connectionMode: ConnectionMode?
    /// <p>
    /// The Amazon Resource Name (ARN) of the connector profile.
    /// </p>
    public let connectorProfileArn: String?
    /// <p>
    ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in the AWS account.
    /// </p>
    public let connectorProfileName: String?
    /// <p>
    /// The connector-specific properties of the profile configuration.
    /// </p>
    public let connectorProfileProperties: ConnectorProfileProperties?
    /// <p>
    ///   The type of connector, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorType: ConnectorType?
    /// <p>
    ///   Specifies when the connector profile was created.
    /// </p>
    public let createdAt: Date?
    /// <p>
    ///   The Amazon Resource Name (ARN) of the connector profile credentials.
    /// </p>
    public let credentialsArn: String?
    /// <p>
    ///   Specifies when the connector profile was last updated.
    /// </p>
    public let lastUpdatedAt: Date?

    public init (
        connectionMode: ConnectionMode? = nil,
        connectorProfileArn: String? = nil,
        connectorProfileName: String? = nil,
        connectorProfileProperties: ConnectorProfileProperties? = nil,
        connectorType: ConnectorType? = nil,
        createdAt: Date? = nil,
        credentialsArn: String? = nil,
        lastUpdatedAt: Date? = nil
    )
    {
        self.connectionMode = connectionMode
        self.connectorProfileArn = connectorProfileArn
        self.connectorProfileName = connectorProfileName
        self.connectorProfileProperties = connectorProfileProperties
        self.connectorType = connectorType
        self.createdAt = createdAt
        self.credentialsArn = credentialsArn
        self.lastUpdatedAt = lastUpdatedAt
    }
}

extension ConnectorProfileConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorProfileCredentials
        case connectorProfileProperties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileCredentials = connectorProfileCredentials {
            try encodeContainer.encode(connectorProfileCredentials, forKey: .connectorProfileCredentials)
        }
        if let connectorProfileProperties = connectorProfileProperties {
            try encodeContainer.encode(connectorProfileProperties, forKey: .connectorProfileProperties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfilePropertiesDecoded = try containerValues.decodeIfPresent(ConnectorProfileProperties.self, forKey: .connectorProfileProperties)
        connectorProfileProperties = connectorProfilePropertiesDecoded
        let connectorProfileCredentialsDecoded = try containerValues.decodeIfPresent(ConnectorProfileCredentials.self, forKey: .connectorProfileCredentials)
        connectorProfileCredentials = connectorProfileCredentialsDecoded
    }
}

extension ConnectorProfileConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorProfileConfig(connectorProfileCredentials: \(String(describing: connectorProfileCredentials)), connectorProfileProperties: \(String(describing: connectorProfileProperties)))"}
}

/// <p>
///   Defines the connector-specific configuration and credentials for the connector profile.
/// </p>
public struct ConnectorProfileConfig: Equatable {
    /// <p>
    ///  The connector-specific credentials required by each connector.
    /// </p>
    public let connectorProfileCredentials: ConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific properties of the profile configuration.
    /// </p>
    public let connectorProfileProperties: ConnectorProfileProperties?

    public init (
        connectorProfileCredentials: ConnectorProfileCredentials? = nil,
        connectorProfileProperties: ConnectorProfileProperties? = nil
    )
    {
        self.connectorProfileCredentials = connectorProfileCredentials
        self.connectorProfileProperties = connectorProfileProperties
    }
}

extension ConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case redshift = "Redshift"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AmplitudeConnectorProfileCredentials.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(DatadogConnectorProfileCredentials.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(DynatraceConnectorProfileCredentials.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(GoogleAnalyticsConnectorProfileCredentials.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(HoneycodeConnectorProfileCredentials.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(InforNexusConnectorProfileCredentials.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(MarketoConnectorProfileCredentials.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(RedshiftConnectorProfileCredentials.self, forKey: .redshift)
        redshift = redshiftDecoded
        let salesforceDecoded = try containerValues.decodeIfPresent(SalesforceConnectorProfileCredentials.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(ServiceNowConnectorProfileCredentials.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(SingularConnectorProfileCredentials.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(SlackConnectorProfileCredentials.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(SnowflakeConnectorProfileCredentials.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(TrendmicroConnectorProfileCredentials.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(VeevaConnectorProfileCredentials.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(ZendeskConnectorProfileCredentials.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension ConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorProfileCredentials(amplitude: \(String(describing: amplitude)), datadog: \(String(describing: datadog)), dynatrace: \(String(describing: dynatrace)), googleAnalytics: \(String(describing: googleAnalytics)), honeycode: \(String(describing: honeycode)), inforNexus: \(String(describing: inforNexus)), marketo: \(String(describing: marketo)), redshift: \(String(describing: redshift)), salesforce: \(String(describing: salesforce)), serviceNow: \(String(describing: serviceNow)), singular: \(String(describing: singular)), slack: \(String(describing: slack)), snowflake: \(String(describing: snowflake)), trendmicro: \(String(describing: trendmicro)), veeva: \(String(describing: veeva)), zendesk: \(String(describing: zendesk)))"}
}

/// <p>
///  The connector-specific credentials required by a connector.
/// </p>
public struct ConnectorProfileCredentials: Equatable {
    /// <p>
    ///   The connector-specific credentials required when using Amplitude.
    /// </p>
    public let amplitude: AmplitudeConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Datadog.
    /// </p>
    public let datadog: DatadogConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Dynatrace.
    /// </p>
    public let dynatrace: DynatraceConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Google Analytics.
    /// </p>
    public let googleAnalytics: GoogleAnalyticsConnectorProfileCredentials?
    /// <p>
    ///       The connector-specific credentials required when using Amazon Honeycode.
    ///     </p>
    public let honeycode: HoneycodeConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Infor Nexus.
    /// </p>
    public let inforNexus: InforNexusConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Marketo.
    /// </p>
    public let marketo: MarketoConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Amazon Redshift.
    /// </p>
    public let redshift: RedshiftConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Salesforce.
    /// </p>
    public let salesforce: SalesforceConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using ServiceNow.
    /// </p>
    public let serviceNow: ServiceNowConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Singular.
    /// </p>
    public let singular: SingularConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Slack.
    /// </p>
    public let slack: SlackConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Snowflake.
    /// </p>
    public let snowflake: SnowflakeConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Trend Micro.
    /// </p>
    public let trendmicro: TrendmicroConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Veeva.
    /// </p>
    public let veeva: VeevaConnectorProfileCredentials?
    /// <p>
    ///   The connector-specific credentials required when using Zendesk.
    /// </p>
    public let zendesk: ZendeskConnectorProfileCredentials?

    public init (
        amplitude: AmplitudeConnectorProfileCredentials? = nil,
        datadog: DatadogConnectorProfileCredentials? = nil,
        dynatrace: DynatraceConnectorProfileCredentials? = nil,
        googleAnalytics: GoogleAnalyticsConnectorProfileCredentials? = nil,
        honeycode: HoneycodeConnectorProfileCredentials? = nil,
        inforNexus: InforNexusConnectorProfileCredentials? = nil,
        marketo: MarketoConnectorProfileCredentials? = nil,
        redshift: RedshiftConnectorProfileCredentials? = nil,
        salesforce: SalesforceConnectorProfileCredentials? = nil,
        serviceNow: ServiceNowConnectorProfileCredentials? = nil,
        singular: SingularConnectorProfileCredentials? = nil,
        slack: SlackConnectorProfileCredentials? = nil,
        snowflake: SnowflakeConnectorProfileCredentials? = nil,
        trendmicro: TrendmicroConnectorProfileCredentials? = nil,
        veeva: VeevaConnectorProfileCredentials? = nil,
        zendesk: ZendeskConnectorProfileCredentials? = nil
    )
    {
        self.amplitude = amplitude
        self.datadog = datadog
        self.dynatrace = dynatrace
        self.googleAnalytics = googleAnalytics
        self.honeycode = honeycode
        self.inforNexus = inforNexus
        self.marketo = marketo
        self.redshift = redshift
        self.salesforce = salesforce
        self.serviceNow = serviceNow
        self.singular = singular
        self.slack = slack
        self.snowflake = snowflake
        self.trendmicro = trendmicro
        self.veeva = veeva
        self.zendesk = zendesk
    }
}

extension ConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case redshift = "Redshift"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AmplitudeConnectorProfileProperties.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(DatadogConnectorProfileProperties.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(DynatraceConnectorProfileProperties.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(GoogleAnalyticsConnectorProfileProperties.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(HoneycodeConnectorProfileProperties.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(InforNexusConnectorProfileProperties.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(MarketoConnectorProfileProperties.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(RedshiftConnectorProfileProperties.self, forKey: .redshift)
        redshift = redshiftDecoded
        let salesforceDecoded = try containerValues.decodeIfPresent(SalesforceConnectorProfileProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(ServiceNowConnectorProfileProperties.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(SingularConnectorProfileProperties.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(SlackConnectorProfileProperties.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(SnowflakeConnectorProfileProperties.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(TrendmicroConnectorProfileProperties.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(VeevaConnectorProfileProperties.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(ZendeskConnectorProfileProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension ConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorProfileProperties(amplitude: \(String(describing: amplitude)), datadog: \(String(describing: datadog)), dynatrace: \(String(describing: dynatrace)), googleAnalytics: \(String(describing: googleAnalytics)), honeycode: \(String(describing: honeycode)), inforNexus: \(String(describing: inforNexus)), marketo: \(String(describing: marketo)), redshift: \(String(describing: redshift)), salesforce: \(String(describing: salesforce)), serviceNow: \(String(describing: serviceNow)), singular: \(String(describing: singular)), slack: \(String(describing: slack)), snowflake: \(String(describing: snowflake)), trendmicro: \(String(describing: trendmicro)), veeva: \(String(describing: veeva)), zendesk: \(String(describing: zendesk)))"}
}

/// <p>
///   The connector-specific profile properties required by each connector.
/// </p>
public struct ConnectorProfileProperties: Equatable {
    /// <p>
    ///   The connector-specific properties required by Amplitude.
    /// </p>
    public let amplitude: AmplitudeConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by Datadog.
    /// </p>
    public let datadog: DatadogConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by Dynatrace.
    /// </p>
    public let dynatrace: DynatraceConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required Google Analytics.
    /// </p>
    public let googleAnalytics: GoogleAnalyticsConnectorProfileProperties?
    /// <p>
    ///       The connector-specific properties required by Amazon Honeycode.
    ///     </p>
    public let honeycode: HoneycodeConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by Infor Nexus.
    /// </p>
    public let inforNexus: InforNexusConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by Marketo.
    /// </p>
    public let marketo: MarketoConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by Amazon Redshift.
    /// </p>
    public let redshift: RedshiftConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by Salesforce.
    /// </p>
    public let salesforce: SalesforceConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by serviceNow.
    /// </p>
    public let serviceNow: ServiceNowConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by Singular.
    /// </p>
    public let singular: SingularConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by Slack.
    /// </p>
    public let slack: SlackConnectorProfileProperties?
    /// <p>
    /// The connector-specific properties required by Snowflake.
    /// </p>
    public let snowflake: SnowflakeConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by Trend Micro.
    /// </p>
    public let trendmicro: TrendmicroConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by Veeva.
    /// </p>
    public let veeva: VeevaConnectorProfileProperties?
    /// <p>
    ///   The connector-specific properties required by Zendesk.
    /// </p>
    public let zendesk: ZendeskConnectorProfileProperties?

    public init (
        amplitude: AmplitudeConnectorProfileProperties? = nil,
        datadog: DatadogConnectorProfileProperties? = nil,
        dynatrace: DynatraceConnectorProfileProperties? = nil,
        googleAnalytics: GoogleAnalyticsConnectorProfileProperties? = nil,
        honeycode: HoneycodeConnectorProfileProperties? = nil,
        inforNexus: InforNexusConnectorProfileProperties? = nil,
        marketo: MarketoConnectorProfileProperties? = nil,
        redshift: RedshiftConnectorProfileProperties? = nil,
        salesforce: SalesforceConnectorProfileProperties? = nil,
        serviceNow: ServiceNowConnectorProfileProperties? = nil,
        singular: SingularConnectorProfileProperties? = nil,
        slack: SlackConnectorProfileProperties? = nil,
        snowflake: SnowflakeConnectorProfileProperties? = nil,
        trendmicro: TrendmicroConnectorProfileProperties? = nil,
        veeva: VeevaConnectorProfileProperties? = nil,
        zendesk: ZendeskConnectorProfileProperties? = nil
    )
    {
        self.amplitude = amplitude
        self.datadog = datadog
        self.dynatrace = dynatrace
        self.googleAnalytics = googleAnalytics
        self.honeycode = honeycode
        self.inforNexus = inforNexus
        self.marketo = marketo
        self.redshift = redshift
        self.salesforce = salesforce
        self.serviceNow = serviceNow
        self.singular = singular
        self.slack = slack
        self.snowflake = snowflake
        self.trendmicro = trendmicro
        self.veeva = veeva
        self.zendesk = zendesk
    }
}

extension ConnectorServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorServerException(message: \(String(describing: message)))"}
}

extension ConnectorServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConnectorServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///  An error occurred when retrieving data from the connector endpoint.
/// </p>
public struct ConnectorServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectorServerExceptionBody: Equatable {
    public let message: String?
}

extension ConnectorServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ConnectorType {
    case amplitude
    case customerprofiles
    case datadog
    case dynatrace
    case eventbridge
    case googleanalytics
    case honeycode
    case infornexus
    case lookoutmetrics
    case marketo
    case redshift
    case s3
    case salesforce
    case servicenow
    case singular
    case slack
    case snowflake
    case trendmicro
    case upsolver
    case veeva
    case zendesk
    case sdkUnknown(String)
}

extension ConnectorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectorType] {
        return [
            .amplitude,
            .customerprofiles,
            .datadog,
            .dynatrace,
            .eventbridge,
            .googleanalytics,
            .honeycode,
            .infornexus,
            .lookoutmetrics,
            .marketo,
            .redshift,
            .s3,
            .salesforce,
            .servicenow,
            .singular,
            .slack,
            .snowflake,
            .trendmicro,
            .upsolver,
            .veeva,
            .zendesk,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amplitude: return "Amplitude"
        case .customerprofiles: return "CustomerProfiles"
        case .datadog: return "Datadog"
        case .dynatrace: return "Dynatrace"
        case .eventbridge: return "EventBridge"
        case .googleanalytics: return "Googleanalytics"
        case .honeycode: return "Honeycode"
        case .infornexus: return "Infornexus"
        case .lookoutmetrics: return "LookoutMetrics"
        case .marketo: return "Marketo"
        case .redshift: return "Redshift"
        case .s3: return "S3"
        case .salesforce: return "Salesforce"
        case .servicenow: return "Servicenow"
        case .singular: return "Singular"
        case .slack: return "Slack"
        case .snowflake: return "Snowflake"
        case .trendmicro: return "Trendmicro"
        case .upsolver: return "Upsolver"
        case .veeva: return "Veeva"
        case .zendesk: return "Zendesk"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectorType(rawValue: rawValue) ?? ConnectorType.sdkUnknown(rawValue)
    }
}

public struct CreateConnectorProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateConnectorProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectorProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectorProfileInput>
    public typealias MOutput = OperationOutput<CreateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectorProfileOutputError>
}

extension CreateConnectorProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectorProfileInput(connectionMode: \(String(describing: connectionMode)), connectorProfileConfig: \(String(describing: connectorProfileConfig)), connectorProfileName: \(String(describing: connectorProfileName)), connectorType: \(String(describing: connectorType)), kmsArn: \(String(describing: kmsArn)))"}
}

extension CreateConnectorProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
        case connectorType
        case kmsArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionMode = connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorProfileConfig = connectorProfileConfig {
            try encodeContainer.encode(connectorProfileConfig, forKey: .connectorProfileConfig)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let kmsArn = kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
    }
}

public struct CreateConnectorProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConnectorProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectorProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectorProfileInput>
    public typealias MOutput = OperationOutput<CreateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectorProfileOutputError>
}

public struct CreateConnectorProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConnectorProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectorProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectorProfileInput>
    public typealias MOutput = OperationOutput<CreateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectorProfileOutputError>
}

public struct CreateConnectorProfileInput: Equatable {
    /// <p>
    ///   Indicates the connection mode and specifies whether it is public or private. Private flows use AWS PrivateLink to route data over AWS infrastructure without exposing it to the public internet.
    /// </p>
    public let connectionMode: ConnectionMode?
    /// <p>
    /// Defines the connector-specific configuration and credentials.
    /// </p>
    public let connectorProfileConfig: ConnectorProfileConfig?
    /// <p>
    ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in your AWS account.
    /// </p>
    public let connectorProfileName: String?
    /// <p>
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorType: ConnectorType?
    /// <p>
    ///   The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    /// </p>
    public let kmsArn: String?

    public init (
        connectionMode: ConnectionMode? = nil,
        connectorProfileConfig: ConnectorProfileConfig? = nil,
        connectorProfileName: String? = nil,
        connectorType: ConnectorType? = nil,
        kmsArn: String? = nil
    )
    {
        self.connectionMode = connectionMode
        self.connectorProfileConfig = connectorProfileConfig
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.kmsArn = kmsArn
    }
}

struct CreateConnectorProfileInputBody: Equatable {
    public let connectorProfileName: String?
    public let kmsArn: String?
    public let connectorType: ConnectorType?
    public let connectionMode: ConnectionMode?
    public let connectorProfileConfig: ConnectorProfileConfig?
}

extension CreateConnectorProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
        case connectorType
        case kmsArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let connectorProfileConfigDecoded = try containerValues.decodeIfPresent(ConnectorProfileConfig.self, forKey: .connectorProfileConfig)
        connectorProfileConfig = connectorProfileConfigDecoded
    }
}

extension CreateConnectorProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectorProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectorProfileOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectorProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectorProfileOutputResponse(connectorProfileArn: \(String(describing: connectorProfileArn)))"}
}

extension CreateConnectorProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectorProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileArn = output.connectorProfileArn
        } else {
            self.connectorProfileArn = nil
        }
    }
}

public struct CreateConnectorProfileOutputResponse: Equatable {
    /// <p>
    ///   The Amazon Resource Name (ARN) of the connector profile.
    /// </p>
    public let connectorProfileArn: String?

    public init (
        connectorProfileArn: String? = nil
    )
    {
        self.connectorProfileArn = connectorProfileArn
    }
}

struct CreateConnectorProfileOutputResponseBody: Equatable {
    public let connectorProfileArn: String?
}

extension CreateConnectorProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorProfileArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
    }
}

public struct CreateFlowInputBodyMiddleware: Middleware {
    public let id: String = "CreateFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFlowInput>
    public typealias MOutput = OperationOutput<CreateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFlowOutputError>
}

extension CreateFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFlowInput(description: \(String(describing: description)), destinationFlowConfigList: \(String(describing: destinationFlowConfigList)), flowName: \(String(describing: flowName)), kmsArn: \(String(describing: kmsArn)), sourceFlowConfig: \(String(describing: sourceFlowConfig)), tags: \(String(describing: tags)), tasks: \(String(describing: tasks)), triggerConfig: \(String(describing: triggerConfig)))"}
}

extension CreateFlowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case kmsArn
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationFlowConfigList = destinationFlowConfigList {
            var destinationFlowConfigListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationFlowConfigList)
            for destinationflowconfiglist0 in destinationFlowConfigList {
                try destinationFlowConfigListContainer.encode(destinationflowconfiglist0)
            }
        }
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let kmsArn = kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let sourceFlowConfig = sourceFlowConfig {
            try encodeContainer.encode(sourceFlowConfig, forKey: .sourceFlowConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tasks = tasks {
            var tasksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tasks)
            for tasks0 in tasks {
                try tasksContainer.encode(tasks0)
            }
        }
        if let triggerConfig = triggerConfig {
            try encodeContainer.encode(triggerConfig, forKey: .triggerConfig)
        }
    }
}

public struct CreateFlowInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFlowInput>
    public typealias MOutput = OperationOutput<CreateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFlowOutputError>
}

public struct CreateFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFlowInput>
    public typealias MOutput = OperationOutput<CreateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFlowOutputError>
}

public struct CreateFlowInput: Equatable {
    /// <p>
    ///  A description of the flow you want to create.
    /// </p>
    public let description: String?
    /// <p>
    /// The configuration that controls how Amazon AppFlow places data in the destination connector.
    /// </p>
    public let destinationFlowConfigList: [DestinationFlowConfig]?
    /// <p>
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: String?
    /// <p>
    ///   The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    /// </p>
    public let kmsArn: String?
    /// <p>
    /// The configuration that controls how Amazon AppFlow retrieves data from the source connector.
    /// </p>
    public let sourceFlowConfig: SourceFlowConfig?
    /// <p>
    /// The tags used to organize, track, or control access for your flow.
    /// </p>
    public let tags: [String:String]?
    /// <p>
    ///  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// </p>
    public let tasks: [Task]?
    /// <p>
    ///  The trigger settings that determine how and when the flow runs.
    /// </p>
    public let triggerConfig: TriggerConfig?

    public init (
        description: String? = nil,
        destinationFlowConfigList: [DestinationFlowConfig]? = nil,
        flowName: String? = nil,
        kmsArn: String? = nil,
        sourceFlowConfig: SourceFlowConfig? = nil,
        tags: [String:String]? = nil,
        tasks: [Task]? = nil,
        triggerConfig: TriggerConfig? = nil
    )
    {
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowName = flowName
        self.kmsArn = kmsArn
        self.sourceFlowConfig = sourceFlowConfig
        self.tags = tags
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct CreateFlowInputBody: Equatable {
    public let flowName: String?
    public let description: String?
    public let kmsArn: String?
    public let triggerConfig: TriggerConfig?
    public let sourceFlowConfig: SourceFlowConfig?
    public let destinationFlowConfigList: [DestinationFlowConfig]?
    public let tasks: [Task]?
    public let tags: [String:String]?
}

extension CreateFlowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case kmsArn
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let tasksContainer = try containerValues.decodeIfPresent([Task?].self, forKey: .tasks)
        var tasksDecoded0:[Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFlowOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFlowOutputResponse(flowArn: \(String(describing: flowArn)), flowStatus: \(String(describing: flowStatus)))"}
}

extension CreateFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct CreateFlowOutputResponse: Equatable {
    /// <p>
    /// The flow's Amazon Resource Name (ARN).
    /// </p>
    public let flowArn: String?
    /// <p>
    ///       Indicates the current status of the flow.
    ///     </p>
    public let flowStatus: FlowStatus?

    public init (
        flowArn: String? = nil,
        flowStatus: FlowStatus? = nil
    )
    {
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct CreateFlowOutputResponseBody: Equatable {
    public let flowArn: String?
    public let flowStatus: FlowStatus?
}

extension CreateFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn
        case flowStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

extension CustomerProfilesDestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName
        case objectTypeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let objectTypeName = objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
    }
}

extension CustomerProfilesDestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerProfilesDestinationProperties(domainName: \(String(describing: domainName)), objectTypeName: \(String(describing: objectTypeName)))"}
}

/// <p>
///       The properties that are applied when Amazon Connect Customer Profiles is used as a destination.
///     </p>
public struct CustomerProfilesDestinationProperties: Equatable {
    /// <p>
    ///       The unique name of the Amazon Connect Customer Profiles domain.
    ///     </p>
    public let domainName: String?
    /// <p>
    ///       The object specified in the Amazon Connect Customer Profiles flow destination.
    ///     </p>
    public let objectTypeName: String?

    public init (
        domainName: String? = nil,
        objectTypeName: String? = nil
    )
    {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
    }
}

extension CustomerProfilesMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension CustomerProfilesMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerProfilesMetadata()"}
}

/// <p>
///       The connector metadata specific to Amazon Connect Customer Profiles.
///     </p>
public struct CustomerProfilesMetadata: Equatable {

    public init() {}
}

public enum DataPullMode {
    case complete
    case incremental
    case sdkUnknown(String)
}

extension DataPullMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataPullMode] {
        return [
            .complete,
            .incremental,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "Complete"
        case .incremental: return "Incremental"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataPullMode(rawValue: rawValue) ?? DataPullMode.sdkUnknown(rawValue)
    }
}

public enum DatadogConnectorOperator {
    case addition
    case between
    case division
    case equalTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension DatadogConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatadogConnectorOperator] {
        return [
            .addition,
            .between,
            .division,
            .equalTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatadogConnectorOperator(rawValue: rawValue) ?? DatadogConnectorOperator.sdkUnknown(rawValue)
    }
}

extension DatadogConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKey
        case applicationKey
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let applicationKey = applicationKey {
            try encodeContainer.encode(applicationKey, forKey: .applicationKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let applicationKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationKey)
        applicationKey = applicationKeyDecoded
    }
}

extension DatadogConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatadogConnectorProfileCredentials(apiKey: \(String(describing: apiKey)), applicationKey: \(String(describing: applicationKey)))"}
}

/// <p>
///   The connector-specific credentials required by Datadog.
/// </p>
public struct DatadogConnectorProfileCredentials: Equatable {
    /// <p>
    ///   A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
    /// </p>
    public let apiKey: String?
    /// <p>
    ///   Application keys, in conjunction with your API key, give you full access to Datadogs programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
    /// </p>
    public let applicationKey: String?

    public init (
        apiKey: String? = nil,
        applicationKey: String? = nil
    )
    {
        self.apiKey = apiKey
        self.applicationKey = applicationKey
    }
}

extension DatadogConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension DatadogConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatadogConnectorProfileProperties(instanceUrl: \(String(describing: instanceUrl)))"}
}

/// <p>
///   The connector-specific profile properties required by Datadog.
/// </p>
public struct DatadogConnectorProfileProperties: Equatable {
    /// <p>
    ///  The location of the Datadog resource.
    /// </p>
    public let instanceUrl: String?

    public init (
        instanceUrl: String? = nil
    )
    {
        self.instanceUrl = instanceUrl
    }
}

extension DatadogMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension DatadogMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatadogMetadata()"}
}

/// <p>
///   The connector metadata specific to Datadog.
/// </p>
public struct DatadogMetadata: Equatable {

    public init() {}
}

extension DatadogSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension DatadogSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatadogSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when Datadog is being used as a source.
/// </p>
public struct DatadogSourceProperties: Equatable {
    /// <p>
    ///   The object specified in the Datadog flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

public struct DeleteConnectorProfileInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConnectorProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectorProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectorProfileInput>
    public typealias MOutput = OperationOutput<DeleteConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectorProfileOutputError>
}

extension DeleteConnectorProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectorProfileInput(connectorProfileName: \(String(describing: connectorProfileName)), forceDelete: \(String(describing: forceDelete)))"}
}

extension DeleteConnectorProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorProfileName
        case forceDelete
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

public struct DeleteConnectorProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConnectorProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectorProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectorProfileInput>
    public typealias MOutput = OperationOutput<DeleteConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectorProfileOutputError>
}

public struct DeleteConnectorProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConnectorProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectorProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectorProfileInput>
    public typealias MOutput = OperationOutput<DeleteConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectorProfileOutputError>
}

public struct DeleteConnectorProfileInput: Equatable {
    /// <p>
    ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in your account.
    /// </p>
    public let connectorProfileName: String?
    /// <p>
    /// Indicates whether Amazon AppFlow should delete the profile, even if it is currently in use in one or more flows.
    /// </p>
    public let forceDelete: Bool

    public init (
        connectorProfileName: String? = nil,
        forceDelete: Bool = false
    )
    {
        self.connectorProfileName = connectorProfileName
        self.forceDelete = forceDelete
    }
}

struct DeleteConnectorProfileInputBody: Equatable {
    public let connectorProfileName: String?
    public let forceDelete: Bool
}

extension DeleteConnectorProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorProfileName
        case forceDelete
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let forceDeleteDecoded = try containerValues.decode(Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteConnectorProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectorProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectorProfileOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectorProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectorProfileOutputResponse()"}
}

extension DeleteConnectorProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectorProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteConnectorProfileOutputResponseBody: Equatable {
}

extension DeleteConnectorProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteFlowInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFlowInput>
    public typealias MOutput = OperationOutput<DeleteFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFlowOutputError>
}

extension DeleteFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFlowInput(flowName: \(String(describing: flowName)), forceDelete: \(String(describing: forceDelete)))"}
}

extension DeleteFlowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case flowName
        case forceDelete
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

public struct DeleteFlowInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFlowInput>
    public typealias MOutput = OperationOutput<DeleteFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFlowOutputError>
}

public struct DeleteFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFlowInput>
    public typealias MOutput = OperationOutput<DeleteFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFlowOutputError>
}

public struct DeleteFlowInput: Equatable {
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: String?
    /// <p>
    ///   Indicates whether Amazon AppFlow should delete the flow, even if it is currently in use.
    /// </p>
    public let forceDelete: Bool

    public init (
        flowName: String? = nil,
        forceDelete: Bool = false
    )
    {
        self.flowName = flowName
        self.forceDelete = forceDelete
    }
}

struct DeleteFlowInputBody: Equatable {
    public let flowName: String?
    public let forceDelete: Bool
}

extension DeleteFlowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowName
        case forceDelete
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let forceDeleteDecoded = try containerValues.decode(Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFlowOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFlowOutputResponse()"}
}

extension DeleteFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFlowOutputResponse: Equatable {

    public init() {}
}

struct DeleteFlowOutputResponseBody: Equatable {
}

extension DeleteFlowOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeConnectorEntityInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConnectorEntityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectorEntityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectorEntityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectorEntityInput>
    public typealias MOutput = OperationOutput<DescribeConnectorEntityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectorEntityOutputError>
}

extension DescribeConnectorEntityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectorEntityInput(connectorEntityName: \(String(describing: connectorEntityName)), connectorProfileName: \(String(describing: connectorProfileName)), connectorType: \(String(describing: connectorType)))"}
}

extension DescribeConnectorEntityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorEntityName
        case connectorProfileName
        case connectorType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorEntityName = connectorEntityName {
            try encodeContainer.encode(connectorEntityName, forKey: .connectorEntityName)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
    }
}

public struct DescribeConnectorEntityInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConnectorEntityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectorEntityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectorEntityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectorEntityInput>
    public typealias MOutput = OperationOutput<DescribeConnectorEntityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectorEntityOutputError>
}

public struct DescribeConnectorEntityInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConnectorEntityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectorEntityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectorEntityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectorEntityInput>
    public typealias MOutput = OperationOutput<DescribeConnectorEntityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectorEntityOutputError>
}

public struct DescribeConnectorEntityInput: Equatable {
    /// <p>
    ///  The entity name for that connector.
    /// </p>
    public let connectorEntityName: String?
    /// <p>
    ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in the AWS account.
    /// </p>
    public let connectorProfileName: String?
    /// <p>
    ///   The type of connector application, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorType: ConnectorType?

    public init (
        connectorEntityName: String? = nil,
        connectorProfileName: String? = nil,
        connectorType: ConnectorType? = nil
    )
    {
        self.connectorEntityName = connectorEntityName
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
    }
}

struct DescribeConnectorEntityInputBody: Equatable {
    public let connectorEntityName: String?
    public let connectorType: ConnectorType?
    public let connectorProfileName: String?
}

extension DescribeConnectorEntityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorEntityName
        case connectorProfileName
        case connectorType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorEntityName)
        connectorEntityName = connectorEntityNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
    }
}

extension DescribeConnectorEntityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectorEntityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectorEntityOutputError: Swift.Error, Equatable {
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectorEntityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectorEntityOutputResponse(connectorEntityFields: \(String(describing: connectorEntityFields)))"}
}

extension DescribeConnectorEntityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectorEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorEntityFields = output.connectorEntityFields
        } else {
            self.connectorEntityFields = nil
        }
    }
}

public struct DescribeConnectorEntityOutputResponse: Equatable {
    /// <p>
    ///   Describes the fields for that connector entity. For example, for an <i>account</i> entity, the fields would be <i>account name</i>, <i>account ID</i>, and so on.
    /// </p>
    public let connectorEntityFields: [ConnectorEntityField]?

    public init (
        connectorEntityFields: [ConnectorEntityField]? = nil
    )
    {
        self.connectorEntityFields = connectorEntityFields
    }
}

struct DescribeConnectorEntityOutputResponseBody: Equatable {
    public let connectorEntityFields: [ConnectorEntityField]?
}

extension DescribeConnectorEntityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorEntityFields
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityFieldsContainer = try containerValues.decodeIfPresent([ConnectorEntityField?].self, forKey: .connectorEntityFields)
        var connectorEntityFieldsDecoded0:[ConnectorEntityField]? = nil
        if let connectorEntityFieldsContainer = connectorEntityFieldsContainer {
            connectorEntityFieldsDecoded0 = [ConnectorEntityField]()
            for structure0 in connectorEntityFieldsContainer {
                if let structure0 = structure0 {
                    connectorEntityFieldsDecoded0?.append(structure0)
                }
            }
        }
        connectorEntityFields = connectorEntityFieldsDecoded0
    }
}

public struct DescribeConnectorProfilesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConnectorProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectorProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectorProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectorProfilesInput>
    public typealias MOutput = OperationOutput<DescribeConnectorProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectorProfilesOutputError>
}

extension DescribeConnectorProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectorProfilesInput(connectorProfileNames: \(String(describing: connectorProfileNames)), connectorType: \(String(describing: connectorType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConnectorProfilesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorProfileNames
        case connectorType
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileNames = connectorProfileNames {
            var connectorProfileNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorProfileNames)
            for connectorprofilenamelist0 in connectorProfileNames {
                try connectorProfileNamesContainer.encode(connectorprofilenamelist0)
            }
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeConnectorProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConnectorProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectorProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectorProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectorProfilesInput>
    public typealias MOutput = OperationOutput<DescribeConnectorProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectorProfilesOutputError>
}

public struct DescribeConnectorProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConnectorProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectorProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectorProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectorProfilesInput>
    public typealias MOutput = OperationOutput<DescribeConnectorProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectorProfilesOutputError>
}

public struct DescribeConnectorProfilesInput: Equatable {
    /// <p>
    ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in the AWS account.
    /// </p>
    public let connectorProfileNames: [String]?
    /// <p>
    ///   The type of connector, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorType: ConnectorType?
    /// <p>
    ///        Specifies the maximum number of items that should be returned in the result set. The default for <code>maxResults</code> is 20 (for all paginated API operations).
    ///     </p>
    public let maxResults: Int?
    /// <p>
    /// The pagination token for the next page of data.
    /// </p>
    public let nextToken: String?

    public init (
        connectorProfileNames: [String]? = nil,
        connectorType: ConnectorType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.connectorProfileNames = connectorProfileNames
        self.connectorType = connectorType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeConnectorProfilesInputBody: Equatable {
    public let connectorProfileNames: [String]?
    public let connectorType: ConnectorType?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeConnectorProfilesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorProfileNames
        case connectorType
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .connectorProfileNames)
        var connectorProfileNamesDecoded0:[String]? = nil
        if let connectorProfileNamesContainer = connectorProfileNamesContainer {
            connectorProfileNamesDecoded0 = [String]()
            for string0 in connectorProfileNamesContainer {
                if let string0 = string0 {
                    connectorProfileNamesDecoded0?.append(string0)
                }
            }
        }
        connectorProfileNames = connectorProfileNamesDecoded0
        let connectorTypeDecoded = try containerValues.decodeIfPresent(ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectorProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectorProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectorProfilesOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectorProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectorProfilesOutputResponse(connectorProfileDetails: \(String(describing: connectorProfileDetails)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConnectorProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectorProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileDetails = output.connectorProfileDetails
            self.nextToken = output.nextToken
        } else {
            self.connectorProfileDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectorProfilesOutputResponse: Equatable {
    /// <p>
    /// Returns information about the connector profiles associated with the flow.
    /// </p>
    public let connectorProfileDetails: [ConnectorProfile]?
    /// <p>
    ///   The pagination token for the next page of data. If <code>nextToken=null</code>, this means that all records have been fetched.
    /// </p>
    public let nextToken: String?

    public init (
        connectorProfileDetails: [ConnectorProfile]? = nil,
        nextToken: String? = nil
    )
    {
        self.connectorProfileDetails = connectorProfileDetails
        self.nextToken = nextToken
    }
}

struct DescribeConnectorProfilesOutputResponseBody: Equatable {
    public let connectorProfileDetails: [ConnectorProfile]?
    public let nextToken: String?
}

extension DescribeConnectorProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorProfileDetails
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileDetailsContainer = try containerValues.decodeIfPresent([ConnectorProfile?].self, forKey: .connectorProfileDetails)
        var connectorProfileDetailsDecoded0:[ConnectorProfile]? = nil
        if let connectorProfileDetailsContainer = connectorProfileDetailsContainer {
            connectorProfileDetailsDecoded0 = [ConnectorProfile]()
            for structure0 in connectorProfileDetailsContainer {
                if let structure0 = structure0 {
                    connectorProfileDetailsDecoded0?.append(structure0)
                }
            }
        }
        connectorProfileDetails = connectorProfileDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeConnectorsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConnectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectorsInput>
    public typealias MOutput = OperationOutput<DescribeConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectorsOutputError>
}

extension DescribeConnectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectorsInput(connectorTypes: \(String(describing: connectorTypes)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConnectorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorTypes
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorTypes = connectorTypes {
            var connectorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorTypes)
            for connectortypelist0 in connectorTypes {
                try connectorTypesContainer.encode(connectortypelist0.rawValue)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeConnectorsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConnectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectorsInput>
    public typealias MOutput = OperationOutput<DescribeConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectorsOutputError>
}

public struct DescribeConnectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConnectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectorsInput>
    public typealias MOutput = OperationOutput<DescribeConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectorsOutputError>
}

public struct DescribeConnectorsInput: Equatable {
    /// <p>
    ///   The type of connector, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorTypes: [ConnectorType]?
    /// <p>
    /// The pagination token for the next page of data.
    /// </p>
    public let nextToken: String?

    public init (
        connectorTypes: [ConnectorType]? = nil,
        nextToken: String? = nil
    )
    {
        self.connectorTypes = connectorTypes
        self.nextToken = nextToken
    }
}

struct DescribeConnectorsInputBody: Equatable {
    public let connectorTypes: [ConnectorType]?
    public let nextToken: String?
}

extension DescribeConnectorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorTypes
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypesContainer = try containerValues.decodeIfPresent([ConnectorType?].self, forKey: .connectorTypes)
        var connectorTypesDecoded0:[ConnectorType]? = nil
        if let connectorTypesContainer = connectorTypesContainer {
            connectorTypesDecoded0 = [ConnectorType]()
            for string0 in connectorTypesContainer {
                if let string0 = string0 {
                    connectorTypesDecoded0?.append(string0)
                }
            }
        }
        connectorTypes = connectorTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectorsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectorsOutputResponse(connectorConfigurations: \(String(describing: connectorConfigurations)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConnectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorConfigurations = output.connectorConfigurations
            self.nextToken = output.nextToken
        } else {
            self.connectorConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectorsOutputResponse: Equatable {
    /// <p>
    ///   The configuration that is applied to the connectors used in the flow.
    /// </p>
    public let connectorConfigurations: [String:ConnectorConfiguration]?
    /// <p>
    /// The pagination token for the next page of data.
    /// </p>
    public let nextToken: String?

    public init (
        connectorConfigurations: [String:ConnectorConfiguration]? = nil,
        nextToken: String? = nil
    )
    {
        self.connectorConfigurations = connectorConfigurations
        self.nextToken = nextToken
    }
}

struct DescribeConnectorsOutputResponseBody: Equatable {
    public let connectorConfigurations: [String:ConnectorConfiguration]?
    public let nextToken: String?
}

extension DescribeConnectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorConfigurations
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorConfigurationsContainer = try containerValues.decodeIfPresent([String: ConnectorConfiguration?].self, forKey: .connectorConfigurations)
        var connectorConfigurationsDecoded0: [String:ConnectorConfiguration]? = nil
        if let connectorConfigurationsContainer = connectorConfigurationsContainer {
            connectorConfigurationsDecoded0 = [String:ConnectorConfiguration]()
            for (key0, connectorconfiguration0) in connectorConfigurationsContainer {
                if let connectorconfiguration0 = connectorconfiguration0 {
                    connectorConfigurationsDecoded0?[key0] = connectorconfiguration0
                }
            }
        }
        connectorConfigurations = connectorConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeFlowExecutionRecordsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFlowExecutionRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFlowExecutionRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFlowExecutionRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFlowExecutionRecordsInput>
    public typealias MOutput = OperationOutput<DescribeFlowExecutionRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFlowExecutionRecordsOutputError>
}

extension DescribeFlowExecutionRecordsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFlowExecutionRecordsInput(flowName: \(String(describing: flowName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeFlowExecutionRecordsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case flowName
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeFlowExecutionRecordsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFlowExecutionRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFlowExecutionRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFlowExecutionRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFlowExecutionRecordsInput>
    public typealias MOutput = OperationOutput<DescribeFlowExecutionRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFlowExecutionRecordsOutputError>
}

public struct DescribeFlowExecutionRecordsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFlowExecutionRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFlowExecutionRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFlowExecutionRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFlowExecutionRecordsInput>
    public typealias MOutput = OperationOutput<DescribeFlowExecutionRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFlowExecutionRecordsOutputError>
}

public struct DescribeFlowExecutionRecordsInput: Equatable {
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: String?
    /// <p>
    ///     Specifies the maximum number of items that should be returned in the result set. The default for <code>maxResults</code> is 20 (for all paginated API operations).
    ///   </p>
    public let maxResults: Int?
    /// <p>
    /// The pagination token for the next page of data.
    /// </p>
    public let nextToken: String?

    public init (
        flowName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.flowName = flowName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeFlowExecutionRecordsInputBody: Equatable {
    public let flowName: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeFlowExecutionRecordsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowName
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFlowExecutionRecordsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFlowExecutionRecordsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFlowExecutionRecordsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFlowExecutionRecordsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFlowExecutionRecordsOutputResponse(flowExecutions: \(String(describing: flowExecutions)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeFlowExecutionRecordsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFlowExecutionRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowExecutions = output.flowExecutions
            self.nextToken = output.nextToken
        } else {
            self.flowExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFlowExecutionRecordsOutputResponse: Equatable {
    /// <p>
    /// Returns a list of all instances when this flow was run.
    /// </p>
    public let flowExecutions: [ExecutionRecord]?
    /// <p>
    ///  The pagination token for the next page of data.
    /// </p>
    public let nextToken: String?

    public init (
        flowExecutions: [ExecutionRecord]? = nil,
        nextToken: String? = nil
    )
    {
        self.flowExecutions = flowExecutions
        self.nextToken = nextToken
    }
}

struct DescribeFlowExecutionRecordsOutputResponseBody: Equatable {
    public let flowExecutions: [ExecutionRecord]?
    public let nextToken: String?
}

extension DescribeFlowExecutionRecordsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowExecutions
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowExecutionsContainer = try containerValues.decodeIfPresent([ExecutionRecord?].self, forKey: .flowExecutions)
        var flowExecutionsDecoded0:[ExecutionRecord]? = nil
        if let flowExecutionsContainer = flowExecutionsContainer {
            flowExecutionsDecoded0 = [ExecutionRecord]()
            for structure0 in flowExecutionsContainer {
                if let structure0 = structure0 {
                    flowExecutionsDecoded0?.append(structure0)
                }
            }
        }
        flowExecutions = flowExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeFlowInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFlowInput>
    public typealias MOutput = OperationOutput<DescribeFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFlowOutputError>
}

extension DescribeFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFlowInput(flowName: \(String(describing: flowName)))"}
}

extension DescribeFlowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case flowName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

public struct DescribeFlowInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFlowInput>
    public typealias MOutput = OperationOutput<DescribeFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFlowOutputError>
}

public struct DescribeFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFlowInput>
    public typealias MOutput = OperationOutput<DescribeFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFlowOutputError>
}

public struct DescribeFlowInput: Equatable {
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: String?

    public init (
        flowName: String? = nil
    )
    {
        self.flowName = flowName
    }
}

struct DescribeFlowInputBody: Equatable {
    public let flowName: String?
}

extension DescribeFlowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension DescribeFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFlowOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFlowOutputResponse(createdAt: \(String(describing: createdAt)), createdBy: \(String(describing: createdBy)), description: \(String(describing: description)), destinationFlowConfigList: \(String(describing: destinationFlowConfigList)), flowArn: \(String(describing: flowArn)), flowName: \(String(describing: flowName)), flowStatus: \(String(describing: flowStatus)), flowStatusMessage: \(String(describing: flowStatusMessage)), kmsArn: \(String(describing: kmsArn)), lastRunExecutionDetails: \(String(describing: lastRunExecutionDetails)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), lastUpdatedBy: \(String(describing: lastUpdatedBy)), sourceFlowConfig: \(String(describing: sourceFlowConfig)), tags: \(String(describing: tags)), tasks: \(String(describing: tasks)), triggerConfig: \(String(describing: triggerConfig)))"}
}

extension DescribeFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.destinationFlowConfigList = output.destinationFlowConfigList
            self.flowArn = output.flowArn
            self.flowName = output.flowName
            self.flowStatus = output.flowStatus
            self.flowStatusMessage = output.flowStatusMessage
            self.kmsArn = output.kmsArn
            self.lastRunExecutionDetails = output.lastRunExecutionDetails
            self.lastUpdatedAt = output.lastUpdatedAt
            self.lastUpdatedBy = output.lastUpdatedBy
            self.sourceFlowConfig = output.sourceFlowConfig
            self.tags = output.tags
            self.tasks = output.tasks
            self.triggerConfig = output.triggerConfig
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.destinationFlowConfigList = nil
            self.flowArn = nil
            self.flowName = nil
            self.flowStatus = nil
            self.flowStatusMessage = nil
            self.kmsArn = nil
            self.lastRunExecutionDetails = nil
            self.lastUpdatedAt = nil
            self.lastUpdatedBy = nil
            self.sourceFlowConfig = nil
            self.tags = nil
            self.tasks = nil
            self.triggerConfig = nil
        }
    }
}

public struct DescribeFlowOutputResponse: Equatable {
    /// <p>
    /// Specifies when the flow was created.
    /// </p>
    public let createdAt: Date?
    /// <p>
    ///   The ARN of the user who created the flow.
    /// </p>
    public let createdBy: String?
    /// <p>
    ///   A description of the flow.
    /// </p>
    public let description: String?
    /// <p>
    ///   The configuration that controls how Amazon AppFlow transfers data to the destination connector.
    /// </p>
    public let destinationFlowConfigList: [DestinationFlowConfig]?
    /// <p>
    ///   The flow's Amazon Resource Name (ARN).
    /// </p>
    public let flowArn: String?
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: String?
    /// <p>
    ///       Indicates the current status of the flow.
    ///     </p>
    public let flowStatus: FlowStatus?
    /// <p>
    ///       Contains an error message if the flow status is in a suspended or error state. This applies only to scheduled or event-triggered flows.
    ///     </p>
    public let flowStatusMessage: String?
    /// <p>
    ///   The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    /// </p>
    public let kmsArn: String?
    /// <p>
    /// Describes the details of the most recent flow run.
    /// </p>
    public let lastRunExecutionDetails: ExecutionDetails?
    /// <p>
    ///   Specifies when the flow was last updated.
    /// </p>
    public let lastUpdatedAt: Date?
    /// <p>
    /// Specifies the user name of the account that performed the most recent update.
    /// </p>
    public let lastUpdatedBy: String?
    /// <p>
    ///   The configuration that controls how Amazon AppFlow retrieves data from the source connector.
    /// </p>
    public let sourceFlowConfig: SourceFlowConfig?
    /// <p>
    ///   The tags used to organize, track, or control access for your flow.
    /// </p>
    public let tags: [String:String]?
    /// <p>
    ///   A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// </p>
    public let tasks: [Task]?
    /// <p>
    ///   The trigger settings that determine how and when the flow runs.
    /// </p>
    public let triggerConfig: TriggerConfig?

    public init (
        createdAt: Date? = nil,
        createdBy: String? = nil,
        description: String? = nil,
        destinationFlowConfigList: [DestinationFlowConfig]? = nil,
        flowArn: String? = nil,
        flowName: String? = nil,
        flowStatus: FlowStatus? = nil,
        flowStatusMessage: String? = nil,
        kmsArn: String? = nil,
        lastRunExecutionDetails: ExecutionDetails? = nil,
        lastUpdatedAt: Date? = nil,
        lastUpdatedBy: String? = nil,
        sourceFlowConfig: SourceFlowConfig? = nil,
        tags: [String:String]? = nil,
        tasks: [Task]? = nil,
        triggerConfig: TriggerConfig? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowArn = flowArn
        self.flowName = flowName
        self.flowStatus = flowStatus
        self.flowStatusMessage = flowStatusMessage
        self.kmsArn = kmsArn
        self.lastRunExecutionDetails = lastRunExecutionDetails
        self.lastUpdatedAt = lastUpdatedAt
        self.lastUpdatedBy = lastUpdatedBy
        self.sourceFlowConfig = sourceFlowConfig
        self.tags = tags
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct DescribeFlowOutputResponseBody: Equatable {
    public let flowArn: String?
    public let description: String?
    public let flowName: String?
    public let kmsArn: String?
    public let flowStatus: FlowStatus?
    public let flowStatusMessage: String?
    public let sourceFlowConfig: SourceFlowConfig?
    public let destinationFlowConfigList: [DestinationFlowConfig]?
    public let lastRunExecutionDetails: ExecutionDetails?
    public let triggerConfig: TriggerConfig?
    public let tasks: [Task]?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
    public let createdBy: String?
    public let lastUpdatedBy: String?
    public let tags: [String:String]?
}

extension DescribeFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case createdBy
        case description
        case destinationFlowConfigList
        case flowArn
        case flowName
        case flowStatus
        case flowStatusMessage
        case kmsArn
        case lastRunExecutionDetails
        case lastUpdatedAt
        case lastUpdatedBy
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let flowStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowStatusMessage)
        flowStatusMessage = flowStatusMessageDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let lastRunExecutionDetailsDecoded = try containerValues.decodeIfPresent(ExecutionDetails.self, forKey: .lastRunExecutionDetails)
        lastRunExecutionDetails = lastRunExecutionDetailsDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let tasksContainer = try containerValues.decodeIfPresent([Task?].self, forKey: .tasks)
        var tasksDecoded0:[Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DestinationConnectorProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerProfiles = "CustomerProfiles"
        case eventBridge = "EventBridge"
        case honeycode = "Honeycode"
        case lookoutMetrics = "LookoutMetrics"
        case redshift = "Redshift"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case snowflake = "Snowflake"
        case upsolver = "Upsolver"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerProfiles = customerProfiles {
            try encodeContainer.encode(customerProfiles, forKey: .customerProfiles)
        }
        if let eventBridge = eventBridge {
            try encodeContainer.encode(eventBridge, forKey: .eventBridge)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let lookoutMetrics = lookoutMetrics {
            try encodeContainer.encode(lookoutMetrics, forKey: .lookoutMetrics)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let upsolver = upsolver {
            try encodeContainer.encode(upsolver, forKey: .upsolver)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let redshiftDecoded = try containerValues.decodeIfPresent(RedshiftDestinationProperties.self, forKey: .redshift)
        redshift = redshiftDecoded
        let s3Decoded = try containerValues.decodeIfPresent(S3DestinationProperties.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(SalesforceDestinationProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(SnowflakeDestinationProperties.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let eventBridgeDecoded = try containerValues.decodeIfPresent(EventBridgeDestinationProperties.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
        let lookoutMetricsDecoded = try containerValues.decodeIfPresent(LookoutMetricsDestinationProperties.self, forKey: .lookoutMetrics)
        lookoutMetrics = lookoutMetricsDecoded
        let upsolverDecoded = try containerValues.decodeIfPresent(UpsolverDestinationProperties.self, forKey: .upsolver)
        upsolver = upsolverDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(HoneycodeDestinationProperties.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let customerProfilesDecoded = try containerValues.decodeIfPresent(CustomerProfilesDestinationProperties.self, forKey: .customerProfiles)
        customerProfiles = customerProfilesDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(ZendeskDestinationProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension DestinationConnectorProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationConnectorProperties(customerProfiles: \(String(describing: customerProfiles)), eventBridge: \(String(describing: eventBridge)), honeycode: \(String(describing: honeycode)), lookoutMetrics: \(String(describing: lookoutMetrics)), redshift: \(String(describing: redshift)), s3: \(String(describing: s3)), salesforce: \(String(describing: salesforce)), snowflake: \(String(describing: snowflake)), upsolver: \(String(describing: upsolver)), zendesk: \(String(describing: zendesk)))"}
}

/// <p>
///   This stores the information that is required to query a particular connector.
/// </p>
public struct DestinationConnectorProperties: Equatable {
    /// <p>
    ///       The properties required to query Amazon Connect Customer Profiles.
    ///     </p>
    public let customerProfiles: CustomerProfilesDestinationProperties?
    /// <p>
    ///       The properties required to query Amazon EventBridge.
    ///     </p>
    public let eventBridge: EventBridgeDestinationProperties?
    /// <p>
    ///       The properties required to query Amazon Honeycode.
    ///     </p>
    public let honeycode: HoneycodeDestinationProperties?
    /// <p>
    ///       The properties required to query Amazon Lookout for Metrics.
    ///     </p>
    public let lookoutMetrics: LookoutMetricsDestinationProperties?
    /// <p>
    ///   The properties required to query Amazon Redshift.
    /// </p>
    public let redshift: RedshiftDestinationProperties?
    /// <p>
    ///   The properties required to query Amazon S3.
    /// </p>
    public let s3: S3DestinationProperties?
    /// <p>
    ///   The properties required to query Salesforce.
    /// </p>
    public let salesforce: SalesforceDestinationProperties?
    /// <p>
    ///   The properties required to query Snowflake.
    /// </p>
    public let snowflake: SnowflakeDestinationProperties?
    /// <p>
    ///       The properties required to query Upsolver.
    ///     </p>
    public let upsolver: UpsolverDestinationProperties?
    public let zendesk: ZendeskDestinationProperties?

    public init (
        customerProfiles: CustomerProfilesDestinationProperties? = nil,
        eventBridge: EventBridgeDestinationProperties? = nil,
        honeycode: HoneycodeDestinationProperties? = nil,
        lookoutMetrics: LookoutMetricsDestinationProperties? = nil,
        redshift: RedshiftDestinationProperties? = nil,
        s3: S3DestinationProperties? = nil,
        salesforce: SalesforceDestinationProperties? = nil,
        snowflake: SnowflakeDestinationProperties? = nil,
        upsolver: UpsolverDestinationProperties? = nil,
        zendesk: ZendeskDestinationProperties? = nil
    )
    {
        self.customerProfiles = customerProfiles
        self.eventBridge = eventBridge
        self.honeycode = honeycode
        self.lookoutMetrics = lookoutMetrics
        self.redshift = redshift
        self.s3 = s3
        self.salesforce = salesforce
        self.snowflake = snowflake
        self.upsolver = upsolver
        self.zendesk = zendesk
    }
}

extension DestinationFieldProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isCreatable
        case isNullable
        case isUpdatable
        case isUpsertable
        case supportedWriteOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isCreatable != false {
            try encodeContainer.encode(isCreatable, forKey: .isCreatable)
        }
        if isNullable != false {
            try encodeContainer.encode(isNullable, forKey: .isNullable)
        }
        if isUpdatable != false {
            try encodeContainer.encode(isUpdatable, forKey: .isUpdatable)
        }
        if isUpsertable != false {
            try encodeContainer.encode(isUpsertable, forKey: .isUpsertable)
        }
        if let supportedWriteOperations = supportedWriteOperations {
            var supportedWriteOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedWriteOperations)
            for supportedwriteoperationlist0 in supportedWriteOperations {
                try supportedWriteOperationsContainer.encode(supportedwriteoperationlist0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isCreatableDecoded = try containerValues.decode(Bool.self, forKey: .isCreatable)
        isCreatable = isCreatableDecoded
        let isNullableDecoded = try containerValues.decode(Bool.self, forKey: .isNullable)
        isNullable = isNullableDecoded
        let isUpsertableDecoded = try containerValues.decode(Bool.self, forKey: .isUpsertable)
        isUpsertable = isUpsertableDecoded
        let isUpdatableDecoded = try containerValues.decode(Bool.self, forKey: .isUpdatable)
        isUpdatable = isUpdatableDecoded
        let supportedWriteOperationsContainer = try containerValues.decodeIfPresent([WriteOperationType?].self, forKey: .supportedWriteOperations)
        var supportedWriteOperationsDecoded0:[WriteOperationType]? = nil
        if let supportedWriteOperationsContainer = supportedWriteOperationsContainer {
            supportedWriteOperationsDecoded0 = [WriteOperationType]()
            for string0 in supportedWriteOperationsContainer {
                if let string0 = string0 {
                    supportedWriteOperationsDecoded0?.append(string0)
                }
            }
        }
        supportedWriteOperations = supportedWriteOperationsDecoded0
    }
}

extension DestinationFieldProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationFieldProperties(isCreatable: \(String(describing: isCreatable)), isNullable: \(String(describing: isNullable)), isUpdatable: \(String(describing: isUpdatable)), isUpsertable: \(String(describing: isUpsertable)), supportedWriteOperations: \(String(describing: supportedWriteOperations)))"}
}

/// <p>
///   The properties that can be applied to a field when connector is being used as a destination.
/// </p>
public struct DestinationFieldProperties: Equatable {
    /// <p>
    ///   Specifies if the destination field can be created by the current user.
    /// </p>
    public let isCreatable: Bool
    /// <p>
    ///   Specifies if the destination field can have a null value.
    /// </p>
    public let isNullable: Bool
    /// <p>
    ///       Specifies whether the field can be updated during an <code>UPDATE</code> or <code>UPSERT</code> write operation.
    ///     </p>
    public let isUpdatable: Bool
    /// <p>
    ///       Specifies if the flow run can either insert new rows in the destination field if they do not already exist, or update them if they do.
    ///     </p>
    public let isUpsertable: Bool
    /// <p>
    ///       A list of supported write operations. For each write operation listed, this field can be used in <code>idFieldNames</code> when that write operation is present as a destination option.
    ///     </p>
    public let supportedWriteOperations: [WriteOperationType]?

    public init (
        isCreatable: Bool = false,
        isNullable: Bool = false,
        isUpdatable: Bool = false,
        isUpsertable: Bool = false,
        supportedWriteOperations: [WriteOperationType]? = nil
    )
    {
        self.isCreatable = isCreatable
        self.isNullable = isNullable
        self.isUpdatable = isUpdatable
        self.isUpsertable = isUpsertable
        self.supportedWriteOperations = supportedWriteOperations
    }
}

extension DestinationFlowConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorProfileName
        case connectorType
        case destinationConnectorProperties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let destinationConnectorProperties = destinationConnectorProperties {
            try encodeContainer.encode(destinationConnectorProperties, forKey: .destinationConnectorProperties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let destinationConnectorPropertiesDecoded = try containerValues.decodeIfPresent(DestinationConnectorProperties.self, forKey: .destinationConnectorProperties)
        destinationConnectorProperties = destinationConnectorPropertiesDecoded
    }
}

extension DestinationFlowConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationFlowConfig(connectorProfileName: \(String(describing: connectorProfileName)), connectorType: \(String(describing: connectorType)), destinationConnectorProperties: \(String(describing: destinationConnectorProperties)))"}
}

/// <p>
///   Contains information about the configuration of destination connectors present in the flow.
/// </p>
public struct DestinationFlowConfig: Equatable {
    /// <p>
    ///   The name of the connector profile. This name must be unique for each connector profile in the AWS account.
    /// </p>
    public let connectorProfileName: String?
    /// <p>
    ///   The type of connector, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorType: ConnectorType?
    /// <p>
    ///   This stores the information that is required to query a particular connector.
    /// </p>
    public let destinationConnectorProperties: DestinationConnectorProperties?

    public init (
        connectorProfileName: String? = nil,
        connectorType: ConnectorType? = nil,
        destinationConnectorProperties: DestinationConnectorProperties? = nil
    )
    {
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.destinationConnectorProperties = destinationConnectorProperties
    }
}

public enum DynatraceConnectorOperator {
    case addition
    case between
    case division
    case equalTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension DynatraceConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DynatraceConnectorOperator] {
        return [
            .addition,
            .between,
            .division,
            .equalTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DynatraceConnectorOperator(rawValue: rawValue) ?? DynatraceConnectorOperator.sdkUnknown(rawValue)
    }
}

extension DynatraceConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiToken = apiToken {
            try encodeContainer.encode(apiToken, forKey: .apiToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiToken)
        apiToken = apiTokenDecoded
    }
}

extension DynatraceConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DynatraceConnectorProfileCredentials(apiToken: \(String(describing: apiToken)))"}
}

/// <p>
///   The connector-specific profile credentials required by Dynatrace.
/// </p>
public struct DynatraceConnectorProfileCredentials: Equatable {
    /// <p>
    ///   The API tokens used by Dynatrace API to authenticate various API calls.
    /// </p>
    public let apiToken: String?

    public init (
        apiToken: String? = nil
    )
    {
        self.apiToken = apiToken
    }
}

extension DynatraceConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension DynatraceConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DynatraceConnectorProfileProperties(instanceUrl: \(String(describing: instanceUrl)))"}
}

/// <p>
///   The connector-specific profile properties required by Dynatrace.
/// </p>
public struct DynatraceConnectorProfileProperties: Equatable {
    /// <p>
    ///   The location of the Dynatrace resource.
    /// </p>
    public let instanceUrl: String?

    public init (
        instanceUrl: String? = nil
    )
    {
        self.instanceUrl = instanceUrl
    }
}

extension DynatraceMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension DynatraceMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DynatraceMetadata()"}
}

/// <p>
///   The connector metadata specific to Dynatrace.
/// </p>
public struct DynatraceMetadata: Equatable {

    public init() {}
}

extension DynatraceSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension DynatraceSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DynatraceSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when Dynatrace is being used as a source.
/// </p>
public struct DynatraceSourceProperties: Equatable {
    /// <p>
    ///   The object specified in the Dynatrace flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

extension ErrorHandlingConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case bucketPrefix
        case failOnFirstDestinationError
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if failOnFirstDestinationError != false {
            try encodeContainer.encode(failOnFirstDestinationError, forKey: .failOnFirstDestinationError)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failOnFirstDestinationErrorDecoded = try containerValues.decode(Bool.self, forKey: .failOnFirstDestinationError)
        failOnFirstDestinationError = failOnFirstDestinationErrorDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension ErrorHandlingConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorHandlingConfig(bucketName: \(String(describing: bucketName)), bucketPrefix: \(String(describing: bucketPrefix)), failOnFirstDestinationError: \(String(describing: failOnFirstDestinationError)))"}
}

/// <p>
///   The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
///
/// </p>
public struct ErrorHandlingConfig: Equatable {
    /// <p>
    /// Specifies the name of the Amazon S3 bucket.
    /// </p>
    public let bucketName: String?
    /// <p>
    /// Specifies the Amazon S3 bucket prefix.
    /// </p>
    public let bucketPrefix: String?
    /// <p>
    /// Specifies if the flow should fail after the first instance of a failure when attempting to place data in the destination.
    /// </p>
    public let failOnFirstDestinationError: Bool

    public init (
        bucketName: String? = nil,
        bucketPrefix: String? = nil,
        failOnFirstDestinationError: Bool = false
    )
    {
        self.bucketName = bucketName
        self.bucketPrefix = bucketPrefix
        self.failOnFirstDestinationError = failOnFirstDestinationError
    }
}

extension ErrorInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionMessage
        case putFailuresCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionMessage = executionMessage {
            try encodeContainer.encode(executionMessage, forKey: .executionMessage)
        }
        if let putFailuresCount = putFailuresCount {
            try encodeContainer.encode(putFailuresCount, forKey: .putFailuresCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let putFailuresCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .putFailuresCount)
        putFailuresCount = putFailuresCountDecoded
        let executionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionMessage)
        executionMessage = executionMessageDecoded
    }
}

extension ErrorInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorInfo(executionMessage: \(String(describing: executionMessage)), putFailuresCount: \(String(describing: putFailuresCount)))"}
}

/// <p>
/// Provides details in the event of a failed flow, including the failure count and the related error messages.
/// </p>
public struct ErrorInfo: Equatable {
    /// <p>
    /// Specifies the error message that appears if a flow fails.
    /// </p>
    public let executionMessage: String?
    /// <p>
    /// Specifies the failure count for the attempted flow.
    /// </p>
    public let putFailuresCount: Int?

    public init (
        executionMessage: String? = nil,
        putFailuresCount: Int? = nil
    )
    {
        self.executionMessage = executionMessage
        self.putFailuresCount = putFailuresCount
    }
}

extension EventBridgeDestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorHandlingConfig
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension EventBridgeDestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventBridgeDestinationProperties(errorHandlingConfig: \(String(describing: errorHandlingConfig)), object: \(String(describing: object)))"}
}

/// <p>
///       The properties that are applied when Amazon EventBridge is being used as a destination.
///     </p>
public struct EventBridgeDestinationProperties: Equatable {
    /// <p>
    ///   The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
    ///
    /// </p>
    public let errorHandlingConfig: ErrorHandlingConfig?
    /// <p>
    ///       The object specified in the Amazon EventBridge flow destination.
    ///     </p>
    public let object: String?

    public init (
        errorHandlingConfig: ErrorHandlingConfig? = nil,
        object: String? = nil
    )
    {
        self.errorHandlingConfig = errorHandlingConfig
        self.object = object
    }
}

extension EventBridgeMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension EventBridgeMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventBridgeMetadata()"}
}

/// <p>
///       The connector metadata specific to Amazon EventBridge.
///     </p>
public struct EventBridgeMetadata: Equatable {

    public init() {}
}

extension ExecutionDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mostRecentExecutionMessage
        case mostRecentExecutionStatus
        case mostRecentExecutionTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mostRecentExecutionMessage = mostRecentExecutionMessage {
            try encodeContainer.encode(mostRecentExecutionMessage, forKey: .mostRecentExecutionMessage)
        }
        if let mostRecentExecutionStatus = mostRecentExecutionStatus {
            try encodeContainer.encode(mostRecentExecutionStatus.rawValue, forKey: .mostRecentExecutionStatus)
        }
        if let mostRecentExecutionTime = mostRecentExecutionTime {
            try encodeContainer.encode(mostRecentExecutionTime.timeIntervalSince1970, forKey: .mostRecentExecutionTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mostRecentExecutionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mostRecentExecutionMessage)
        mostRecentExecutionMessage = mostRecentExecutionMessageDecoded
        let mostRecentExecutionTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .mostRecentExecutionTime)
        mostRecentExecutionTime = mostRecentExecutionTimeDecoded
        let mostRecentExecutionStatusDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .mostRecentExecutionStatus)
        mostRecentExecutionStatus = mostRecentExecutionStatusDecoded
    }
}

extension ExecutionDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionDetails(mostRecentExecutionMessage: \(String(describing: mostRecentExecutionMessage)), mostRecentExecutionStatus: \(String(describing: mostRecentExecutionStatus)), mostRecentExecutionTime: \(String(describing: mostRecentExecutionTime)))"}
}

/// <p>
///   Describes the details of the flow run, including the timestamp, status, and message.
/// </p>
public struct ExecutionDetails: Equatable {
    /// <p>
    ///   Describes the details of the most recent flow run.
    /// </p>
    public let mostRecentExecutionMessage: String?
    /// <p>
    ///   Specifies the status of the most recent flow run.
    /// </p>
    public let mostRecentExecutionStatus: ExecutionStatus?
    /// <p>
    ///   Specifies the time of the most recent flow run.
    /// </p>
    public let mostRecentExecutionTime: Date?

    public init (
        mostRecentExecutionMessage: String? = nil,
        mostRecentExecutionStatus: ExecutionStatus? = nil,
        mostRecentExecutionTime: Date? = nil
    )
    {
        self.mostRecentExecutionMessage = mostRecentExecutionMessage
        self.mostRecentExecutionStatus = mostRecentExecutionStatus
        self.mostRecentExecutionTime = mostRecentExecutionTime
    }
}

extension ExecutionRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataPullEndTime
        case dataPullStartTime
        case executionId
        case executionResult
        case executionStatus
        case lastUpdatedAt
        case startedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPullEndTime = dataPullEndTime {
            try encodeContainer.encode(dataPullEndTime.timeIntervalSince1970, forKey: .dataPullEndTime)
        }
        if let dataPullStartTime = dataPullStartTime {
            try encodeContainer.encode(dataPullStartTime.timeIntervalSince1970, forKey: .dataPullStartTime)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let executionResult = executionResult {
            try encodeContainer.encode(executionResult, forKey: .executionResult)
        }
        if let executionStatus = executionStatus {
            try encodeContainer.encode(executionStatus.rawValue, forKey: .executionStatus)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let executionStatusDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .executionStatus)
        executionStatus = executionStatusDecoded
        let executionResultDecoded = try containerValues.decodeIfPresent(ExecutionResult.self, forKey: .executionResult)
        executionResult = executionResultDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let dataPullStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dataPullStartTime)
        dataPullStartTime = dataPullStartTimeDecoded
        let dataPullEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dataPullEndTime)
        dataPullEndTime = dataPullEndTimeDecoded
    }
}

extension ExecutionRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionRecord(dataPullEndTime: \(String(describing: dataPullEndTime)), dataPullStartTime: \(String(describing: dataPullStartTime)), executionId: \(String(describing: executionId)), executionResult: \(String(describing: executionResult)), executionStatus: \(String(describing: executionStatus)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), startedAt: \(String(describing: startedAt)))"}
}

/// <p>
/// Specifies information about the past flow run instances for a given flow.
/// </p>
public struct ExecutionRecord: Equatable {
    /// <p>
    /// The timestamp that indicates the last new or updated record to be transferred in the flow run.
    /// </p>
    public let dataPullEndTime: Date?
    /// <p>
    /// The timestamp that determines the first new or updated record to be transferred in the flow run.
    /// </p>
    public let dataPullStartTime: Date?
    /// <p>
    /// Specifies the identifier of the given flow run.
    /// </p>
    public let executionId: String?
    /// <p>
    /// Describes the result of the given flow run.
    /// </p>
    public let executionResult: ExecutionResult?
    /// <p>
    /// Specifies the flow run status and whether it is in progress, has completed successfully, or has failed.
    /// </p>
    public let executionStatus: ExecutionStatus?
    /// <p>
    ///   Specifies the time of the most recent update.
    /// </p>
    public let lastUpdatedAt: Date?
    /// <p>
    /// Specifies the start time of the flow run.
    /// </p>
    public let startedAt: Date?

    public init (
        dataPullEndTime: Date? = nil,
        dataPullStartTime: Date? = nil,
        executionId: String? = nil,
        executionResult: ExecutionResult? = nil,
        executionStatus: ExecutionStatus? = nil,
        lastUpdatedAt: Date? = nil,
        startedAt: Date? = nil
    )
    {
        self.dataPullEndTime = dataPullEndTime
        self.dataPullStartTime = dataPullStartTime
        self.executionId = executionId
        self.executionResult = executionResult
        self.executionStatus = executionStatus
        self.lastUpdatedAt = lastUpdatedAt
        self.startedAt = startedAt
    }
}

extension ExecutionResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bytesProcessed
        case bytesWritten
        case errorInfo
        case recordsProcessed
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesProcessed = bytesProcessed {
            try encodeContainer.encode(bytesProcessed, forKey: .bytesProcessed)
        }
        if let bytesWritten = bytesWritten {
            try encodeContainer.encode(bytesWritten, forKey: .bytesWritten)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let recordsProcessed = recordsProcessed {
            try encodeContainer.encode(recordsProcessed, forKey: .recordsProcessed)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorInfoDecoded = try containerValues.decodeIfPresent(ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let bytesProcessedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .bytesProcessed)
        bytesProcessed = bytesProcessedDecoded
        let bytesWrittenDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .bytesWritten)
        bytesWritten = bytesWrittenDecoded
        let recordsProcessedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .recordsProcessed)
        recordsProcessed = recordsProcessedDecoded
    }
}

extension ExecutionResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionResult(bytesProcessed: \(String(describing: bytesProcessed)), bytesWritten: \(String(describing: bytesWritten)), errorInfo: \(String(describing: errorInfo)), recordsProcessed: \(String(describing: recordsProcessed)))"}
}

/// <p>
/// Specifies the end result of the flow run.
/// </p>
public struct ExecutionResult: Equatable {
    /// <p>
    ///   The total number of bytes processed by the flow run.
    /// </p>
    public let bytesProcessed: Int?
    /// <p>
    ///   The total number of bytes written as a result of the flow run.
    /// </p>
    public let bytesWritten: Int?
    /// <p>
    /// Provides any error message information related to the flow run.
    /// </p>
    public let errorInfo: ErrorInfo?
    /// <p>
    /// The number of records processed in the flow run.
    /// </p>
    public let recordsProcessed: Int?

    public init (
        bytesProcessed: Int? = nil,
        bytesWritten: Int? = nil,
        errorInfo: ErrorInfo? = nil,
        recordsProcessed: Int? = nil
    )
    {
        self.bytesProcessed = bytesProcessed
        self.bytesWritten = bytesWritten
        self.errorInfo = errorInfo
        self.recordsProcessed = recordsProcessed
    }
}

public enum ExecutionStatus {
    case error
    case inprogress
    case successful
    case sdkUnknown(String)
}

extension ExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExecutionStatus] {
        return [
            .error,
            .inprogress,
            .successful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "Error"
        case .inprogress: return "InProgress"
        case .successful: return "Successful"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
    }
}

extension FieldTypeDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldType
        case filterOperators
        case supportedValues
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldType = fieldType {
            try encodeContainer.encode(fieldType, forKey: .fieldType)
        }
        if let filterOperators = filterOperators {
            var filterOperatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterOperators)
            for filteroperatorlist0 in filterOperators {
                try filterOperatorsContainer.encode(filteroperatorlist0.rawValue)
            }
        }
        if let supportedValues = supportedValues {
            var supportedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedValues)
            for supportedvaluelist0 in supportedValues {
                try supportedValuesContainer.encode(supportedvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldType)
        fieldType = fieldTypeDecoded
        let filterOperatorsContainer = try containerValues.decodeIfPresent([Operator?].self, forKey: .filterOperators)
        var filterOperatorsDecoded0:[Operator]? = nil
        if let filterOperatorsContainer = filterOperatorsContainer {
            filterOperatorsDecoded0 = [Operator]()
            for string0 in filterOperatorsContainer {
                if let string0 = string0 {
                    filterOperatorsDecoded0?.append(string0)
                }
            }
        }
        filterOperators = filterOperatorsDecoded0
        let supportedValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .supportedValues)
        var supportedValuesDecoded0:[String]? = nil
        if let supportedValuesContainer = supportedValuesContainer {
            supportedValuesDecoded0 = [String]()
            for string0 in supportedValuesContainer {
                if let string0 = string0 {
                    supportedValuesDecoded0?.append(string0)
                }
            }
        }
        supportedValues = supportedValuesDecoded0
    }
}

extension FieldTypeDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldTypeDetails(fieldType: \(String(describing: fieldType)), filterOperators: \(String(describing: filterOperators)), supportedValues: \(String(describing: supportedValues)))"}
}

/// <p>
///  Contains details regarding the supported field type and the operators that can be applied for filtering.
/// </p>
public struct FieldTypeDetails: Equatable {
    /// <p>
    /// The type of field, such as string, integer, date, and so on.
    /// </p>
    public let fieldType: String?
    /// <p>
    /// The list of operators supported by a field.
    /// </p>
    public let filterOperators: [Operator]?
    /// <p>
    ///  The list of values that a field can contain. For example, a Boolean <code>fieldType</code> can have two values: "true" and "false".
    /// </p>
    public let supportedValues: [String]?

    public init (
        fieldType: String? = nil,
        filterOperators: [Operator]? = nil,
        supportedValues: [String]? = nil
    )
    {
        self.fieldType = fieldType
        self.filterOperators = filterOperators
        self.supportedValues = supportedValues
    }
}

public enum FileType {
    case csv
    case json
    case parquet
    case sdkUnknown(String)
}

extension FileType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileType] {
        return [
            .csv,
            .json,
            .parquet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .json: return "JSON"
        case .parquet: return "PARQUET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileType(rawValue: rawValue) ?? FileType.sdkUnknown(rawValue)
    }
}

extension FlowDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case createdBy
        case description
        case destinationConnectorType
        case flowArn
        case flowName
        case flowStatus
        case lastRunExecutionDetails
        case lastUpdatedAt
        case lastUpdatedBy
        case sourceConnectorType
        case tags
        case triggerType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConnectorType = destinationConnectorType {
            try encodeContainer.encode(destinationConnectorType.rawValue, forKey: .destinationConnectorType)
        }
        if let flowArn = flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let flowStatus = flowStatus {
            try encodeContainer.encode(flowStatus.rawValue, forKey: .flowStatus)
        }
        if let lastRunExecutionDetails = lastRunExecutionDetails {
            try encodeContainer.encode(lastRunExecutionDetails, forKey: .lastRunExecutionDetails)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let lastUpdatedBy = lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let sourceConnectorType = sourceConnectorType {
            try encodeContainer.encode(sourceConnectorType.rawValue, forKey: .sourceConnectorType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let sourceConnectorTypeDecoded = try containerValues.decodeIfPresent(ConnectorType.self, forKey: .sourceConnectorType)
        sourceConnectorType = sourceConnectorTypeDecoded
        let destinationConnectorTypeDecoded = try containerValues.decodeIfPresent(ConnectorType.self, forKey: .destinationConnectorType)
        destinationConnectorType = destinationConnectorTypeDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastRunExecutionDetailsDecoded = try containerValues.decodeIfPresent(ExecutionDetails.self, forKey: .lastRunExecutionDetails)
        lastRunExecutionDetails = lastRunExecutionDetailsDecoded
    }
}

extension FlowDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlowDefinition(createdAt: \(String(describing: createdAt)), createdBy: \(String(describing: createdBy)), description: \(String(describing: description)), destinationConnectorType: \(String(describing: destinationConnectorType)), flowArn: \(String(describing: flowArn)), flowName: \(String(describing: flowName)), flowStatus: \(String(describing: flowStatus)), lastRunExecutionDetails: \(String(describing: lastRunExecutionDetails)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), lastUpdatedBy: \(String(describing: lastUpdatedBy)), sourceConnectorType: \(String(describing: sourceConnectorType)), tags: \(String(describing: tags)), triggerType: \(String(describing: triggerType)))"}
}

/// <p>
/// The properties of the flow, such as its source, destination, trigger type, and so on.
/// </p>
public struct FlowDefinition: Equatable {
    /// <p>
    ///   Specifies when the flow was created.
    /// </p>
    public let createdAt: Date?
    /// <p>
    ///   The ARN of the user who created the flow.
    /// </p>
    public let createdBy: String?
    /// <p>
    ///   A user-entered description of the flow.
    /// </p>
    public let description: String?
    /// <p>
    ///   Specifies the destination connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
    /// </p>
    public let destinationConnectorType: ConnectorType?
    /// <p>
    ///   The flow's Amazon Resource Name (ARN).
    /// </p>
    public let flowArn: String?
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: String?
    /// <p>
    ///   Indicates the current status of the flow.
    /// </p>
    public let flowStatus: FlowStatus?
    /// <p>
    ///   Describes the details of the most recent flow run.
    /// </p>
    public let lastRunExecutionDetails: ExecutionDetails?
    /// <p>
    ///   Specifies when the flow was last updated.
    /// </p>
    public let lastUpdatedAt: Date?
    /// <p>
    ///   Specifies the account user name that most recently updated the flow.
    /// </p>
    public let lastUpdatedBy: String?
    /// <p>
    ///   Specifies the source connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
    /// </p>
    public let sourceConnectorType: ConnectorType?
    /// <p>
    /// The tags used to organize, track, or control access for your flow.
    /// </p>
    public let tags: [String:String]?
    /// <p>
    ///   Specifies the type of flow trigger. This can be <code>OnDemand</code>, <code>Scheduled</code>, or <code>Event</code>.
    /// </p>
    public let triggerType: TriggerType?

    public init (
        createdAt: Date? = nil,
        createdBy: String? = nil,
        description: String? = nil,
        destinationConnectorType: ConnectorType? = nil,
        flowArn: String? = nil,
        flowName: String? = nil,
        flowStatus: FlowStatus? = nil,
        lastRunExecutionDetails: ExecutionDetails? = nil,
        lastUpdatedAt: Date? = nil,
        lastUpdatedBy: String? = nil,
        sourceConnectorType: ConnectorType? = nil,
        tags: [String:String]? = nil,
        triggerType: TriggerType? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.destinationConnectorType = destinationConnectorType
        self.flowArn = flowArn
        self.flowName = flowName
        self.flowStatus = flowStatus
        self.lastRunExecutionDetails = lastRunExecutionDetails
        self.lastUpdatedAt = lastUpdatedAt
        self.lastUpdatedBy = lastUpdatedBy
        self.sourceConnectorType = sourceConnectorType
        self.tags = tags
        self.triggerType = triggerType
    }
}

public enum FlowStatus {
    case active
    case deleted
    case deprecated
    case draft
    case errored
    case suspended
    case sdkUnknown(String)
}

extension FlowStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FlowStatus] {
        return [
            .active,
            .deleted,
            .deprecated,
            .draft,
            .errored,
            .suspended,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .deleted: return "Deleted"
        case .deprecated: return "Deprecated"
        case .draft: return "Draft"
        case .errored: return "Errored"
        case .suspended: return "Suspended"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FlowStatus(rawValue: rawValue) ?? FlowStatus.sdkUnknown(rawValue)
    }
}

public enum GoogleAnalyticsConnectorOperator {
    case between
    case projection
    case sdkUnknown(String)
}

extension GoogleAnalyticsConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GoogleAnalyticsConnectorOperator] {
        return [
            .between,
            .projection,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .between: return "BETWEEN"
        case .projection: return "PROJECTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GoogleAnalyticsConnectorOperator(rawValue: rawValue) ?? GoogleAnalyticsConnectorOperator.sdkUnknown(rawValue)
    }
}

extension GoogleAnalyticsConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension GoogleAnalyticsConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GoogleAnalyticsConnectorProfileCredentials(accessToken: \(String(describing: accessToken)), clientId: \(String(describing: clientId)), clientSecret: \(String(describing: clientSecret)), oAuthRequest: \(String(describing: oAuthRequest)), refreshToken: \(String(describing: refreshToken)))"}
}

/// <p>
///   The connector-specific profile credentials required by Google Analytics.
/// </p>
public struct GoogleAnalyticsConnectorProfileCredentials: Equatable {
    /// <p>
    /// The credentials used to access protected Google Analytics resources.
    /// </p>
    public let accessToken: String?
    /// <p>
    ///   The identifier for the desired client.
    /// </p>
    public let clientId: String?
    /// <p>
    ///   The client secret used by the OAuth client to authenticate to the authorization server.
    /// </p>
    public let clientSecret: String?
    /// <p>
    ///   The OAuth requirement needed to request security tokens from the connector endpoint.
    /// </p>
    public let oAuthRequest: ConnectorOAuthRequest?
    /// <p>
    ///   The credentials used to acquire new access tokens. This is required only for OAuth2 access tokens, and is not required for OAuth1 access tokens.
    /// </p>
    public let refreshToken: String?

    public init (
        accessToken: String? = nil,
        clientId: String? = nil,
        clientSecret: String? = nil,
        oAuthRequest: ConnectorOAuthRequest? = nil,
        refreshToken: String? = nil
    )
    {
        self.accessToken = accessToken
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.oAuthRequest = oAuthRequest
        self.refreshToken = refreshToken
    }
}

extension GoogleAnalyticsConnectorProfileProperties: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension GoogleAnalyticsConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GoogleAnalyticsConnectorProfileProperties()"}
}

/// <p>
///   The connector-specific profile properties required by Google Analytics.
/// </p>
public struct GoogleAnalyticsConnectorProfileProperties: Equatable {

    public init() {}
}

extension GoogleAnalyticsMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension GoogleAnalyticsMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GoogleAnalyticsMetadata(oAuthScopes: \(String(describing: oAuthScopes)))"}
}

/// <p>
///   The connector metadata specific to Google Analytics.
/// </p>
public struct GoogleAnalyticsMetadata: Equatable {
    /// <p>
    ///   The desired authorization scope for the Google Analytics account.
    /// </p>
    public let oAuthScopes: [String]?

    public init (
        oAuthScopes: [String]? = nil
    )
    {
        self.oAuthScopes = oAuthScopes
    }
}

extension GoogleAnalyticsSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension GoogleAnalyticsSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GoogleAnalyticsSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when Google Analytics is being used as a source.
/// </p>
public struct GoogleAnalyticsSourceProperties: Equatable {
    /// <p>
    ///   The object specified in the Google Analytics flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

extension HoneycodeConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension HoneycodeConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HoneycodeConnectorProfileCredentials(accessToken: \(String(describing: accessToken)), oAuthRequest: \(String(describing: oAuthRequest)), refreshToken: \(String(describing: refreshToken)))"}
}

/// <p>
///       The connector-specific credentials required when using Amazon Honeycode.
///     </p>
public struct HoneycodeConnectorProfileCredentials: Equatable {
    /// <p>
    ///       The credentials used to access protected Amazon Honeycode resources.
    ///     </p>
    public let accessToken: String?
    /// <p>
    ///  Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
    /// </p>
    public let oAuthRequest: ConnectorOAuthRequest?
    /// <p>
    ///       The credentials used to acquire new access tokens.
    ///     </p>
    public let refreshToken: String?

    public init (
        accessToken: String? = nil,
        oAuthRequest: ConnectorOAuthRequest? = nil,
        refreshToken: String? = nil
    )
    {
        self.accessToken = accessToken
        self.oAuthRequest = oAuthRequest
        self.refreshToken = refreshToken
    }
}

extension HoneycodeConnectorProfileProperties: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension HoneycodeConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HoneycodeConnectorProfileProperties()"}
}

/// <p>
///       The connector-specific properties required when using Amazon Honeycode.
///     </p>
public struct HoneycodeConnectorProfileProperties: Equatable {

    public init() {}
}

extension HoneycodeDestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorHandlingConfig
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension HoneycodeDestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HoneycodeDestinationProperties(errorHandlingConfig: \(String(describing: errorHandlingConfig)), object: \(String(describing: object)))"}
}

/// <p>
///       The properties that are applied when Amazon Honeycode is used as a destination.
///     </p>
public struct HoneycodeDestinationProperties: Equatable {
    /// <p>
    ///   The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
    ///
    /// </p>
    public let errorHandlingConfig: ErrorHandlingConfig?
    /// <p>
    ///       The object specified in the Amazon Honeycode flow destination.
    ///     </p>
    public let object: String?

    public init (
        errorHandlingConfig: ErrorHandlingConfig? = nil,
        object: String? = nil
    )
    {
        self.errorHandlingConfig = errorHandlingConfig
        self.object = object
    }
}

extension HoneycodeMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension HoneycodeMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HoneycodeMetadata(oAuthScopes: \(String(describing: oAuthScopes)))"}
}

/// <p>
///       The connector metadata specific to Amazon Honeycode.
///     </p>
public struct HoneycodeMetadata: Equatable {
    /// <p>
    ///       The desired authorization scope for the Amazon Honeycode account.
    ///     </p>
    public let oAuthScopes: [String]?

    public init (
        oAuthScopes: [String]? = nil
    )
    {
        self.oAuthScopes = oAuthScopes
    }
}

extension IncrementalPullConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datetimeTypeFieldName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datetimeTypeFieldName = datetimeTypeFieldName {
            try encodeContainer.encode(datetimeTypeFieldName, forKey: .datetimeTypeFieldName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datetimeTypeFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datetimeTypeFieldName)
        datetimeTypeFieldName = datetimeTypeFieldNameDecoded
    }
}

extension IncrementalPullConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncrementalPullConfig(datetimeTypeFieldName: \(String(describing: datetimeTypeFieldName)))"}
}

/// <p>
/// Specifies the configuration used when importing incremental records from the source.
/// </p>
public struct IncrementalPullConfig: Equatable {
    /// <p>
    ///       A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
    ///     </p>
    public let datetimeTypeFieldName: String?

    public init (
        datetimeTypeFieldName: String? = nil
    )
    {
        self.datetimeTypeFieldName = datetimeTypeFieldName
    }
}

public enum InforNexusConnectorOperator {
    case addition
    case between
    case division
    case equalTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension InforNexusConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InforNexusConnectorOperator] {
        return [
            .addition,
            .between,
            .division,
            .equalTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InforNexusConnectorOperator(rawValue: rawValue) ?? InforNexusConnectorOperator.sdkUnknown(rawValue)
    }
}

extension InforNexusConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId
        case datakey
        case secretAccessKey
        case userId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let datakey = datakey {
            try encodeContainer.encode(datakey, forKey: .datakey)
        }
        if let secretAccessKey = secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let datakeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datakey)
        datakey = datakeyDecoded
    }
}

extension InforNexusConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InforNexusConnectorProfileCredentials(accessKeyId: \(String(describing: accessKeyId)), datakey: \(String(describing: datakey)), secretAccessKey: \(String(describing: secretAccessKey)), userId: \(String(describing: userId)))"}
}

/// <p>
///   The connector-specific profile credentials required by Infor Nexus.
/// </p>
public struct InforNexusConnectorProfileCredentials: Equatable {
    /// <p>
    ///   The Access Key portion of the credentials.
    /// </p>
    public let accessKeyId: String?
    /// <p>
    ///   The encryption keys used to encrypt data.
    /// </p>
    public let datakey: String?
    /// <p>
    ///   The secret key used to sign requests.
    /// </p>
    public let secretAccessKey: String?
    /// <p>
    ///   The identifier for the user.
    /// </p>
    public let userId: String?

    public init (
        accessKeyId: String? = nil,
        datakey: String? = nil,
        secretAccessKey: String? = nil,
        userId: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.datakey = datakey
        self.secretAccessKey = secretAccessKey
        self.userId = userId
    }
}

extension InforNexusConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension InforNexusConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InforNexusConnectorProfileProperties(instanceUrl: \(String(describing: instanceUrl)))"}
}

/// <p>
///   The connector-specific profile properties required by Infor Nexus.
/// </p>
public struct InforNexusConnectorProfileProperties: Equatable {
    /// <p>
    ///   The location of the Infor Nexus resource.
    /// </p>
    public let instanceUrl: String?

    public init (
        instanceUrl: String? = nil
    )
    {
        self.instanceUrl = instanceUrl
    }
}

extension InforNexusMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension InforNexusMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InforNexusMetadata()"}
}

/// <p>
///   The connector metadata specific to Infor Nexus.
/// </p>
public struct InforNexusMetadata: Equatable {

    public init() {}
}

extension InforNexusSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension InforNexusSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InforNexusSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when Infor Nexus is being used as a source.
/// </p>
public struct InforNexusSourceProperties: Equatable {
    /// <p>
    ///   The object specified in the Infor Nexus flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///  An internal service error occurred during the processing of your request. Try again later.
/// </p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListConnectorEntitiesInputBodyMiddleware: Middleware {
    public let id: String = "ListConnectorEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectorEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectorEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectorEntitiesInput>
    public typealias MOutput = OperationOutput<ListConnectorEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectorEntitiesOutputError>
}

extension ListConnectorEntitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectorEntitiesInput(connectorProfileName: \(String(describing: connectorProfileName)), connectorType: \(String(describing: connectorType)), entitiesPath: \(String(describing: entitiesPath)))"}
}

extension ListConnectorEntitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorProfileName
        case connectorType
        case entitiesPath
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let entitiesPath = entitiesPath {
            try encodeContainer.encode(entitiesPath, forKey: .entitiesPath)
        }
    }
}

public struct ListConnectorEntitiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListConnectorEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectorEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectorEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectorEntitiesInput>
    public typealias MOutput = OperationOutput<ListConnectorEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectorEntitiesOutputError>
}

public struct ListConnectorEntitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConnectorEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectorEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectorEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectorEntitiesInput>
    public typealias MOutput = OperationOutput<ListConnectorEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectorEntitiesOutputError>
}

public struct ListConnectorEntitiesInput: Equatable {
    /// <p>
    ///   The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in the AWS account, and is used to query the downstream connector.
    /// </p>
    public let connectorProfileName: String?
    /// <p>
    ///   The type of connector, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorType: ConnectorType?
    /// <p>
    ///   This optional parameter is specific to connector implementation. Some connectors support multiple levels or categories of entities. You can find out the list of roots for such providers by sending a request without the <code>entitiesPath</code> parameter. If the connector supports entities at different roots, this initial request returns the list of roots. Otherwise, this request returns all entities supported by the provider.
    /// </p>
    public let entitiesPath: String?

    public init (
        connectorProfileName: String? = nil,
        connectorType: ConnectorType? = nil,
        entitiesPath: String? = nil
    )
    {
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.entitiesPath = entitiesPath
    }
}

struct ListConnectorEntitiesInputBody: Equatable {
    public let connectorProfileName: String?
    public let connectorType: ConnectorType?
    public let entitiesPath: String?
}

extension ListConnectorEntitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorProfileName
        case connectorType
        case entitiesPath
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let entitiesPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entitiesPath)
        entitiesPath = entitiesPathDecoded
    }
}

extension ListConnectorEntitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectorEntitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectorEntitiesOutputError: Swift.Error, Equatable {
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectorEntitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectorEntitiesOutputResponse(connectorEntityMap: \(String(describing: connectorEntityMap)))"}
}

extension ListConnectorEntitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConnectorEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorEntityMap = output.connectorEntityMap
        } else {
            self.connectorEntityMap = nil
        }
    }
}

public struct ListConnectorEntitiesOutputResponse: Equatable {
    /// <p>
    ///  The response of <code>ListConnectorEntities</code> lists entities grouped by category. This map's key represents the group name, and its value contains the list of entities belonging to that group.
    /// </p>
    public let connectorEntityMap: [String:[ConnectorEntity]]?

    public init (
        connectorEntityMap: [String:[ConnectorEntity]]? = nil
    )
    {
        self.connectorEntityMap = connectorEntityMap
    }
}

struct ListConnectorEntitiesOutputResponseBody: Equatable {
    public let connectorEntityMap: [String:[ConnectorEntity]]?
}

extension ListConnectorEntitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorEntityMap
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityMapContainer = try containerValues.decodeIfPresent([String: [ConnectorEntity?]?].self, forKey: .connectorEntityMap)
        var connectorEntityMapDecoded0: [String:[ConnectorEntity]]? = nil
        if let connectorEntityMapContainer = connectorEntityMapContainer {
            connectorEntityMapDecoded0 = [String:[ConnectorEntity]]()
            for (key0, connectorentitylist0) in connectorEntityMapContainer {
                var connectorentitylist0Decoded0: [ConnectorEntity]? = nil
                if let connectorentitylist0 = connectorentitylist0 {
                    connectorentitylist0Decoded0 = [ConnectorEntity]()
                    for structure1 in connectorentitylist0 {
                        if let structure1 = structure1 {
                            connectorentitylist0Decoded0?.append(structure1)
                        }
                    }
                }
                connectorEntityMapDecoded0?[key0] = connectorentitylist0Decoded0
            }
        }
        connectorEntityMap = connectorEntityMapDecoded0
    }
}

public struct ListFlowsInputBodyMiddleware: Middleware {
    public let id: String = "ListFlowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFlowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFlowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFlowsInput>
    public typealias MOutput = OperationOutput<ListFlowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFlowsOutputError>
}

extension ListFlowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFlowsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFlowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFlowsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFlowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFlowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFlowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFlowsInput>
    public typealias MOutput = OperationOutput<ListFlowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFlowsOutputError>
}

public struct ListFlowsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFlowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFlowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFlowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFlowsInput>
    public typealias MOutput = OperationOutput<ListFlowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFlowsOutputError>
}

public struct ListFlowsInput: Equatable {
    /// <p>
    ///       Specifies the maximum number of items that should be returned in the result set.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///  The pagination token for next page of data.
    /// </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFlowsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListFlowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFlowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFlowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFlowsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFlowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFlowsOutputResponse(flows: \(String(describing: flows)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFlowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFlowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flows = output.flows
            self.nextToken = output.nextToken
        } else {
            self.flows = nil
            self.nextToken = nil
        }
    }
}

public struct ListFlowsOutputResponse: Equatable {
    /// <p>
    /// The list of flows associated with your account.
    /// </p>
    public let flows: [FlowDefinition]?
    /// <p>
    /// The pagination token for next page of data.
    /// </p>
    public let nextToken: String?

    public init (
        flows: [FlowDefinition]? = nil,
        nextToken: String? = nil
    )
    {
        self.flows = flows
        self.nextToken = nextToken
    }
}

struct ListFlowsOutputResponseBody: Equatable {
    public let flows: [FlowDefinition]?
    public let nextToken: String?
}

extension ListFlowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flows
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowsContainer = try containerValues.decodeIfPresent([FlowDefinition?].self, forKey: .flows)
        var flowsDecoded0:[FlowDefinition]? = nil
        if let flowsContainer = flowsContainer {
            flowsDecoded0 = [FlowDefinition]()
            for structure0 in flowsContainer {
                if let structure0 = structure0 {
                    flowsDecoded0?.append(structure0)
                }
            }
        }
        flows = flowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>
    ///   The Amazon Resource Name (ARN) of the specified flow.
    /// </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>
    ///  The tags used to organize, track, or control access for your flow.
    /// </p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutMetricsDestinationProperties: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension LookoutMetricsDestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LookoutMetricsDestinationProperties()"}
}

/// <p>
///       The properties that are applied when Amazon Lookout for Metrics is used as a destination.
///     </p>
public struct LookoutMetricsDestinationProperties: Equatable {

    public init() {}
}

public enum MarketoConnectorOperator {
    case addition
    case between
    case division
    case greaterThan
    case lessThan
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension MarketoConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MarketoConnectorOperator] {
        return [
            .addition,
            .between,
            .division,
            .greaterThan,
            .lessThan,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .division: return "DIVISION"
        case .greaterThan: return "GREATER_THAN"
        case .lessThan: return "LESS_THAN"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MarketoConnectorOperator(rawValue: rawValue) ?? MarketoConnectorOperator.sdkUnknown(rawValue)
    }
}

extension MarketoConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension MarketoConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MarketoConnectorProfileCredentials(accessToken: \(String(describing: accessToken)), clientId: \(String(describing: clientId)), clientSecret: \(String(describing: clientSecret)), oAuthRequest: \(String(describing: oAuthRequest)))"}
}

/// <p>
///   The connector-specific profile credentials required by Marketo.
/// </p>
public struct MarketoConnectorProfileCredentials: Equatable {
    /// <p>
    ///   The credentials used to access protected Marketo resources.
    /// </p>
    public let accessToken: String?
    /// <p>
    ///   The identifier for the desired client.
    /// </p>
    public let clientId: String?
    /// <p>
    ///   The client secret used by the OAuth client to authenticate to the authorization server.
    /// </p>
    public let clientSecret: String?
    /// <p>
    ///   The OAuth requirement needed to request security tokens from the connector endpoint.
    /// </p>
    public let oAuthRequest: ConnectorOAuthRequest?

    public init (
        accessToken: String? = nil,
        clientId: String? = nil,
        clientSecret: String? = nil,
        oAuthRequest: ConnectorOAuthRequest? = nil
    )
    {
        self.accessToken = accessToken
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.oAuthRequest = oAuthRequest
    }
}

extension MarketoConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension MarketoConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MarketoConnectorProfileProperties(instanceUrl: \(String(describing: instanceUrl)))"}
}

/// <p>
///   The connector-specific profile properties required when using Marketo.
/// </p>
public struct MarketoConnectorProfileProperties: Equatable {
    /// <p>
    ///   The location of the Marketo resource.
    /// </p>
    public let instanceUrl: String?

    public init (
        instanceUrl: String? = nil
    )
    {
        self.instanceUrl = instanceUrl
    }
}

extension MarketoMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension MarketoMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MarketoMetadata()"}
}

/// <p>
///   The connector metadata specific to Marketo.
/// </p>
public struct MarketoMetadata: Equatable {

    public init() {}
}

extension MarketoSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension MarketoSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MarketoSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when Marketo is being used as a source.
/// </p>
public struct MarketoSourceProperties: Equatable {
    /// <p>
    ///   The object specified in the Marketo flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

public enum Operator {
    case addition
    case between
    case contains
    case division
    case equalTo
    case greaterThan
    case greaterThanOrEqualTo
    case lessThan
    case lessThanOrEqualTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case notEqualTo
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension Operator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Operator] {
        return [
            .addition,
            .between,
            .contains,
            .division,
            .equalTo,
            .greaterThan,
            .greaterThanOrEqualTo,
            .lessThan,
            .lessThanOrEqualTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .notEqualTo,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .contains: return "CONTAINS"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
        case .lessThan: return "LESS_THAN"
        case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .notEqualTo: return "NOT_EQUAL_TO"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
    }
}

public enum OperatorPropertiesKeys {
    case concatFormat
    case dataType
    case destinationDataType
    case lowerBound
    case maskLength
    case maskValue
    case mathOperationFieldsOrder
    case sourceDataType
    case subfieldCategoryMap
    case truncateLength
    case upperBound
    case validationAction
    case value
    case values
    case sdkUnknown(String)
}

extension OperatorPropertiesKeys : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperatorPropertiesKeys] {
        return [
            .concatFormat,
            .dataType,
            .destinationDataType,
            .lowerBound,
            .maskLength,
            .maskValue,
            .mathOperationFieldsOrder,
            .sourceDataType,
            .subfieldCategoryMap,
            .truncateLength,
            .upperBound,
            .validationAction,
            .value,
            .values,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .concatFormat: return "CONCAT_FORMAT"
        case .dataType: return "DATA_TYPE"
        case .destinationDataType: return "DESTINATION_DATA_TYPE"
        case .lowerBound: return "LOWER_BOUND"
        case .maskLength: return "MASK_LENGTH"
        case .maskValue: return "MASK_VALUE"
        case .mathOperationFieldsOrder: return "MATH_OPERATION_FIELDS_ORDER"
        case .sourceDataType: return "SOURCE_DATA_TYPE"
        case .subfieldCategoryMap: return "SUBFIELD_CATEGORY_MAP"
        case .truncateLength: return "TRUNCATE_LENGTH"
        case .upperBound: return "UPPER_BOUND"
        case .validationAction: return "VALIDATION_ACTION"
        case .value: return "VALUE"
        case .values: return "VALUES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperatorPropertiesKeys(rawValue: rawValue) ?? OperatorPropertiesKeys.sdkUnknown(rawValue)
    }
}

extension PrefixConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prefixFormat
        case prefixType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prefixFormat = prefixFormat {
            try encodeContainer.encode(prefixFormat.rawValue, forKey: .prefixFormat)
        }
        if let prefixType = prefixType {
            try encodeContainer.encode(prefixType.rawValue, forKey: .prefixType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixTypeDecoded = try containerValues.decodeIfPresent(PrefixType.self, forKey: .prefixType)
        prefixType = prefixTypeDecoded
        let prefixFormatDecoded = try containerValues.decodeIfPresent(PrefixFormat.self, forKey: .prefixFormat)
        prefixFormat = prefixFormatDecoded
    }
}

extension PrefixConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PrefixConfig(prefixFormat: \(String(describing: prefixFormat)), prefixType: \(String(describing: prefixType)))"}
}

/// <p>
/// Determines the prefix that Amazon AppFlow applies to the destination folder name. You can name your destination folders according to the flow frequency and date.
///     </p>
public struct PrefixConfig: Equatable {
    /// <p>
    ///       Determines the level of granularity that's included in the prefix.
    ///     </p>
    public let prefixFormat: PrefixFormat?
    /// <p>
    ///       Determines the format of the prefix, and whether it applies to the file name, file path, or both.
    ///     </p>
    public let prefixType: PrefixType?

    public init (
        prefixFormat: PrefixFormat? = nil,
        prefixType: PrefixType? = nil
    )
    {
        self.prefixFormat = prefixFormat
        self.prefixType = prefixType
    }
}

public enum PrefixFormat {
    case day
    case hour
    case minute
    case month
    case year
    case sdkUnknown(String)
}

extension PrefixFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PrefixFormat] {
        return [
            .day,
            .hour,
            .minute,
            .month,
            .year,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .day: return "DAY"
        case .hour: return "HOUR"
        case .minute: return "MINUTE"
        case .month: return "MONTH"
        case .year: return "YEAR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PrefixFormat(rawValue: rawValue) ?? PrefixFormat.sdkUnknown(rawValue)
    }
}

public enum PrefixType {
    case filename
    case path
    case pathAndFilename
    case sdkUnknown(String)
}

extension PrefixType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PrefixType] {
        return [
            .filename,
            .path,
            .pathAndFilename,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .filename: return "FILENAME"
        case .path: return "PATH"
        case .pathAndFilename: return "PATH_AND_FILENAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PrefixType(rawValue: rawValue) ?? PrefixType.sdkUnknown(rawValue)
    }
}

extension RedshiftConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension RedshiftConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedshiftConnectorProfileCredentials(password: \(String(describing: password)), username: \(String(describing: username)))"}
}

/// <p>
///   The connector-specific profile credentials required when using Amazon Redshift.
/// </p>
public struct RedshiftConnectorProfileCredentials: Equatable {
    /// <p>
    ///   The password that corresponds to the user name.
    /// </p>
    public let password: String?
    /// <p>
    ///   The name of the user.
    /// </p>
    public let username: String?

    public init (
        password: String? = nil,
        username: String? = nil
    )
    {
        self.password = password
        self.username = username
    }
}

extension RedshiftConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case bucketPrefix
        case databaseUrl
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let databaseUrl = databaseUrl {
            try encodeContainer.encode(databaseUrl, forKey: .databaseUrl)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseUrl)
        databaseUrl = databaseUrlDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension RedshiftConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedshiftConnectorProfileProperties(bucketName: \(String(describing: bucketName)), bucketPrefix: \(String(describing: bucketPrefix)), databaseUrl: \(String(describing: databaseUrl)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>
///   The connector-specific profile properties when using Amazon Redshift.
/// </p>
public struct RedshiftConnectorProfileProperties: Equatable {
    /// <p>
    ///   A name for the associated Amazon S3 bucket.
    /// </p>
    public let bucketName: String?
    /// <p>
    ///   The object key for the destination bucket in which Amazon AppFlow places the files.
    /// </p>
    public let bucketPrefix: String?
    /// <p>
    /// The JDBC URL of the Amazon Redshift cluster.
    /// </p>
    public let databaseUrl: String?
    /// <p>
    ///   The Amazon Resource Name (ARN) of the IAM role.
    /// </p>
    public let roleArn: String?

    public init (
        bucketName: String? = nil,
        bucketPrefix: String? = nil,
        databaseUrl: String? = nil,
        roleArn: String? = nil
    )
    {
        self.bucketName = bucketName
        self.bucketPrefix = bucketPrefix
        self.databaseUrl = databaseUrl
        self.roleArn = roleArn
    }
}

extension RedshiftDestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketPrefix
        case errorHandlingConfig
        case intermediateBucketName
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let intermediateBucketName = intermediateBucketName {
            try encodeContainer.encode(intermediateBucketName, forKey: .intermediateBucketName)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
        let intermediateBucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intermediateBucketName)
        intermediateBucketName = intermediateBucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension RedshiftDestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedshiftDestinationProperties(bucketPrefix: \(String(describing: bucketPrefix)), errorHandlingConfig: \(String(describing: errorHandlingConfig)), intermediateBucketName: \(String(describing: intermediateBucketName)), object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when Amazon Redshift is being used as a destination.
/// </p>
public struct RedshiftDestinationProperties: Equatable {
    /// <p>
    ///   The object key for the bucket in which Amazon AppFlow places the destination files.
    /// </p>
    public let bucketPrefix: String?
    /// <p>
    ///   The settings that determine how Amazon AppFlow handles an error when placing data in the Amazon Redshift destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
    /// </p>
    public let errorHandlingConfig: ErrorHandlingConfig?
    /// <p>
    ///  The intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
    /// </p>
    public let intermediateBucketName: String?
    /// <p>
    ///   The object specified in the Amazon Redshift flow destination.
    /// </p>
    public let object: String?

    public init (
        bucketPrefix: String? = nil,
        errorHandlingConfig: ErrorHandlingConfig? = nil,
        intermediateBucketName: String? = nil,
        object: String? = nil
    )
    {
        self.bucketPrefix = bucketPrefix
        self.errorHandlingConfig = errorHandlingConfig
        self.intermediateBucketName = intermediateBucketName
        self.object = object
    }
}

extension RedshiftMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension RedshiftMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedshiftMetadata()"}
}

/// <p>
///   The connector metadata specific to Amazon Redshift.
/// </p>
public struct RedshiftMetadata: Equatable {

    public init() {}
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///   The resource specified in the request (such as the source or destination connector profile) is not found.
/// </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum S3ConnectorOperator {
    case addition
    case between
    case division
    case equalTo
    case greaterThan
    case greaterThanOrEqualTo
    case lessThan
    case lessThanOrEqualTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case notEqualTo
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension S3ConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3ConnectorOperator] {
        return [
            .addition,
            .between,
            .division,
            .equalTo,
            .greaterThan,
            .greaterThanOrEqualTo,
            .lessThan,
            .lessThanOrEqualTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .notEqualTo,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
        case .lessThan: return "LESS_THAN"
        case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .notEqualTo: return "NOT_EQUAL_TO"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3ConnectorOperator(rawValue: rawValue) ?? S3ConnectorOperator.sdkUnknown(rawValue)
    }
}

extension S3DestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case bucketPrefix
        case s3OutputFormatConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let s3OutputFormatConfig = s3OutputFormatConfig {
            try encodeContainer.encode(s3OutputFormatConfig, forKey: .s3OutputFormatConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let s3OutputFormatConfigDecoded = try containerValues.decodeIfPresent(S3OutputFormatConfig.self, forKey: .s3OutputFormatConfig)
        s3OutputFormatConfig = s3OutputFormatConfigDecoded
    }
}

extension S3DestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3DestinationProperties(bucketName: \(String(describing: bucketName)), bucketPrefix: \(String(describing: bucketPrefix)), s3OutputFormatConfig: \(String(describing: s3OutputFormatConfig)))"}
}

/// <p>
///   The properties that are applied when Amazon S3 is used as a destination.
/// </p>
public struct S3DestinationProperties: Equatable {
    /// <p>
    ///   The Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
    /// </p>
    public let bucketName: String?
    /// <p>
    ///   The object key for the destination bucket in which Amazon AppFlow places the files.
    /// </p>
    public let bucketPrefix: String?
    /// <p>
    /// The configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination.
    ///     </p>
    public let s3OutputFormatConfig: S3OutputFormatConfig?

    public init (
        bucketName: String? = nil,
        bucketPrefix: String? = nil,
        s3OutputFormatConfig: S3OutputFormatConfig? = nil
    )
    {
        self.bucketName = bucketName
        self.bucketPrefix = bucketPrefix
        self.s3OutputFormatConfig = s3OutputFormatConfig
    }
}

extension S3Metadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension S3Metadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Metadata()"}
}

/// <p>
///   The connector metadata specific to Amazon S3.
/// </p>
public struct S3Metadata: Equatable {

    public init() {}
}

extension S3OutputFormatConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregationConfig
        case fileType
        case prefixConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationConfig = aggregationConfig {
            try encodeContainer.encode(aggregationConfig, forKey: .aggregationConfig)
        }
        if let fileType = fileType {
            try encodeContainer.encode(fileType.rawValue, forKey: .fileType)
        }
        if let prefixConfig = prefixConfig {
            try encodeContainer.encode(prefixConfig, forKey: .prefixConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileTypeDecoded = try containerValues.decodeIfPresent(FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let prefixConfigDecoded = try containerValues.decodeIfPresent(PrefixConfig.self, forKey: .prefixConfig)
        prefixConfig = prefixConfigDecoded
        let aggregationConfigDecoded = try containerValues.decodeIfPresent(AggregationConfig.self, forKey: .aggregationConfig)
        aggregationConfig = aggregationConfigDecoded
    }
}

extension S3OutputFormatConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3OutputFormatConfig(aggregationConfig: \(String(describing: aggregationConfig)), fileType: \(String(describing: fileType)), prefixConfig: \(String(describing: prefixConfig)))"}
}

/// <p>
/// The configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination.
///     </p>
public struct S3OutputFormatConfig: Equatable {
    /// <p>
    /// The aggregation settings that you can use to customize the output format of your flow data.
    /// </p>
    public let aggregationConfig: AggregationConfig?
    /// <p>
    /// Indicates the file type that Amazon AppFlow places in the Amazon S3 bucket.
    ///     </p>
    public let fileType: FileType?
    /// <p>
    ///       Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date.
    ///     </p>
    public let prefixConfig: PrefixConfig?

    public init (
        aggregationConfig: AggregationConfig? = nil,
        fileType: FileType? = nil,
        prefixConfig: PrefixConfig? = nil
    )
    {
        self.aggregationConfig = aggregationConfig
        self.fileType = fileType
        self.prefixConfig = prefixConfig
    }
}

extension S3SourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case bucketPrefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
    }
}

extension S3SourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3SourceProperties(bucketName: \(String(describing: bucketName)), bucketPrefix: \(String(describing: bucketPrefix)))"}
}

/// <p>
///   The properties that are applied when Amazon S3 is being used as the flow source.
/// </p>
public struct S3SourceProperties: Equatable {
    /// <p>
    ///   The Amazon S3 bucket name where the source files are stored.
    /// </p>
    public let bucketName: String?
    /// <p>
    ///   The object key for the Amazon S3 bucket in which the source files are stored.
    /// </p>
    public let bucketPrefix: String?

    public init (
        bucketName: String? = nil,
        bucketPrefix: String? = nil
    )
    {
        self.bucketName = bucketName
        self.bucketPrefix = bucketPrefix
    }
}

public enum SalesforceConnectorOperator {
    case addition
    case between
    case contains
    case division
    case equalTo
    case greaterThan
    case greaterThanOrEqualTo
    case lessThan
    case lessThanOrEqualTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case notEqualTo
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension SalesforceConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SalesforceConnectorOperator] {
        return [
            .addition,
            .between,
            .contains,
            .division,
            .equalTo,
            .greaterThan,
            .greaterThanOrEqualTo,
            .lessThan,
            .lessThanOrEqualTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .notEqualTo,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .contains: return "CONTAINS"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
        case .lessThan: return "LESS_THAN"
        case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .notEqualTo: return "NOT_EQUAL_TO"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SalesforceConnectorOperator(rawValue: rawValue) ?? SalesforceConnectorOperator.sdkUnknown(rawValue)
    }
}

extension SalesforceConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case clientCredentialsArn
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientCredentialsArn = clientCredentialsArn {
            try encodeContainer.encode(clientCredentialsArn, forKey: .clientCredentialsArn)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
        let clientCredentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCredentialsArn)
        clientCredentialsArn = clientCredentialsArnDecoded
    }
}

extension SalesforceConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceConnectorProfileCredentials(accessToken: \(String(describing: accessToken)), clientCredentialsArn: \(String(describing: clientCredentialsArn)), oAuthRequest: \(String(describing: oAuthRequest)), refreshToken: \(String(describing: refreshToken)))"}
}

/// <p>
///   The connector-specific profile credentials required when using Salesforce.
/// </p>
public struct SalesforceConnectorProfileCredentials: Equatable {
    /// <p>
    ///   The credentials used to access protected Salesforce resources.
    /// </p>
    public let accessToken: String?
    /// <p>
    ///       The secret manager ARN, which contains the client ID and client secret of the connected app.
    ///     </p>
    public let clientCredentialsArn: String?
    /// <p>
    ///   The OAuth requirement needed to request security tokens from the connector endpoint.
    /// </p>
    public let oAuthRequest: ConnectorOAuthRequest?
    /// <p>
    ///   The credentials used to acquire new access tokens.
    /// </p>
    public let refreshToken: String?

    public init (
        accessToken: String? = nil,
        clientCredentialsArn: String? = nil,
        oAuthRequest: ConnectorOAuthRequest? = nil,
        refreshToken: String? = nil
    )
    {
        self.accessToken = accessToken
        self.clientCredentialsArn = clientCredentialsArn
        self.oAuthRequest = oAuthRequest
        self.refreshToken = refreshToken
    }
}

extension SalesforceConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceUrl
        case isSandboxEnvironment
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
        if isSandboxEnvironment != false {
            try encodeContainer.encode(isSandboxEnvironment, forKey: .isSandboxEnvironment)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
        let isSandboxEnvironmentDecoded = try containerValues.decode(Bool.self, forKey: .isSandboxEnvironment)
        isSandboxEnvironment = isSandboxEnvironmentDecoded
    }
}

extension SalesforceConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceConnectorProfileProperties(instanceUrl: \(String(describing: instanceUrl)), isSandboxEnvironment: \(String(describing: isSandboxEnvironment)))"}
}

/// <p>
///   The connector-specific profile properties required when using Salesforce.
/// </p>
public struct SalesforceConnectorProfileProperties: Equatable {
    /// <p>
    ///   The location of the Salesforce resource.
    /// </p>
    public let instanceUrl: String?
    /// <p>
    ///  Indicates whether the connector profile applies to a sandbox or production environment.
    /// </p>
    public let isSandboxEnvironment: Bool

    public init (
        instanceUrl: String? = nil,
        isSandboxEnvironment: Bool = false
    )
    {
        self.instanceUrl = instanceUrl
        self.isSandboxEnvironment = isSandboxEnvironment
    }
}

extension SalesforceDestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorHandlingConfig
        case idFieldNames
        case object
        case writeOperationType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let idFieldNames = idFieldNames {
            var idFieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idFieldNames)
            for idfieldnamelist0 in idFieldNames {
                try idFieldNamesContainer.encode(idfieldnamelist0)
            }
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let writeOperationType = writeOperationType {
            try encodeContainer.encode(writeOperationType.rawValue, forKey: .writeOperationType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
        let idFieldNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .idFieldNames)
        var idFieldNamesDecoded0:[String]? = nil
        if let idFieldNamesContainer = idFieldNamesContainer {
            idFieldNamesDecoded0 = [String]()
            for string0 in idFieldNamesContainer {
                if let string0 = string0 {
                    idFieldNamesDecoded0?.append(string0)
                }
            }
        }
        idFieldNames = idFieldNamesDecoded0
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
        let writeOperationTypeDecoded = try containerValues.decodeIfPresent(WriteOperationType.self, forKey: .writeOperationType)
        writeOperationType = writeOperationTypeDecoded
    }
}

extension SalesforceDestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceDestinationProperties(errorHandlingConfig: \(String(describing: errorHandlingConfig)), idFieldNames: \(String(describing: idFieldNames)), object: \(String(describing: object)), writeOperationType: \(String(describing: writeOperationType)))"}
}

/// <p>
///   The properties that are applied when Salesforce is being used as a destination.
/// </p>
public struct SalesforceDestinationProperties: Equatable {
    /// <p>
    ///   The settings that determine how Amazon AppFlow handles an error when placing data in the Salesforce destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
    /// </p>
    public let errorHandlingConfig: ErrorHandlingConfig?
    /// <p>
    ///       The name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
    ///     </p>
    public let idFieldNames: [String]?
    /// <p>
    ///   The object specified in the Salesforce flow destination.
    /// </p>
    public let object: String?
    /// <p>
    ///       This specifies the type of write operation to be performed in Salesforce. When the value is <code>UPSERT</code>, then <code>idFieldNames</code> is required.
    ///     </p>
    public let writeOperationType: WriteOperationType?

    public init (
        errorHandlingConfig: ErrorHandlingConfig? = nil,
        idFieldNames: [String]? = nil,
        object: String? = nil,
        writeOperationType: WriteOperationType? = nil
    )
    {
        self.errorHandlingConfig = errorHandlingConfig
        self.idFieldNames = idFieldNames
        self.object = object
        self.writeOperationType = writeOperationType
    }
}

extension SalesforceMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension SalesforceMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceMetadata(oAuthScopes: \(String(describing: oAuthScopes)))"}
}

/// <p>
///   The connector metadata specific to Salesforce.
/// </p>
public struct SalesforceMetadata: Equatable {
    /// <p>
    ///     The desired authorization scope for the Salesforce account.
    /// </p>
    public let oAuthScopes: [String]?

    public init (
        oAuthScopes: [String]? = nil
    )
    {
        self.oAuthScopes = oAuthScopes
    }
}

extension SalesforceSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enableDynamicFieldUpdate
        case includeDeletedRecords
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableDynamicFieldUpdate != false {
            try encodeContainer.encode(enableDynamicFieldUpdate, forKey: .enableDynamicFieldUpdate)
        }
        if includeDeletedRecords != false {
            try encodeContainer.encode(includeDeletedRecords, forKey: .includeDeletedRecords)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
        let enableDynamicFieldUpdateDecoded = try containerValues.decode(Bool.self, forKey: .enableDynamicFieldUpdate)
        enableDynamicFieldUpdate = enableDynamicFieldUpdateDecoded
        let includeDeletedRecordsDecoded = try containerValues.decode(Bool.self, forKey: .includeDeletedRecords)
        includeDeletedRecords = includeDeletedRecordsDecoded
    }
}

extension SalesforceSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceSourceProperties(enableDynamicFieldUpdate: \(String(describing: enableDynamicFieldUpdate)), includeDeletedRecords: \(String(describing: includeDeletedRecords)), object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when Salesforce is being used as a source.
/// </p>
public struct SalesforceSourceProperties: Equatable {
    /// <p>
    /// The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
    ///      </p>
    public let enableDynamicFieldUpdate: Bool
    /// <p>
    ///  Indicates whether Amazon AppFlow includes deleted files in the flow run.
    ///     </p>
    public let includeDeletedRecords: Bool
    /// <p>
    ///   The object specified in the Salesforce flow source.
    /// </p>
    public let object: String?

    public init (
        enableDynamicFieldUpdate: Bool = false,
        includeDeletedRecords: Bool = false,
        object: String? = nil
    )
    {
        self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
        self.includeDeletedRecords = includeDeletedRecords
        self.object = object
    }
}

public enum ScheduleFrequencyType {
    case byminute
    case daily
    case hourly
    case monthly
    case once
    case weekly
    case sdkUnknown(String)
}

extension ScheduleFrequencyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScheduleFrequencyType] {
        return [
            .byminute,
            .daily,
            .hourly,
            .monthly,
            .once,
            .weekly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .byminute: return "BYMINUTE"
        case .daily: return "DAILY"
        case .hourly: return "HOURLY"
        case .monthly: return "MONTHLY"
        case .once: return "ONCE"
        case .weekly: return "WEEKLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScheduleFrequencyType(rawValue: rawValue) ?? ScheduleFrequencyType.sdkUnknown(rawValue)
    }
}

extension ScheduledTriggerProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataPullMode
        case firstExecutionFrom
        case scheduleEndTime
        case scheduleExpression
        case scheduleOffset
        case scheduleStartTime
        case timezone
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPullMode = dataPullMode {
            try encodeContainer.encode(dataPullMode.rawValue, forKey: .dataPullMode)
        }
        if let firstExecutionFrom = firstExecutionFrom {
            try encodeContainer.encode(firstExecutionFrom.timeIntervalSince1970, forKey: .firstExecutionFrom)
        }
        if let scheduleEndTime = scheduleEndTime {
            try encodeContainer.encode(scheduleEndTime.timeIntervalSince1970, forKey: .scheduleEndTime)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleStartTime = scheduleStartTime {
            try encodeContainer.encode(scheduleStartTime.timeIntervalSince1970, forKey: .scheduleStartTime)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let dataPullModeDecoded = try containerValues.decodeIfPresent(DataPullMode.self, forKey: .dataPullMode)
        dataPullMode = dataPullModeDecoded
        let scheduleStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduleStartTime)
        scheduleStartTime = scheduleStartTimeDecoded
        let scheduleEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduleEndTime)
        scheduleEndTime = scheduleEndTimeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let firstExecutionFromDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .firstExecutionFrom)
        firstExecutionFrom = firstExecutionFromDecoded
    }
}

extension ScheduledTriggerProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduledTriggerProperties(dataPullMode: \(String(describing: dataPullMode)), firstExecutionFrom: \(String(describing: firstExecutionFrom)), scheduleEndTime: \(String(describing: scheduleEndTime)), scheduleExpression: \(String(describing: scheduleExpression)), scheduleOffset: \(String(describing: scheduleOffset)), scheduleStartTime: \(String(describing: scheduleStartTime)), timezone: \(String(describing: timezone)))"}
}

/// <p>
///   Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the <code>Scheduled</code> trigger type.
/// </p>
public struct ScheduledTriggerProperties: Equatable {
    /// <p>
    ///  Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
    /// </p>
    public let dataPullMode: DataPullMode?
    /// <p>
    ///       Specifies the date range for the records to import from the connector in the first flow run.
    ///     </p>
    public let firstExecutionFrom: Date?
    /// <p>
    ///  Specifies the scheduled end time for a schedule-triggered flow.
    /// </p>
    public let scheduleEndTime: Date?
    /// <p>
    ///   The scheduling expression that determines the rate at which the schedule will run, for example <code>rate(5minutes)</code>.
    /// </p>
    public let scheduleExpression: String?
    /// <p>
    /// Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
    /// </p>
    public let scheduleOffset: Int
    /// <p>
    /// Specifies the scheduled start time for a schedule-triggered flow.
    /// </p>
    public let scheduleStartTime: Date?
    /// <p>
    ///   Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as <code>America/New_York</code>.
    /// </p>
    public let timezone: String?

    public init (
        dataPullMode: DataPullMode? = nil,
        firstExecutionFrom: Date? = nil,
        scheduleEndTime: Date? = nil,
        scheduleExpression: String? = nil,
        scheduleOffset: Int = 0,
        scheduleStartTime: Date? = nil,
        timezone: String? = nil
    )
    {
        self.dataPullMode = dataPullMode
        self.firstExecutionFrom = firstExecutionFrom
        self.scheduleEndTime = scheduleEndTime
        self.scheduleExpression = scheduleExpression
        self.scheduleOffset = scheduleOffset
        self.scheduleStartTime = scheduleStartTime
        self.timezone = timezone
    }
}

public enum ServiceNowConnectorOperator {
    case addition
    case between
    case contains
    case division
    case equalTo
    case greaterThan
    case greaterThanOrEqualTo
    case lessThan
    case lessThanOrEqualTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case notEqualTo
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension ServiceNowConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceNowConnectorOperator] {
        return [
            .addition,
            .between,
            .contains,
            .division,
            .equalTo,
            .greaterThan,
            .greaterThanOrEqualTo,
            .lessThan,
            .lessThanOrEqualTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .notEqualTo,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .contains: return "CONTAINS"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
        case .lessThan: return "LESS_THAN"
        case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .notEqualTo: return "NOT_EQUAL_TO"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceNowConnectorOperator(rawValue: rawValue) ?? ServiceNowConnectorOperator.sdkUnknown(rawValue)
    }
}

extension ServiceNowConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension ServiceNowConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNowConnectorProfileCredentials(password: \(String(describing: password)), username: \(String(describing: username)))"}
}

/// <p>
///   The connector-specific profile credentials required when using ServiceNow.
/// </p>
public struct ServiceNowConnectorProfileCredentials: Equatable {
    /// <p>
    ///   The password that corresponds to the user name.
    /// </p>
    public let password: String?
    /// <p>
    ///   The name of the user.
    /// </p>
    public let username: String?

    public init (
        password: String? = nil,
        username: String? = nil
    )
    {
        self.password = password
        self.username = username
    }
}

extension ServiceNowConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension ServiceNowConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNowConnectorProfileProperties(instanceUrl: \(String(describing: instanceUrl)))"}
}

/// <p>
///   The connector-specific profile properties required when using ServiceNow.
/// </p>
public struct ServiceNowConnectorProfileProperties: Equatable {
    /// <p>
    ///   The location of the ServiceNow resource.
    /// </p>
    public let instanceUrl: String?

    public init (
        instanceUrl: String? = nil
    )
    {
        self.instanceUrl = instanceUrl
    }
}

extension ServiceNowMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension ServiceNowMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNowMetadata()"}
}

/// <p>
///   The connector metadata specific to ServiceNow.
/// </p>
public struct ServiceNowMetadata: Equatable {

    public init() {}
}

extension ServiceNowSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension ServiceNowSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNowSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when ServiceNow is being used as a source.
/// </p>
public struct ServiceNowSourceProperties: Equatable {
    /// <p>
    ///   The object specified in the ServiceNow flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
/// The request would cause a service quota (such as the number of flows) to be exceeded.
/// </p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SingularConnectorOperator {
    case addition
    case division
    case equalTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension SingularConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SingularConnectorOperator] {
        return [
            .addition,
            .division,
            .equalTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SingularConnectorOperator(rawValue: rawValue) ?? SingularConnectorOperator.sdkUnknown(rawValue)
    }
}

extension SingularConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKey
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

extension SingularConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SingularConnectorProfileCredentials(apiKey: \(String(describing: apiKey)))"}
}

/// <p>
///   The connector-specific profile credentials required when using Singular.
/// </p>
public struct SingularConnectorProfileCredentials: Equatable {
    /// <p>  A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
    /// </p>
    public let apiKey: String?

    public init (
        apiKey: String? = nil
    )
    {
        self.apiKey = apiKey
    }
}

extension SingularConnectorProfileProperties: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension SingularConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SingularConnectorProfileProperties()"}
}

/// <p>
///   The connector-specific profile properties required when using Singular.
/// </p>
public struct SingularConnectorProfileProperties: Equatable {

    public init() {}
}

extension SingularMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension SingularMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SingularMetadata()"}
}

/// <p>
///   The connector metadata specific to Singular.
/// </p>
public struct SingularMetadata: Equatable {

    public init() {}
}

extension SingularSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension SingularSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SingularSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when Singular is being used as a source.
/// </p>
public struct SingularSourceProperties: Equatable {
    /// <p>
    ///   The object specified in the Singular flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

public enum SlackConnectorOperator {
    case addition
    case between
    case division
    case equalTo
    case greaterThan
    case greaterThanOrEqualTo
    case lessThan
    case lessThanOrEqualTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension SlackConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SlackConnectorOperator] {
        return [
            .addition,
            .between,
            .division,
            .equalTo,
            .greaterThan,
            .greaterThanOrEqualTo,
            .lessThan,
            .lessThanOrEqualTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
        case .lessThan: return "LESS_THAN"
        case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SlackConnectorOperator(rawValue: rawValue) ?? SlackConnectorOperator.sdkUnknown(rawValue)
    }
}

extension SlackConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension SlackConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlackConnectorProfileCredentials(accessToken: \(String(describing: accessToken)), clientId: \(String(describing: clientId)), clientSecret: \(String(describing: clientSecret)), oAuthRequest: \(String(describing: oAuthRequest)))"}
}

/// <p>
///   The connector-specific profile credentials required when using Slack.
/// </p>
public struct SlackConnectorProfileCredentials: Equatable {
    /// <p>
    ///   The credentials used to access protected Slack resources.
    /// </p>
    public let accessToken: String?
    /// <p>
    ///   The identifier for the client.
    /// </p>
    public let clientId: String?
    /// <p>
    ///   The client secret used by the OAuth client to authenticate to the authorization server.
    /// </p>
    public let clientSecret: String?
    /// <p>
    ///   The OAuth requirement needed to request security tokens from the connector endpoint.
    /// </p>
    public let oAuthRequest: ConnectorOAuthRequest?

    public init (
        accessToken: String? = nil,
        clientId: String? = nil,
        clientSecret: String? = nil,
        oAuthRequest: ConnectorOAuthRequest? = nil
    )
    {
        self.accessToken = accessToken
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.oAuthRequest = oAuthRequest
    }
}

extension SlackConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension SlackConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlackConnectorProfileProperties(instanceUrl: \(String(describing: instanceUrl)))"}
}

/// <p>
///   The connector-specific profile properties required when using Slack.
/// </p>
public struct SlackConnectorProfileProperties: Equatable {
    /// <p>
    ///   The location of the Slack resource.
    /// </p>
    public let instanceUrl: String?

    public init (
        instanceUrl: String? = nil
    )
    {
        self.instanceUrl = instanceUrl
    }
}

extension SlackMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension SlackMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlackMetadata(oAuthScopes: \(String(describing: oAuthScopes)))"}
}

/// <p>
///   The connector metadata specific to Slack.
/// </p>
public struct SlackMetadata: Equatable {
    /// <p>
    /// The desired authorization scope for the Slack account.
    /// </p>
    public let oAuthScopes: [String]?

    public init (
        oAuthScopes: [String]? = nil
    )
    {
        self.oAuthScopes = oAuthScopes
    }
}

extension SlackSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension SlackSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlackSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when Slack is being used as a source.
/// </p>
public struct SlackSourceProperties: Equatable {
    /// <p>
    ///   The object specified in the Slack flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

extension SnowflakeConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension SnowflakeConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnowflakeConnectorProfileCredentials(password: \(String(describing: password)), username: \(String(describing: username)))"}
}

/// <p>
///   The connector-specific profile credentials required when using Snowflake.
/// </p>
public struct SnowflakeConnectorProfileCredentials: Equatable {
    /// <p>
    /// The password that corresponds to the user name.
    /// </p>
    public let password: String?
    /// <p>
    ///   The name of the user.
    /// </p>
    public let username: String?

    public init (
        password: String? = nil,
        username: String? = nil
    )
    {
        self.password = password
        self.username = username
    }
}

extension SnowflakeConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountName
        case bucketName
        case bucketPrefix
        case privateLinkServiceName
        case region
        case stage
        case warehouse
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let privateLinkServiceName = privateLinkServiceName {
            try encodeContainer.encode(privateLinkServiceName, forKey: .privateLinkServiceName)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
        if let warehouse = warehouse {
            try encodeContainer.encode(warehouse, forKey: .warehouse)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let warehouseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .warehouse)
        warehouse = warehouseDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let privateLinkServiceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateLinkServiceName)
        privateLinkServiceName = privateLinkServiceNameDecoded
        let accountNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
    }
}

extension SnowflakeConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnowflakeConnectorProfileProperties(accountName: \(String(describing: accountName)), bucketName: \(String(describing: bucketName)), bucketPrefix: \(String(describing: bucketPrefix)), privateLinkServiceName: \(String(describing: privateLinkServiceName)), region: \(String(describing: region)), stage: \(String(describing: stage)), warehouse: \(String(describing: warehouse)))"}
}

/// <p>
///   The connector-specific profile properties required when using Snowflake.
/// </p>
public struct SnowflakeConnectorProfileProperties: Equatable {
    /// <p>
    /// The name of the account.
    /// </p>
    public let accountName: String?
    /// <p>
    ///   The name of the Amazon S3 bucket associated with Snowflake.
    /// </p>
    public let bucketName: String?
    /// <p>
    ///   The bucket path that refers to the Amazon S3 bucket associated with Snowflake.
    /// </p>
    public let bucketPrefix: String?
    /// <p>
    /// The Snowflake Private Link service name to be used for private data transfers.
    /// </p>
    public let privateLinkServiceName: String?
    /// <p>
    /// The AWS Region of the Snowflake account.
    /// </p>
    public let region: String?
    /// <p>
    ///   The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: < Database>< Schema><Stage Name>.
    /// </p>
    public let stage: String?
    /// <p>
    /// The name of the Snowflake warehouse.
    /// </p>
    public let warehouse: String?

    public init (
        accountName: String? = nil,
        bucketName: String? = nil,
        bucketPrefix: String? = nil,
        privateLinkServiceName: String? = nil,
        region: String? = nil,
        stage: String? = nil,
        warehouse: String? = nil
    )
    {
        self.accountName = accountName
        self.bucketName = bucketName
        self.bucketPrefix = bucketPrefix
        self.privateLinkServiceName = privateLinkServiceName
        self.region = region
        self.stage = stage
        self.warehouse = warehouse
    }
}

extension SnowflakeDestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketPrefix
        case errorHandlingConfig
        case intermediateBucketName
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let intermediateBucketName = intermediateBucketName {
            try encodeContainer.encode(intermediateBucketName, forKey: .intermediateBucketName)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
        let intermediateBucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intermediateBucketName)
        intermediateBucketName = intermediateBucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension SnowflakeDestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnowflakeDestinationProperties(bucketPrefix: \(String(describing: bucketPrefix)), errorHandlingConfig: \(String(describing: errorHandlingConfig)), intermediateBucketName: \(String(describing: intermediateBucketName)), object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when Snowflake is being used as a destination.
/// </p>
public struct SnowflakeDestinationProperties: Equatable {
    /// <p>
    ///   The object key for the destination bucket in which Amazon AppFlow places the files.
    /// </p>
    public let bucketPrefix: String?
    /// <p>
    ///   The settings that determine how Amazon AppFlow handles an error when placing data in the Snowflake destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
    /// </p>
    public let errorHandlingConfig: ErrorHandlingConfig?
    /// <p>
    ///  The intermediate bucket that Amazon AppFlow uses when moving data into Snowflake.
    /// </p>
    public let intermediateBucketName: String?
    /// <p>
    ///   The object specified in the Snowflake flow destination.
    /// </p>
    public let object: String?

    public init (
        bucketPrefix: String? = nil,
        errorHandlingConfig: ErrorHandlingConfig? = nil,
        intermediateBucketName: String? = nil,
        object: String? = nil
    )
    {
        self.bucketPrefix = bucketPrefix
        self.errorHandlingConfig = errorHandlingConfig
        self.intermediateBucketName = intermediateBucketName
        self.object = object
    }
}

extension SnowflakeMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case supportedRegions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let supportedRegions = supportedRegions {
            var supportedRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedRegions)
            for regionlist0 in supportedRegions {
                try supportedRegionsContainer.encode(regionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportedRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .supportedRegions)
        var supportedRegionsDecoded0:[String]? = nil
        if let supportedRegionsContainer = supportedRegionsContainer {
            supportedRegionsDecoded0 = [String]()
            for string0 in supportedRegionsContainer {
                if let string0 = string0 {
                    supportedRegionsDecoded0?.append(string0)
                }
            }
        }
        supportedRegions = supportedRegionsDecoded0
    }
}

extension SnowflakeMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnowflakeMetadata(supportedRegions: \(String(describing: supportedRegions)))"}
}

/// <p>
///   The connector metadata specific to Snowflake.
/// </p>
public struct SnowflakeMetadata: Equatable {
    /// <p>
    /// Specifies the supported AWS Regions when using Snowflake.
    /// </p>
    public let supportedRegions: [String]?

    public init (
        supportedRegions: [String]? = nil
    )
    {
        self.supportedRegions = supportedRegions
    }
}

extension SourceConnectorProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AmplitudeSourceProperties.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(DatadogSourceProperties.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(DynatraceSourceProperties.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(GoogleAnalyticsSourceProperties.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(InforNexusSourceProperties.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(MarketoSourceProperties.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(S3SourceProperties.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(SalesforceSourceProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(ServiceNowSourceProperties.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(SingularSourceProperties.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(SlackSourceProperties.self, forKey: .slack)
        slack = slackDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(TrendmicroSourceProperties.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(VeevaSourceProperties.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(ZendeskSourceProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension SourceConnectorProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceConnectorProperties(amplitude: \(String(describing: amplitude)), datadog: \(String(describing: datadog)), dynatrace: \(String(describing: dynatrace)), googleAnalytics: \(String(describing: googleAnalytics)), inforNexus: \(String(describing: inforNexus)), marketo: \(String(describing: marketo)), s3: \(String(describing: s3)), salesforce: \(String(describing: salesforce)), serviceNow: \(String(describing: serviceNow)), singular: \(String(describing: singular)), slack: \(String(describing: slack)), trendmicro: \(String(describing: trendmicro)), veeva: \(String(describing: veeva)), zendesk: \(String(describing: zendesk)))"}
}

/// <p>
///  Specifies the information that is required to query a particular connector.
/// </p>
public struct SourceConnectorProperties: Equatable {
    /// <p>
    ///   Specifies the information that is required for querying Amplitude.
    /// </p>
    public let amplitude: AmplitudeSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Datadog.
    /// </p>
    public let datadog: DatadogSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Dynatrace.
    /// </p>
    public let dynatrace: DynatraceSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Google Analytics.
    /// </p>
    public let googleAnalytics: GoogleAnalyticsSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Infor Nexus.
    /// </p>
    public let inforNexus: InforNexusSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Marketo.
    /// </p>
    public let marketo: MarketoSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Amazon S3.
    /// </p>
    public let s3: S3SourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Salesforce.
    /// </p>
    public let salesforce: SalesforceSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying ServiceNow.
    /// </p>
    public let serviceNow: ServiceNowSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Singular.
    /// </p>
    public let singular: SingularSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Slack.
    /// </p>
    public let slack: SlackSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Trend Micro.
    /// </p>
    public let trendmicro: TrendmicroSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Veeva.
    /// </p>
    public let veeva: VeevaSourceProperties?
    /// <p>
    ///   Specifies the information that is required for querying Zendesk.
    /// </p>
    public let zendesk: ZendeskSourceProperties?

    public init (
        amplitude: AmplitudeSourceProperties? = nil,
        datadog: DatadogSourceProperties? = nil,
        dynatrace: DynatraceSourceProperties? = nil,
        googleAnalytics: GoogleAnalyticsSourceProperties? = nil,
        inforNexus: InforNexusSourceProperties? = nil,
        marketo: MarketoSourceProperties? = nil,
        s3: S3SourceProperties? = nil,
        salesforce: SalesforceSourceProperties? = nil,
        serviceNow: ServiceNowSourceProperties? = nil,
        singular: SingularSourceProperties? = nil,
        slack: SlackSourceProperties? = nil,
        trendmicro: TrendmicroSourceProperties? = nil,
        veeva: VeevaSourceProperties? = nil,
        zendesk: ZendeskSourceProperties? = nil
    )
    {
        self.amplitude = amplitude
        self.datadog = datadog
        self.dynatrace = dynatrace
        self.googleAnalytics = googleAnalytics
        self.inforNexus = inforNexus
        self.marketo = marketo
        self.s3 = s3
        self.salesforce = salesforce
        self.serviceNow = serviceNow
        self.singular = singular
        self.slack = slack
        self.trendmicro = trendmicro
        self.veeva = veeva
        self.zendesk = zendesk
    }
}

extension SourceFieldProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isQueryable
        case isRetrievable
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isQueryable != false {
            try encodeContainer.encode(isQueryable, forKey: .isQueryable)
        }
        if isRetrievable != false {
            try encodeContainer.encode(isRetrievable, forKey: .isRetrievable)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isRetrievableDecoded = try containerValues.decode(Bool.self, forKey: .isRetrievable)
        isRetrievable = isRetrievableDecoded
        let isQueryableDecoded = try containerValues.decode(Bool.self, forKey: .isQueryable)
        isQueryable = isQueryableDecoded
    }
}

extension SourceFieldProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceFieldProperties(isQueryable: \(String(describing: isQueryable)), isRetrievable: \(String(describing: isRetrievable)))"}
}

/// <p>
///   The properties that can be applied to a field when the connector is being used as a source.
/// </p>
public struct SourceFieldProperties: Equatable {
    /// <p>
    ///  Indicates if the field can be queried.
    /// </p>
    public let isQueryable: Bool
    /// <p>
    /// Indicates whether the field can be returned in a search result.
    /// </p>
    public let isRetrievable: Bool

    public init (
        isQueryable: Bool = false,
        isRetrievable: Bool = false
    )
    {
        self.isQueryable = isQueryable
        self.isRetrievable = isRetrievable
    }
}

extension SourceFlowConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorProfileName
        case connectorType
        case incrementalPullConfig
        case sourceConnectorProperties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let incrementalPullConfig = incrementalPullConfig {
            try encodeContainer.encode(incrementalPullConfig, forKey: .incrementalPullConfig)
        }
        if let sourceConnectorProperties = sourceConnectorProperties {
            try encodeContainer.encode(sourceConnectorProperties, forKey: .sourceConnectorProperties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let sourceConnectorPropertiesDecoded = try containerValues.decodeIfPresent(SourceConnectorProperties.self, forKey: .sourceConnectorProperties)
        sourceConnectorProperties = sourceConnectorPropertiesDecoded
        let incrementalPullConfigDecoded = try containerValues.decodeIfPresent(IncrementalPullConfig.self, forKey: .incrementalPullConfig)
        incrementalPullConfig = incrementalPullConfigDecoded
    }
}

extension SourceFlowConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceFlowConfig(connectorProfileName: \(String(describing: connectorProfileName)), connectorType: \(String(describing: connectorType)), incrementalPullConfig: \(String(describing: incrementalPullConfig)), sourceConnectorProperties: \(String(describing: sourceConnectorProperties)))"}
}

/// <p>
///  Contains information about the configuration of the source connector used in the flow.
/// </p>
public struct SourceFlowConfig: Equatable {
    /// <p>
    ///   The name of the connector profile. This name must be unique for each connector profile in the AWS account.
    /// </p>
    public let connectorProfileName: String?
    /// <p>
    ///   The type of connector, such as Salesforce, Amplitude, and so on.
    /// </p>
    public let connectorType: ConnectorType?
    /// <p>
    ///       Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
    ///     </p>
    public let incrementalPullConfig: IncrementalPullConfig?
    /// <p>
    ///   Specifies the information that is required to query a particular source connector.
    /// </p>
    public let sourceConnectorProperties: SourceConnectorProperties?

    public init (
        connectorProfileName: String? = nil,
        connectorType: ConnectorType? = nil,
        incrementalPullConfig: IncrementalPullConfig? = nil,
        sourceConnectorProperties: SourceConnectorProperties? = nil
    )
    {
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.incrementalPullConfig = incrementalPullConfig
        self.sourceConnectorProperties = sourceConnectorProperties
    }
}

public struct StartFlowInputBodyMiddleware: Middleware {
    public let id: String = "StartFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFlowInput>
    public typealias MOutput = OperationOutput<StartFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFlowOutputError>
}

extension StartFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartFlowInput(flowName: \(String(describing: flowName)))"}
}

extension StartFlowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case flowName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

public struct StartFlowInputHeadersMiddleware: Middleware {
    public let id: String = "StartFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFlowInput>
    public typealias MOutput = OperationOutput<StartFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFlowOutputError>
}

public struct StartFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "StartFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFlowInput>
    public typealias MOutput = OperationOutput<StartFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFlowOutputError>
}

public struct StartFlowInput: Equatable {
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: String?

    public init (
        flowName: String? = nil
    )
    {
        self.flowName = flowName
    }
}

struct StartFlowInputBody: Equatable {
    public let flowName: String?
}

extension StartFlowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension StartFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFlowOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartFlowOutputResponse(executionId: \(String(describing: executionId)), flowArn: \(String(describing: flowArn)), flowStatus: \(String(describing: flowStatus)))"}
}

extension StartFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executionId = output.executionId
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.executionId = nil
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct StartFlowOutputResponse: Equatable {
    /// <p>
    ///       Returns the internal execution ID of an on-demand flow when the flow is started. For scheduled or event-triggered flows, this value is null.
    ///     </p>
    public let executionId: String?
    /// <p>
    ///   The flow's Amazon Resource Name (ARN).
    /// </p>
    public let flowArn: String?
    /// <p>
    ///   Indicates the current status of the flow.
    ///
    /// </p>
    public let flowStatus: FlowStatus?

    public init (
        executionId: String? = nil,
        flowArn: String? = nil,
        flowStatus: FlowStatus? = nil
    )
    {
        self.executionId = executionId
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct StartFlowOutputResponseBody: Equatable {
    public let flowArn: String?
    public let flowStatus: FlowStatus?
    public let executionId: String?
}

extension StartFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionId
        case flowArn
        case flowStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionId)
        executionId = executionIdDecoded
    }
}

public struct StopFlowInputBodyMiddleware: Middleware {
    public let id: String = "StopFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<StopFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopFlowInput>
    public typealias MOutput = OperationOutput<StopFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopFlowOutputError>
}

extension StopFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopFlowInput(flowName: \(String(describing: flowName)))"}
}

extension StopFlowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case flowName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

public struct StopFlowInputHeadersMiddleware: Middleware {
    public let id: String = "StopFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<StopFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopFlowInput>
    public typealias MOutput = OperationOutput<StopFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopFlowOutputError>
}

public struct StopFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "StopFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<StopFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopFlowInput>
    public typealias MOutput = OperationOutput<StopFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopFlowOutputError>
}

public struct StopFlowInput: Equatable {
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: String?

    public init (
        flowName: String? = nil
    )
    {
        self.flowName = flowName
    }
}

struct StopFlowInputBody: Equatable {
    public let flowName: String?
}

extension StopFlowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension StopFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopFlowOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopFlowOutputResponse(flowArn: \(String(describing: flowArn)), flowStatus: \(String(describing: flowStatus)))"}
}

extension StopFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct StopFlowOutputResponse: Equatable {
    /// <p>
    ///   The flow's Amazon Resource Name (ARN).
    /// </p>
    public let flowArn: String?
    /// <p>
    ///   Indicates the current status of the flow.
    /// </p>
    public let flowStatus: FlowStatus?

    public init (
        flowArn: String? = nil,
        flowStatus: FlowStatus? = nil
    )
    {
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct StopFlowOutputResponseBody: Equatable {
    public let flowArn: String?
    public let flowStatus: FlowStatus?
}

extension StopFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn
        case flowStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

extension SupportedFieldTypeDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case v1
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let v1 = v1 {
            try encodeContainer.encode(v1, forKey: .v1)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let v1Decoded = try containerValues.decodeIfPresent(FieldTypeDetails.self, forKey: .v1)
        v1 = v1Decoded
    }
}

extension SupportedFieldTypeDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SupportedFieldTypeDetails(v1: \(String(describing: v1)))"}
}

/// <p>
///  Contains details regarding all the supported <code>FieldTypes</code> and their corresponding <code>filterOperators</code> and <code>supportedValues</code>.
/// </p>
public struct SupportedFieldTypeDetails: Equatable {
    /// <p>
    ///  The initial supported version for <code>fieldType</code>. If this is later changed to a different version, v2 will be introduced.
    /// </p>
    public let v1: FieldTypeDetails?

    public init (
        v1: FieldTypeDetails? = nil
    )
    {
        self.v1 = v1
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>
    ///   The Amazon Resource Name (ARN) of the flow that you want to tag.
    /// </p>
    public let resourceArn: String?
    /// <p>
    ///   The tags used to organize, track, or control access for your flow.
    /// </p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Task: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorOperator
        case destinationField
        case sourceFields
        case taskProperties
        case taskType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorOperator = connectorOperator {
            try encodeContainer.encode(connectorOperator, forKey: .connectorOperator)
        }
        if let destinationField = destinationField {
            try encodeContainer.encode(destinationField, forKey: .destinationField)
        }
        if let sourceFields = sourceFields {
            var sourceFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceFields)
            for sourcefields0 in sourceFields {
                try sourceFieldsContainer.encode(sourcefields0)
            }
        }
        if let taskProperties = taskProperties {
            var taskPropertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .taskProperties)
            for (dictKey0, taskpropertiesmap0) in taskProperties {
                try taskPropertiesContainer.encode(taskpropertiesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFieldsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sourceFields)
        var sourceFieldsDecoded0:[String]? = nil
        if let sourceFieldsContainer = sourceFieldsContainer {
            sourceFieldsDecoded0 = [String]()
            for string0 in sourceFieldsContainer {
                if let string0 = string0 {
                    sourceFieldsDecoded0?.append(string0)
                }
            }
        }
        sourceFields = sourceFieldsDecoded0
        let connectorOperatorDecoded = try containerValues.decodeIfPresent(ConnectorOperator.self, forKey: .connectorOperator)
        connectorOperator = connectorOperatorDecoded
        let destinationFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationField)
        destinationField = destinationFieldDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(TaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .taskProperties)
        var taskPropertiesDecoded0: [String:String]? = nil
        if let taskPropertiesContainer = taskPropertiesContainer {
            taskPropertiesDecoded0 = [String:String]()
            for (key0, property0) in taskPropertiesContainer {
                if let property0 = property0 {
                    taskPropertiesDecoded0?[key0] = property0
                }
            }
        }
        taskProperties = taskPropertiesDecoded0
    }
}

extension Task: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Task(connectorOperator: \(String(describing: connectorOperator)), destinationField: \(String(describing: destinationField)), sourceFields: \(String(describing: sourceFields)), taskProperties: \(String(describing: taskProperties)), taskType: \(String(describing: taskType)))"}
}

/// <p>
///   A class for modeling different type of tasks. Task implementation varies based on the <code>TaskType</code>.
/// </p>
public struct Task: Equatable {
    /// <p>
    /// The operation to be performed on the provided source fields.
    /// </p>
    public let connectorOperator: ConnectorOperator?
    /// <p>
    ///   A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
    /// </p>
    public let destinationField: String?
    /// <p>
    /// The source fields to which a particular task is applied.
    /// </p>
    public let sourceFields: [String]?
    /// <p>
    ///  A map used to store task-related information. The execution service looks for particular information based on the <code>TaskType</code>.
    /// </p>
    public let taskProperties: [String:String]?
    /// <p>
    /// Specifies the particular task implementation that Amazon AppFlow performs.
    /// </p>
    public let taskType: TaskType?

    public init (
        connectorOperator: ConnectorOperator? = nil,
        destinationField: String? = nil,
        sourceFields: [String]? = nil,
        taskProperties: [String:String]? = nil,
        taskType: TaskType? = nil
    )
    {
        self.connectorOperator = connectorOperator
        self.destinationField = destinationField
        self.sourceFields = sourceFields
        self.taskProperties = taskProperties
        self.taskType = taskType
    }
}

public enum TaskType {
    case arithmetic
    case filter
    case map
    case mask
    case merge
    case truncate
    case validate
    case sdkUnknown(String)
}

extension TaskType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaskType] {
        return [
            .arithmetic,
            .filter,
            .map,
            .mask,
            .merge,
            .truncate,
            .validate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .arithmetic: return "Arithmetic"
        case .filter: return "Filter"
        case .map: return "Map"
        case .mask: return "Mask"
        case .merge: return "Merge"
        case .truncate: return "Truncate"
        case .validate: return "Validate"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaskType(rawValue: rawValue) ?? TaskType.sdkUnknown(rawValue)
    }
}

public enum TrendmicroConnectorOperator {
    case addition
    case division
    case equalTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension TrendmicroConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TrendmicroConnectorOperator] {
        return [
            .addition,
            .division,
            .equalTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TrendmicroConnectorOperator(rawValue: rawValue) ?? TrendmicroConnectorOperator.sdkUnknown(rawValue)
    }
}

extension TrendmicroConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiSecretKey
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiSecretKey = apiSecretKey {
            try encodeContainer.encode(apiSecretKey, forKey: .apiSecretKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiSecretKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiSecretKey)
        apiSecretKey = apiSecretKeyDecoded
    }
}

extension TrendmicroConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrendmicroConnectorProfileCredentials(apiSecretKey: \(String(describing: apiSecretKey)))"}
}

/// <p>
///   The connector-specific profile credentials required when using Trend Micro.
/// </p>
public struct TrendmicroConnectorProfileCredentials: Equatable {
    /// <p>
    ///   The Secret Access Key portion of the credentials.
    /// </p>
    public let apiSecretKey: String?

    public init (
        apiSecretKey: String? = nil
    )
    {
        self.apiSecretKey = apiSecretKey
    }
}

extension TrendmicroConnectorProfileProperties: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension TrendmicroConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrendmicroConnectorProfileProperties()"}
}

/// <p>
///   The connector-specific profile properties required when using Trend Micro.
/// </p>
public struct TrendmicroConnectorProfileProperties: Equatable {

    public init() {}
}

extension TrendmicroMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension TrendmicroMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrendmicroMetadata()"}
}

/// <p>
///   The connector metadata specific to Trend Micro.
/// </p>
public struct TrendmicroMetadata: Equatable {

    public init() {}
}

extension TrendmicroSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension TrendmicroSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrendmicroSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when using Trend Micro as a flow source.
/// </p>
public struct TrendmicroSourceProperties: Equatable {
    /// <p>
    ///   The object specified in the Trend Micro flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

extension TriggerConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case triggerProperties
        case triggerType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerProperties = triggerProperties {
            try encodeContainer.encode(triggerProperties, forKey: .triggerProperties)
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerTypeDecoded = try containerValues.decodeIfPresent(TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerPropertiesDecoded = try containerValues.decodeIfPresent(TriggerProperties.self, forKey: .triggerProperties)
        triggerProperties = triggerPropertiesDecoded
    }
}

extension TriggerConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TriggerConfig(triggerProperties: \(String(describing: triggerProperties)), triggerType: \(String(describing: triggerType)))"}
}

/// <p>
///   The trigger settings that determine how and when Amazon AppFlow runs the specified flow.
///
///
/// </p>
public struct TriggerConfig: Equatable {
    /// <p>
    ///   Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the <code>Scheduled</code> trigger type.
    /// </p>
    public let triggerProperties: TriggerProperties?
    /// <p>
    ///   Specifies the type of flow trigger. This can be <code>OnDemand</code>, <code>Scheduled</code>, or <code>Event</code>.
    /// </p>
    public let triggerType: TriggerType?

    public init (
        triggerProperties: TriggerProperties? = nil,
        triggerType: TriggerType? = nil
    )
    {
        self.triggerProperties = triggerProperties
        self.triggerType = triggerType
    }
}

extension TriggerProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scheduled = "Scheduled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduled = scheduled {
            try encodeContainer.encode(scheduled, forKey: .scheduled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledDecoded = try containerValues.decodeIfPresent(ScheduledTriggerProperties.self, forKey: .scheduled)
        scheduled = scheduledDecoded
    }
}

extension TriggerProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TriggerProperties(scheduled: \(String(describing: scheduled)))"}
}

/// <p>
///   Specifies the configuration details that control the trigger for a flow. Currently, these settings only apply to the <code>Scheduled</code> trigger type.
/// </p>
public struct TriggerProperties: Equatable {
    /// <p>
    ///   Specifies the configuration details of a schedule-triggered flow as defined by the user.
    /// </p>
    public let scheduled: ScheduledTriggerProperties?

    public init (
        scheduled: ScheduledTriggerProperties? = nil
    )
    {
        self.scheduled = scheduled
    }
}

public enum TriggerType {
    case event
    case ondemand
    case scheduled
    case sdkUnknown(String)
}

extension TriggerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TriggerType] {
        return [
            .event,
            .ondemand,
            .scheduled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .event: return "Event"
        case .ondemand: return "OnDemand"
        case .scheduled: return "Scheduled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
    }
}

extension UnsupportedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperationException(message: \(String(describing: message)))"}
}

extension UnsupportedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///  The requested operation is not supported for the current flow.
/// </p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>
    ///   The Amazon Resource Name (ARN) of the flow that you want to untag.
    /// </p>
    public let resourceArn: String?
    /// <p>
    /// The tag keys associated with the tag that you want to remove from your flow.
    /// </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateConnectorProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConnectorProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectorProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectorProfileInput>
    public typealias MOutput = OperationOutput<UpdateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectorProfileOutputError>
}

extension UpdateConnectorProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectorProfileInput(connectionMode: \(String(describing: connectionMode)), connectorProfileConfig: \(String(describing: connectorProfileConfig)), connectorProfileName: \(String(describing: connectorProfileName)))"}
}

extension UpdateConnectorProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionMode = connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorProfileConfig = connectorProfileConfig {
            try encodeContainer.encode(connectorProfileConfig, forKey: .connectorProfileConfig)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
    }
}

public struct UpdateConnectorProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConnectorProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectorProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectorProfileInput>
    public typealias MOutput = OperationOutput<UpdateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectorProfileOutputError>
}

public struct UpdateConnectorProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConnectorProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectorProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectorProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectorProfileInput>
    public typealias MOutput = OperationOutput<UpdateConnectorProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectorProfileOutputError>
}

public struct UpdateConnectorProfileInput: Equatable {
    /// <p>
    ///   Indicates the connection mode and if it is public or private.
    /// </p>
    public let connectionMode: ConnectionMode?
    /// <p>
    ///   Defines the connector-specific profile configuration and credentials.
    /// </p>
    public let connectorProfileConfig: ConnectorProfileConfig?
    /// <p>
    ///   The name of the connector profile and is unique for each <code>ConnectorProfile</code> in the AWS Account.
    /// </p>
    public let connectorProfileName: String?

    public init (
        connectionMode: ConnectionMode? = nil,
        connectorProfileConfig: ConnectorProfileConfig? = nil,
        connectorProfileName: String? = nil
    )
    {
        self.connectionMode = connectionMode
        self.connectorProfileConfig = connectorProfileConfig
        self.connectorProfileName = connectorProfileName
    }
}

struct UpdateConnectorProfileInputBody: Equatable {
    public let connectorProfileName: String?
    public let connectionMode: ConnectionMode?
    public let connectorProfileConfig: ConnectorProfileConfig?
}

extension UpdateConnectorProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let connectorProfileConfigDecoded = try containerValues.decodeIfPresent(ConnectorProfileConfig.self, forKey: .connectorProfileConfig)
        connectorProfileConfig = connectorProfileConfigDecoded
    }
}

extension UpdateConnectorProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectorProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectorProfileOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectorProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectorProfileOutputResponse(connectorProfileArn: \(String(describing: connectorProfileArn)))"}
}

extension UpdateConnectorProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConnectorProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileArn = output.connectorProfileArn
        } else {
            self.connectorProfileArn = nil
        }
    }
}

public struct UpdateConnectorProfileOutputResponse: Equatable {
    /// <p>
    ///   The Amazon Resource Name (ARN) of the connector profile.
    /// </p>
    public let connectorProfileArn: String?

    public init (
        connectorProfileArn: String? = nil
    )
    {
        self.connectorProfileArn = connectorProfileArn
    }
}

struct UpdateConnectorProfileOutputResponseBody: Equatable {
    public let connectorProfileArn: String?
}

extension UpdateConnectorProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorProfileArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
    }
}

public struct UpdateFlowInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowInput>
    public typealias MOutput = OperationOutput<UpdateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowOutputError>
}

extension UpdateFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowInput(description: \(String(describing: description)), destinationFlowConfigList: \(String(describing: destinationFlowConfigList)), flowName: \(String(describing: flowName)), sourceFlowConfig: \(String(describing: sourceFlowConfig)), tasks: \(String(describing: tasks)), triggerConfig: \(String(describing: triggerConfig)))"}
}

extension UpdateFlowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case sourceFlowConfig
        case tasks
        case triggerConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationFlowConfigList = destinationFlowConfigList {
            var destinationFlowConfigListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationFlowConfigList)
            for destinationflowconfiglist0 in destinationFlowConfigList {
                try destinationFlowConfigListContainer.encode(destinationflowconfiglist0)
            }
        }
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let sourceFlowConfig = sourceFlowConfig {
            try encodeContainer.encode(sourceFlowConfig, forKey: .sourceFlowConfig)
        }
        if let tasks = tasks {
            var tasksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tasks)
            for tasks0 in tasks {
                try tasksContainer.encode(tasks0)
            }
        }
        if let triggerConfig = triggerConfig {
            try encodeContainer.encode(triggerConfig, forKey: .triggerConfig)
        }
    }
}

public struct UpdateFlowInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowInput>
    public typealias MOutput = OperationOutput<UpdateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowOutputError>
}

public struct UpdateFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowInput>
    public typealias MOutput = OperationOutput<UpdateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowOutputError>
}

public struct UpdateFlowInput: Equatable {
    /// <p>
    ///   A description of the flow.
    /// </p>
    public let description: String?
    /// <p>
    ///   The configuration that controls how Amazon AppFlow transfers data to the destination connector.
    /// </p>
    public let destinationFlowConfigList: [DestinationFlowConfig]?
    /// <p>
    ///   The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// </p>
    public let flowName: String?
    /// <p>
    ///  Contains information about the configuration of the source connector used in the flow.
    /// </p>
    public let sourceFlowConfig: SourceFlowConfig?
    /// <p>
    ///   A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// </p>
    public let tasks: [Task]?
    /// <p>
    ///   The trigger settings that determine how and when the flow runs.
    /// </p>
    public let triggerConfig: TriggerConfig?

    public init (
        description: String? = nil,
        destinationFlowConfigList: [DestinationFlowConfig]? = nil,
        flowName: String? = nil,
        sourceFlowConfig: SourceFlowConfig? = nil,
        tasks: [Task]? = nil,
        triggerConfig: TriggerConfig? = nil
    )
    {
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowName = flowName
        self.sourceFlowConfig = sourceFlowConfig
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct UpdateFlowInputBody: Equatable {
    public let flowName: String?
    public let description: String?
    public let triggerConfig: TriggerConfig?
    public let sourceFlowConfig: SourceFlowConfig?
    public let destinationFlowConfigList: [DestinationFlowConfig]?
    public let tasks: [Task]?
}

extension UpdateFlowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case sourceFlowConfig
        case tasks
        case triggerConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let tasksContainer = try containerValues.decodeIfPresent([Task?].self, forKey: .tasks)
        var tasksDecoded0:[Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
    }
}

extension UpdateFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowOutputResponse(flowStatus: \(String(describing: flowStatus)))"}
}

extension UpdateFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowStatus = output.flowStatus
        } else {
            self.flowStatus = nil
        }
    }
}

public struct UpdateFlowOutputResponse: Equatable {
    /// <p>Indicates the current status of the flow.
    /// </p>
    public let flowStatus: FlowStatus?

    public init (
        flowStatus: FlowStatus? = nil
    )
    {
        self.flowStatus = flowStatus
    }
}

struct UpdateFlowOutputResponseBody: Equatable {
    public let flowStatus: FlowStatus?
}

extension UpdateFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowStatusDecoded = try containerValues.decodeIfPresent(FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

extension UpsolverDestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case bucketPrefix
        case s3OutputFormatConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let s3OutputFormatConfig = s3OutputFormatConfig {
            try encodeContainer.encode(s3OutputFormatConfig, forKey: .s3OutputFormatConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let s3OutputFormatConfigDecoded = try containerValues.decodeIfPresent(UpsolverS3OutputFormatConfig.self, forKey: .s3OutputFormatConfig)
        s3OutputFormatConfig = s3OutputFormatConfigDecoded
    }
}

extension UpsolverDestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpsolverDestinationProperties(bucketName: \(String(describing: bucketName)), bucketPrefix: \(String(describing: bucketPrefix)), s3OutputFormatConfig: \(String(describing: s3OutputFormatConfig)))"}
}

/// <p>
///       The properties that are applied when Upsolver is used as a destination.
///     </p>
public struct UpsolverDestinationProperties: Equatable {
    /// <p>
    ///       The Upsolver Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
    ///     </p>
    public let bucketName: String?
    /// <p>
    ///       The object key for the destination Upsolver Amazon S3 bucket in which Amazon AppFlow places the files.
    ///     </p>
    public let bucketPrefix: String?
    /// <p>
    ///       The configuration that determines how data is formatted when Upsolver is used as the flow destination.
    ///     </p>
    public let s3OutputFormatConfig: UpsolverS3OutputFormatConfig?

    public init (
        bucketName: String? = nil,
        bucketPrefix: String? = nil,
        s3OutputFormatConfig: UpsolverS3OutputFormatConfig? = nil
    )
    {
        self.bucketName = bucketName
        self.bucketPrefix = bucketPrefix
        self.s3OutputFormatConfig = s3OutputFormatConfig
    }
}

extension UpsolverMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension UpsolverMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpsolverMetadata()"}
}

/// <p>
///       The connector metadata specific to Upsolver.
///     </p>
public struct UpsolverMetadata: Equatable {

    public init() {}
}

extension UpsolverS3OutputFormatConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregationConfig
        case fileType
        case prefixConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationConfig = aggregationConfig {
            try encodeContainer.encode(aggregationConfig, forKey: .aggregationConfig)
        }
        if let fileType = fileType {
            try encodeContainer.encode(fileType.rawValue, forKey: .fileType)
        }
        if let prefixConfig = prefixConfig {
            try encodeContainer.encode(prefixConfig, forKey: .prefixConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileTypeDecoded = try containerValues.decodeIfPresent(FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let prefixConfigDecoded = try containerValues.decodeIfPresent(PrefixConfig.self, forKey: .prefixConfig)
        prefixConfig = prefixConfigDecoded
        let aggregationConfigDecoded = try containerValues.decodeIfPresent(AggregationConfig.self, forKey: .aggregationConfig)
        aggregationConfig = aggregationConfigDecoded
    }
}

extension UpsolverS3OutputFormatConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpsolverS3OutputFormatConfig(aggregationConfig: \(String(describing: aggregationConfig)), fileType: \(String(describing: fileType)), prefixConfig: \(String(describing: prefixConfig)))"}
}

/// <p>
///       The configuration that determines how Amazon AppFlow formats the flow output data when Upsolver is used as the destination.
///     </p>
public struct UpsolverS3OutputFormatConfig: Equatable {
    /// <p>
    /// The aggregation settings that you can use to customize the output format of your flow data.
    /// </p>
    public let aggregationConfig: AggregationConfig?
    /// <p>
    ///       Indicates the file type that Amazon AppFlow places in the Upsolver Amazon S3 bucket.
    ///     </p>
    public let fileType: FileType?
    /// <p>
    /// Determines the prefix that Amazon AppFlow applies to the destination folder name. You can name your destination folders according to the flow frequency and date.
    ///     </p>
    public let prefixConfig: PrefixConfig?

    public init (
        aggregationConfig: AggregationConfig? = nil,
        fileType: FileType? = nil,
        prefixConfig: PrefixConfig? = nil
    )
    {
        self.aggregationConfig = aggregationConfig
        self.fileType = fileType
        self.prefixConfig = prefixConfig
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
/// The request has invalid or missing parameters.
/// </p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum VeevaConnectorOperator {
    case addition
    case between
    case contains
    case division
    case equalTo
    case greaterThan
    case greaterThanOrEqualTo
    case lessThan
    case lessThanOrEqualTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case notEqualTo
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension VeevaConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VeevaConnectorOperator] {
        return [
            .addition,
            .between,
            .contains,
            .division,
            .equalTo,
            .greaterThan,
            .greaterThanOrEqualTo,
            .lessThan,
            .lessThanOrEqualTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .notEqualTo,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .contains: return "CONTAINS"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
        case .lessThan: return "LESS_THAN"
        case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .notEqualTo: return "NOT_EQUAL_TO"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VeevaConnectorOperator(rawValue: rawValue) ?? VeevaConnectorOperator.sdkUnknown(rawValue)
    }
}

extension VeevaConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension VeevaConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VeevaConnectorProfileCredentials(password: \(String(describing: password)), username: \(String(describing: username)))"}
}

/// <p>
///   The connector-specific profile credentials required when using Veeva.
/// </p>
public struct VeevaConnectorProfileCredentials: Equatable {
    /// <p>
    ///   The password that corresponds to the user name.
    /// </p>
    public let password: String?
    /// <p>
    ///   The name of the user.
    /// </p>
    public let username: String?

    public init (
        password: String? = nil,
        username: String? = nil
    )
    {
        self.password = password
        self.username = username
    }
}

extension VeevaConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension VeevaConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VeevaConnectorProfileProperties(instanceUrl: \(String(describing: instanceUrl)))"}
}

/// <p>
///   The connector-specific profile properties required when using Veeva.
/// </p>
public struct VeevaConnectorProfileProperties: Equatable {
    /// <p>
    ///   The location of the Veeva resource.
    /// </p>
    public let instanceUrl: String?

    public init (
        instanceUrl: String? = nil
    )
    {
        self.instanceUrl = instanceUrl
    }
}

extension VeevaMetadata: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension VeevaMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VeevaMetadata()"}
}

/// <p>
///   The connector metadata specific to Veeva.
/// </p>
public struct VeevaMetadata: Equatable {

    public init() {}
}

extension VeevaSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension VeevaSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VeevaSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when using Veeva as a flow source.
/// </p>
public struct VeevaSourceProperties: Equatable {
    /// <p>
    ///   The object specified in the Veeva flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

/// <p>
///       The possible write operations in the destination connector. When this value is not provided, this defaults to the <code>INSERT</code> operation.
///     </p>
public enum WriteOperationType {
    case insert
    case update
    case upsert
    case sdkUnknown(String)
}

extension WriteOperationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WriteOperationType] {
        return [
            .insert,
            .update,
            .upsert,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .insert: return "INSERT"
        case .update: return "UPDATE"
        case .upsert: return "UPSERT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WriteOperationType(rawValue: rawValue) ?? WriteOperationType.sdkUnknown(rawValue)
    }
}

public enum ZendeskConnectorOperator {
    case addition
    case division
    case greaterThan
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension ZendeskConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ZendeskConnectorOperator] {
        return [
            .addition,
            .division,
            .greaterThan,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .division: return "DIVISION"
        case .greaterThan: return "GREATER_THAN"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ZendeskConnectorOperator(rawValue: rawValue) ?? ZendeskConnectorOperator.sdkUnknown(rawValue)
    }
}

extension ZendeskConnectorProfileCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension ZendeskConnectorProfileCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZendeskConnectorProfileCredentials(accessToken: \(String(describing: accessToken)), clientId: \(String(describing: clientId)), clientSecret: \(String(describing: clientSecret)), oAuthRequest: \(String(describing: oAuthRequest)))"}
}

/// <p>
///   The connector-specific profile credentials required when using Zendesk.
/// </p>
public struct ZendeskConnectorProfileCredentials: Equatable {
    /// <p>
    ///   The credentials used to access protected Zendesk resources.
    /// </p>
    public let accessToken: String?
    /// <p>
    ///   The identifier for the desired client.
    /// </p>
    public let clientId: String?
    /// <p>
    ///  The client secret used by the OAuth client to authenticate to the authorization server.
    /// </p>
    public let clientSecret: String?
    /// <p>
    ///  The OAuth requirement needed to request security tokens from the connector endpoint.
    /// </p>
    public let oAuthRequest: ConnectorOAuthRequest?

    public init (
        accessToken: String? = nil,
        clientId: String? = nil,
        clientSecret: String? = nil,
        oAuthRequest: ConnectorOAuthRequest? = nil
    )
    {
        self.accessToken = accessToken
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.oAuthRequest = oAuthRequest
    }
}

extension ZendeskConnectorProfileProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension ZendeskConnectorProfileProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZendeskConnectorProfileProperties(instanceUrl: \(String(describing: instanceUrl)))"}
}

/// <p>
///   The connector-specific profile properties required when using Zendesk.
/// </p>
public struct ZendeskConnectorProfileProperties: Equatable {
    /// <p>
    ///   The location of the Zendesk resource.
    /// </p>
    public let instanceUrl: String?

    public init (
        instanceUrl: String? = nil
    )
    {
        self.instanceUrl = instanceUrl
    }
}

extension ZendeskDestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorHandlingConfig
        case idFieldNames
        case object
        case writeOperationType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let idFieldNames = idFieldNames {
            var idFieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idFieldNames)
            for idfieldnamelist0 in idFieldNames {
                try idFieldNamesContainer.encode(idfieldnamelist0)
            }
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let writeOperationType = writeOperationType {
            try encodeContainer.encode(writeOperationType.rawValue, forKey: .writeOperationType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
        let idFieldNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .idFieldNames)
        var idFieldNamesDecoded0:[String]? = nil
        if let idFieldNamesContainer = idFieldNamesContainer {
            idFieldNamesDecoded0 = [String]()
            for string0 in idFieldNamesContainer {
                if let string0 = string0 {
                    idFieldNamesDecoded0?.append(string0)
                }
            }
        }
        idFieldNames = idFieldNamesDecoded0
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
        let writeOperationTypeDecoded = try containerValues.decodeIfPresent(WriteOperationType.self, forKey: .writeOperationType)
        writeOperationType = writeOperationTypeDecoded
    }
}

extension ZendeskDestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZendeskDestinationProperties(errorHandlingConfig: \(String(describing: errorHandlingConfig)), idFieldNames: \(String(describing: idFieldNames)), object: \(String(describing: object)), writeOperationType: \(String(describing: writeOperationType)))"}
}

public struct ZendeskDestinationProperties: Equatable {
    /// <p>
    ///   The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. <code>ErrorHandlingConfig</code> is a part of the destination connector details.
    ///
    /// </p>
    public let errorHandlingConfig: ErrorHandlingConfig?
    /// <p>
    ///       A list of field names that can be used as an ID field when performing a write operation.
    ///     </p>
    public let idFieldNames: [String]?
    public let object: String?
    /// <p>
    ///       The possible write operations in the destination connector. When this value is not provided, this defaults to the <code>INSERT</code> operation.
    ///     </p>
    public let writeOperationType: WriteOperationType?

    public init (
        errorHandlingConfig: ErrorHandlingConfig? = nil,
        idFieldNames: [String]? = nil,
        object: String? = nil,
        writeOperationType: WriteOperationType? = nil
    )
    {
        self.errorHandlingConfig = errorHandlingConfig
        self.idFieldNames = idFieldNames
        self.object = object
        self.writeOperationType = writeOperationType
    }
}

extension ZendeskMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension ZendeskMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZendeskMetadata(oAuthScopes: \(String(describing: oAuthScopes)))"}
}

/// <p>
///   The connector metadata specific to Zendesk.
/// </p>
public struct ZendeskMetadata: Equatable {
    /// <p>
    ///       The desired authorization scope for the Zendesk account.
    ///     </p>
    public let oAuthScopes: [String]?

    public init (
        oAuthScopes: [String]? = nil
    )
    {
        self.oAuthScopes = oAuthScopes
    }
}

extension ZendeskSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension ZendeskSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZendeskSourceProperties(object: \(String(describing: object)))"}
}

/// <p>
///   The properties that are applied when using Zendesk as a flow source.
/// </p>
public struct ZendeskSourceProperties: Equatable {
    /// <p>
    ///   The object specified in the Zendesk flow source.
    /// </p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}
