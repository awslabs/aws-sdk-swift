// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ConnectorConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case canUseAsDestination
        case canUseAsSource
        case connectorMetadata
        case isPrivateLinkEnabled
        case isPrivateLinkEndpointUrlRequired
        case supportedDestinationConnectors
        case supportedSchedulingFrequencies
        case supportedTriggerTypes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if canUseAsDestination != false {
            try encodeContainer.encode(canUseAsDestination, forKey: .canUseAsDestination)
        }
        if canUseAsSource != false {
            try encodeContainer.encode(canUseAsSource, forKey: .canUseAsSource)
        }
        if let connectorMetadata = connectorMetadata {
            try encodeContainer.encode(connectorMetadata, forKey: .connectorMetadata)
        }
        if isPrivateLinkEnabled != false {
            try encodeContainer.encode(isPrivateLinkEnabled, forKey: .isPrivateLinkEnabled)
        }
        if isPrivateLinkEndpointUrlRequired != false {
            try encodeContainer.encode(isPrivateLinkEndpointUrlRequired, forKey: .isPrivateLinkEndpointUrlRequired)
        }
        if let supportedDestinationConnectors = supportedDestinationConnectors {
            var supportedDestinationConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDestinationConnectors)
            for connectortypelist0 in supportedDestinationConnectors {
                try supportedDestinationConnectorsContainer.encode(connectortypelist0.rawValue)
            }
        }
        if let supportedSchedulingFrequencies = supportedSchedulingFrequencies {
            var supportedSchedulingFrequenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedSchedulingFrequencies)
            for schedulingfrequencytypelist0 in supportedSchedulingFrequencies {
                try supportedSchedulingFrequenciesContainer.encode(schedulingfrequencytypelist0.rawValue)
            }
        }
        if let supportedTriggerTypes = supportedTriggerTypes {
            var supportedTriggerTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedTriggerTypes)
            for triggertypelist0 in supportedTriggerTypes {
                try supportedTriggerTypesContainer.encode(triggertypelist0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canUseAsSourceDecoded = try containerValues.decode(Bool.self, forKey: .canUseAsSource)
        canUseAsSource = canUseAsSourceDecoded
        let canUseAsDestinationDecoded = try containerValues.decode(Bool.self, forKey: .canUseAsDestination)
        canUseAsDestination = canUseAsDestinationDecoded
        let supportedDestinationConnectorsContainer = try containerValues.decodeIfPresent([ConnectorType].self, forKey: .supportedDestinationConnectors)
        var supportedDestinationConnectorsDecoded0:[ConnectorType]? = nil
        if let supportedDestinationConnectorsContainer = supportedDestinationConnectorsContainer {
            supportedDestinationConnectorsDecoded0 = [ConnectorType]()
            for string0 in supportedDestinationConnectorsContainer {
                supportedDestinationConnectorsDecoded0?.append(string0)
            }
        }
        supportedDestinationConnectors = supportedDestinationConnectorsDecoded0
        let supportedSchedulingFrequenciesContainer = try containerValues.decodeIfPresent([ScheduleFrequencyType].self, forKey: .supportedSchedulingFrequencies)
        var supportedSchedulingFrequenciesDecoded0:[ScheduleFrequencyType]? = nil
        if let supportedSchedulingFrequenciesContainer = supportedSchedulingFrequenciesContainer {
            supportedSchedulingFrequenciesDecoded0 = [ScheduleFrequencyType]()
            for string0 in supportedSchedulingFrequenciesContainer {
                supportedSchedulingFrequenciesDecoded0?.append(string0)
            }
        }
        supportedSchedulingFrequencies = supportedSchedulingFrequenciesDecoded0
        let isPrivateLinkEnabledDecoded = try containerValues.decode(Bool.self, forKey: .isPrivateLinkEnabled)
        isPrivateLinkEnabled = isPrivateLinkEnabledDecoded
        let isPrivateLinkEndpointUrlRequiredDecoded = try containerValues.decode(Bool.self, forKey: .isPrivateLinkEndpointUrlRequired)
        isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequiredDecoded
        let supportedTriggerTypesContainer = try containerValues.decodeIfPresent([TriggerType].self, forKey: .supportedTriggerTypes)
        var supportedTriggerTypesDecoded0:[TriggerType]? = nil
        if let supportedTriggerTypesContainer = supportedTriggerTypesContainer {
            supportedTriggerTypesDecoded0 = [TriggerType]()
            for string0 in supportedTriggerTypesContainer {
                supportedTriggerTypesDecoded0?.append(string0)
            }
        }
        supportedTriggerTypes = supportedTriggerTypesDecoded0
        let connectorMetadataDecoded = try containerValues.decodeIfPresent(ConnectorMetadata.self, forKey: .connectorMetadata)
        connectorMetadata = connectorMetadataDecoded
    }
}
