// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension FlowDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case createdBy
        case description
        case destinationConnectorType
        case flowArn
        case flowName
        case flowStatus
        case lastRunExecutionDetails
        case lastUpdatedAt
        case lastUpdatedBy
        case sourceConnectorType
        case tags
        case triggerType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConnectorType = destinationConnectorType {
            try encodeContainer.encode(destinationConnectorType.rawValue, forKey: .destinationConnectorType)
        }
        if let flowArn = flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let flowStatus = flowStatus {
            try encodeContainer.encode(flowStatus.rawValue, forKey: .flowStatus)
        }
        if let lastRunExecutionDetails = lastRunExecutionDetails {
            try encodeContainer.encode(lastRunExecutionDetails, forKey: .lastRunExecutionDetails)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let lastUpdatedBy = lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let sourceConnectorType = sourceConnectorType {
            try encodeContainer.encode(sourceConnectorType.rawValue, forKey: .sourceConnectorType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let sourceConnectorTypeDecoded = try containerValues.decodeIfPresent(ConnectorType.self, forKey: .sourceConnectorType)
        sourceConnectorType = sourceConnectorTypeDecoded
        let destinationConnectorTypeDecoded = try containerValues.decodeIfPresent(ConnectorType.self, forKey: .destinationConnectorType)
        destinationConnectorType = destinationConnectorTypeDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastRunExecutionDetailsDecoded = try containerValues.decodeIfPresent(ExecutionDetails.self, forKey: .lastRunExecutionDetails)
        lastRunExecutionDetails = lastRunExecutionDetailsDecoded
    }
}
