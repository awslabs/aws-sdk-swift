// Code generated by smithy-swift-codegen. DO NOT EDIT!



/// <p>Defines a condition under which a trigger fires.</p>
public struct Condition: Equatable {
    /// <p>The state of the crawler to which this condition applies.</p>
    public let crawlState: CrawlState?
    /// <p>The name of the crawler to which this condition applies.</p>
    public let crawlerName: String?
    /// <p>The name of the job whose <code>JobRuns</code> this condition applies to, and on which
    ///       this trigger waits.</p>
    public let jobName: String?
    /// <p>A logical operator.</p>
    public let logicalOperator: LogicalOperator?
    /// <p>The condition state. Currently, the only job states that a trigger can listen for are <code>SUCCEEDED</code>, <code>STOPPED</code>, <code>FAILED</code>, and <code>TIMEOUT</code>. The only crawler states that a trigger can listen for are <code>SUCCEEDED</code>, <code>FAILED</code>, and <code>CANCELLED</code>.</p>
    public let state: JobRunState?

    public init (
        crawlState: CrawlState? = nil,
        crawlerName: String? = nil,
        jobName: String? = nil,
        logicalOperator: LogicalOperator? = nil,
        state: JobRunState? = nil
    )
    {
        self.crawlState = crawlState
        self.crawlerName = crawlerName
        self.jobName = jobName
        self.logicalOperator = logicalOperator
        self.state = state
    }
}

extension Condition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Condition(crawlState: \(String(describing: crawlState)), crawlerName: \(String(describing: crawlerName)), jobName: \(String(describing: jobName)), logicalOperator: \(String(describing: logicalOperator)), state: \(String(describing: state)))"}
}
