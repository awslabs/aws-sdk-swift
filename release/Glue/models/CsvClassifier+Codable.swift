// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CsvClassifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowSingleColumn = "AllowSingleColumn"
        case containsHeader = "ContainsHeader"
        case creationTime = "CreationTime"
        case delimiter = "Delimiter"
        case disableValueTrimming = "DisableValueTrimming"
        case header = "Header"
        case lastUpdated = "LastUpdated"
        case name = "Name"
        case quoteSymbol = "QuoteSymbol"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSingleColumn = allowSingleColumn {
            try encodeContainer.encode(allowSingleColumn, forKey: .allowSingleColumn)
        }
        if let containsHeader = containsHeader {
            try encodeContainer.encode(containsHeader.rawValue, forKey: .containsHeader)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let delimiter = delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let disableValueTrimming = disableValueTrimming {
            try encodeContainer.encode(disableValueTrimming, forKey: .disableValueTrimming)
        }
        if let header = header {
            var headerContainer = encodeContainer.nestedUnkeyedContainer(forKey: .header)
            for csvheader0 in header {
                try headerContainer.encode(csvheader0)
            }
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quoteSymbol = quoteSymbol {
            try encodeContainer.encode(quoteSymbol, forKey: .quoteSymbol)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let quoteSymbolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteSymbol)
        quoteSymbol = quoteSymbolDecoded
        let containsHeaderDecoded = try containerValues.decodeIfPresent(CsvHeaderOption.self, forKey: .containsHeader)
        containsHeader = containsHeaderDecoded
        let headerContainer = try containerValues.decodeIfPresent([String?].self, forKey: .header)
        var headerDecoded0:[String]? = nil
        if let headerContainer = headerContainer {
            headerDecoded0 = [String]()
            for string0 in headerContainer {
                if let string0 = string0 {
                    headerDecoded0?.append(string0)
                }
            }
        }
        header = headerDecoded0
        let disableValueTrimmingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableValueTrimming)
        disableValueTrimming = disableValueTrimmingDecoded
        let allowSingleColumnDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSingleColumn)
        allowSingleColumn = allowSingleColumnDecoded
    }
}
