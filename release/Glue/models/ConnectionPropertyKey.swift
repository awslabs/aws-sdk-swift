// Code generated by smithy-swift-codegen. DO NOT EDIT!



public enum ConnectionPropertyKey {
    case configFiles
    case connectionUrl
    case connectorClassName
    case connectorType
    case connectorUrl
    case customJdbcCert
    case customJdbcCertString
    case encryptedKafkaClientKeystorePassword
    case encryptedKafkaClientKeyPassword
    case encryptedPassword
    case host
    case instanceId
    case jdbcConnectionUrl
    case jdbcDriverClassName
    case jdbcDriverJarUri
    case jdbcEnforceSsl
    case jdbcEngine
    case jdbcEngineVersion
    case kafkaBootstrapServers
    case kafkaClientKeystore
    case kafkaClientKeystorePassword
    case kafkaClientKeyPassword
    case kafkaCustomCert
    case kafkaSkipCustomCertValidation
    case kafkaSslEnabled
    case password
    case port
    case secretId
    case skipCustomJdbcCertValidation
    case userName
    case sdkUnknown(String)
}

extension ConnectionPropertyKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionPropertyKey] {
        return [
            .configFiles,
            .connectionUrl,
            .connectorClassName,
            .connectorType,
            .connectorUrl,
            .customJdbcCert,
            .customJdbcCertString,
            .encryptedKafkaClientKeystorePassword,
            .encryptedKafkaClientKeyPassword,
            .encryptedPassword,
            .host,
            .instanceId,
            .jdbcConnectionUrl,
            .jdbcDriverClassName,
            .jdbcDriverJarUri,
            .jdbcEnforceSsl,
            .jdbcEngine,
            .jdbcEngineVersion,
            .kafkaBootstrapServers,
            .kafkaClientKeystore,
            .kafkaClientKeystorePassword,
            .kafkaClientKeyPassword,
            .kafkaCustomCert,
            .kafkaSkipCustomCertValidation,
            .kafkaSslEnabled,
            .password,
            .port,
            .secretId,
            .skipCustomJdbcCertValidation,
            .userName,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configFiles: return "CONFIG_FILES"
        case .connectionUrl: return "CONNECTION_URL"
        case .connectorClassName: return "CONNECTOR_CLASS_NAME"
        case .connectorType: return "CONNECTOR_TYPE"
        case .connectorUrl: return "CONNECTOR_URL"
        case .customJdbcCert: return "CUSTOM_JDBC_CERT"
        case .customJdbcCertString: return "CUSTOM_JDBC_CERT_STRING"
        case .encryptedKafkaClientKeystorePassword: return "ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"
        case .encryptedKafkaClientKeyPassword: return "ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"
        case .encryptedPassword: return "ENCRYPTED_PASSWORD"
        case .host: return "HOST"
        case .instanceId: return "INSTANCE_ID"
        case .jdbcConnectionUrl: return "JDBC_CONNECTION_URL"
        case .jdbcDriverClassName: return "JDBC_DRIVER_CLASS_NAME"
        case .jdbcDriverJarUri: return "JDBC_DRIVER_JAR_URI"
        case .jdbcEnforceSsl: return "JDBC_ENFORCE_SSL"
        case .jdbcEngine: return "JDBC_ENGINE"
        case .jdbcEngineVersion: return "JDBC_ENGINE_VERSION"
        case .kafkaBootstrapServers: return "KAFKA_BOOTSTRAP_SERVERS"
        case .kafkaClientKeystore: return "KAFKA_CLIENT_KEYSTORE"
        case .kafkaClientKeystorePassword: return "KAFKA_CLIENT_KEYSTORE_PASSWORD"
        case .kafkaClientKeyPassword: return "KAFKA_CLIENT_KEY_PASSWORD"
        case .kafkaCustomCert: return "KAFKA_CUSTOM_CERT"
        case .kafkaSkipCustomCertValidation: return "KAFKA_SKIP_CUSTOM_CERT_VALIDATION"
        case .kafkaSslEnabled: return "KAFKA_SSL_ENABLED"
        case .password: return "PASSWORD"
        case .port: return "PORT"
        case .secretId: return "SECRET_ID"
        case .skipCustomJdbcCertValidation: return "SKIP_CUSTOM_JDBC_CERT_VALIDATION"
        case .userName: return "USERNAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionPropertyKey(rawValue: rawValue) ?? ConnectionPropertyKey.sdkUnknown(rawValue)
    }
}
