// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

/// <p>A structure used to define a table.</p>
public struct TableInput: Equatable {
    /// <p>A description of the table.</p>
    public let description: String?
    /// <p>The last time that the table was accessed.</p>
    public let lastAccessTime: Date?
    /// <p>The last time that column statistics were computed for this table.</p>
    public let lastAnalyzedTime: Date?
    /// <p>The table name. For Hive compatibility, this is folded to
    ///       lowercase when it is stored.</p>
    public let name: String?
    /// <p>The table owner.</p>
    public let owner: String?
    /// <p>These key-value pairs define properties associated with the table.</p>
    public let parameters: [String:String]?
    /// <p>A list of columns by which the table is partitioned. Only primitive
    ///       types are supported as partition keys.</p>
    /// 	        <p>When you create a table used by Amazon Athena, and you do not specify any
    ///         <code>partitionKeys</code>, you must at least set the value of <code>partitionKeys</code> to
    ///       an empty list. For example:</p>
    ///          <p>
    ///             <code>"PartitionKeys": []</code>
    ///          </p>
    public let partitionKeys: [Column]?
    /// <p>The retention time for this table.</p>
    public let retention: Int
    /// <p>A storage descriptor containing information about the physical storage
    ///       of this table.</p>
    public let storageDescriptor: StorageDescriptor?
    /// <p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>
    public let tableType: String?
    /// <p>A <code>TableIdentifier</code> structure that describes a target table for resource linking.</p>
    public let targetTable: TableIdentifier?
    /// <p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>
    public let viewExpandedText: String?
    /// <p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>
    public let viewOriginalText: String?

    public init (
        description: String? = nil,
        lastAccessTime: Date? = nil,
        lastAnalyzedTime: Date? = nil,
        name: String? = nil,
        owner: String? = nil,
        parameters: [String:String]? = nil,
        partitionKeys: [Column]? = nil,
        retention: Int = 0,
        storageDescriptor: StorageDescriptor? = nil,
        tableType: String? = nil,
        targetTable: TableIdentifier? = nil,
        viewExpandedText: String? = nil,
        viewOriginalText: String? = nil
    )
    {
        self.description = description
        self.lastAccessTime = lastAccessTime
        self.lastAnalyzedTime = lastAnalyzedTime
        self.name = name
        self.owner = owner
        self.parameters = parameters
        self.partitionKeys = partitionKeys
        self.retention = retention
        self.storageDescriptor = storageDescriptor
        self.tableType = tableType
        self.targetTable = targetTable
        self.viewExpandedText = viewExpandedText
        self.viewOriginalText = viewOriginalText
    }
}

extension TableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableInput(description: \(String(describing: description)), lastAccessTime: \(String(describing: lastAccessTime)), lastAnalyzedTime: \(String(describing: lastAnalyzedTime)), name: \(String(describing: name)), owner: \(String(describing: owner)), parameters: \(String(describing: parameters)), partitionKeys: \(String(describing: partitionKeys)), retention: \(String(describing: retention)), storageDescriptor: \(String(describing: storageDescriptor)), tableType: \(String(describing: tableType)), targetTable: \(String(describing: targetTable)), viewExpandedText: \(String(describing: viewExpandedText)), viewOriginalText: \(String(describing: viewOriginalText)))"}
}
