// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access to a resource was denied.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arguments = "Arguments"
        case crawlerName = "CrawlerName"
        case jobName = "JobName"
        case notificationProperty = "NotificationProperty"
        case securityConfiguration = "SecurityConfiguration"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .arguments)
            for (dictKey0, genericmap0) in arguments {
                try argumentsContainer.encode(genericmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let crawlerName = crawlerName {
            try encodeContainer.encode(crawlerName, forKey: .crawlerName)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let notificationProperty = notificationProperty {
            try encodeContainer.encode(notificationProperty, forKey: .notificationProperty)
        }
        if let securityConfiguration = securityConfiguration {
            try encodeContainer.encode(securityConfiguration, forKey: .securityConfiguration)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let argumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .arguments)
        var argumentsDecoded0: [String:String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in argumentsContainer {
                if let genericstring0 = genericstring0 {
                    argumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        arguments = argumentsDecoded0
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let securityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityConfiguration)
        securityConfiguration = securityConfigurationDecoded
        let notificationPropertyDecoded = try containerValues.decodeIfPresent(NotificationProperty.self, forKey: .notificationProperty)
        notificationProperty = notificationPropertyDecoded
        let crawlerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .crawlerName)
        crawlerName = crawlerNameDecoded
    }
}

extension Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Action(arguments: \(String(describing: arguments)), crawlerName: \(String(describing: crawlerName)), jobName: \(String(describing: jobName)), notificationProperty: \(String(describing: notificationProperty)), securityConfiguration: \(String(describing: securityConfiguration)), timeout: \(String(describing: timeout)))"}
}

/// <p>Defines an action to be initiated by a trigger.</p>
public struct Action: Equatable {
    /// <p>The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself.</p>
    ///          <p>You can specify arguments here that your own job-execution script
    ///       consumes, as well as arguments that AWS Glue itself consumes.</p>
    ///          <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling AWS Glue APIs in Python</a> topic in the developer guide.</p>
    ///          <p>For information about the key-value pairs that AWS Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by AWS Glue</a> topic in the developer guide.</p>
    public let arguments: [String:String]?
    /// <p>The name of the crawler to be used with this action.</p>
    public let crawlerName: String?
    /// <p>The name of a job to be executed.</p>
    public let jobName: String?
    /// <p>Specifies configuration properties of a job run notification.</p>
    public let notificationProperty: NotificationProperty?
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this
    ///       action.</p>
    public let securityConfiguration: String?
    /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can
    ///       consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default
    ///       is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.</p>
    public let timeout: Int?

    public init (
        arguments: [String:String]? = nil,
        crawlerName: String? = nil,
        jobName: String? = nil,
        notificationProperty: NotificationProperty? = nil,
        securityConfiguration: String? = nil,
        timeout: Int? = nil
    )
    {
        self.arguments = arguments
        self.crawlerName = crawlerName
        self.jobName = jobName
        self.notificationProperty = notificationProperty
        self.securityConfiguration = securityConfiguration
        self.timeout = timeout
    }
}

extension AlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyExistsException(message: \(String(describing: message)))"}
}

extension AlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource to be created or added already exists.</p>
public struct AlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension AlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BackfillError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case partitions = "Partitions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let partitions = partitions {
            var partitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitions)
            for backfillerroredpartitionslist0 in partitions {
                try partitionsContainer.encode(backfillerroredpartitionslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(BackfillErrorCode.self, forKey: .code)
        code = codeDecoded
        let partitionsContainer = try containerValues.decodeIfPresent([PartitionValueList?].self, forKey: .partitions)
        var partitionsDecoded0:[PartitionValueList]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [PartitionValueList]()
            for structure0 in partitionsContainer {
                if let structure0 = structure0 {
                    partitionsDecoded0?.append(structure0)
                }
            }
        }
        partitions = partitionsDecoded0
    }
}

extension BackfillError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackfillError(code: \(String(describing: code)), partitions: \(String(describing: partitions)))"}
}

/// <p>A list of errors that can occur when registering partition indexes for an existing table.</p>
/// 	
/// 	        <p>These errors give the details about why an index registration failed and provide a limited number of partitions in the response, so that you can fix the partitions at fault and try registering the index again. The most common set of errors that can occur are categorized as follows:</p>
/// 	
/// 	        <ul>
///             <li>
///                <p>EncryptedPartitionError: The partitions are encrypted.</p>
///             </li>
///             <li>
///                <p>InvalidPartitionTypeDataError: The partition value doesn't match the data type for that partition column.</p>
///             </li>
///             <li>
///                <p>MissingPartitionValueError: The partitions are encrypted.</p>
///             </li>
///             <li>
///                <p>UnsupportedPartitionCharacterError: Characters inside the partition value are not supported. For example: U+0000 , U+0001, U+0002.</p>
///             </li>
///             <li>
///                <p>InternalError: Any error which does not belong to other error codes.</p>
///             </li>
///          </ul>
public struct BackfillError: Equatable {
    /// <p>The error code for an error that occurred when registering partition indexes for an existing table.</p>
    public let code: BackfillErrorCode?
    /// <p>A list of a limited number of partitions in the response.</p>
    public let partitions: [PartitionValueList]?

    public init (
        code: BackfillErrorCode? = nil,
        partitions: [PartitionValueList]? = nil
    )
    {
        self.code = code
        self.partitions = partitions
    }
}

public enum BackfillErrorCode {
    case encryptedPartitionError
    case internalError
    case invalidPartitionTypeDataError
    case missingPartitionValueError
    case unsupportedPartitionCharacterError
    case sdkUnknown(String)
}

extension BackfillErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BackfillErrorCode] {
        return [
            .encryptedPartitionError,
            .internalError,
            .invalidPartitionTypeDataError,
            .missingPartitionValueError,
            .unsupportedPartitionCharacterError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .encryptedPartitionError: return "ENCRYPTED_PARTITION_ERROR"
        case .internalError: return "INTERNAL_ERROR"
        case .invalidPartitionTypeDataError: return "INVALID_PARTITION_TYPE_DATA_ERROR"
        case .missingPartitionValueError: return "MISSING_PARTITION_VALUE_ERROR"
        case .unsupportedPartitionCharacterError: return "UNSUPPORTED_PARTITION_CHARACTER_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BackfillErrorCode(rawValue: rawValue) ?? BackfillErrorCode.sdkUnknown(rawValue)
    }
}

public struct BatchCreatePartitionInputBodyMiddleware: Middleware {
    public let id: String = "BatchCreatePartitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreatePartitionInput>
    public typealias MOutput = OperationOutput<BatchCreatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreatePartitionOutputError>
}

extension BatchCreatePartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreatePartitionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), partitionInputList: \(String(describing: partitionInputList)), tableName: \(String(describing: tableName)))"}
}

extension BatchCreatePartitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionInputList = "PartitionInputList"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionInputList = partitionInputList {
            var partitionInputListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionInputList)
            for partitioninputlist0 in partitionInputList {
                try partitionInputListContainer.encode(partitioninputlist0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct BatchCreatePartitionInputHeadersMiddleware: Middleware {
    public let id: String = "BatchCreatePartitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreatePartitionInput>
    public typealias MOutput = OperationOutput<BatchCreatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreatePartitionOutputError>
}

public struct BatchCreatePartitionInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchCreatePartitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreatePartitionInput>
    public typealias MOutput = OperationOutput<BatchCreatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreatePartitionOutputError>
}

public struct BatchCreatePartitionInput: Equatable {
    /// <p>The ID of the catalog in which the partition is to be created. Currently, this should be
    ///       the AWS account ID.</p>
    public let catalogId: String?
    /// <p>The name of the metadata database in which the partition is
    ///       to be created.</p>
    public let databaseName: String?
    /// <p>A list of <code>PartitionInput</code> structures that define
    ///       the partitions to be created.</p>
    public let partitionInputList: [PartitionInput]?
    /// <p>The name of the metadata table in which the partition is to be created.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        partitionInputList: [PartitionInput]? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionInputList = partitionInputList
        self.tableName = tableName
    }
}

struct BatchCreatePartitionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let partitionInputList: [PartitionInput]?
}

extension BatchCreatePartitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionInputList = "PartitionInputList"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let partitionInputListContainer = try containerValues.decodeIfPresent([PartitionInput?].self, forKey: .partitionInputList)
        var partitionInputListDecoded0:[PartitionInput]? = nil
        if let partitionInputListContainer = partitionInputListContainer {
            partitionInputListDecoded0 = [PartitionInput]()
            for structure0 in partitionInputListContainer {
                if let structure0 = structure0 {
                    partitionInputListDecoded0?.append(structure0)
                }
            }
        }
        partitionInputList = partitionInputListDecoded0
    }
}

extension BatchCreatePartitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreatePartitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCreatePartitionOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreatePartitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreatePartitionOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchCreatePartitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchCreatePartitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchCreatePartitionOutputResponse: Equatable {
    /// <p>The errors encountered when trying to create the requested partitions.</p>
    public let errors: [PartitionError]?

    public init (
        errors: [PartitionError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchCreatePartitionOutputResponseBody: Equatable {
    public let errors: [PartitionError]?
}

extension BatchCreatePartitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([PartitionError?].self, forKey: .errors)
        var errorsDecoded0:[PartitionError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [PartitionError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchDeleteConnectionInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteConnectionInput>
    public typealias MOutput = OperationOutput<BatchDeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteConnectionOutputError>
}

extension BatchDeleteConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteConnectionInput(catalogId: \(String(describing: catalogId)), connectionNameList: \(String(describing: connectionNameList)))"}
}

extension BatchDeleteConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case connectionNameList = "ConnectionNameList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let connectionNameList = connectionNameList {
            var connectionNameListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectionNameList)
            for deleteconnectionnamelist0 in connectionNameList {
                try connectionNameListContainer.encode(deleteconnectionnamelist0)
            }
        }
    }
}

public struct BatchDeleteConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteConnectionInput>
    public typealias MOutput = OperationOutput<BatchDeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteConnectionOutputError>
}

public struct BatchDeleteConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteConnectionInput>
    public typealias MOutput = OperationOutput<BatchDeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteConnectionOutputError>
}

public struct BatchDeleteConnectionInput: Equatable {
    /// <p>The ID of the Data Catalog in which the connections reside. If none is provided, the AWS
    ///       account ID is used by default.</p>
    public let catalogId: String?
    /// <p>A list of names of the connections to delete.</p>
    public let connectionNameList: [String]?

    public init (
        catalogId: String? = nil,
        connectionNameList: [String]? = nil
    )
    {
        self.catalogId = catalogId
        self.connectionNameList = connectionNameList
    }
}

struct BatchDeleteConnectionInputBody: Equatable {
    public let catalogId: String?
    public let connectionNameList: [String]?
}

extension BatchDeleteConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case connectionNameList = "ConnectionNameList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let connectionNameListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .connectionNameList)
        var connectionNameListDecoded0:[String]? = nil
        if let connectionNameListContainer = connectionNameListContainer {
            connectionNameListDecoded0 = [String]()
            for string0 in connectionNameListContainer {
                if let string0 = string0 {
                    connectionNameListDecoded0?.append(string0)
                }
            }
        }
        connectionNameList = connectionNameListDecoded0
    }
}

extension BatchDeleteConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteConnectionOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteConnectionOutputResponse(errors: \(String(describing: errors)), succeeded: \(String(describing: succeeded)))"}
}

extension BatchDeleteConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
            self.succeeded = output.succeeded
        } else {
            self.errors = nil
            self.succeeded = nil
        }
    }
}

public struct BatchDeleteConnectionOutputResponse: Equatable {
    /// <p>A map of the names of connections that were not successfully
    ///        deleted to error details.</p>
    public let errors: [String:ErrorDetail]?
    /// <p>A list of names of the connection definitions that were
    ///        successfully deleted.</p>
    public let succeeded: [String]?

    public init (
        errors: [String:ErrorDetail]? = nil,
        succeeded: [String]? = nil
    )
    {
        self.errors = errors
        self.succeeded = succeeded
    }
}

struct BatchDeleteConnectionOutputResponseBody: Equatable {
    public let succeeded: [String]?
    public let errors: [String:ErrorDetail]?
}

extension BatchDeleteConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
        case succeeded = "Succeeded"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let succeededContainer = try containerValues.decodeIfPresent([String?].self, forKey: .succeeded)
        var succeededDecoded0:[String]? = nil
        if let succeededContainer = succeededContainer {
            succeededDecoded0 = [String]()
            for string0 in succeededContainer {
                if let string0 = string0 {
                    succeededDecoded0?.append(string0)
                }
            }
        }
        succeeded = succeededDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([String: ErrorDetail?].self, forKey: .errors)
        var errorsDecoded0: [String:ErrorDetail]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [String:ErrorDetail]()
            for (key0, errordetail0) in errorsContainer {
                if let errordetail0 = errordetail0 {
                    errorsDecoded0?[key0] = errordetail0
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchDeletePartitionInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeletePartitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeletePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeletePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeletePartitionInput>
    public typealias MOutput = OperationOutput<BatchDeletePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeletePartitionOutputError>
}

extension BatchDeletePartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeletePartitionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), partitionsToDelete: \(String(describing: partitionsToDelete)), tableName: \(String(describing: tableName)))"}
}

extension BatchDeletePartitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionsToDelete = "PartitionsToDelete"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionsToDelete = partitionsToDelete {
            var partitionsToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionsToDelete)
            for batchdeletepartitionvaluelist0 in partitionsToDelete {
                try partitionsToDeleteContainer.encode(batchdeletepartitionvaluelist0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct BatchDeletePartitionInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeletePartitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeletePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeletePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeletePartitionInput>
    public typealias MOutput = OperationOutput<BatchDeletePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeletePartitionOutputError>
}

public struct BatchDeletePartitionInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeletePartitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeletePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeletePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeletePartitionInput>
    public typealias MOutput = OperationOutput<BatchDeletePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeletePartitionOutputError>
}

public struct BatchDeletePartitionInput: Equatable {
    /// <p>The ID of the Data Catalog where the partition to be deleted resides. If none is provided,
    ///       the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database in which the table in question
    ///       resides.</p>
    public let databaseName: String?
    /// <p>A list of <code>PartitionInput</code> structures that define
    ///       the partitions to be deleted.</p>
    public let partitionsToDelete: [PartitionValueList]?
    /// <p>The name of the table that contains the partitions to be deleted.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        partitionsToDelete: [PartitionValueList]? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionsToDelete = partitionsToDelete
        self.tableName = tableName
    }
}

struct BatchDeletePartitionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let partitionsToDelete: [PartitionValueList]?
}

extension BatchDeletePartitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionsToDelete = "PartitionsToDelete"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let partitionsToDeleteContainer = try containerValues.decodeIfPresent([PartitionValueList?].self, forKey: .partitionsToDelete)
        var partitionsToDeleteDecoded0:[PartitionValueList]? = nil
        if let partitionsToDeleteContainer = partitionsToDeleteContainer {
            partitionsToDeleteDecoded0 = [PartitionValueList]()
            for structure0 in partitionsToDeleteContainer {
                if let structure0 = structure0 {
                    partitionsToDeleteDecoded0?.append(structure0)
                }
            }
        }
        partitionsToDelete = partitionsToDeleteDecoded0
    }
}

extension BatchDeletePartitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeletePartitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeletePartitionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeletePartitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeletePartitionOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchDeletePartitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeletePartitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeletePartitionOutputResponse: Equatable {
    /// <p>The errors encountered when trying to delete the requested partitions.</p>
    public let errors: [PartitionError]?

    public init (
        errors: [PartitionError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeletePartitionOutputResponseBody: Equatable {
    public let errors: [PartitionError]?
}

extension BatchDeletePartitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([PartitionError?].self, forKey: .errors)
        var errorsDecoded0:[PartitionError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [PartitionError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchDeleteTableInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteTableInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteTableInput>
    public typealias MOutput = OperationOutput<BatchDeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteTableOutputError>
}

extension BatchDeleteTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteTableInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), tablesToDelete: \(String(describing: tablesToDelete)))"}
}

extension BatchDeleteTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tablesToDelete = "TablesToDelete"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tablesToDelete = tablesToDelete {
            var tablesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tablesToDelete)
            for batchdeletetablenamelist0 in tablesToDelete {
                try tablesToDeleteContainer.encode(batchdeletetablenamelist0)
            }
        }
    }
}

public struct BatchDeleteTableInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteTableInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteTableInput>
    public typealias MOutput = OperationOutput<BatchDeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteTableOutputError>
}

public struct BatchDeleteTableInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteTableInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteTableInput>
    public typealias MOutput = OperationOutput<BatchDeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteTableOutputError>
}

public struct BatchDeleteTableInput: Equatable {
    /// <p>The ID of the Data Catalog where the table resides. If none is provided, the AWS account
    ///       ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database in which the tables to delete reside. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let databaseName: String?
    /// <p>A list of the table to delete.</p>
    public let tablesToDelete: [String]?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        tablesToDelete: [String]? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tablesToDelete = tablesToDelete
    }
}

struct BatchDeleteTableInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tablesToDelete: [String]?
}

extension BatchDeleteTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tablesToDelete = "TablesToDelete"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tablesToDeleteContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tablesToDelete)
        var tablesToDeleteDecoded0:[String]? = nil
        if let tablesToDeleteContainer = tablesToDeleteContainer {
            tablesToDeleteDecoded0 = [String]()
            for string0 in tablesToDeleteContainer {
                if let string0 = string0 {
                    tablesToDeleteDecoded0?.append(string0)
                }
            }
        }
        tablesToDelete = tablesToDeleteDecoded0
    }
}

extension BatchDeleteTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteTableOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteTableOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchDeleteTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteTableOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteTableOutputResponse: Equatable {
    /// <p>A list of errors encountered in attempting to delete the specified tables.</p>
    public let errors: [TableError]?

    public init (
        errors: [TableError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteTableOutputResponseBody: Equatable {
    public let errors: [TableError]?
}

extension BatchDeleteTableOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([TableError?].self, forKey: .errors)
        var errorsDecoded0:[TableError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [TableError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchDeleteTableVersionInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteTableVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteTableVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteTableVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteTableVersionInput>
    public typealias MOutput = OperationOutput<BatchDeleteTableVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteTableVersionOutputError>
}

extension BatchDeleteTableVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteTableVersionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)), versionIds: \(String(describing: versionIds)))"}
}

extension BatchDeleteTableVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
        case versionIds = "VersionIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let versionIds = versionIds {
            var versionIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versionIds)
            for batchdeletetableversionlist0 in versionIds {
                try versionIdsContainer.encode(batchdeletetableversionlist0)
            }
        }
    }
}

public struct BatchDeleteTableVersionInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteTableVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteTableVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteTableVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteTableVersionInput>
    public typealias MOutput = OperationOutput<BatchDeleteTableVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteTableVersionOutputError>
}

public struct BatchDeleteTableVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteTableVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteTableVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteTableVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteTableVersionInput>
    public typealias MOutput = OperationOutput<BatchDeleteTableVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteTableVersionOutputError>
}

public struct BatchDeleteTableVersionInput: Equatable {
    /// <p>The ID of the Data Catalog where the tables reside. If none is provided, the AWS account
    ///       ID is used by default.</p>
    public let catalogId: String?
    /// <p>The database in the catalog in which the table resides. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let databaseName: String?
    /// <p>The name of the table. For Hive compatibility,
    ///       this name is entirely lowercase.</p>
    public let tableName: String?
    /// <p>A list of the IDs of versions to be deleted. A <code>VersionId</code> is a string representation of an integer. Each version is incremented by 1.</p>
    public let versionIds: [String]?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        tableName: String? = nil,
        versionIds: [String]? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.versionIds = versionIds
    }
}

struct BatchDeleteTableVersionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let versionIds: [String]?
}

extension BatchDeleteTableVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
        case versionIds = "VersionIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let versionIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .versionIds)
        var versionIdsDecoded0:[String]? = nil
        if let versionIdsContainer = versionIdsContainer {
            versionIdsDecoded0 = [String]()
            for string0 in versionIdsContainer {
                if let string0 = string0 {
                    versionIdsDecoded0?.append(string0)
                }
            }
        }
        versionIds = versionIdsDecoded0
    }
}

extension BatchDeleteTableVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteTableVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteTableVersionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteTableVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteTableVersionOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchDeleteTableVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteTableVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteTableVersionOutputResponse: Equatable {
    /// <p>A list of errors encountered while trying to delete
    ///       the specified table versions.</p>
    public let errors: [TableVersionError]?

    public init (
        errors: [TableVersionError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteTableVersionOutputResponseBody: Equatable {
    public let errors: [TableVersionError]?
}

extension BatchDeleteTableVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([TableVersionError?].self, forKey: .errors)
        var errorsDecoded0:[TableVersionError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [TableVersionError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchGetCrawlersInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetCrawlersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetCrawlersInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetCrawlersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetCrawlersInput>
    public typealias MOutput = OperationOutput<BatchGetCrawlersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetCrawlersOutputError>
}

extension BatchGetCrawlersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetCrawlersInput(crawlerNames: \(String(describing: crawlerNames)))"}
}

extension BatchGetCrawlersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlerNames = "CrawlerNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawlerNames = crawlerNames {
            var crawlerNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crawlerNames)
            for crawlernamelist0 in crawlerNames {
                try crawlerNamesContainer.encode(crawlernamelist0)
            }
        }
    }
}

public struct BatchGetCrawlersInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetCrawlersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetCrawlersInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetCrawlersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetCrawlersInput>
    public typealias MOutput = OperationOutput<BatchGetCrawlersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetCrawlersOutputError>
}

public struct BatchGetCrawlersInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetCrawlersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetCrawlersInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetCrawlersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetCrawlersInput>
    public typealias MOutput = OperationOutput<BatchGetCrawlersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetCrawlersOutputError>
}

public struct BatchGetCrawlersInput: Equatable {
    /// <p>A list of crawler names, which might be the names returned from the
    ///         <code>ListCrawlers</code> operation.</p>
    public let crawlerNames: [String]?

    public init (
        crawlerNames: [String]? = nil
    )
    {
        self.crawlerNames = crawlerNames
    }
}

struct BatchGetCrawlersInputBody: Equatable {
    public let crawlerNames: [String]?
}

extension BatchGetCrawlersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case crawlerNames = "CrawlerNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .crawlerNames)
        var crawlerNamesDecoded0:[String]? = nil
        if let crawlerNamesContainer = crawlerNamesContainer {
            crawlerNamesDecoded0 = [String]()
            for string0 in crawlerNamesContainer {
                if let string0 = string0 {
                    crawlerNamesDecoded0?.append(string0)
                }
            }
        }
        crawlerNames = crawlerNamesDecoded0
    }
}

extension BatchGetCrawlersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetCrawlersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetCrawlersOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetCrawlersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetCrawlersOutputResponse(crawlers: \(String(describing: crawlers)), crawlersNotFound: \(String(describing: crawlersNotFound)))"}
}

extension BatchGetCrawlersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetCrawlersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.crawlers = output.crawlers
            self.crawlersNotFound = output.crawlersNotFound
        } else {
            self.crawlers = nil
            self.crawlersNotFound = nil
        }
    }
}

public struct BatchGetCrawlersOutputResponse: Equatable {
    /// <p>A list of crawler definitions.</p>
    public let crawlers: [Crawler]?
    /// <p>A list of names of crawlers that were not found.</p>
    public let crawlersNotFound: [String]?

    public init (
        crawlers: [Crawler]? = nil,
        crawlersNotFound: [String]? = nil
    )
    {
        self.crawlers = crawlers
        self.crawlersNotFound = crawlersNotFound
    }
}

struct BatchGetCrawlersOutputResponseBody: Equatable {
    public let crawlers: [Crawler]?
    public let crawlersNotFound: [String]?
}

extension BatchGetCrawlersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case crawlers = "Crawlers"
        case crawlersNotFound = "CrawlersNotFound"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlersContainer = try containerValues.decodeIfPresent([Crawler?].self, forKey: .crawlers)
        var crawlersDecoded0:[Crawler]? = nil
        if let crawlersContainer = crawlersContainer {
            crawlersDecoded0 = [Crawler]()
            for structure0 in crawlersContainer {
                if let structure0 = structure0 {
                    crawlersDecoded0?.append(structure0)
                }
            }
        }
        crawlers = crawlersDecoded0
        let crawlersNotFoundContainer = try containerValues.decodeIfPresent([String?].self, forKey: .crawlersNotFound)
        var crawlersNotFoundDecoded0:[String]? = nil
        if let crawlersNotFoundContainer = crawlersNotFoundContainer {
            crawlersNotFoundDecoded0 = [String]()
            for string0 in crawlersNotFoundContainer {
                if let string0 = string0 {
                    crawlersNotFoundDecoded0?.append(string0)
                }
            }
        }
        crawlersNotFound = crawlersNotFoundDecoded0
    }
}

public struct BatchGetDevEndpointsInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetDevEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetDevEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetDevEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetDevEndpointsInput>
    public typealias MOutput = OperationOutput<BatchGetDevEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetDevEndpointsOutputError>
}

extension BatchGetDevEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetDevEndpointsInput(devEndpointNames: \(String(describing: devEndpointNames)))"}
}

extension BatchGetDevEndpointsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case devEndpointNames = "DevEndpointNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devEndpointNames = devEndpointNames {
            var devEndpointNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devEndpointNames)
            for devendpointnames0 in devEndpointNames {
                try devEndpointNamesContainer.encode(devendpointnames0)
            }
        }
    }
}

public struct BatchGetDevEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetDevEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetDevEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetDevEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetDevEndpointsInput>
    public typealias MOutput = OperationOutput<BatchGetDevEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetDevEndpointsOutputError>
}

public struct BatchGetDevEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetDevEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetDevEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetDevEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetDevEndpointsInput>
    public typealias MOutput = OperationOutput<BatchGetDevEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetDevEndpointsOutputError>
}

public struct BatchGetDevEndpointsInput: Equatable {
    /// <p>The list of <code>DevEndpoint</code> names, which might be the names returned from the
    ///         <code>ListDevEndpoint</code> operation.</p>
    public let devEndpointNames: [String]?

    public init (
        devEndpointNames: [String]? = nil
    )
    {
        self.devEndpointNames = devEndpointNames
    }
}

struct BatchGetDevEndpointsInputBody: Equatable {
    public let devEndpointNames: [String]?
}

extension BatchGetDevEndpointsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devEndpointNames = "DevEndpointNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEndpointNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .devEndpointNames)
        var devEndpointNamesDecoded0:[String]? = nil
        if let devEndpointNamesContainer = devEndpointNamesContainer {
            devEndpointNamesDecoded0 = [String]()
            for string0 in devEndpointNamesContainer {
                if let string0 = string0 {
                    devEndpointNamesDecoded0?.append(string0)
                }
            }
        }
        devEndpointNames = devEndpointNamesDecoded0
    }
}

extension BatchGetDevEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetDevEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetDevEndpointsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetDevEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetDevEndpointsOutputResponse(devEndpoints: \(String(describing: devEndpoints)), devEndpointsNotFound: \(String(describing: devEndpointsNotFound)))"}
}

extension BatchGetDevEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetDevEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devEndpoints = output.devEndpoints
            self.devEndpointsNotFound = output.devEndpointsNotFound
        } else {
            self.devEndpoints = nil
            self.devEndpointsNotFound = nil
        }
    }
}

public struct BatchGetDevEndpointsOutputResponse: Equatable {
    /// <p>A list of <code>DevEndpoint</code> definitions.</p>
    public let devEndpoints: [DevEndpoint]?
    /// <p>A list of <code>DevEndpoints</code> not found.</p>
    public let devEndpointsNotFound: [String]?

    public init (
        devEndpoints: [DevEndpoint]? = nil,
        devEndpointsNotFound: [String]? = nil
    )
    {
        self.devEndpoints = devEndpoints
        self.devEndpointsNotFound = devEndpointsNotFound
    }
}

struct BatchGetDevEndpointsOutputResponseBody: Equatable {
    public let devEndpoints: [DevEndpoint]?
    public let devEndpointsNotFound: [String]?
}

extension BatchGetDevEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devEndpoints = "DevEndpoints"
        case devEndpointsNotFound = "DevEndpointsNotFound"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEndpointsContainer = try containerValues.decodeIfPresent([DevEndpoint?].self, forKey: .devEndpoints)
        var devEndpointsDecoded0:[DevEndpoint]? = nil
        if let devEndpointsContainer = devEndpointsContainer {
            devEndpointsDecoded0 = [DevEndpoint]()
            for structure0 in devEndpointsContainer {
                if let structure0 = structure0 {
                    devEndpointsDecoded0?.append(structure0)
                }
            }
        }
        devEndpoints = devEndpointsDecoded0
        let devEndpointsNotFoundContainer = try containerValues.decodeIfPresent([String?].self, forKey: .devEndpointsNotFound)
        var devEndpointsNotFoundDecoded0:[String]? = nil
        if let devEndpointsNotFoundContainer = devEndpointsNotFoundContainer {
            devEndpointsNotFoundDecoded0 = [String]()
            for string0 in devEndpointsNotFoundContainer {
                if let string0 = string0 {
                    devEndpointsNotFoundDecoded0?.append(string0)
                }
            }
        }
        devEndpointsNotFound = devEndpointsNotFoundDecoded0
    }
}

public struct BatchGetJobsInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetJobsInput>
    public typealias MOutput = OperationOutput<BatchGetJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetJobsOutputError>
}

extension BatchGetJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetJobsInput(jobNames: \(String(describing: jobNames)))"}
}

extension BatchGetJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobNames = "JobNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobNames = jobNames {
            var jobNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobNames)
            for jobnamelist0 in jobNames {
                try jobNamesContainer.encode(jobnamelist0)
            }
        }
    }
}

public struct BatchGetJobsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetJobsInput>
    public typealias MOutput = OperationOutput<BatchGetJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetJobsOutputError>
}

public struct BatchGetJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetJobsInput>
    public typealias MOutput = OperationOutput<BatchGetJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetJobsOutputError>
}

public struct BatchGetJobsInput: Equatable {
    /// <p>A list of job names, which might be the names returned from the <code>ListJobs</code>
    ///       operation.</p>
    public let jobNames: [String]?

    public init (
        jobNames: [String]? = nil
    )
    {
        self.jobNames = jobNames
    }
}

struct BatchGetJobsInputBody: Equatable {
    public let jobNames: [String]?
}

extension BatchGetJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobNames = "JobNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobNames)
        var jobNamesDecoded0:[String]? = nil
        if let jobNamesContainer = jobNamesContainer {
            jobNamesDecoded0 = [String]()
            for string0 in jobNamesContainer {
                if let string0 = string0 {
                    jobNamesDecoded0?.append(string0)
                }
            }
        }
        jobNames = jobNamesDecoded0
    }
}

extension BatchGetJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetJobsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetJobsOutputResponse(jobs: \(String(describing: jobs)), jobsNotFound: \(String(describing: jobsNotFound)))"}
}

extension BatchGetJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.jobsNotFound = output.jobsNotFound
        } else {
            self.jobs = nil
            self.jobsNotFound = nil
        }
    }
}

public struct BatchGetJobsOutputResponse: Equatable {
    /// <p>A list of job definitions.</p>
    public let jobs: [Job]?
    /// <p>A list of names of jobs not found.</p>
    public let jobsNotFound: [String]?

    public init (
        jobs: [Job]? = nil,
        jobsNotFound: [String]? = nil
    )
    {
        self.jobs = jobs
        self.jobsNotFound = jobsNotFound
    }
}

struct BatchGetJobsOutputResponseBody: Equatable {
    public let jobs: [Job]?
    public let jobsNotFound: [String]?
}

extension BatchGetJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs = "Jobs"
        case jobsNotFound = "JobsNotFound"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([Job?].self, forKey: .jobs)
        var jobsDecoded0:[Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let jobsNotFoundContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobsNotFound)
        var jobsNotFoundDecoded0:[String]? = nil
        if let jobsNotFoundContainer = jobsNotFoundContainer {
            jobsNotFoundDecoded0 = [String]()
            for string0 in jobsNotFoundContainer {
                if let string0 = string0 {
                    jobsNotFoundDecoded0?.append(string0)
                }
            }
        }
        jobsNotFound = jobsNotFoundDecoded0
    }
}

public struct BatchGetPartitionInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetPartitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetPartitionInput>
    public typealias MOutput = OperationOutput<BatchGetPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetPartitionOutputError>
}

extension BatchGetPartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetPartitionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), partitionsToGet: \(String(describing: partitionsToGet)), tableName: \(String(describing: tableName)))"}
}

extension BatchGetPartitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionsToGet = "PartitionsToGet"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionsToGet = partitionsToGet {
            var partitionsToGetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionsToGet)
            for batchgetpartitionvaluelist0 in partitionsToGet {
                try partitionsToGetContainer.encode(batchgetpartitionvaluelist0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct BatchGetPartitionInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetPartitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetPartitionInput>
    public typealias MOutput = OperationOutput<BatchGetPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetPartitionOutputError>
}

public struct BatchGetPartitionInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetPartitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetPartitionInput>
    public typealias MOutput = OperationOutput<BatchGetPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetPartitionOutputError>
}

public struct BatchGetPartitionInput: Equatable {
    /// <p>The ID of the Data Catalog where the partitions in question reside.
    ///       If none is supplied, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database where the partitions reside.</p>
    public let databaseName: String?
    /// <p>A list of partition values identifying the partitions to retrieve.</p>
    public let partitionsToGet: [PartitionValueList]?
    /// <p>The name of the partitions' table.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        partitionsToGet: [PartitionValueList]? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionsToGet = partitionsToGet
        self.tableName = tableName
    }
}

struct BatchGetPartitionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let partitionsToGet: [PartitionValueList]?
}

extension BatchGetPartitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionsToGet = "PartitionsToGet"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let partitionsToGetContainer = try containerValues.decodeIfPresent([PartitionValueList?].self, forKey: .partitionsToGet)
        var partitionsToGetDecoded0:[PartitionValueList]? = nil
        if let partitionsToGetContainer = partitionsToGetContainer {
            partitionsToGetDecoded0 = [PartitionValueList]()
            for structure0 in partitionsToGetContainer {
                if let structure0 = structure0 {
                    partitionsToGetDecoded0?.append(structure0)
                }
            }
        }
        partitionsToGet = partitionsToGetDecoded0
    }
}

extension BatchGetPartitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetPartitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetPartitionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetPartitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetPartitionOutputResponse(partitions: \(String(describing: partitions)), unprocessedKeys: \(String(describing: unprocessedKeys)))"}
}

extension BatchGetPartitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetPartitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.partitions = output.partitions
            self.unprocessedKeys = output.unprocessedKeys
        } else {
            self.partitions = nil
            self.unprocessedKeys = nil
        }
    }
}

public struct BatchGetPartitionOutputResponse: Equatable {
    /// <p>A list of the requested partitions.</p>
    public let partitions: [Partition]?
    /// <p>A list of the partition values in the request for which partitions were not
    ///       returned.</p>
    public let unprocessedKeys: [PartitionValueList]?

    public init (
        partitions: [Partition]? = nil,
        unprocessedKeys: [PartitionValueList]? = nil
    )
    {
        self.partitions = partitions
        self.unprocessedKeys = unprocessedKeys
    }
}

struct BatchGetPartitionOutputResponseBody: Equatable {
    public let partitions: [Partition]?
    public let unprocessedKeys: [PartitionValueList]?
}

extension BatchGetPartitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case partitions = "Partitions"
        case unprocessedKeys = "UnprocessedKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionsContainer = try containerValues.decodeIfPresent([Partition?].self, forKey: .partitions)
        var partitionsDecoded0:[Partition]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [Partition]()
            for structure0 in partitionsContainer {
                if let structure0 = structure0 {
                    partitionsDecoded0?.append(structure0)
                }
            }
        }
        partitions = partitionsDecoded0
        let unprocessedKeysContainer = try containerValues.decodeIfPresent([PartitionValueList?].self, forKey: .unprocessedKeys)
        var unprocessedKeysDecoded0:[PartitionValueList]? = nil
        if let unprocessedKeysContainer = unprocessedKeysContainer {
            unprocessedKeysDecoded0 = [PartitionValueList]()
            for structure0 in unprocessedKeysContainer {
                if let structure0 = structure0 {
                    unprocessedKeysDecoded0?.append(structure0)
                }
            }
        }
        unprocessedKeys = unprocessedKeysDecoded0
    }
}

public struct BatchGetTriggersInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetTriggersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetTriggersInput>
    public typealias MOutput = OperationOutput<BatchGetTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetTriggersOutputError>
}

extension BatchGetTriggersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetTriggersInput(triggerNames: \(String(describing: triggerNames)))"}
}

extension BatchGetTriggersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case triggerNames = "TriggerNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerNames = triggerNames {
            var triggerNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggerNames)
            for triggernamelist0 in triggerNames {
                try triggerNamesContainer.encode(triggernamelist0)
            }
        }
    }
}

public struct BatchGetTriggersInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetTriggersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetTriggersInput>
    public typealias MOutput = OperationOutput<BatchGetTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetTriggersOutputError>
}

public struct BatchGetTriggersInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetTriggersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetTriggersInput>
    public typealias MOutput = OperationOutput<BatchGetTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetTriggersOutputError>
}

public struct BatchGetTriggersInput: Equatable {
    /// <p>A list of trigger names, which may be the names returned from the <code>ListTriggers</code> operation.</p>
    public let triggerNames: [String]?

    public init (
        triggerNames: [String]? = nil
    )
    {
        self.triggerNames = triggerNames
    }
}

struct BatchGetTriggersInputBody: Equatable {
    public let triggerNames: [String]?
}

extension BatchGetTriggersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case triggerNames = "TriggerNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .triggerNames)
        var triggerNamesDecoded0:[String]? = nil
        if let triggerNamesContainer = triggerNamesContainer {
            triggerNamesDecoded0 = [String]()
            for string0 in triggerNamesContainer {
                if let string0 = string0 {
                    triggerNamesDecoded0?.append(string0)
                }
            }
        }
        triggerNames = triggerNamesDecoded0
    }
}

extension BatchGetTriggersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetTriggersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetTriggersOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetTriggersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetTriggersOutputResponse(triggers: \(String(describing: triggers)), triggersNotFound: \(String(describing: triggersNotFound)))"}
}

extension BatchGetTriggersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetTriggersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.triggers = output.triggers
            self.triggersNotFound = output.triggersNotFound
        } else {
            self.triggers = nil
            self.triggersNotFound = nil
        }
    }
}

public struct BatchGetTriggersOutputResponse: Equatable {
    /// <p>A list of trigger definitions.</p>
    public let triggers: [Trigger]?
    /// <p>A list of names of triggers not found.</p>
    public let triggersNotFound: [String]?

    public init (
        triggers: [Trigger]? = nil,
        triggersNotFound: [String]? = nil
    )
    {
        self.triggers = triggers
        self.triggersNotFound = triggersNotFound
    }
}

struct BatchGetTriggersOutputResponseBody: Equatable {
    public let triggers: [Trigger]?
    public let triggersNotFound: [String]?
}

extension BatchGetTriggersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case triggers = "Triggers"
        case triggersNotFound = "TriggersNotFound"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggersContainer = try containerValues.decodeIfPresent([Trigger?].self, forKey: .triggers)
        var triggersDecoded0:[Trigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [Trigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
        let triggersNotFoundContainer = try containerValues.decodeIfPresent([String?].self, forKey: .triggersNotFound)
        var triggersNotFoundDecoded0:[String]? = nil
        if let triggersNotFoundContainer = triggersNotFoundContainer {
            triggersNotFoundDecoded0 = [String]()
            for string0 in triggersNotFoundContainer {
                if let string0 = string0 {
                    triggersNotFoundDecoded0?.append(string0)
                }
            }
        }
        triggersNotFound = triggersNotFoundDecoded0
    }
}

public struct BatchGetWorkflowsInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetWorkflowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetWorkflowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetWorkflowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetWorkflowsInput>
    public typealias MOutput = OperationOutput<BatchGetWorkflowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetWorkflowsOutputError>
}

extension BatchGetWorkflowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetWorkflowsInput(includeGraph: \(String(describing: includeGraph)), names: \(String(describing: names)))"}
}

extension BatchGetWorkflowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeGraph = "IncludeGraph"
        case names = "Names"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeGraph = includeGraph {
            try encodeContainer.encode(includeGraph, forKey: .includeGraph)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for workflownames0 in names {
                try namesContainer.encode(workflownames0)
            }
        }
    }
}

public struct BatchGetWorkflowsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetWorkflowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetWorkflowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetWorkflowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetWorkflowsInput>
    public typealias MOutput = OperationOutput<BatchGetWorkflowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetWorkflowsOutputError>
}

public struct BatchGetWorkflowsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetWorkflowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetWorkflowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetWorkflowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetWorkflowsInput>
    public typealias MOutput = OperationOutput<BatchGetWorkflowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetWorkflowsOutputError>
}

public struct BatchGetWorkflowsInput: Equatable {
    /// <p>Specifies whether to include a graph when returning the workflow resource metadata.</p>
    public let includeGraph: Bool?
    /// <p>A list of workflow names, which may be the names returned from the <code>ListWorkflows</code> operation.</p>
    public let names: [String]?

    public init (
        includeGraph: Bool? = nil,
        names: [String]? = nil
    )
    {
        self.includeGraph = includeGraph
        self.names = names
    }
}

struct BatchGetWorkflowsInputBody: Equatable {
    public let names: [String]?
    public let includeGraph: Bool?
}

extension BatchGetWorkflowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includeGraph = "IncludeGraph"
        case names = "Names"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let includeGraphDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeGraph)
        includeGraph = includeGraphDecoded
    }
}

extension BatchGetWorkflowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetWorkflowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetWorkflowsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetWorkflowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetWorkflowsOutputResponse(missingWorkflows: \(String(describing: missingWorkflows)), workflows: \(String(describing: workflows)))"}
}

extension BatchGetWorkflowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetWorkflowsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.missingWorkflows = output.missingWorkflows
            self.workflows = output.workflows
        } else {
            self.missingWorkflows = nil
            self.workflows = nil
        }
    }
}

public struct BatchGetWorkflowsOutputResponse: Equatable {
    /// <p>A list of names of workflows not found.</p>
    public let missingWorkflows: [String]?
    /// <p>A list of workflow resource metadata.</p>
    public let workflows: [Workflow]?

    public init (
        missingWorkflows: [String]? = nil,
        workflows: [Workflow]? = nil
    )
    {
        self.missingWorkflows = missingWorkflows
        self.workflows = workflows
    }
}

struct BatchGetWorkflowsOutputResponseBody: Equatable {
    public let workflows: [Workflow]?
    public let missingWorkflows: [String]?
}

extension BatchGetWorkflowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case missingWorkflows = "MissingWorkflows"
        case workflows = "Workflows"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowsContainer = try containerValues.decodeIfPresent([Workflow?].self, forKey: .workflows)
        var workflowsDecoded0:[Workflow]? = nil
        if let workflowsContainer = workflowsContainer {
            workflowsDecoded0 = [Workflow]()
            for structure0 in workflowsContainer {
                if let structure0 = structure0 {
                    workflowsDecoded0?.append(structure0)
                }
            }
        }
        workflows = workflowsDecoded0
        let missingWorkflowsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .missingWorkflows)
        var missingWorkflowsDecoded0:[String]? = nil
        if let missingWorkflowsContainer = missingWorkflowsContainer {
            missingWorkflowsDecoded0 = [String]()
            for string0 in missingWorkflowsContainer {
                if let string0 = string0 {
                    missingWorkflowsDecoded0?.append(string0)
                }
            }
        }
        missingWorkflows = missingWorkflowsDecoded0
    }
}

extension BatchStopJobRunError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorDetail = "ErrorDetail"
        case jobName = "JobName"
        case jobRunId = "JobRunId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorDetail = errorDetail {
            try encodeContainer.encode(errorDetail, forKey: .errorDetail)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobRunId = jobRunId {
            try encodeContainer.encode(jobRunId, forKey: .jobRunId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobRunId)
        jobRunId = jobRunIdDecoded
        let errorDetailDecoded = try containerValues.decodeIfPresent(ErrorDetail.self, forKey: .errorDetail)
        errorDetail = errorDetailDecoded
    }
}

extension BatchStopJobRunError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchStopJobRunError(errorDetail: \(String(describing: errorDetail)), jobName: \(String(describing: jobName)), jobRunId: \(String(describing: jobRunId)))"}
}

/// <p>Records an error that occurred when attempting to stop a
///       specified job run.</p>
public struct BatchStopJobRunError: Equatable {
    /// <p>Specifies details about the error that was encountered.</p>
    public let errorDetail: ErrorDetail?
    /// <p>The name of the job definition that is used in the job run in question.</p>
    public let jobName: String?
    /// <p>The <code>JobRunId</code> of the job run in question.</p>
    public let jobRunId: String?

    public init (
        errorDetail: ErrorDetail? = nil,
        jobName: String? = nil,
        jobRunId: String? = nil
    )
    {
        self.errorDetail = errorDetail
        self.jobName = jobName
        self.jobRunId = jobRunId
    }
}

public struct BatchStopJobRunInputBodyMiddleware: Middleware {
    public let id: String = "BatchStopJobRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchStopJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchStopJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchStopJobRunInput>
    public typealias MOutput = OperationOutput<BatchStopJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchStopJobRunOutputError>
}

extension BatchStopJobRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchStopJobRunInput(jobName: \(String(describing: jobName)), jobRunIds: \(String(describing: jobRunIds)))"}
}

extension BatchStopJobRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobRunIds = "JobRunIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobRunIds = jobRunIds {
            var jobRunIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobRunIds)
            for batchstopjobrunjobrunidlist0 in jobRunIds {
                try jobRunIdsContainer.encode(batchstopjobrunjobrunidlist0)
            }
        }
    }
}

public struct BatchStopJobRunInputHeadersMiddleware: Middleware {
    public let id: String = "BatchStopJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchStopJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchStopJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchStopJobRunInput>
    public typealias MOutput = OperationOutput<BatchStopJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchStopJobRunOutputError>
}

public struct BatchStopJobRunInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchStopJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchStopJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchStopJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchStopJobRunInput>
    public typealias MOutput = OperationOutput<BatchStopJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchStopJobRunOutputError>
}

public struct BatchStopJobRunInput: Equatable {
    /// <p>The name of the job definition for which to stop job runs.</p>
    public let jobName: String?
    /// <p>A list of the <code>JobRunIds</code> that should be stopped for that job
    ///       definition.</p>
    public let jobRunIds: [String]?

    public init (
        jobName: String? = nil,
        jobRunIds: [String]? = nil
    )
    {
        self.jobName = jobName
        self.jobRunIds = jobRunIds
    }
}

struct BatchStopJobRunInputBody: Equatable {
    public let jobName: String?
    public let jobRunIds: [String]?
}

extension BatchStopJobRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobRunIds = "JobRunIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobRunIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobRunIds)
        var jobRunIdsDecoded0:[String]? = nil
        if let jobRunIdsContainer = jobRunIdsContainer {
            jobRunIdsDecoded0 = [String]()
            for string0 in jobRunIdsContainer {
                if let string0 = string0 {
                    jobRunIdsDecoded0?.append(string0)
                }
            }
        }
        jobRunIds = jobRunIdsDecoded0
    }
}

extension BatchStopJobRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchStopJobRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchStopJobRunOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchStopJobRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchStopJobRunOutputResponse(errors: \(String(describing: errors)), successfulSubmissions: \(String(describing: successfulSubmissions)))"}
}

extension BatchStopJobRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchStopJobRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
            self.successfulSubmissions = output.successfulSubmissions
        } else {
            self.errors = nil
            self.successfulSubmissions = nil
        }
    }
}

public struct BatchStopJobRunOutputResponse: Equatable {
    /// <p>A list of the errors that were encountered in trying to stop <code>JobRuns</code>,
    ///       including the <code>JobRunId</code> for which each error was encountered and details about the
    ///       error.</p>
    public let errors: [BatchStopJobRunError]?
    /// <p>A list of the JobRuns that were successfully submitted for stopping.</p>
    public let successfulSubmissions: [BatchStopJobRunSuccessfulSubmission]?

    public init (
        errors: [BatchStopJobRunError]? = nil,
        successfulSubmissions: [BatchStopJobRunSuccessfulSubmission]? = nil
    )
    {
        self.errors = errors
        self.successfulSubmissions = successfulSubmissions
    }
}

struct BatchStopJobRunOutputResponseBody: Equatable {
    public let successfulSubmissions: [BatchStopJobRunSuccessfulSubmission]?
    public let errors: [BatchStopJobRunError]?
}

extension BatchStopJobRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
        case successfulSubmissions = "SuccessfulSubmissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulSubmissionsContainer = try containerValues.decodeIfPresent([BatchStopJobRunSuccessfulSubmission?].self, forKey: .successfulSubmissions)
        var successfulSubmissionsDecoded0:[BatchStopJobRunSuccessfulSubmission]? = nil
        if let successfulSubmissionsContainer = successfulSubmissionsContainer {
            successfulSubmissionsDecoded0 = [BatchStopJobRunSuccessfulSubmission]()
            for structure0 in successfulSubmissionsContainer {
                if let structure0 = structure0 {
                    successfulSubmissionsDecoded0?.append(structure0)
                }
            }
        }
        successfulSubmissions = successfulSubmissionsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([BatchStopJobRunError?].self, forKey: .errors)
        var errorsDecoded0:[BatchStopJobRunError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchStopJobRunError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchStopJobRunSuccessfulSubmission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobRunId = "JobRunId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobRunId = jobRunId {
            try encodeContainer.encode(jobRunId, forKey: .jobRunId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobRunId)
        jobRunId = jobRunIdDecoded
    }
}

extension BatchStopJobRunSuccessfulSubmission: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchStopJobRunSuccessfulSubmission(jobName: \(String(describing: jobName)), jobRunId: \(String(describing: jobRunId)))"}
}

/// <p>Records a successful request to stop a specified <code>JobRun</code>.</p>
public struct BatchStopJobRunSuccessfulSubmission: Equatable {
    /// <p>The name of the job definition used in the job run that was stopped.</p>
    public let jobName: String?
    /// <p>The <code>JobRunId</code> of the job run that was stopped.</p>
    public let jobRunId: String?

    public init (
        jobName: String? = nil,
        jobRunId: String? = nil
    )
    {
        self.jobName = jobName
        self.jobRunId = jobRunId
    }
}

extension BatchUpdatePartitionFailureEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorDetail = "ErrorDetail"
        case partitionValueList = "PartitionValueList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorDetail = errorDetail {
            try encodeContainer.encode(errorDetail, forKey: .errorDetail)
        }
        if let partitionValueList = partitionValueList {
            var partitionValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValueList)
            for boundedpartitionvaluelist0 in partitionValueList {
                try partitionValueListContainer.encode(boundedpartitionvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionValueListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionValueList)
        var partitionValueListDecoded0:[String]? = nil
        if let partitionValueListContainer = partitionValueListContainer {
            partitionValueListDecoded0 = [String]()
            for string0 in partitionValueListContainer {
                if let string0 = string0 {
                    partitionValueListDecoded0?.append(string0)
                }
            }
        }
        partitionValueList = partitionValueListDecoded0
        let errorDetailDecoded = try containerValues.decodeIfPresent(ErrorDetail.self, forKey: .errorDetail)
        errorDetail = errorDetailDecoded
    }
}

extension BatchUpdatePartitionFailureEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdatePartitionFailureEntry(errorDetail: \(String(describing: errorDetail)), partitionValueList: \(String(describing: partitionValueList)))"}
}

/// <p>Contains information about a batch update partition error.</p>
public struct BatchUpdatePartitionFailureEntry: Equatable {
    /// <p>The details about the batch update partition error.</p>
    public let errorDetail: ErrorDetail?
    /// <p>A list of values defining the partitions.</p>
    public let partitionValueList: [String]?

    public init (
        errorDetail: ErrorDetail? = nil,
        partitionValueList: [String]? = nil
    )
    {
        self.errorDetail = errorDetail
        self.partitionValueList = partitionValueList
    }
}

public struct BatchUpdatePartitionInputBodyMiddleware: Middleware {
    public let id: String = "BatchUpdatePartitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdatePartitionInput>
    public typealias MOutput = OperationOutput<BatchUpdatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdatePartitionOutputError>
}

extension BatchUpdatePartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdatePartitionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), entries: \(String(describing: entries)), tableName: \(String(describing: tableName)))"}
}

extension BatchUpdatePartitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case entries = "Entries"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchupdatepartitionrequestentrylist0 in entries {
                try entriesContainer.encode(batchupdatepartitionrequestentrylist0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct BatchUpdatePartitionInputHeadersMiddleware: Middleware {
    public let id: String = "BatchUpdatePartitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdatePartitionInput>
    public typealias MOutput = OperationOutput<BatchUpdatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdatePartitionOutputError>
}

public struct BatchUpdatePartitionInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchUpdatePartitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdatePartitionInput>
    public typealias MOutput = OperationOutput<BatchUpdatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdatePartitionOutputError>
}

public struct BatchUpdatePartitionInput: Equatable {
    /// <p>The ID of the catalog in which the partition is to be updated. Currently, this should be
    ///       the AWS account ID.</p>
    public let catalogId: String?
    /// <p>The name of the metadata database in which the partition is
    ///       to be updated.</p>
    public let databaseName: String?
    /// <p>A list of up to 100 <code>BatchUpdatePartitionRequestEntry</code> objects to update.</p>
    public let entries: [BatchUpdatePartitionRequestEntry]?
    /// <p>The name of the metadata table in which the partition is to be updated.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        entries: [BatchUpdatePartitionRequestEntry]? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.entries = entries
        self.tableName = tableName
    }
}

struct BatchUpdatePartitionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let entries: [BatchUpdatePartitionRequestEntry]?
}

extension BatchUpdatePartitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case entries = "Entries"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let entriesContainer = try containerValues.decodeIfPresent([BatchUpdatePartitionRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[BatchUpdatePartitionRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [BatchUpdatePartitionRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchUpdatePartitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdatePartitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchUpdatePartitionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdatePartitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdatePartitionOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchUpdatePartitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchUpdatePartitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchUpdatePartitionOutputResponse: Equatable {
    /// <p>The errors encountered when trying to update the requested partitions. A list of <code>BatchUpdatePartitionFailureEntry</code> objects.</p>
    public let errors: [BatchUpdatePartitionFailureEntry]?

    public init (
        errors: [BatchUpdatePartitionFailureEntry]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchUpdatePartitionOutputResponseBody: Equatable {
    public let errors: [BatchUpdatePartitionFailureEntry]?
}

extension BatchUpdatePartitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([BatchUpdatePartitionFailureEntry?].self, forKey: .errors)
        var errorsDecoded0:[BatchUpdatePartitionFailureEntry]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchUpdatePartitionFailureEntry]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchUpdatePartitionRequestEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case partitionInput = "PartitionInput"
        case partitionValueList = "PartitionValueList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let partitionInput = partitionInput {
            try encodeContainer.encode(partitionInput, forKey: .partitionInput)
        }
        if let partitionValueList = partitionValueList {
            var partitionValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValueList)
            for boundedpartitionvaluelist0 in partitionValueList {
                try partitionValueListContainer.encode(boundedpartitionvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionValueListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionValueList)
        var partitionValueListDecoded0:[String]? = nil
        if let partitionValueListContainer = partitionValueListContainer {
            partitionValueListDecoded0 = [String]()
            for string0 in partitionValueListContainer {
                if let string0 = string0 {
                    partitionValueListDecoded0?.append(string0)
                }
            }
        }
        partitionValueList = partitionValueListDecoded0
        let partitionInputDecoded = try containerValues.decodeIfPresent(PartitionInput.self, forKey: .partitionInput)
        partitionInput = partitionInputDecoded
    }
}

extension BatchUpdatePartitionRequestEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdatePartitionRequestEntry(partitionInput: \(String(describing: partitionInput)), partitionValueList: \(String(describing: partitionValueList)))"}
}

/// <p>A structure that contains the values and structure used to update a partition.</p>
public struct BatchUpdatePartitionRequestEntry: Equatable {
    /// <p>The structure used to update a partition.</p>
    public let partitionInput: PartitionInput?
    /// <p>A list of values defining the partitions.</p>
    public let partitionValueList: [String]?

    public init (
        partitionInput: PartitionInput? = nil,
        partitionValueList: [String]? = nil
    )
    {
        self.partitionInput = partitionInput
        self.partitionValueList = partitionValueList
    }
}

extension BinaryColumnStatisticsData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case averageLength = "AverageLength"
        case maximumLength = "MaximumLength"
        case numberOfNulls = "NumberOfNulls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if averageLength != 0.0 {
            try encodeContainer.encode(averageLength, forKey: .averageLength)
        }
        if maximumLength != 0 {
            try encodeContainer.encode(maximumLength, forKey: .maximumLength)
        }
        if numberOfNulls != 0 {
            try encodeContainer.encode(numberOfNulls, forKey: .numberOfNulls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumLengthDecoded = try containerValues.decode(Int.self, forKey: .maximumLength)
        maximumLength = maximumLengthDecoded
        let averageLengthDecoded = try containerValues.decode(Double.self, forKey: .averageLength)
        averageLength = averageLengthDecoded
        let numberOfNullsDecoded = try containerValues.decode(Int.self, forKey: .numberOfNulls)
        numberOfNulls = numberOfNullsDecoded
    }
}

extension BinaryColumnStatisticsData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BinaryColumnStatisticsData(averageLength: \(String(describing: averageLength)), maximumLength: \(String(describing: maximumLength)), numberOfNulls: \(String(describing: numberOfNulls)))"}
}

/// <p>Defines column statistics supported for bit sequence data values.</p>
public struct BinaryColumnStatisticsData: Equatable {
    /// <p>The average bit sequence length in the column.</p>
    public let averageLength: Double
    /// <p>The size of the longest bit sequence in the column.</p>
    public let maximumLength: Int
    /// <p>The number of null values in the column.</p>
    public let numberOfNulls: Int

    public init (
        averageLength: Double = 0.0,
        maximumLength: Int = 0,
        numberOfNulls: Int = 0
    )
    {
        self.averageLength = averageLength
        self.maximumLength = maximumLength
        self.numberOfNulls = numberOfNulls
    }
}

extension BooleanColumnStatisticsData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numberOfFalses = "NumberOfFalses"
        case numberOfNulls = "NumberOfNulls"
        case numberOfTrues = "NumberOfTrues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfFalses != 0 {
            try encodeContainer.encode(numberOfFalses, forKey: .numberOfFalses)
        }
        if numberOfNulls != 0 {
            try encodeContainer.encode(numberOfNulls, forKey: .numberOfNulls)
        }
        if numberOfTrues != 0 {
            try encodeContainer.encode(numberOfTrues, forKey: .numberOfTrues)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfTruesDecoded = try containerValues.decode(Int.self, forKey: .numberOfTrues)
        numberOfTrues = numberOfTruesDecoded
        let numberOfFalsesDecoded = try containerValues.decode(Int.self, forKey: .numberOfFalses)
        numberOfFalses = numberOfFalsesDecoded
        let numberOfNullsDecoded = try containerValues.decode(Int.self, forKey: .numberOfNulls)
        numberOfNulls = numberOfNullsDecoded
    }
}

extension BooleanColumnStatisticsData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BooleanColumnStatisticsData(numberOfFalses: \(String(describing: numberOfFalses)), numberOfNulls: \(String(describing: numberOfNulls)), numberOfTrues: \(String(describing: numberOfTrues)))"}
}

/// <p>Defines column statistics supported for Boolean data columns.</p>
public struct BooleanColumnStatisticsData: Equatable {
    /// <p>The number of false values in the column.</p>
    public let numberOfFalses: Int
    /// <p>The number of null values in the column.</p>
    public let numberOfNulls: Int
    /// <p>The number of true values in the column.</p>
    public let numberOfTrues: Int

    public init (
        numberOfFalses: Int = 0,
        numberOfNulls: Int = 0,
        numberOfTrues: Int = 0
    )
    {
        self.numberOfFalses = numberOfFalses
        self.numberOfNulls = numberOfNulls
        self.numberOfTrues = numberOfTrues
    }
}

public struct CancelMLTaskRunInputBodyMiddleware: Middleware {
    public let id: String = "CancelMLTaskRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelMLTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelMLTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelMLTaskRunInput>
    public typealias MOutput = OperationOutput<CancelMLTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelMLTaskRunOutputError>
}

extension CancelMLTaskRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelMLTaskRunInput(taskRunId: \(String(describing: taskRunId)), transformId: \(String(describing: transformId)))"}
}

extension CancelMLTaskRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case taskRunId = "TaskRunId"
        case transformId = "TransformId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskRunId = taskRunId {
            try encodeContainer.encode(taskRunId, forKey: .taskRunId)
        }
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
    }
}

public struct CancelMLTaskRunInputHeadersMiddleware: Middleware {
    public let id: String = "CancelMLTaskRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelMLTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelMLTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelMLTaskRunInput>
    public typealias MOutput = OperationOutput<CancelMLTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelMLTaskRunOutputError>
}

public struct CancelMLTaskRunInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelMLTaskRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelMLTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelMLTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelMLTaskRunInput>
    public typealias MOutput = OperationOutput<CancelMLTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelMLTaskRunOutputError>
}

public struct CancelMLTaskRunInput: Equatable {
    /// <p>A unique identifier for the task run.</p>
    public let taskRunId: String?
    /// <p>The unique identifier of the machine learning transform.</p>
    public let transformId: String?

    public init (
        taskRunId: String? = nil,
        transformId: String? = nil
    )
    {
        self.taskRunId = taskRunId
        self.transformId = transformId
    }
}

struct CancelMLTaskRunInputBody: Equatable {
    public let transformId: String?
    public let taskRunId: String?
}

extension CancelMLTaskRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskRunId = "TaskRunId"
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let taskRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRunId)
        taskRunId = taskRunIdDecoded
    }
}

extension CancelMLTaskRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelMLTaskRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelMLTaskRunOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelMLTaskRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelMLTaskRunOutputResponse(status: \(String(describing: status)), taskRunId: \(String(describing: taskRunId)), transformId: \(String(describing: transformId)))"}
}

extension CancelMLTaskRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelMLTaskRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
            self.taskRunId = output.taskRunId
            self.transformId = output.transformId
        } else {
            self.status = nil
            self.taskRunId = nil
            self.transformId = nil
        }
    }
}

public struct CancelMLTaskRunOutputResponse: Equatable {
    /// <p>The status for this run.</p>
    public let status: TaskStatusType?
    /// <p>The unique identifier for the task run.</p>
    public let taskRunId: String?
    /// <p>The unique identifier of the machine learning transform.</p>
    public let transformId: String?

    public init (
        status: TaskStatusType? = nil,
        taskRunId: String? = nil,
        transformId: String? = nil
    )
    {
        self.status = status
        self.taskRunId = taskRunId
        self.transformId = transformId
    }
}

struct CancelMLTaskRunOutputResponseBody: Equatable {
    public let transformId: String?
    public let taskRunId: String?
    public let status: TaskStatusType?
}

extension CancelMLTaskRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case taskRunId = "TaskRunId"
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let taskRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRunId)
        taskRunId = taskRunIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TaskStatusType.self, forKey: .status)
        status = statusDecoded
    }
}

public enum CatalogEncryptionMode {
    case disabled
    case ssekms
    case sdkUnknown(String)
}

extension CatalogEncryptionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CatalogEncryptionMode] {
        return [
            .disabled,
            .ssekms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .ssekms: return "SSE-KMS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CatalogEncryptionMode(rawValue: rawValue) ?? CatalogEncryptionMode.sdkUnknown(rawValue)
    }
}

extension CatalogEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension CatalogEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CatalogEntry(databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)))"}
}

/// <p>Specifies a table definition in the AWS Glue Data Catalog.</p>
public struct CatalogEntry: Equatable {
    /// <p>The database in which the table metadata resides.</p>
    public let databaseName: String?
    /// <p>The name of the table in question.</p>
    public let tableName: String?

    public init (
        databaseName: String? = nil,
        tableName: String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

extension CatalogImportStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case importCompleted = "ImportCompleted"
        case importTime = "ImportTime"
        case importedBy = "ImportedBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if importCompleted != false {
            try encodeContainer.encode(importCompleted, forKey: .importCompleted)
        }
        if let importTime = importTime {
            try encodeContainer.encode(importTime.timeIntervalSince1970, forKey: .importTime)
        }
        if let importedBy = importedBy {
            try encodeContainer.encode(importedBy, forKey: .importedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importCompletedDecoded = try containerValues.decode(Bool.self, forKey: .importCompleted)
        importCompleted = importCompletedDecoded
        let importTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .importTime)
        importTime = importTimeDecoded
        let importedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importedBy)
        importedBy = importedByDecoded
    }
}

extension CatalogImportStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CatalogImportStatus(importCompleted: \(String(describing: importCompleted)), importTime: \(String(describing: importTime)), importedBy: \(String(describing: importedBy)))"}
}

/// <p>A structure containing migration status information.</p>
public struct CatalogImportStatus: Equatable {
    /// <p>
    ///             <code>True</code> if the migration has completed, or <code>False</code> otherwise.</p>
    public let importCompleted: Bool
    /// <p>The time that the migration was started.</p>
    public let importTime: Date?
    /// <p>The name of the person who initiated the migration.</p>
    public let importedBy: String?

    public init (
        importCompleted: Bool = false,
        importTime: Date? = nil,
        importedBy: String? = nil
    )
    {
        self.importCompleted = importCompleted
        self.importTime = importTime
        self.importedBy = importedBy
    }
}

extension CatalogTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case tables = "Tables"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tables = tables {
            var tablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tables)
            for catalogtableslist0 in tables {
                try tablesContainer.encode(catalogtableslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tablesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tables)
        var tablesDecoded0:[String]? = nil
        if let tablesContainer = tablesContainer {
            tablesDecoded0 = [String]()
            for string0 in tablesContainer {
                if let string0 = string0 {
                    tablesDecoded0?.append(string0)
                }
            }
        }
        tables = tablesDecoded0
    }
}

extension CatalogTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CatalogTarget(databaseName: \(String(describing: databaseName)), tables: \(String(describing: tables)))"}
}

/// <p>Specifies an AWS Glue Data Catalog target.</p>
public struct CatalogTarget: Equatable {
    /// <p>The name of the database to be synchronized.</p>
    public let databaseName: String?
    /// <p>A list of the tables to be synchronized.</p>
    public let tables: [String]?

    public init (
        databaseName: String? = nil,
        tables: [String]? = nil
    )
    {
        self.databaseName = databaseName
        self.tables = tables
    }
}

public struct CheckSchemaVersionValidityInputBodyMiddleware: Middleware {
    public let id: String = "CheckSchemaVersionValidityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckSchemaVersionValidityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckSchemaVersionValidityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckSchemaVersionValidityInput>
    public typealias MOutput = OperationOutput<CheckSchemaVersionValidityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckSchemaVersionValidityOutputError>
}

extension CheckSchemaVersionValidityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckSchemaVersionValidityInput(dataFormat: \(String(describing: dataFormat)), schemaDefinition: \(String(describing: schemaDefinition)))"}
}

extension CheckSchemaVersionValidityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataFormat = "DataFormat"
        case schemaDefinition = "SchemaDefinition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataFormat = dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let schemaDefinition = schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }
}

public struct CheckSchemaVersionValidityInputHeadersMiddleware: Middleware {
    public let id: String = "CheckSchemaVersionValidityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckSchemaVersionValidityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckSchemaVersionValidityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckSchemaVersionValidityInput>
    public typealias MOutput = OperationOutput<CheckSchemaVersionValidityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckSchemaVersionValidityOutputError>
}

public struct CheckSchemaVersionValidityInputQueryItemMiddleware: Middleware {
    public let id: String = "CheckSchemaVersionValidityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckSchemaVersionValidityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckSchemaVersionValidityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckSchemaVersionValidityInput>
    public typealias MOutput = OperationOutput<CheckSchemaVersionValidityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckSchemaVersionValidityOutputError>
}

public struct CheckSchemaVersionValidityInput: Equatable {
    /// <p>The data format of the schema definition. Currently only <code>AVRO</code> is supported.</p>
    public let dataFormat: DataFormat?
    /// <p>The definition of the schema that has to be validated.</p>
    public let schemaDefinition: String?

    public init (
        dataFormat: DataFormat? = nil,
        schemaDefinition: String? = nil
    )
    {
        self.dataFormat = dataFormat
        self.schemaDefinition = schemaDefinition
    }
}

struct CheckSchemaVersionValidityInputBody: Equatable {
    public let dataFormat: DataFormat?
    public let schemaDefinition: String?
}

extension CheckSchemaVersionValidityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataFormat = "DataFormat"
        case schemaDefinition = "SchemaDefinition"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataFormatDecoded = try containerValues.decodeIfPresent(DataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension CheckSchemaVersionValidityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckSchemaVersionValidityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckSchemaVersionValidityOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckSchemaVersionValidityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckSchemaVersionValidityOutputResponse(error: \(String(describing: error)), valid: \(String(describing: valid)))"}
}

extension CheckSchemaVersionValidityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CheckSchemaVersionValidityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.valid = output.valid
        } else {
            self.error = nil
            self.valid = false
        }
    }
}

public struct CheckSchemaVersionValidityOutputResponse: Equatable {
    /// <p>A validation failure error message.</p>
    public let error: String?
    /// <p>Return true, if the schema is valid and false otherwise.</p>
    public let valid: Bool

    public init (
        error: String? = nil,
        valid: Bool = false
    )
    {
        self.error = error
        self.valid = valid
    }
}

struct CheckSchemaVersionValidityOutputResponseBody: Equatable {
    public let valid: Bool
    public let error: String?
}

extension CheckSchemaVersionValidityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error = "Error"
        case valid = "Valid"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validDecoded = try containerValues.decode(Bool.self, forKey: .valid)
        valid = validDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
    }
}

extension Classifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case csvClassifier = "CsvClassifier"
        case grokClassifier = "GrokClassifier"
        case jsonClassifier = "JsonClassifier"
        case xMLClassifier = "XMLClassifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvClassifier = csvClassifier {
            try encodeContainer.encode(csvClassifier, forKey: .csvClassifier)
        }
        if let grokClassifier = grokClassifier {
            try encodeContainer.encode(grokClassifier, forKey: .grokClassifier)
        }
        if let jsonClassifier = jsonClassifier {
            try encodeContainer.encode(jsonClassifier, forKey: .jsonClassifier)
        }
        if let xMLClassifier = xMLClassifier {
            try encodeContainer.encode(xMLClassifier, forKey: .xMLClassifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grokClassifierDecoded = try containerValues.decodeIfPresent(GrokClassifier.self, forKey: .grokClassifier)
        grokClassifier = grokClassifierDecoded
        let xMLClassifierDecoded = try containerValues.decodeIfPresent(XMLClassifier.self, forKey: .xMLClassifier)
        xMLClassifier = xMLClassifierDecoded
        let jsonClassifierDecoded = try containerValues.decodeIfPresent(JsonClassifier.self, forKey: .jsonClassifier)
        jsonClassifier = jsonClassifierDecoded
        let csvClassifierDecoded = try containerValues.decodeIfPresent(CsvClassifier.self, forKey: .csvClassifier)
        csvClassifier = csvClassifierDecoded
    }
}

extension Classifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Classifier(csvClassifier: \(String(describing: csvClassifier)), grokClassifier: \(String(describing: grokClassifier)), jsonClassifier: \(String(describing: jsonClassifier)), xMLClassifier: \(String(describing: xMLClassifier)))"}
}

/// <p>Classifiers are triggered during a crawl task. A classifier checks whether a given file is
///       in a format it can handle. If it is, the classifier creates a schema in the form of a
///         <code>StructType</code> object that matches that data format.</p>
///          <p>You can use the standard classifiers that AWS Glue provides, or you can write your own
///       classifiers to best categorize your data sources and specify the appropriate schemas to use
///       for them. A classifier can be a <code>grok</code> classifier, an <code>XML</code> classifier,
///       a <code>JSON</code> classifier, or a custom <code>CSV</code> classifier, as specified in one
///       of the fields in the <code>Classifier</code> object.</p>
public struct Classifier: Equatable {
    /// <p>A classifier for comma-separated values (CSV).</p>
    public let csvClassifier: CsvClassifier?
    /// <p>A classifier that uses <code>grok</code>.</p>
    public let grokClassifier: GrokClassifier?
    /// <p>A classifier for JSON content.</p>
    public let jsonClassifier: JsonClassifier?
    /// <p>A classifier for XML content.</p>
    public let xMLClassifier: XMLClassifier?

    public init (
        csvClassifier: CsvClassifier? = nil,
        grokClassifier: GrokClassifier? = nil,
        jsonClassifier: JsonClassifier? = nil,
        xMLClassifier: XMLClassifier? = nil
    )
    {
        self.csvClassifier = csvClassifier
        self.grokClassifier = grokClassifier
        self.jsonClassifier = jsonClassifier
        self.xMLClassifier = xMLClassifier
    }
}

extension CloudWatchEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchEncryptionMode = "CloudWatchEncryptionMode"
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchEncryptionMode = cloudWatchEncryptionMode {
            try encodeContainer.encode(cloudWatchEncryptionMode.rawValue, forKey: .cloudWatchEncryptionMode)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchEncryptionModeDecoded = try containerValues.decodeIfPresent(CloudWatchEncryptionMode.self, forKey: .cloudWatchEncryptionMode)
        cloudWatchEncryptionMode = cloudWatchEncryptionModeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension CloudWatchEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchEncryption(cloudWatchEncryptionMode: \(String(describing: cloudWatchEncryptionMode)), kmsKeyArn: \(String(describing: kmsKeyArn)))"}
}

/// <p>Specifies how Amazon CloudWatch data should be encrypted.</p>
public struct CloudWatchEncryption: Equatable {
    /// <p>The encryption mode to use for CloudWatch data.</p>
    public let cloudWatchEncryptionMode: CloudWatchEncryptionMode?
    /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
    public let kmsKeyArn: String?

    public init (
        cloudWatchEncryptionMode: CloudWatchEncryptionMode? = nil,
        kmsKeyArn: String? = nil
    )
    {
        self.cloudWatchEncryptionMode = cloudWatchEncryptionMode
        self.kmsKeyArn = kmsKeyArn
    }
}

public enum CloudWatchEncryptionMode {
    case disabled
    case ssekms
    case sdkUnknown(String)
}

extension CloudWatchEncryptionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CloudWatchEncryptionMode] {
        return [
            .disabled,
            .ssekms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .ssekms: return "SSE-KMS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CloudWatchEncryptionMode(rawValue: rawValue) ?? CloudWatchEncryptionMode.sdkUnknown(rawValue)
    }
}

extension CodeGenEdge: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case source = "Source"
        case target = "Target"
        case targetParameter = "TargetParameter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetParameter = targetParameter {
            try encodeContainer.encode(targetParameter, forKey: .targetParameter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let targetParameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetParameter)
        targetParameter = targetParameterDecoded
    }
}

extension CodeGenEdge: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeGenEdge(source: \(String(describing: source)), target: \(String(describing: target)), targetParameter: \(String(describing: targetParameter)))"}
}

/// <p>Represents a directional edge in a directed acyclic graph (DAG).</p>
public struct CodeGenEdge: Equatable {
    /// <p>The ID of the node at which the edge starts.</p>
    public let source: String?
    /// <p>The ID of the node at which the edge ends.</p>
    public let target: String?
    /// <p>The target of the edge.</p>
    public let targetParameter: String?

    public init (
        source: String? = nil,
        target: String? = nil,
        targetParameter: String? = nil
    )
    {
        self.source = source
        self.target = target
        self.targetParameter = targetParameter
    }
}

extension CodeGenNode: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case args = "Args"
        case id = "Id"
        case lineNumber = "LineNumber"
        case nodeType = "NodeType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let args = args {
            var argsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .args)
            for codegennodeargs0 in args {
                try argsContainer.encode(codegennodeargs0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if lineNumber != 0 {
            try encodeContainer.encode(lineNumber, forKey: .lineNumber)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let argsContainer = try containerValues.decodeIfPresent([CodeGenNodeArg?].self, forKey: .args)
        var argsDecoded0:[CodeGenNodeArg]? = nil
        if let argsContainer = argsContainer {
            argsDecoded0 = [CodeGenNodeArg]()
            for structure0 in argsContainer {
                if let structure0 = structure0 {
                    argsDecoded0?.append(structure0)
                }
            }
        }
        args = argsDecoded0
        let lineNumberDecoded = try containerValues.decode(Int.self, forKey: .lineNumber)
        lineNumber = lineNumberDecoded
    }
}

extension CodeGenNode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeGenNode(args: \(String(describing: args)), id: \(String(describing: id)), lineNumber: \(String(describing: lineNumber)), nodeType: \(String(describing: nodeType)))"}
}

/// <p>Represents a node in a directed acyclic graph (DAG)</p>
public struct CodeGenNode: Equatable {
    /// <p>Properties of the node, in the form of name-value pairs.</p>
    public let args: [CodeGenNodeArg]?
    /// <p>A node identifier that is unique within the node's graph.</p>
    public let id: String?
    /// <p>The line number of the node.</p>
    public let lineNumber: Int
    /// <p>The type of node that this is.</p>
    public let nodeType: String?

    public init (
        args: [CodeGenNodeArg]? = nil,
        id: String? = nil,
        lineNumber: Int = 0,
        nodeType: String? = nil
    )
    {
        self.args = args
        self.id = id
        self.lineNumber = lineNumber
        self.nodeType = nodeType
    }
}

extension CodeGenNodeArg: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case param = "Param"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if param != false {
            try encodeContainer.encode(param, forKey: .param)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let paramDecoded = try containerValues.decode(Bool.self, forKey: .param)
        param = paramDecoded
    }
}

extension CodeGenNodeArg: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeGenNodeArg(name: \(String(describing: name)), param: \(String(describing: param)), value: \(String(describing: value)))"}
}

/// <p>An argument or property of a node.</p>
public struct CodeGenNodeArg: Equatable {
    /// <p>The name of the argument or property.</p>
    public let name: String?
    /// <p>True if the value is used as a parameter.</p>
    public let param: Bool
    /// <p>The value of the argument or property.</p>
    public let value: String?

    public init (
        name: String? = nil,
        param: Bool = false,
        value: String? = nil
    )
    {
        self.name = name
        self.param = param
        self.value = value
    }
}

extension Column: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension Column: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Column(comment: \(String(describing: comment)), name: \(String(describing: name)), parameters: \(String(describing: parameters)), type: \(String(describing: type)))"}
}

/// <p>A column in a <code>Table</code>.</p>
public struct Column: Equatable {
    /// <p>A free-form text comment.</p>
    public let comment: String?
    /// <p>The name of the <code>Column</code>.</p>
    public let name: String?
    /// <p>These key-value pairs define properties associated with the column.</p>
    public let parameters: [String:String]?
    /// <p>The data type of the <code>Column</code>.</p>
    public let type: String?

    public init (
        comment: String? = nil,
        name: String? = nil,
        parameters: [String:String]? = nil,
        type: String? = nil
    )
    {
        self.comment = comment
        self.name = name
        self.parameters = parameters
        self.type = type
    }
}

extension ColumnError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnName = "ColumnName"
        case error = "Error"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(ErrorDetail.self, forKey: .error)
        error = errorDecoded
    }
}

extension ColumnError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnError(columnName: \(String(describing: columnName)), error: \(String(describing: error)))"}
}

/// <p>Encapsulates a column name that failed and the reason for failure.</p>
public struct ColumnError: Equatable {
    /// <p>The name of the column that failed.</p>
    public let columnName: String?
    /// <p>An error message with the reason for the failure of an operation.</p>
    public let error: ErrorDetail?

    public init (
        columnName: String? = nil,
        error: ErrorDetail? = nil
    )
    {
        self.columnName = columnName
        self.error = error
    }
}

extension ColumnImportance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnName = "ColumnName"
        case importance = "Importance"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let importance = importance {
            try encodeContainer.encode(importance, forKey: .importance)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let importanceDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .importance)
        importance = importanceDecoded
    }
}

extension ColumnImportance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnImportance(columnName: \(String(describing: columnName)), importance: \(String(describing: importance)))"}
}

/// <p>A structure containing the column name and column importance score for a column. </p>
/// 	
/// 	        <p>Column importance helps you understand how columns contribute to your model, by identifying which columns in your records are more important than others.</p>
public struct ColumnImportance: Equatable {
    /// <p>The name of a column.</p>
    public let columnName: String?
    /// <p>The column importance score for the column, as a decimal.</p>
    public let importance: Double?

    public init (
        columnName: String? = nil,
        importance: Double? = nil
    )
    {
        self.columnName = columnName
        self.importance = importance
    }
}

extension ColumnStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyzedTime = "AnalyzedTime"
        case columnName = "ColumnName"
        case columnType = "ColumnType"
        case statisticsData = "StatisticsData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzedTime = analyzedTime {
            try encodeContainer.encode(analyzedTime.timeIntervalSince1970, forKey: .analyzedTime)
        }
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let columnType = columnType {
            try encodeContainer.encode(columnType, forKey: .columnType)
        }
        if let statisticsData = statisticsData {
            try encodeContainer.encode(statisticsData, forKey: .statisticsData)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let columnTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnType)
        columnType = columnTypeDecoded
        let analyzedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .analyzedTime)
        analyzedTime = analyzedTimeDecoded
        let statisticsDataDecoded = try containerValues.decodeIfPresent(ColumnStatisticsData.self, forKey: .statisticsData)
        statisticsData = statisticsDataDecoded
    }
}

extension ColumnStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnStatistics(analyzedTime: \(String(describing: analyzedTime)), columnName: \(String(describing: columnName)), columnType: \(String(describing: columnType)), statisticsData: \(String(describing: statisticsData)))"}
}

/// <p>Represents the generated column-level statistics for a table or partition.</p>
public struct ColumnStatistics: Equatable {
    /// <p>The timestamp of when column statistics were generated.</p>
    public let analyzedTime: Date?
    /// <p>Name of column which statistics belong to.</p>
    public let columnName: String?
    /// <p>The data type of the column.</p>
    public let columnType: String?
    /// <p>A <code>ColumnStatisticData</code> object that contains the statistics data values.</p>
    public let statisticsData: ColumnStatisticsData?

    public init (
        analyzedTime: Date? = nil,
        columnName: String? = nil,
        columnType: String? = nil,
        statisticsData: ColumnStatisticsData? = nil
    )
    {
        self.analyzedTime = analyzedTime
        self.columnName = columnName
        self.columnType = columnType
        self.statisticsData = statisticsData
    }
}

extension ColumnStatisticsData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case binaryColumnStatisticsData = "BinaryColumnStatisticsData"
        case booleanColumnStatisticsData = "BooleanColumnStatisticsData"
        case dateColumnStatisticsData = "DateColumnStatisticsData"
        case decimalColumnStatisticsData = "DecimalColumnStatisticsData"
        case doubleColumnStatisticsData = "DoubleColumnStatisticsData"
        case longColumnStatisticsData = "LongColumnStatisticsData"
        case stringColumnStatisticsData = "StringColumnStatisticsData"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binaryColumnStatisticsData = binaryColumnStatisticsData {
            try encodeContainer.encode(binaryColumnStatisticsData, forKey: .binaryColumnStatisticsData)
        }
        if let booleanColumnStatisticsData = booleanColumnStatisticsData {
            try encodeContainer.encode(booleanColumnStatisticsData, forKey: .booleanColumnStatisticsData)
        }
        if let dateColumnStatisticsData = dateColumnStatisticsData {
            try encodeContainer.encode(dateColumnStatisticsData, forKey: .dateColumnStatisticsData)
        }
        if let decimalColumnStatisticsData = decimalColumnStatisticsData {
            try encodeContainer.encode(decimalColumnStatisticsData, forKey: .decimalColumnStatisticsData)
        }
        if let doubleColumnStatisticsData = doubleColumnStatisticsData {
            try encodeContainer.encode(doubleColumnStatisticsData, forKey: .doubleColumnStatisticsData)
        }
        if let longColumnStatisticsData = longColumnStatisticsData {
            try encodeContainer.encode(longColumnStatisticsData, forKey: .longColumnStatisticsData)
        }
        if let stringColumnStatisticsData = stringColumnStatisticsData {
            try encodeContainer.encode(stringColumnStatisticsData, forKey: .stringColumnStatisticsData)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ColumnStatisticsType.self, forKey: .type)
        type = typeDecoded
        let booleanColumnStatisticsDataDecoded = try containerValues.decodeIfPresent(BooleanColumnStatisticsData.self, forKey: .booleanColumnStatisticsData)
        booleanColumnStatisticsData = booleanColumnStatisticsDataDecoded
        let dateColumnStatisticsDataDecoded = try containerValues.decodeIfPresent(DateColumnStatisticsData.self, forKey: .dateColumnStatisticsData)
        dateColumnStatisticsData = dateColumnStatisticsDataDecoded
        let decimalColumnStatisticsDataDecoded = try containerValues.decodeIfPresent(DecimalColumnStatisticsData.self, forKey: .decimalColumnStatisticsData)
        decimalColumnStatisticsData = decimalColumnStatisticsDataDecoded
        let doubleColumnStatisticsDataDecoded = try containerValues.decodeIfPresent(DoubleColumnStatisticsData.self, forKey: .doubleColumnStatisticsData)
        doubleColumnStatisticsData = doubleColumnStatisticsDataDecoded
        let longColumnStatisticsDataDecoded = try containerValues.decodeIfPresent(LongColumnStatisticsData.self, forKey: .longColumnStatisticsData)
        longColumnStatisticsData = longColumnStatisticsDataDecoded
        let stringColumnStatisticsDataDecoded = try containerValues.decodeIfPresent(StringColumnStatisticsData.self, forKey: .stringColumnStatisticsData)
        stringColumnStatisticsData = stringColumnStatisticsDataDecoded
        let binaryColumnStatisticsDataDecoded = try containerValues.decodeIfPresent(BinaryColumnStatisticsData.self, forKey: .binaryColumnStatisticsData)
        binaryColumnStatisticsData = binaryColumnStatisticsDataDecoded
    }
}

extension ColumnStatisticsData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnStatisticsData(binaryColumnStatisticsData: \(String(describing: binaryColumnStatisticsData)), booleanColumnStatisticsData: \(String(describing: booleanColumnStatisticsData)), dateColumnStatisticsData: \(String(describing: dateColumnStatisticsData)), decimalColumnStatisticsData: \(String(describing: decimalColumnStatisticsData)), doubleColumnStatisticsData: \(String(describing: doubleColumnStatisticsData)), longColumnStatisticsData: \(String(describing: longColumnStatisticsData)), stringColumnStatisticsData: \(String(describing: stringColumnStatisticsData)), type: \(String(describing: type)))"}
}

/// <p>Contains the individual types of column statistics data. Only one data object should be set and indicated by the <code>Type</code> attribute.</p>
public struct ColumnStatisticsData: Equatable {
    /// <p>Binary column statistics data.</p>
    public let binaryColumnStatisticsData: BinaryColumnStatisticsData?
    /// <p>Boolean column statistics data.</p>
    public let booleanColumnStatisticsData: BooleanColumnStatisticsData?
    /// <p>Date column statistics data.</p>
    public let dateColumnStatisticsData: DateColumnStatisticsData?
    /// <p>Decimal column statistics data.</p>
    public let decimalColumnStatisticsData: DecimalColumnStatisticsData?
    /// <p>Double column statistics data.</p>
    public let doubleColumnStatisticsData: DoubleColumnStatisticsData?
    /// <p>Long column statistics data.</p>
    public let longColumnStatisticsData: LongColumnStatisticsData?
    /// <p>String column statistics data.</p>
    public let stringColumnStatisticsData: StringColumnStatisticsData?
    /// <p>The type of column statistics data.</p>
    public let type: ColumnStatisticsType?

    public init (
        binaryColumnStatisticsData: BinaryColumnStatisticsData? = nil,
        booleanColumnStatisticsData: BooleanColumnStatisticsData? = nil,
        dateColumnStatisticsData: DateColumnStatisticsData? = nil,
        decimalColumnStatisticsData: DecimalColumnStatisticsData? = nil,
        doubleColumnStatisticsData: DoubleColumnStatisticsData? = nil,
        longColumnStatisticsData: LongColumnStatisticsData? = nil,
        stringColumnStatisticsData: StringColumnStatisticsData? = nil,
        type: ColumnStatisticsType? = nil
    )
    {
        self.binaryColumnStatisticsData = binaryColumnStatisticsData
        self.booleanColumnStatisticsData = booleanColumnStatisticsData
        self.dateColumnStatisticsData = dateColumnStatisticsData
        self.decimalColumnStatisticsData = decimalColumnStatisticsData
        self.doubleColumnStatisticsData = doubleColumnStatisticsData
        self.longColumnStatisticsData = longColumnStatisticsData
        self.stringColumnStatisticsData = stringColumnStatisticsData
        self.type = type
    }
}

extension ColumnStatisticsError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnStatistics = "ColumnStatistics"
        case error = "Error"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnStatistics = columnStatistics {
            try encodeContainer.encode(columnStatistics, forKey: .columnStatistics)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnStatisticsDecoded = try containerValues.decodeIfPresent(ColumnStatistics.self, forKey: .columnStatistics)
        columnStatistics = columnStatisticsDecoded
        let errorDecoded = try containerValues.decodeIfPresent(ErrorDetail.self, forKey: .error)
        error = errorDecoded
    }
}

extension ColumnStatisticsError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnStatisticsError(columnStatistics: \(String(describing: columnStatistics)), error: \(String(describing: error)))"}
}

/// <p>Encapsulates a <code>ColumnStatistics</code> object that failed and the reason for failure.</p>
public struct ColumnStatisticsError: Equatable {
    /// <p>The <code>ColumnStatistics</code> of the column.</p>
    public let columnStatistics: ColumnStatistics?
    /// <p>An error message with the reason for the failure of an operation.</p>
    public let error: ErrorDetail?

    public init (
        columnStatistics: ColumnStatistics? = nil,
        error: ErrorDetail? = nil
    )
    {
        self.columnStatistics = columnStatistics
        self.error = error
    }
}

public enum ColumnStatisticsType {
    case binary
    case boolean
    case date
    case decimal
    case double
    case long
    case string
    case sdkUnknown(String)
}

extension ColumnStatisticsType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ColumnStatisticsType] {
        return [
            .binary,
            .boolean,
            .date,
            .decimal,
            .double,
            .long,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .binary: return "BINARY"
        case .boolean: return "BOOLEAN"
        case .date: return "DATE"
        case .decimal: return "DECIMAL"
        case .double: return "DOUBLE"
        case .long: return "LONG"
        case .string: return "STRING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ColumnStatisticsType(rawValue: rawValue) ?? ColumnStatisticsType.sdkUnknown(rawValue)
    }
}

public enum Comparator {
    case equals
    case greaterThan
    case greaterThanEquals
    case lessThan
    case lessThanEquals
    case sdkUnknown(String)
}

extension Comparator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Comparator] {
        return [
            .equals,
            .greaterThan,
            .greaterThanEquals,
            .lessThan,
            .lessThanEquals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equals: return "EQUALS"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanEquals: return "GREATER_THAN_EQUALS"
        case .lessThan: return "LESS_THAN"
        case .lessThanEquals: return "LESS_THAN_EQUALS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Comparator(rawValue: rawValue) ?? Comparator.sdkUnknown(rawValue)
    }
}

public enum Compatibility {
    case backward
    case backwardAll
    case disabled
    case forward
    case forwardAll
    case full
    case fullAll
    case `none`
    case sdkUnknown(String)
}

extension Compatibility : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Compatibility] {
        return [
            .backward,
            .backwardAll,
            .disabled,
            .forward,
            .forwardAll,
            .full,
            .fullAll,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .backward: return "BACKWARD"
        case .backwardAll: return "BACKWARD_ALL"
        case .disabled: return "DISABLED"
        case .forward: return "FORWARD"
        case .forwardAll: return "FORWARD_ALL"
        case .full: return "FULL"
        case .fullAll: return "FULL_ALL"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Compatibility(rawValue: rawValue) ?? Compatibility.sdkUnknown(rawValue)
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Two processes are trying to modify a resource simultaneously.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentRunsExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentRunsExceededException(message: \(String(describing: message)))"}
}

extension ConcurrentRunsExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentRunsExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Too many jobs are being run concurrently.</p>
public struct ConcurrentRunsExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentRunsExceededExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentRunsExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Condition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlState = "CrawlState"
        case crawlerName = "CrawlerName"
        case jobName = "JobName"
        case logicalOperator = "LogicalOperator"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawlState = crawlState {
            try encodeContainer.encode(crawlState.rawValue, forKey: .crawlState)
        }
        if let crawlerName = crawlerName {
            try encodeContainer.encode(crawlerName, forKey: .crawlerName)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let logicalOperator = logicalOperator {
            try encodeContainer.encode(logicalOperator.rawValue, forKey: .logicalOperator)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logicalOperatorDecoded = try containerValues.decodeIfPresent(LogicalOperator.self, forKey: .logicalOperator)
        logicalOperator = logicalOperatorDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(JobRunState.self, forKey: .state)
        state = stateDecoded
        let crawlerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .crawlerName)
        crawlerName = crawlerNameDecoded
        let crawlStateDecoded = try containerValues.decodeIfPresent(CrawlState.self, forKey: .crawlState)
        crawlState = crawlStateDecoded
    }
}

extension Condition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Condition(crawlState: \(String(describing: crawlState)), crawlerName: \(String(describing: crawlerName)), jobName: \(String(describing: jobName)), logicalOperator: \(String(describing: logicalOperator)), state: \(String(describing: state)))"}
}

/// <p>Defines a condition under which a trigger fires.</p>
public struct Condition: Equatable {
    /// <p>The state of the crawler to which this condition applies.</p>
    public let crawlState: CrawlState?
    /// <p>The name of the crawler to which this condition applies.</p>
    public let crawlerName: String?
    /// <p>The name of the job whose <code>JobRuns</code> this condition applies to, and on which
    ///       this trigger waits.</p>
    public let jobName: String?
    /// <p>A logical operator.</p>
    public let logicalOperator: LogicalOperator?
    /// <p>The condition state. Currently, the only job states that a trigger can listen for are <code>SUCCEEDED</code>, <code>STOPPED</code>, <code>FAILED</code>, and <code>TIMEOUT</code>. The only crawler states that a trigger can listen for are <code>SUCCEEDED</code>, <code>FAILED</code>, and <code>CANCELLED</code>.</p>
    public let state: JobRunState?

    public init (
        crawlState: CrawlState? = nil,
        crawlerName: String? = nil,
        jobName: String? = nil,
        logicalOperator: LogicalOperator? = nil,
        state: JobRunState? = nil
    )
    {
        self.crawlState = crawlState
        self.crawlerName = crawlerName
        self.jobName = jobName
        self.logicalOperator = logicalOperator
        self.state = state
    }
}

extension ConditionCheckFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConditionCheckFailureException(message: \(String(describing: message)))"}
}

extension ConditionCheckFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConditionCheckFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified condition was not satisfied.</p>
public struct ConditionCheckFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConditionCheckFailureExceptionBody: Equatable {
    public let message: String?
}

extension ConditionCheckFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>CreatePartitions</code> API was called on a table that has indexes enabled.	</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfusionMatrix: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numFalseNegatives = "NumFalseNegatives"
        case numFalsePositives = "NumFalsePositives"
        case numTrueNegatives = "NumTrueNegatives"
        case numTruePositives = "NumTruePositives"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numFalseNegatives = numFalseNegatives {
            try encodeContainer.encode(numFalseNegatives, forKey: .numFalseNegatives)
        }
        if let numFalsePositives = numFalsePositives {
            try encodeContainer.encode(numFalsePositives, forKey: .numFalsePositives)
        }
        if let numTrueNegatives = numTrueNegatives {
            try encodeContainer.encode(numTrueNegatives, forKey: .numTrueNegatives)
        }
        if let numTruePositives = numTruePositives {
            try encodeContainer.encode(numTruePositives, forKey: .numTruePositives)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numTruePositivesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numTruePositives)
        numTruePositives = numTruePositivesDecoded
        let numFalsePositivesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numFalsePositives)
        numFalsePositives = numFalsePositivesDecoded
        let numTrueNegativesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numTrueNegatives)
        numTrueNegatives = numTrueNegativesDecoded
        let numFalseNegativesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numFalseNegatives)
        numFalseNegatives = numFalseNegativesDecoded
    }
}

extension ConfusionMatrix: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfusionMatrix(numFalseNegatives: \(String(describing: numFalseNegatives)), numFalsePositives: \(String(describing: numFalsePositives)), numTrueNegatives: \(String(describing: numTrueNegatives)), numTruePositives: \(String(describing: numTruePositives)))"}
}

/// <p>The confusion matrix shows you what your transform is predicting accurately and what types of errors it is making.</p>
/// 	
/// 	        <p>For more information, see <a href="https://en.wikipedia.org/wiki/Confusion_matrix">Confusion matrix</a> in Wikipedia.</p>
public struct ConfusionMatrix: Equatable {
    /// <p>The number of matches in the data that the transform didn't find, in the confusion matrix for your transform.</p>
    public let numFalseNegatives: Int?
    /// <p>The number of nonmatches in the data that the transform incorrectly classified as a match,
    ///       in the confusion matrix for your transform.</p>
    public let numFalsePositives: Int?
    /// <p>The number of nonmatches in the data that the transform correctly rejected, in the
    ///       confusion matrix for your transform.</p>
    public let numTrueNegatives: Int?
    /// <p>The number of matches in the data that the transform correctly found, in the confusion matrix for your transform.</p>
    public let numTruePositives: Int?

    public init (
        numFalseNegatives: Int? = nil,
        numFalsePositives: Int? = nil,
        numTrueNegatives: Int? = nil,
        numTruePositives: Int? = nil
    )
    {
        self.numFalseNegatives = numFalseNegatives
        self.numFalsePositives = numFalsePositives
        self.numTrueNegatives = numTrueNegatives
        self.numTruePositives = numTruePositives
    }
}

extension Connection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionProperties = "ConnectionProperties"
        case connectionType = "ConnectionType"
        case creationTime = "CreationTime"
        case description = "Description"
        case lastUpdatedBy = "LastUpdatedBy"
        case lastUpdatedTime = "LastUpdatedTime"
        case matchCriteria = "MatchCriteria"
        case name = "Name"
        case physicalConnectionRequirements = "PhysicalConnectionRequirements"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionProperties = connectionProperties {
            var connectionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .connectionProperties)
            for (dictKey0, connectionproperties0) in connectionProperties {
                try connectionPropertiesContainer.encode(connectionproperties0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedBy = lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let matchCriteria = matchCriteria {
            var matchCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchCriteria)
            for matchcriteria0 in matchCriteria {
                try matchCriteriaContainer.encode(matchcriteria0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let physicalConnectionRequirements = physicalConnectionRequirements {
            try encodeContainer.encode(physicalConnectionRequirements, forKey: .physicalConnectionRequirements)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let matchCriteriaContainer = try containerValues.decodeIfPresent([String?].self, forKey: .matchCriteria)
        var matchCriteriaDecoded0:[String]? = nil
        if let matchCriteriaContainer = matchCriteriaContainer {
            matchCriteriaDecoded0 = [String]()
            for string0 in matchCriteriaContainer {
                if let string0 = string0 {
                    matchCriteriaDecoded0?.append(string0)
                }
            }
        }
        matchCriteria = matchCriteriaDecoded0
        let connectionPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .connectionProperties)
        var connectionPropertiesDecoded0: [String:String]? = nil
        if let connectionPropertiesContainer = connectionPropertiesContainer {
            connectionPropertiesDecoded0 = [String:String]()
            for (key0, valuestring0) in connectionPropertiesContainer {
                if let valuestring0 = valuestring0 {
                    connectionPropertiesDecoded0?[key0] = valuestring0
                }
            }
        }
        connectionProperties = connectionPropertiesDecoded0
        let physicalConnectionRequirementsDecoded = try containerValues.decodeIfPresent(PhysicalConnectionRequirements.self, forKey: .physicalConnectionRequirements)
        physicalConnectionRequirements = physicalConnectionRequirementsDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
    }
}

extension Connection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Connection(connectionProperties: \(String(describing: connectionProperties)), connectionType: \(String(describing: connectionType)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), lastUpdatedBy: \(String(describing: lastUpdatedBy)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), matchCriteria: \(String(describing: matchCriteria)), name: \(String(describing: name)), physicalConnectionRequirements: \(String(describing: physicalConnectionRequirements)))"}
}

/// <p>Defines a connection to a data source.</p>
public struct Connection: Equatable {
    /// <p>These key-value pairs define parameters for the connection:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HOST</code> - The host URI: either the
    ///         fully qualified domain name (FQDN) or the IPv4 address of
    ///         the database host.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PORT</code> - The port number, between
    ///         1024 and 65535, of the port on which the database host is
    ///         listening for database connections.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>USER_NAME</code> -  The name under which
    ///         to log in to the database. The value string for <code>USER_NAME</code> is "<code>USERNAME</code>".</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PASSWORD</code> - A password,
    ///         if one is used, for the user name.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ENCRYPTED_PASSWORD</code> - When you enable connection password protection by setting <code>ConnectionPasswordEncryption</code> in the Data Catalog encryption settings, this field stores the encrypted password.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JDBC_DRIVER_JAR_URI</code> - The Amazon Simple Storage Service (Amazon S3) path of the
    ///           JAR file that contains the JDBC driver to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JDBC_DRIVER_CLASS_NAME</code> - The class name of the JDBC driver to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JDBC_ENGINE</code> - The name of the JDBC engine to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JDBC_ENGINE_VERSION</code> - The version of the JDBC engine to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CONFIG_FILES</code> - (Reserved for future use.)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INSTANCE_ID</code> - The instance ID to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JDBC_CONNECTION_URL</code> - The URL for connecting to a JDBC data source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JDBC_ENFORCE_SSL</code> - A Boolean string (true, false) specifying whether Secure
    ///           Sockets Layer (SSL) with hostname matching is enforced for the JDBC connection on the
    ///           client. The default is false.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CUSTOM_JDBC_CERT</code> - An Amazon S3 location specifying the customer's root certificate. AWS Glue uses this root certificate to validate the customer’s certificate when connecting to the customer database. AWS Glue only handles X.509 certificates. The certificate provided must be DER-encoded and supplied in Base64 encoding PEM format.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SKIP_CUSTOM_JDBC_CERT_VALIDATION</code> - By default, this is <code>false</code>. AWS Glue validates the Signature algorithm and Subject Public Key Algorithm for the customer certificate. The only permitted algorithms for the Signature algorithm are SHA256withRSA, SHA384withRSA or SHA512withRSA. For the Subject Public Key Algorithm, the key length must be at least 2048. You can set the value of this property to <code>true</code> to skip AWS Glue’s validation of the customer certificate.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CUSTOM_JDBC_CERT_STRING</code> - A custom JDBC certificate string which is used for domain match or distinguished name match to prevent a man-in-the-middle attack. In Oracle database, this is used as the <code>SSL_SERVER_CERT_DN</code>; in Microsoft SQL Server, this is used as the <code>hostNameInCertificate</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CONNECTION_URL</code> - The URL for connecting to a general (non-JDBC) data source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>KAFKA_BOOTSTRAP_SERVERS</code> - A comma-separated list of host and port pairs that are the addresses of the Apache Kafka brokers in a Kafka cluster to which a Kafka client will connect to and bootstrap itself.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>KAFKA_SSL_ENABLED</code> - Whether to enable or disable SSL on an Apache Kafka connection. Default value is "true".</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>KAFKA_CUSTOM_CERT</code> - The Amazon S3 URL for the private CA cert file (.pem format). The default is an empty string.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>KAFKA_SKIP_CUSTOM_CERT_VALIDATION</code> - Whether to skip the validation of the CA cert file or not. AWS Glue validates for three algorithms: SHA256withRSA, SHA384withRSA and SHA512withRSA. Default value is "false".</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SECRET_ID</code> - The secret ID used for the secret manager of credentials.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CONNECTOR_URL</code> - The connector URL for a MARKETPLACE or CUSTOM connection.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CONNECTOR_TYPE</code> - The connector type for a MARKETPLACE or CUSTOM connection.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CONNECTOR_CLASS_NAME</code> - The connector class name for a MARKETPLACE or CUSTOM connection.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>KAFKA_CLIENT_KEYSTORE</code> - The Amazon S3 location of the client keystore file for Kafka client side authentication (Optional).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>KAFKA_CLIENT_KEYSTORE_PASSWORD</code> - The password to access the provided keystore (Optional).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>KAFKA_CLIENT_KEY_PASSWORD</code> - A keystore can consist of multiple keys, so this is the password to access the client key to be used with the Kafka server side key (Optional).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD</code> - The encrypted version of the Kafka client keystore password (if the user has the AWS Glue encrypt passwords setting selected).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD</code> - The encrypted version of the Kafka client key password (if the user has the AWS Glue encrypt passwords setting selected).</p>
    ///             </li>
    ///          </ul>
    public let connectionProperties: [String:String]?
    /// <p>The type of the connection. Currently, SFTP is not supported.</p>
    public let connectionType: ConnectionType?
    /// <p>The time that this connection definition was created.</p>
    public let creationTime: Date?
    /// <p>The description of the connection.</p>
    public let description: String?
    /// <p>The user, group, or role that last updated this connection definition.</p>
    public let lastUpdatedBy: String?
    /// <p>The last time that this connection definition was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>A list of criteria that can be used in selecting this connection.</p>
    public let matchCriteria: [String]?
    /// <p>The name of the connection definition.</p>
    public let name: String?
    /// <p>A map of physical connection requirements, such as virtual private cloud (VPC) and
    ///         <code>SecurityGroup</code>, that are needed to make this connection successfully.</p>
    public let physicalConnectionRequirements: PhysicalConnectionRequirements?

    public init (
        connectionProperties: [String:String]? = nil,
        connectionType: ConnectionType? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        lastUpdatedBy: String? = nil,
        lastUpdatedTime: Date? = nil,
        matchCriteria: [String]? = nil,
        name: String? = nil,
        physicalConnectionRequirements: PhysicalConnectionRequirements? = nil
    )
    {
        self.connectionProperties = connectionProperties
        self.connectionType = connectionType
        self.creationTime = creationTime
        self.description = description
        self.lastUpdatedBy = lastUpdatedBy
        self.lastUpdatedTime = lastUpdatedTime
        self.matchCriteria = matchCriteria
        self.name = name
        self.physicalConnectionRequirements = physicalConnectionRequirements
    }
}

extension ConnectionInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionProperties = "ConnectionProperties"
        case connectionType = "ConnectionType"
        case description = "Description"
        case matchCriteria = "MatchCriteria"
        case name = "Name"
        case physicalConnectionRequirements = "PhysicalConnectionRequirements"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionProperties = connectionProperties {
            var connectionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .connectionProperties)
            for (dictKey0, connectionproperties0) in connectionProperties {
                try connectionPropertiesContainer.encode(connectionproperties0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let matchCriteria = matchCriteria {
            var matchCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchCriteria)
            for matchcriteria0 in matchCriteria {
                try matchCriteriaContainer.encode(matchcriteria0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let physicalConnectionRequirements = physicalConnectionRequirements {
            try encodeContainer.encode(physicalConnectionRequirements, forKey: .physicalConnectionRequirements)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let matchCriteriaContainer = try containerValues.decodeIfPresent([String?].self, forKey: .matchCriteria)
        var matchCriteriaDecoded0:[String]? = nil
        if let matchCriteriaContainer = matchCriteriaContainer {
            matchCriteriaDecoded0 = [String]()
            for string0 in matchCriteriaContainer {
                if let string0 = string0 {
                    matchCriteriaDecoded0?.append(string0)
                }
            }
        }
        matchCriteria = matchCriteriaDecoded0
        let connectionPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .connectionProperties)
        var connectionPropertiesDecoded0: [String:String]? = nil
        if let connectionPropertiesContainer = connectionPropertiesContainer {
            connectionPropertiesDecoded0 = [String:String]()
            for (key0, valuestring0) in connectionPropertiesContainer {
                if let valuestring0 = valuestring0 {
                    connectionPropertiesDecoded0?[key0] = valuestring0
                }
            }
        }
        connectionProperties = connectionPropertiesDecoded0
        let physicalConnectionRequirementsDecoded = try containerValues.decodeIfPresent(PhysicalConnectionRequirements.self, forKey: .physicalConnectionRequirements)
        physicalConnectionRequirements = physicalConnectionRequirementsDecoded
    }
}

extension ConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionInput(connectionProperties: \(String(describing: connectionProperties)), connectionType: \(String(describing: connectionType)), description: \(String(describing: description)), matchCriteria: \(String(describing: matchCriteria)), name: \(String(describing: name)), physicalConnectionRequirements: \(String(describing: physicalConnectionRequirements)))"}
}

/// <p>A structure that is used to specify a connection to create or update.</p>
public struct ConnectionInput: Equatable {
    /// <p>These key-value pairs define parameters for the connection.</p>
    public let connectionProperties: [String:String]?
    /// <p>The type of the connection. Currently, these types are supported:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>
    ///                   <code>JDBC</code> - Designates a connection to a database through Java Database Connectivity (JDBC).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>KAFKA</code> - Designates a connection to an Apache Kafka streaming platform.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MONGODB</code> - Designates a connection to a MongoDB document database.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NETWORK</code> - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MARKETPLACE</code> - Uses configuration settings contained in a connector purchased from AWS Marketplace to read from and write to data stores that are not natively supported by AWS Glue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CUSTOM</code> - Uses configuration settings contained in a custom connector to read from and write to data stores that are not natively supported by AWS Glue.</p>
    ///             </li>
    ///          </ul>
    ///          <p>SFTP is not supported.</p>
    public let connectionType: ConnectionType?
    /// <p>The description of the connection.</p>
    public let description: String?
    /// <p>A list of criteria that can be used in selecting this connection.</p>
    public let matchCriteria: [String]?
    /// <p>The name of the connection.</p>
    public let name: String?
    /// <p>A map of physical connection requirements, such as virtual private cloud (VPC) and
    ///         <code>SecurityGroup</code>, that are needed to successfully make this connection.</p>
    public let physicalConnectionRequirements: PhysicalConnectionRequirements?

    public init (
        connectionProperties: [String:String]? = nil,
        connectionType: ConnectionType? = nil,
        description: String? = nil,
        matchCriteria: [String]? = nil,
        name: String? = nil,
        physicalConnectionRequirements: PhysicalConnectionRequirements? = nil
    )
    {
        self.connectionProperties = connectionProperties
        self.connectionType = connectionType
        self.description = description
        self.matchCriteria = matchCriteria
        self.name = name
        self.physicalConnectionRequirements = physicalConnectionRequirements
    }
}

extension ConnectionPasswordEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsKmsKeyId = "AwsKmsKeyId"
        case returnConnectionPasswordEncrypted = "ReturnConnectionPasswordEncrypted"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsKmsKeyId = awsKmsKeyId {
            try encodeContainer.encode(awsKmsKeyId, forKey: .awsKmsKeyId)
        }
        if returnConnectionPasswordEncrypted != false {
            try encodeContainer.encode(returnConnectionPasswordEncrypted, forKey: .returnConnectionPasswordEncrypted)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnConnectionPasswordEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .returnConnectionPasswordEncrypted)
        returnConnectionPasswordEncrypted = returnConnectionPasswordEncryptedDecoded
        let awsKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsKmsKeyId)
        awsKmsKeyId = awsKmsKeyIdDecoded
    }
}

extension ConnectionPasswordEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionPasswordEncryption(awsKmsKeyId: \(String(describing: awsKmsKeyId)), returnConnectionPasswordEncrypted: \(String(describing: returnConnectionPasswordEncrypted)))"}
}

/// <p>The data structure used by the Data Catalog to encrypt the password as part of
///         <code>CreateConnection</code> or <code>UpdateConnection</code> and store it in the
///         <code>ENCRYPTED_PASSWORD</code> field in the connection properties. You can enable catalog
///       encryption or only password encryption.</p>
/// 	
/// 	        <p>When a <code>CreationConnection</code> request arrives containing a password, the Data
///       Catalog first encrypts the password using your AWS KMS key. It then encrypts the whole
///       connection object again if catalog encryption is also enabled.</p>
///
///          <p>This encryption requires that you set AWS KMS key permissions to enable or restrict access
///       on the password key according to your security requirements. For example, you might want only
///       administrators to have decrypt permission on the password key.</p>
public struct ConnectionPasswordEncryption: Equatable {
    /// <p>An AWS KMS key that is used to encrypt the connection password. </p>
    /// 	
    ///          <p>If connection password protection is enabled, the caller of <code>CreateConnection</code>
    ///       and <code>UpdateConnection</code> needs at least <code>kms:Encrypt</code> permission on the
    ///       specified AWS KMS key, to encrypt passwords before storing them in the Data Catalog. </p>
    ///
    /// 	        <p>You can set the decrypt permission to enable or restrict access on the password key according to your security requirements.</p>
    public let awsKmsKeyId: String?
    /// <p>When the <code>ReturnConnectionPasswordEncrypted</code> flag is set to "true", passwords remain encrypted in the responses of <code>GetConnection</code> and <code>GetConnections</code>. This encryption takes effect independently from catalog encryption. </p>
    public let returnConnectionPasswordEncrypted: Bool

    public init (
        awsKmsKeyId: String? = nil,
        returnConnectionPasswordEncrypted: Bool = false
    )
    {
        self.awsKmsKeyId = awsKmsKeyId
        self.returnConnectionPasswordEncrypted = returnConnectionPasswordEncrypted
    }
}

public enum ConnectionPropertyKey {
    case configFiles
    case connectionUrl
    case connectorClassName
    case connectorType
    case connectorUrl
    case customJdbcCert
    case customJdbcCertString
    case encryptedKafkaClientKeystorePassword
    case encryptedKafkaClientKeyPassword
    case encryptedPassword
    case host
    case instanceId
    case jdbcConnectionUrl
    case jdbcDriverClassName
    case jdbcDriverJarUri
    case jdbcEnforceSsl
    case jdbcEngine
    case jdbcEngineVersion
    case kafkaBootstrapServers
    case kafkaClientKeystore
    case kafkaClientKeystorePassword
    case kafkaClientKeyPassword
    case kafkaCustomCert
    case kafkaSkipCustomCertValidation
    case kafkaSslEnabled
    case password
    case port
    case secretId
    case skipCustomJdbcCertValidation
    case userName
    case sdkUnknown(String)
}

extension ConnectionPropertyKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionPropertyKey] {
        return [
            .configFiles,
            .connectionUrl,
            .connectorClassName,
            .connectorType,
            .connectorUrl,
            .customJdbcCert,
            .customJdbcCertString,
            .encryptedKafkaClientKeystorePassword,
            .encryptedKafkaClientKeyPassword,
            .encryptedPassword,
            .host,
            .instanceId,
            .jdbcConnectionUrl,
            .jdbcDriverClassName,
            .jdbcDriverJarUri,
            .jdbcEnforceSsl,
            .jdbcEngine,
            .jdbcEngineVersion,
            .kafkaBootstrapServers,
            .kafkaClientKeystore,
            .kafkaClientKeystorePassword,
            .kafkaClientKeyPassword,
            .kafkaCustomCert,
            .kafkaSkipCustomCertValidation,
            .kafkaSslEnabled,
            .password,
            .port,
            .secretId,
            .skipCustomJdbcCertValidation,
            .userName,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configFiles: return "CONFIG_FILES"
        case .connectionUrl: return "CONNECTION_URL"
        case .connectorClassName: return "CONNECTOR_CLASS_NAME"
        case .connectorType: return "CONNECTOR_TYPE"
        case .connectorUrl: return "CONNECTOR_URL"
        case .customJdbcCert: return "CUSTOM_JDBC_CERT"
        case .customJdbcCertString: return "CUSTOM_JDBC_CERT_STRING"
        case .encryptedKafkaClientKeystorePassword: return "ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"
        case .encryptedKafkaClientKeyPassword: return "ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"
        case .encryptedPassword: return "ENCRYPTED_PASSWORD"
        case .host: return "HOST"
        case .instanceId: return "INSTANCE_ID"
        case .jdbcConnectionUrl: return "JDBC_CONNECTION_URL"
        case .jdbcDriverClassName: return "JDBC_DRIVER_CLASS_NAME"
        case .jdbcDriverJarUri: return "JDBC_DRIVER_JAR_URI"
        case .jdbcEnforceSsl: return "JDBC_ENFORCE_SSL"
        case .jdbcEngine: return "JDBC_ENGINE"
        case .jdbcEngineVersion: return "JDBC_ENGINE_VERSION"
        case .kafkaBootstrapServers: return "KAFKA_BOOTSTRAP_SERVERS"
        case .kafkaClientKeystore: return "KAFKA_CLIENT_KEYSTORE"
        case .kafkaClientKeystorePassword: return "KAFKA_CLIENT_KEYSTORE_PASSWORD"
        case .kafkaClientKeyPassword: return "KAFKA_CLIENT_KEY_PASSWORD"
        case .kafkaCustomCert: return "KAFKA_CUSTOM_CERT"
        case .kafkaSkipCustomCertValidation: return "KAFKA_SKIP_CUSTOM_CERT_VALIDATION"
        case .kafkaSslEnabled: return "KAFKA_SSL_ENABLED"
        case .password: return "PASSWORD"
        case .port: return "PORT"
        case .secretId: return "SECRET_ID"
        case .skipCustomJdbcCertValidation: return "SKIP_CUSTOM_JDBC_CERT_VALIDATION"
        case .userName: return "USERNAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionPropertyKey(rawValue: rawValue) ?? ConnectionPropertyKey.sdkUnknown(rawValue)
    }
}

public enum ConnectionType {
    case custom
    case jdbc
    case kafka
    case marketplace
    case mongodb
    case network
    case sftp
    case sdkUnknown(String)
}

extension ConnectionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionType] {
        return [
            .custom,
            .jdbc,
            .kafka,
            .marketplace,
            .mongodb,
            .network,
            .sftp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .custom: return "CUSTOM"
        case .jdbc: return "JDBC"
        case .kafka: return "KAFKA"
        case .marketplace: return "MARKETPLACE"
        case .mongodb: return "MONGODB"
        case .network: return "NETWORK"
        case .sftp: return "SFTP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
    }
}

extension ConnectionsList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connections = "Connections"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connections = connections {
            var connectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connections)
            for orchestrationstringlist0 in connections {
                try connectionsContainer.encode(orchestrationstringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .connections)
        var connectionsDecoded0:[String]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [String]()
            for string0 in connectionsContainer {
                if let string0 = string0 {
                    connectionsDecoded0?.append(string0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

extension ConnectionsList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionsList(connections: \(String(describing: connections)))"}
}

/// <p>Specifies the connections used by a job.</p>
public struct ConnectionsList: Equatable {
    /// <p>A list of connections used by the job.</p>
    public let connections: [String]?

    public init (
        connections: [String]? = nil
    )
    {
        self.connections = connections
    }
}

extension Crawl: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completedOn = "CompletedOn"
        case errorMessage = "ErrorMessage"
        case logGroup = "LogGroup"
        case logStream = "LogStream"
        case startedOn = "StartedOn"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedOn = completedOn {
            try encodeContainer.encode(completedOn.timeIntervalSince1970, forKey: .completedOn)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let logGroup = logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
        if let logStream = logStream {
            try encodeContainer.encode(logStream, forKey: .logStream)
        }
        if let startedOn = startedOn {
            try encodeContainer.encode(startedOn.timeIntervalSince1970, forKey: .startedOn)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(CrawlState.self, forKey: .state)
        state = stateDecoded
        let startedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedOn)
        startedOn = startedOnDecoded
        let completedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedOn)
        completedOn = completedOnDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let logGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
        let logStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logStream)
        logStream = logStreamDecoded
    }
}

extension Crawl: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Crawl(completedOn: \(String(describing: completedOn)), errorMessage: \(String(describing: errorMessage)), logGroup: \(String(describing: logGroup)), logStream: \(String(describing: logStream)), startedOn: \(String(describing: startedOn)), state: \(String(describing: state)))"}
}

/// <p>The details of a crawl in the workflow.</p>
public struct Crawl: Equatable {
    /// <p>The date and time on which the crawl completed.</p>
    public let completedOn: Date?
    /// <p>The error message associated with the crawl.</p>
    public let errorMessage: String?
    /// <p>The log group associated with the crawl.</p>
    public let logGroup: String?
    /// <p>The log stream associated with the crawl.</p>
    public let logStream: String?
    /// <p>The date and time on which the crawl started.</p>
    public let startedOn: Date?
    /// <p>The state of the crawler.</p>
    public let state: CrawlState?

    public init (
        completedOn: Date? = nil,
        errorMessage: String? = nil,
        logGroup: String? = nil,
        logStream: String? = nil,
        startedOn: Date? = nil,
        state: CrawlState? = nil
    )
    {
        self.completedOn = completedOn
        self.errorMessage = errorMessage
        self.logGroup = logGroup
        self.logStream = logStream
        self.startedOn = startedOn
        self.state = state
    }
}

public enum CrawlState {
    case cancelled
    case cancelling
    case failed
    case running
    case succeeded
    case sdkUnknown(String)
}

extension CrawlState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CrawlState] {
        return [
            .cancelled,
            .cancelling,
            .failed,
            .running,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .cancelling: return "CANCELLING"
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CrawlState(rawValue: rawValue) ?? CrawlState.sdkUnknown(rawValue)
    }
}

extension Crawler: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classifiers = "Classifiers"
        case configuration = "Configuration"
        case crawlElapsedTime = "CrawlElapsedTime"
        case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
        case creationTime = "CreationTime"
        case databaseName = "DatabaseName"
        case description = "Description"
        case lastCrawl = "LastCrawl"
        case lastUpdated = "LastUpdated"
        case lineageConfiguration = "LineageConfiguration"
        case name = "Name"
        case recrawlPolicy = "RecrawlPolicy"
        case role = "Role"
        case schedule = "Schedule"
        case schemaChangePolicy = "SchemaChangePolicy"
        case state = "State"
        case tablePrefix = "TablePrefix"
        case targets = "Targets"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classifiers = classifiers {
            var classifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .classifiers)
            for classifiernamelist0 in classifiers {
                try classifiersContainer.encode(classifiernamelist0)
            }
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if crawlElapsedTime != 0 {
            try encodeContainer.encode(crawlElapsedTime, forKey: .crawlElapsedTime)
        }
        if let crawlerSecurityConfiguration = crawlerSecurityConfiguration {
            try encodeContainer.encode(crawlerSecurityConfiguration, forKey: .crawlerSecurityConfiguration)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastCrawl = lastCrawl {
            try encodeContainer.encode(lastCrawl, forKey: .lastCrawl)
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let lineageConfiguration = lineageConfiguration {
            try encodeContainer.encode(lineageConfiguration, forKey: .lineageConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recrawlPolicy = recrawlPolicy {
            try encodeContainer.encode(recrawlPolicy, forKey: .recrawlPolicy)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let schemaChangePolicy = schemaChangePolicy {
            try encodeContainer.encode(schemaChangePolicy, forKey: .schemaChangePolicy)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tablePrefix = tablePrefix {
            try encodeContainer.encode(tablePrefix, forKey: .tablePrefix)
        }
        if let targets = targets {
            try encodeContainer.encode(targets, forKey: .targets)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let targetsDecoded = try containerValues.decodeIfPresent(CrawlerTargets.self, forKey: .targets)
        targets = targetsDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let classifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .classifiers)
        var classifiersDecoded0:[String]? = nil
        if let classifiersContainer = classifiersContainer {
            classifiersDecoded0 = [String]()
            for string0 in classifiersContainer {
                if let string0 = string0 {
                    classifiersDecoded0?.append(string0)
                }
            }
        }
        classifiers = classifiersDecoded0
        let recrawlPolicyDecoded = try containerValues.decodeIfPresent(RecrawlPolicy.self, forKey: .recrawlPolicy)
        recrawlPolicy = recrawlPolicyDecoded
        let schemaChangePolicyDecoded = try containerValues.decodeIfPresent(SchemaChangePolicy.self, forKey: .schemaChangePolicy)
        schemaChangePolicy = schemaChangePolicyDecoded
        let lineageConfigurationDecoded = try containerValues.decodeIfPresent(LineageConfiguration.self, forKey: .lineageConfiguration)
        lineageConfiguration = lineageConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CrawlerState.self, forKey: .state)
        state = stateDecoded
        let tablePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tablePrefix)
        tablePrefix = tablePrefixDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let crawlElapsedTimeDecoded = try containerValues.decode(Int.self, forKey: .crawlElapsedTime)
        crawlElapsedTime = crawlElapsedTimeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let lastCrawlDecoded = try containerValues.decodeIfPresent(LastCrawlInfo.self, forKey: .lastCrawl)
        lastCrawl = lastCrawlDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configuration)
        configuration = configurationDecoded
        let crawlerSecurityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .crawlerSecurityConfiguration)
        crawlerSecurityConfiguration = crawlerSecurityConfigurationDecoded
    }
}

extension Crawler: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Crawler(classifiers: \(String(describing: classifiers)), configuration: \(String(describing: configuration)), crawlElapsedTime: \(String(describing: crawlElapsedTime)), crawlerSecurityConfiguration: \(String(describing: crawlerSecurityConfiguration)), creationTime: \(String(describing: creationTime)), databaseName: \(String(describing: databaseName)), description: \(String(describing: description)), lastCrawl: \(String(describing: lastCrawl)), lastUpdated: \(String(describing: lastUpdated)), lineageConfiguration: \(String(describing: lineageConfiguration)), name: \(String(describing: name)), recrawlPolicy: \(String(describing: recrawlPolicy)), role: \(String(describing: role)), schedule: \(String(describing: schedule)), schemaChangePolicy: \(String(describing: schemaChangePolicy)), state: \(String(describing: state)), tablePrefix: \(String(describing: tablePrefix)), targets: \(String(describing: targets)), version: \(String(describing: version)))"}
}

/// <p>Specifies a crawler program that examines a data source and uses classifiers to try to
///       determine its schema. If successful, the crawler records metadata concerning the data source
///       in the AWS Glue Data Catalog.</p>
public struct Crawler: Equatable {
    /// <p>A list of UTF-8 strings that specify the custom classifiers that are associated
    ///      with the crawler.</p>
    public let classifiers: [String]?
    /// <p>Crawler configuration information. This versioned JSON string allows users
    ///         to specify aspects of a crawler's behavior.
    ///         For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html">Configuring a Crawler</a>.</p>
    public let configuration: String?
    /// <p>If the crawler is running, contains the total time elapsed since the last crawl
    ///       began.</p>
    public let crawlElapsedTime: Int
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used by this
    ///       crawler.</p>
    public let crawlerSecurityConfiguration: String?
    /// <p>The time that the crawler was created.</p>
    public let creationTime: Date?
    /// <p>The name of the database in which the crawler's output is stored.</p>
    public let databaseName: String?
    /// <p>A description of the crawler.</p>
    public let description: String?
    /// <p>The status of the last crawl, and potentially error information if
    ///       an error occurred.</p>
    public let lastCrawl: LastCrawlInfo?
    /// <p>The time that the crawler was last updated.</p>
    public let lastUpdated: Date?
    /// <p>A configuration that specifies whether data lineage is enabled for the crawler.</p>
    public let lineageConfiguration: LineageConfiguration?
    /// <p>The name of the crawler.</p>
    public let name: String?
    /// <p>A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.</p>
    public let recrawlPolicy: RecrawlPolicy?
    /// <p>The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources,
    ///       such as Amazon Simple Storage Service (Amazon S3) data.</p>
    public let role: String?
    /// <p>For scheduled crawlers, the schedule when the crawler runs.</p>
    public let schedule: Schedule?
    /// <p>The policy that specifies update and delete behaviors for the crawler.</p>
    public let schemaChangePolicy: SchemaChangePolicy?
    /// <p>Indicates whether the crawler is running, or whether a run is pending.</p>
    public let state: CrawlerState?
    /// <p>The prefix added to the names of tables that are created.</p>
    public let tablePrefix: String?
    /// <p>A collection of targets to crawl.</p>
    public let targets: CrawlerTargets?
    /// <p>The version of the crawler.</p>
    public let version: Int

    public init (
        classifiers: [String]? = nil,
        configuration: String? = nil,
        crawlElapsedTime: Int = 0,
        crawlerSecurityConfiguration: String? = nil,
        creationTime: Date? = nil,
        databaseName: String? = nil,
        description: String? = nil,
        lastCrawl: LastCrawlInfo? = nil,
        lastUpdated: Date? = nil,
        lineageConfiguration: LineageConfiguration? = nil,
        name: String? = nil,
        recrawlPolicy: RecrawlPolicy? = nil,
        role: String? = nil,
        schedule: Schedule? = nil,
        schemaChangePolicy: SchemaChangePolicy? = nil,
        state: CrawlerState? = nil,
        tablePrefix: String? = nil,
        targets: CrawlerTargets? = nil,
        version: Int = 0
    )
    {
        self.classifiers = classifiers
        self.configuration = configuration
        self.crawlElapsedTime = crawlElapsedTime
        self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
        self.creationTime = creationTime
        self.databaseName = databaseName
        self.description = description
        self.lastCrawl = lastCrawl
        self.lastUpdated = lastUpdated
        self.lineageConfiguration = lineageConfiguration
        self.name = name
        self.recrawlPolicy = recrawlPolicy
        self.role = role
        self.schedule = schedule
        self.schemaChangePolicy = schemaChangePolicy
        self.state = state
        self.tablePrefix = tablePrefix
        self.targets = targets
        self.version = version
    }
}

public enum CrawlerLineageSettings {
    case disable
    case enable
    case sdkUnknown(String)
}

extension CrawlerLineageSettings : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CrawlerLineageSettings] {
        return [
            .disable,
            .enable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disable: return "DISABLE"
        case .enable: return "ENABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CrawlerLineageSettings(rawValue: rawValue) ?? CrawlerLineageSettings.sdkUnknown(rawValue)
    }
}

extension CrawlerMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlerName = "CrawlerName"
        case lastRuntimeSeconds = "LastRuntimeSeconds"
        case medianRuntimeSeconds = "MedianRuntimeSeconds"
        case stillEstimating = "StillEstimating"
        case tablesCreated = "TablesCreated"
        case tablesDeleted = "TablesDeleted"
        case tablesUpdated = "TablesUpdated"
        case timeLeftSeconds = "TimeLeftSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawlerName = crawlerName {
            try encodeContainer.encode(crawlerName, forKey: .crawlerName)
        }
        if lastRuntimeSeconds != 0.0 {
            try encodeContainer.encode(lastRuntimeSeconds, forKey: .lastRuntimeSeconds)
        }
        if medianRuntimeSeconds != 0.0 {
            try encodeContainer.encode(medianRuntimeSeconds, forKey: .medianRuntimeSeconds)
        }
        if stillEstimating != false {
            try encodeContainer.encode(stillEstimating, forKey: .stillEstimating)
        }
        if tablesCreated != 0 {
            try encodeContainer.encode(tablesCreated, forKey: .tablesCreated)
        }
        if tablesDeleted != 0 {
            try encodeContainer.encode(tablesDeleted, forKey: .tablesDeleted)
        }
        if tablesUpdated != 0 {
            try encodeContainer.encode(tablesUpdated, forKey: .tablesUpdated)
        }
        if timeLeftSeconds != 0.0 {
            try encodeContainer.encode(timeLeftSeconds, forKey: .timeLeftSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .crawlerName)
        crawlerName = crawlerNameDecoded
        let timeLeftSecondsDecoded = try containerValues.decode(Double.self, forKey: .timeLeftSeconds)
        timeLeftSeconds = timeLeftSecondsDecoded
        let stillEstimatingDecoded = try containerValues.decode(Bool.self, forKey: .stillEstimating)
        stillEstimating = stillEstimatingDecoded
        let lastRuntimeSecondsDecoded = try containerValues.decode(Double.self, forKey: .lastRuntimeSeconds)
        lastRuntimeSeconds = lastRuntimeSecondsDecoded
        let medianRuntimeSecondsDecoded = try containerValues.decode(Double.self, forKey: .medianRuntimeSeconds)
        medianRuntimeSeconds = medianRuntimeSecondsDecoded
        let tablesCreatedDecoded = try containerValues.decode(Int.self, forKey: .tablesCreated)
        tablesCreated = tablesCreatedDecoded
        let tablesUpdatedDecoded = try containerValues.decode(Int.self, forKey: .tablesUpdated)
        tablesUpdated = tablesUpdatedDecoded
        let tablesDeletedDecoded = try containerValues.decode(Int.self, forKey: .tablesDeleted)
        tablesDeleted = tablesDeletedDecoded
    }
}

extension CrawlerMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CrawlerMetrics(crawlerName: \(String(describing: crawlerName)), lastRuntimeSeconds: \(String(describing: lastRuntimeSeconds)), medianRuntimeSeconds: \(String(describing: medianRuntimeSeconds)), stillEstimating: \(String(describing: stillEstimating)), tablesCreated: \(String(describing: tablesCreated)), tablesDeleted: \(String(describing: tablesDeleted)), tablesUpdated: \(String(describing: tablesUpdated)), timeLeftSeconds: \(String(describing: timeLeftSeconds)))"}
}

/// <p>Metrics for a specified crawler.</p>
public struct CrawlerMetrics: Equatable {
    /// <p>The name of the crawler.</p>
    public let crawlerName: String?
    /// <p>The duration of the crawler's most recent run, in seconds.</p>
    public let lastRuntimeSeconds: Double
    /// <p>The median duration of this crawler's runs, in seconds.</p>
    public let medianRuntimeSeconds: Double
    /// <p>True if the crawler is still estimating how long it will take to complete this run.</p>
    public let stillEstimating: Bool
    /// <p>The number of tables created by this crawler.</p>
    public let tablesCreated: Int
    /// <p>The number of tables deleted by this crawler.</p>
    public let tablesDeleted: Int
    /// <p>The number of tables updated by this crawler.</p>
    public let tablesUpdated: Int
    /// <p>The estimated time left to complete a running crawl.</p>
    public let timeLeftSeconds: Double

    public init (
        crawlerName: String? = nil,
        lastRuntimeSeconds: Double = 0.0,
        medianRuntimeSeconds: Double = 0.0,
        stillEstimating: Bool = false,
        tablesCreated: Int = 0,
        tablesDeleted: Int = 0,
        tablesUpdated: Int = 0,
        timeLeftSeconds: Double = 0.0
    )
    {
        self.crawlerName = crawlerName
        self.lastRuntimeSeconds = lastRuntimeSeconds
        self.medianRuntimeSeconds = medianRuntimeSeconds
        self.stillEstimating = stillEstimating
        self.tablesCreated = tablesCreated
        self.tablesDeleted = tablesDeleted
        self.tablesUpdated = tablesUpdated
        self.timeLeftSeconds = timeLeftSeconds
    }
}

extension CrawlerNodeDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawls = "Crawls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawls = crawls {
            var crawlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crawls)
            for crawllist0 in crawls {
                try crawlsContainer.encode(crawllist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlsContainer = try containerValues.decodeIfPresent([Crawl?].self, forKey: .crawls)
        var crawlsDecoded0:[Crawl]? = nil
        if let crawlsContainer = crawlsContainer {
            crawlsDecoded0 = [Crawl]()
            for structure0 in crawlsContainer {
                if let structure0 = structure0 {
                    crawlsDecoded0?.append(structure0)
                }
            }
        }
        crawls = crawlsDecoded0
    }
}

extension CrawlerNodeDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CrawlerNodeDetails(crawls: \(String(describing: crawls)))"}
}

/// <p>The details of a Crawler node present in the workflow.</p>
public struct CrawlerNodeDetails: Equatable {
    /// <p>A list of crawls represented by the crawl node.</p>
    public let crawls: [Crawl]?

    public init (
        crawls: [Crawl]? = nil
    )
    {
        self.crawls = crawls
    }
}

extension CrawlerNotRunningException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CrawlerNotRunningException(message: \(String(describing: message)))"}
}

extension CrawlerNotRunningException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CrawlerNotRunningExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified crawler is not running.</p>
public struct CrawlerNotRunningException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CrawlerNotRunningExceptionBody: Equatable {
    public let message: String?
}

extension CrawlerNotRunningExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CrawlerRunningException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CrawlerRunningException(message: \(String(describing: message)))"}
}

extension CrawlerRunningException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CrawlerRunningExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation cannot be performed because the crawler is already running.</p>
public struct CrawlerRunningException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CrawlerRunningExceptionBody: Equatable {
    public let message: String?
}

extension CrawlerRunningExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum CrawlerState {
    case ready
    case running
    case stopping
    case sdkUnknown(String)
}

extension CrawlerState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CrawlerState] {
        return [
            .ready,
            .running,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ready: return "READY"
        case .running: return "RUNNING"
        case .stopping: return "STOPPING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CrawlerState(rawValue: rawValue) ?? CrawlerState.sdkUnknown(rawValue)
    }
}

extension CrawlerStoppingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CrawlerStoppingException(message: \(String(describing: message)))"}
}

extension CrawlerStoppingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CrawlerStoppingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified crawler is stopping.</p>
public struct CrawlerStoppingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CrawlerStoppingExceptionBody: Equatable {
    public let message: String?
}

extension CrawlerStoppingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CrawlerTargets: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogTargets = "CatalogTargets"
        case dynamoDBTargets = "DynamoDBTargets"
        case jdbcTargets = "JdbcTargets"
        case mongoDBTargets = "MongoDBTargets"
        case s3Targets = "S3Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogTargets = catalogTargets {
            var catalogTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .catalogTargets)
            for catalogtargetlist0 in catalogTargets {
                try catalogTargetsContainer.encode(catalogtargetlist0)
            }
        }
        if let dynamoDBTargets = dynamoDBTargets {
            var dynamoDBTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dynamoDBTargets)
            for dynamodbtargetlist0 in dynamoDBTargets {
                try dynamoDBTargetsContainer.encode(dynamodbtargetlist0)
            }
        }
        if let jdbcTargets = jdbcTargets {
            var jdbcTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jdbcTargets)
            for jdbctargetlist0 in jdbcTargets {
                try jdbcTargetsContainer.encode(jdbctargetlist0)
            }
        }
        if let mongoDBTargets = mongoDBTargets {
            var mongoDBTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mongoDBTargets)
            for mongodbtargetlist0 in mongoDBTargets {
                try mongoDBTargetsContainer.encode(mongodbtargetlist0)
            }
        }
        if let s3Targets = s3Targets {
            var s3TargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Targets)
            for s3targetlist0 in s3Targets {
                try s3TargetsContainer.encode(s3targetlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3TargetsContainer = try containerValues.decodeIfPresent([S3Target?].self, forKey: .s3Targets)
        var s3TargetsDecoded0:[S3Target]? = nil
        if let s3TargetsContainer = s3TargetsContainer {
            s3TargetsDecoded0 = [S3Target]()
            for structure0 in s3TargetsContainer {
                if let structure0 = structure0 {
                    s3TargetsDecoded0?.append(structure0)
                }
            }
        }
        s3Targets = s3TargetsDecoded0
        let jdbcTargetsContainer = try containerValues.decodeIfPresent([JdbcTarget?].self, forKey: .jdbcTargets)
        var jdbcTargetsDecoded0:[JdbcTarget]? = nil
        if let jdbcTargetsContainer = jdbcTargetsContainer {
            jdbcTargetsDecoded0 = [JdbcTarget]()
            for structure0 in jdbcTargetsContainer {
                if let structure0 = structure0 {
                    jdbcTargetsDecoded0?.append(structure0)
                }
            }
        }
        jdbcTargets = jdbcTargetsDecoded0
        let mongoDBTargetsContainer = try containerValues.decodeIfPresent([MongoDBTarget?].self, forKey: .mongoDBTargets)
        var mongoDBTargetsDecoded0:[MongoDBTarget]? = nil
        if let mongoDBTargetsContainer = mongoDBTargetsContainer {
            mongoDBTargetsDecoded0 = [MongoDBTarget]()
            for structure0 in mongoDBTargetsContainer {
                if let structure0 = structure0 {
                    mongoDBTargetsDecoded0?.append(structure0)
                }
            }
        }
        mongoDBTargets = mongoDBTargetsDecoded0
        let dynamoDBTargetsContainer = try containerValues.decodeIfPresent([DynamoDBTarget?].self, forKey: .dynamoDBTargets)
        var dynamoDBTargetsDecoded0:[DynamoDBTarget]? = nil
        if let dynamoDBTargetsContainer = dynamoDBTargetsContainer {
            dynamoDBTargetsDecoded0 = [DynamoDBTarget]()
            for structure0 in dynamoDBTargetsContainer {
                if let structure0 = structure0 {
                    dynamoDBTargetsDecoded0?.append(structure0)
                }
            }
        }
        dynamoDBTargets = dynamoDBTargetsDecoded0
        let catalogTargetsContainer = try containerValues.decodeIfPresent([CatalogTarget?].self, forKey: .catalogTargets)
        var catalogTargetsDecoded0:[CatalogTarget]? = nil
        if let catalogTargetsContainer = catalogTargetsContainer {
            catalogTargetsDecoded0 = [CatalogTarget]()
            for structure0 in catalogTargetsContainer {
                if let structure0 = structure0 {
                    catalogTargetsDecoded0?.append(structure0)
                }
            }
        }
        catalogTargets = catalogTargetsDecoded0
    }
}

extension CrawlerTargets: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CrawlerTargets(catalogTargets: \(String(describing: catalogTargets)), dynamoDBTargets: \(String(describing: dynamoDBTargets)), jdbcTargets: \(String(describing: jdbcTargets)), mongoDBTargets: \(String(describing: mongoDBTargets)), s3Targets: \(String(describing: s3Targets)))"}
}

/// <p>Specifies data stores to crawl.</p>
public struct CrawlerTargets: Equatable {
    /// <p>Specifies AWS Glue Data Catalog targets.</p>
    public let catalogTargets: [CatalogTarget]?
    /// <p>Specifies Amazon DynamoDB targets.</p>
    public let dynamoDBTargets: [DynamoDBTarget]?
    /// <p>Specifies JDBC targets.</p>
    public let jdbcTargets: [JdbcTarget]?
    /// <p>Specifies Amazon DocumentDB or MongoDB targets.</p>
    public let mongoDBTargets: [MongoDBTarget]?
    /// <p>Specifies Amazon Simple Storage Service (Amazon S3) targets.</p>
    public let s3Targets: [S3Target]?

    public init (
        catalogTargets: [CatalogTarget]? = nil,
        dynamoDBTargets: [DynamoDBTarget]? = nil,
        jdbcTargets: [JdbcTarget]? = nil,
        mongoDBTargets: [MongoDBTarget]? = nil,
        s3Targets: [S3Target]? = nil
    )
    {
        self.catalogTargets = catalogTargets
        self.dynamoDBTargets = dynamoDBTargets
        self.jdbcTargets = jdbcTargets
        self.mongoDBTargets = mongoDBTargets
        self.s3Targets = s3Targets
    }
}

public struct CreateClassifierInputBodyMiddleware: Middleware {
    public let id: String = "CreateClassifierInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClassifierInput>
    public typealias MOutput = OperationOutput<CreateClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClassifierOutputError>
}

extension CreateClassifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClassifierInput(csvClassifier: \(String(describing: csvClassifier)), grokClassifier: \(String(describing: grokClassifier)), jsonClassifier: \(String(describing: jsonClassifier)), xMLClassifier: \(String(describing: xMLClassifier)))"}
}

extension CreateClassifierInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case csvClassifier = "CsvClassifier"
        case grokClassifier = "GrokClassifier"
        case jsonClassifier = "JsonClassifier"
        case xMLClassifier = "XMLClassifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvClassifier = csvClassifier {
            try encodeContainer.encode(csvClassifier, forKey: .csvClassifier)
        }
        if let grokClassifier = grokClassifier {
            try encodeContainer.encode(grokClassifier, forKey: .grokClassifier)
        }
        if let jsonClassifier = jsonClassifier {
            try encodeContainer.encode(jsonClassifier, forKey: .jsonClassifier)
        }
        if let xMLClassifier = xMLClassifier {
            try encodeContainer.encode(xMLClassifier, forKey: .xMLClassifier)
        }
    }
}

public struct CreateClassifierInputHeadersMiddleware: Middleware {
    public let id: String = "CreateClassifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClassifierInput>
    public typealias MOutput = OperationOutput<CreateClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClassifierOutputError>
}

public struct CreateClassifierInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateClassifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClassifierInput>
    public typealias MOutput = OperationOutput<CreateClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClassifierOutputError>
}

public struct CreateClassifierInput: Equatable {
    /// <p>A <code>CsvClassifier</code> object specifying the classifier
    ///       to create.</p>
    public let csvClassifier: CreateCsvClassifierRequest?
    /// <p>A <code>GrokClassifier</code> object specifying the classifier
    ///       to create.</p>
    public let grokClassifier: CreateGrokClassifierRequest?
    /// <p>A <code>JsonClassifier</code> object specifying the classifier
    ///       to create.</p>
    public let jsonClassifier: CreateJsonClassifierRequest?
    /// <p>An <code>XMLClassifier</code> object specifying the classifier
    ///       to create.</p>
    public let xMLClassifier: CreateXMLClassifierRequest?

    public init (
        csvClassifier: CreateCsvClassifierRequest? = nil,
        grokClassifier: CreateGrokClassifierRequest? = nil,
        jsonClassifier: CreateJsonClassifierRequest? = nil,
        xMLClassifier: CreateXMLClassifierRequest? = nil
    )
    {
        self.csvClassifier = csvClassifier
        self.grokClassifier = grokClassifier
        self.jsonClassifier = jsonClassifier
        self.xMLClassifier = xMLClassifier
    }
}

struct CreateClassifierInputBody: Equatable {
    public let grokClassifier: CreateGrokClassifierRequest?
    public let xMLClassifier: CreateXMLClassifierRequest?
    public let jsonClassifier: CreateJsonClassifierRequest?
    public let csvClassifier: CreateCsvClassifierRequest?
}

extension CreateClassifierInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case csvClassifier = "CsvClassifier"
        case grokClassifier = "GrokClassifier"
        case jsonClassifier = "JsonClassifier"
        case xMLClassifier = "XMLClassifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grokClassifierDecoded = try containerValues.decodeIfPresent(CreateGrokClassifierRequest.self, forKey: .grokClassifier)
        grokClassifier = grokClassifierDecoded
        let xMLClassifierDecoded = try containerValues.decodeIfPresent(CreateXMLClassifierRequest.self, forKey: .xMLClassifier)
        xMLClassifier = xMLClassifierDecoded
        let jsonClassifierDecoded = try containerValues.decodeIfPresent(CreateJsonClassifierRequest.self, forKey: .jsonClassifier)
        jsonClassifier = jsonClassifierDecoded
        let csvClassifierDecoded = try containerValues.decodeIfPresent(CreateCsvClassifierRequest.self, forKey: .csvClassifier)
        csvClassifier = csvClassifierDecoded
    }
}

extension CreateClassifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClassifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClassifierOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClassifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClassifierOutputResponse()"}
}

extension CreateClassifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateClassifierOutputResponse: Equatable {

    public init() {}
}

struct CreateClassifierOutputResponseBody: Equatable {
}

extension CreateClassifierOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateConnectionInputBodyMiddleware: Middleware {
    public let id: String = "CreateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

extension CreateConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionInput(catalogId: \(String(describing: catalogId)), connectionInput: \(String(describing: connectionInput)))"}
}

extension CreateConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case connectionInput = "ConnectionInput"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let connectionInput = connectionInput {
            try encodeContainer.encode(connectionInput, forKey: .connectionInput)
        }
    }
}

public struct CreateConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInput: Equatable {
    /// <p>The ID of the Data Catalog in which to create the connection. If none is provided, the AWS
    ///       account ID is used by default.</p>
    public let catalogId: String?
    /// <p>A <code>ConnectionInput</code> object defining the connection
    ///       to create.</p>
    public let connectionInput: ConnectionInput?

    public init (
        catalogId: String? = nil,
        connectionInput: ConnectionInput? = nil
    )
    {
        self.catalogId = catalogId
        self.connectionInput = connectionInput
    }
}

struct CreateConnectionInputBody: Equatable {
    public let catalogId: String?
    public let connectionInput: ConnectionInput?
}

extension CreateConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case connectionInput = "ConnectionInput"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let connectionInputDecoded = try containerValues.decodeIfPresent(ConnectionInput.self, forKey: .connectionInput)
        connectionInput = connectionInputDecoded
    }
}

extension CreateConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case glueEncryptionException(GlueEncryptionException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionOutputResponse()"}
}

extension CreateConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateConnectionOutputResponse: Equatable {

    public init() {}
}

struct CreateConnectionOutputResponseBody: Equatable {
}

extension CreateConnectionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateCrawlerInputBodyMiddleware: Middleware {
    public let id: String = "CreateCrawlerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCrawlerInput>
    public typealias MOutput = OperationOutput<CreateCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCrawlerOutputError>
}

extension CreateCrawlerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCrawlerInput(classifiers: \(String(describing: classifiers)), configuration: \(String(describing: configuration)), crawlerSecurityConfiguration: \(String(describing: crawlerSecurityConfiguration)), databaseName: \(String(describing: databaseName)), description: \(String(describing: description)), lineageConfiguration: \(String(describing: lineageConfiguration)), name: \(String(describing: name)), recrawlPolicy: \(String(describing: recrawlPolicy)), role: \(String(describing: role)), schedule: \(String(describing: schedule)), schemaChangePolicy: \(String(describing: schemaChangePolicy)), tablePrefix: \(String(describing: tablePrefix)), tags: \(String(describing: tags)), targets: \(String(describing: targets)))"}
}

extension CreateCrawlerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classifiers = "Classifiers"
        case configuration = "Configuration"
        case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
        case databaseName = "DatabaseName"
        case description = "Description"
        case lineageConfiguration = "LineageConfiguration"
        case name = "Name"
        case recrawlPolicy = "RecrawlPolicy"
        case role = "Role"
        case schedule = "Schedule"
        case schemaChangePolicy = "SchemaChangePolicy"
        case tablePrefix = "TablePrefix"
        case tags = "Tags"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classifiers = classifiers {
            var classifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .classifiers)
            for classifiernamelist0 in classifiers {
                try classifiersContainer.encode(classifiernamelist0)
            }
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let crawlerSecurityConfiguration = crawlerSecurityConfiguration {
            try encodeContainer.encode(crawlerSecurityConfiguration, forKey: .crawlerSecurityConfiguration)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lineageConfiguration = lineageConfiguration {
            try encodeContainer.encode(lineageConfiguration, forKey: .lineageConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recrawlPolicy = recrawlPolicy {
            try encodeContainer.encode(recrawlPolicy, forKey: .recrawlPolicy)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let schemaChangePolicy = schemaChangePolicy {
            try encodeContainer.encode(schemaChangePolicy, forKey: .schemaChangePolicy)
        }
        if let tablePrefix = tablePrefix {
            try encodeContainer.encode(tablePrefix, forKey: .tablePrefix)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            try encodeContainer.encode(targets, forKey: .targets)
        }
    }
}

public struct CreateCrawlerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCrawlerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCrawlerInput>
    public typealias MOutput = OperationOutput<CreateCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCrawlerOutputError>
}

public struct CreateCrawlerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCrawlerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCrawlerInput>
    public typealias MOutput = OperationOutput<CreateCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCrawlerOutputError>
}

public struct CreateCrawlerInput: Equatable {
    /// <p>A list of custom classifiers that the user has registered. By default, all built-in
    ///       classifiers are included in a crawl, but these custom classifiers always override the default
    ///       classifiers for a given classification.</p>
    public let classifiers: [String]?
    /// <p>Crawler configuration information. This versioned JSON
    ///       string allows users to specify aspects of a crawler's behavior.
    ///       For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html">Configuring a Crawler</a>.</p>
    public let configuration: String?
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used by this
    ///       crawler.</p>
    public let crawlerSecurityConfiguration: String?
    /// <p>The AWS Glue database where results are written, such as:
    ///         <code>arn:aws:daylight:us-east-1::database/sometable/*</code>.</p>
    public let databaseName: String?
    /// <p>A description of the new crawler.</p>
    public let description: String?
    /// <p>Specifies data lineage configuration settings for the crawler.</p>
    public let lineageConfiguration: LineageConfiguration?
    /// <p>Name of the new crawler.</p>
    public let name: String?
    /// <p>A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.</p>
    public let recrawlPolicy: RecrawlPolicy?
    /// <p>The IAM role or Amazon Resource Name (ARN) of an IAM role used by the new crawler to
    ///       access customer resources.</p>
    public let role: String?
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run
    ///       something every day at 12:15 UTC, you would specify:
    ///       <code>cron(15 12 * * ? *)</code>.</p>
    public let schedule: String?
    /// <p>The policy for the crawler's update and deletion behavior.</p>
    public let schemaChangePolicy: SchemaChangePolicy?
    /// <p>The table prefix used for catalog tables that are created.</p>
    public let tablePrefix: String?
    /// <p>The tags to use with this crawler request. You may use tags to limit access to the
    ///             crawler. For more information about tags in AWS Glue, see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">AWS Tags in AWS Glue</a> in the developer
    ///             guide.</p>
    public let tags: [String:String]?
    /// <p>A list of collection of targets to crawl.</p>
    public let targets: CrawlerTargets?

    public init (
        classifiers: [String]? = nil,
        configuration: String? = nil,
        crawlerSecurityConfiguration: String? = nil,
        databaseName: String? = nil,
        description: String? = nil,
        lineageConfiguration: LineageConfiguration? = nil,
        name: String? = nil,
        recrawlPolicy: RecrawlPolicy? = nil,
        role: String? = nil,
        schedule: String? = nil,
        schemaChangePolicy: SchemaChangePolicy? = nil,
        tablePrefix: String? = nil,
        tags: [String:String]? = nil,
        targets: CrawlerTargets? = nil
    )
    {
        self.classifiers = classifiers
        self.configuration = configuration
        self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
        self.databaseName = databaseName
        self.description = description
        self.lineageConfiguration = lineageConfiguration
        self.name = name
        self.recrawlPolicy = recrawlPolicy
        self.role = role
        self.schedule = schedule
        self.schemaChangePolicy = schemaChangePolicy
        self.tablePrefix = tablePrefix
        self.tags = tags
        self.targets = targets
    }
}

struct CreateCrawlerInputBody: Equatable {
    public let name: String?
    public let role: String?
    public let databaseName: String?
    public let description: String?
    public let targets: CrawlerTargets?
    public let schedule: String?
    public let classifiers: [String]?
    public let tablePrefix: String?
    public let schemaChangePolicy: SchemaChangePolicy?
    public let recrawlPolicy: RecrawlPolicy?
    public let lineageConfiguration: LineageConfiguration?
    public let configuration: String?
    public let crawlerSecurityConfiguration: String?
    public let tags: [String:String]?
}

extension CreateCrawlerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case classifiers = "Classifiers"
        case configuration = "Configuration"
        case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
        case databaseName = "DatabaseName"
        case description = "Description"
        case lineageConfiguration = "LineageConfiguration"
        case name = "Name"
        case recrawlPolicy = "RecrawlPolicy"
        case role = "Role"
        case schedule = "Schedule"
        case schemaChangePolicy = "SchemaChangePolicy"
        case tablePrefix = "TablePrefix"
        case tags = "Tags"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetsDecoded = try containerValues.decodeIfPresent(CrawlerTargets.self, forKey: .targets)
        targets = targetsDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let classifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .classifiers)
        var classifiersDecoded0:[String]? = nil
        if let classifiersContainer = classifiersContainer {
            classifiersDecoded0 = [String]()
            for string0 in classifiersContainer {
                if let string0 = string0 {
                    classifiersDecoded0?.append(string0)
                }
            }
        }
        classifiers = classifiersDecoded0
        let tablePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tablePrefix)
        tablePrefix = tablePrefixDecoded
        let schemaChangePolicyDecoded = try containerValues.decodeIfPresent(SchemaChangePolicy.self, forKey: .schemaChangePolicy)
        schemaChangePolicy = schemaChangePolicyDecoded
        let recrawlPolicyDecoded = try containerValues.decodeIfPresent(RecrawlPolicy.self, forKey: .recrawlPolicy)
        recrawlPolicy = recrawlPolicyDecoded
        let lineageConfigurationDecoded = try containerValues.decodeIfPresent(LineageConfiguration.self, forKey: .lineageConfiguration)
        lineageConfiguration = lineageConfigurationDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configuration)
        configuration = configurationDecoded
        let crawlerSecurityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .crawlerSecurityConfiguration)
        crawlerSecurityConfiguration = crawlerSecurityConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCrawlerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCrawlerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCrawlerOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCrawlerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCrawlerOutputResponse()"}
}

extension CreateCrawlerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateCrawlerOutputResponse: Equatable {

    public init() {}
}

struct CreateCrawlerOutputResponseBody: Equatable {
}

extension CreateCrawlerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateCsvClassifierRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowSingleColumn = "AllowSingleColumn"
        case containsHeader = "ContainsHeader"
        case delimiter = "Delimiter"
        case disableValueTrimming = "DisableValueTrimming"
        case header = "Header"
        case name = "Name"
        case quoteSymbol = "QuoteSymbol"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSingleColumn = allowSingleColumn {
            try encodeContainer.encode(allowSingleColumn, forKey: .allowSingleColumn)
        }
        if let containsHeader = containsHeader {
            try encodeContainer.encode(containsHeader.rawValue, forKey: .containsHeader)
        }
        if let delimiter = delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let disableValueTrimming = disableValueTrimming {
            try encodeContainer.encode(disableValueTrimming, forKey: .disableValueTrimming)
        }
        if let header = header {
            var headerContainer = encodeContainer.nestedUnkeyedContainer(forKey: .header)
            for csvheader0 in header {
                try headerContainer.encode(csvheader0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quoteSymbol = quoteSymbol {
            try encodeContainer.encode(quoteSymbol, forKey: .quoteSymbol)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let quoteSymbolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteSymbol)
        quoteSymbol = quoteSymbolDecoded
        let containsHeaderDecoded = try containerValues.decodeIfPresent(CsvHeaderOption.self, forKey: .containsHeader)
        containsHeader = containsHeaderDecoded
        let headerContainer = try containerValues.decodeIfPresent([String?].self, forKey: .header)
        var headerDecoded0:[String]? = nil
        if let headerContainer = headerContainer {
            headerDecoded0 = [String]()
            for string0 in headerContainer {
                if let string0 = string0 {
                    headerDecoded0?.append(string0)
                }
            }
        }
        header = headerDecoded0
        let disableValueTrimmingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableValueTrimming)
        disableValueTrimming = disableValueTrimmingDecoded
        let allowSingleColumnDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSingleColumn)
        allowSingleColumn = allowSingleColumnDecoded
    }
}

extension CreateCsvClassifierRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCsvClassifierRequest(allowSingleColumn: \(String(describing: allowSingleColumn)), containsHeader: \(String(describing: containsHeader)), delimiter: \(String(describing: delimiter)), disableValueTrimming: \(String(describing: disableValueTrimming)), header: \(String(describing: header)), name: \(String(describing: name)), quoteSymbol: \(String(describing: quoteSymbol)))"}
}

/// <p>Specifies a custom CSV classifier for <code>CreateClassifier</code> to create.</p>
public struct CreateCsvClassifierRequest: Equatable {
    /// <p>Enables the processing of files that contain only one column.</p>
    public let allowSingleColumn: Bool?
    /// <p>Indicates whether the CSV file contains a header.</p>
    public let containsHeader: CsvHeaderOption?
    /// <p>A custom symbol to denote what separates each column entry in the row.</p>
    public let delimiter: String?
    /// <p>Specifies not to trim values before identifying the type of column values. The default value is true.</p>
    public let disableValueTrimming: Bool?
    /// <p>A list of strings representing column names.</p>
    public let header: [String]?
    /// <p>The name of the classifier.</p>
    public let name: String?
    /// <p>A custom symbol to denote what combines content into a single column value. Must be different from the column delimiter.</p>
    public let quoteSymbol: String?

    public init (
        allowSingleColumn: Bool? = nil,
        containsHeader: CsvHeaderOption? = nil,
        delimiter: String? = nil,
        disableValueTrimming: Bool? = nil,
        header: [String]? = nil,
        name: String? = nil,
        quoteSymbol: String? = nil
    )
    {
        self.allowSingleColumn = allowSingleColumn
        self.containsHeader = containsHeader
        self.delimiter = delimiter
        self.disableValueTrimming = disableValueTrimming
        self.header = header
        self.name = name
        self.quoteSymbol = quoteSymbol
    }
}

public struct CreateDatabaseInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatabaseInput>
    public typealias MOutput = OperationOutput<CreateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatabaseOutputError>
}

extension CreateDatabaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatabaseInput(catalogId: \(String(describing: catalogId)), databaseInput: \(String(describing: databaseInput)))"}
}

extension CreateDatabaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseInput = "DatabaseInput"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseInput = databaseInput {
            try encodeContainer.encode(databaseInput, forKey: .databaseInput)
        }
    }
}

public struct CreateDatabaseInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatabaseInput>
    public typealias MOutput = OperationOutput<CreateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatabaseOutputError>
}

public struct CreateDatabaseInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatabaseInput>
    public typealias MOutput = OperationOutput<CreateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatabaseOutputError>
}

public struct CreateDatabaseInput: Equatable {
    /// <p>The ID of the Data Catalog in which to create the database. If none is provided, the AWS
    ///       account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The metadata for the database.</p>
    public let databaseInput: DatabaseInput?

    public init (
        catalogId: String? = nil,
        databaseInput: DatabaseInput? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseInput = databaseInput
    }
}

struct CreateDatabaseInputBody: Equatable {
    public let catalogId: String?
    public let databaseInput: DatabaseInput?
}

extension CreateDatabaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseInput = "DatabaseInput"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseInputDecoded = try containerValues.decodeIfPresent(DatabaseInput.self, forKey: .databaseInput)
        databaseInput = databaseInputDecoded
    }
}

extension CreateDatabaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatabaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatabaseOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatabaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatabaseOutputResponse()"}
}

extension CreateDatabaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateDatabaseOutputResponse: Equatable {

    public init() {}
}

struct CreateDatabaseOutputResponseBody: Equatable {
}

extension CreateDatabaseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateDevEndpointInputBodyMiddleware: Middleware {
    public let id: String = "CreateDevEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDevEndpointInput>
    public typealias MOutput = OperationOutput<CreateDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDevEndpointOutputError>
}

extension CreateDevEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDevEndpointInput(arguments: \(String(describing: arguments)), endpointName: \(String(describing: endpointName)), extraJarsS3Path: \(String(describing: extraJarsS3Path)), extraPythonLibsS3Path: \(String(describing: extraPythonLibsS3Path)), glueVersion: \(String(describing: glueVersion)), numberOfNodes: \(String(describing: numberOfNodes)), numberOfWorkers: \(String(describing: numberOfWorkers)), publicKey: \(String(describing: publicKey)), publicKeys: \(String(describing: publicKeys)), roleArn: \(String(describing: roleArn)), securityConfiguration: \(String(describing: securityConfiguration)), securityGroupIds: \(String(describing: securityGroupIds)), subnetId: \(String(describing: subnetId)), tags: \(String(describing: tags)), workerType: \(String(describing: workerType)))"}
}

extension CreateDevEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arguments = "Arguments"
        case endpointName = "EndpointName"
        case extraJarsS3Path = "ExtraJarsS3Path"
        case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
        case glueVersion = "GlueVersion"
        case numberOfNodes = "NumberOfNodes"
        case numberOfWorkers = "NumberOfWorkers"
        case publicKey = "PublicKey"
        case publicKeys = "PublicKeys"
        case roleArn = "RoleArn"
        case securityConfiguration = "SecurityConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case subnetId = "SubnetId"
        case tags = "Tags"
        case workerType = "WorkerType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .arguments)
            for (dictKey0, mapvalue0) in arguments {
                try argumentsContainer.encode(mapvalue0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let endpointName = endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
        if let extraJarsS3Path = extraJarsS3Path {
            try encodeContainer.encode(extraJarsS3Path, forKey: .extraJarsS3Path)
        }
        if let extraPythonLibsS3Path = extraPythonLibsS3Path {
            try encodeContainer.encode(extraPythonLibsS3Path, forKey: .extraPythonLibsS3Path)
        }
        if let glueVersion = glueVersion {
            try encodeContainer.encode(glueVersion, forKey: .glueVersion)
        }
        if numberOfNodes != 0 {
            try encodeContainer.encode(numberOfNodes, forKey: .numberOfNodes)
        }
        if let numberOfWorkers = numberOfWorkers {
            try encodeContainer.encode(numberOfWorkers, forKey: .numberOfWorkers)
        }
        if let publicKey = publicKey {
            try encodeContainer.encode(publicKey, forKey: .publicKey)
        }
        if let publicKeys = publicKeys {
            var publicKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .publicKeys)
            for publickeyslist0 in publicKeys {
                try publicKeysContainer.encode(publickeyslist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityConfiguration = securityConfiguration {
            try encodeContainer.encode(securityConfiguration, forKey: .securityConfiguration)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for stringlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(stringlist0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let workerType = workerType {
            try encodeContainer.encode(workerType.rawValue, forKey: .workerType)
        }
    }
}

public struct CreateDevEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDevEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDevEndpointInput>
    public typealias MOutput = OperationOutput<CreateDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDevEndpointOutputError>
}

public struct CreateDevEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDevEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDevEndpointInput>
    public typealias MOutput = OperationOutput<CreateDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDevEndpointOutputError>
}

public struct CreateDevEndpointInput: Equatable {
    /// <p>A map of arguments used to configure the <code>DevEndpoint</code>.</p>
    public let arguments: [String:String]?
    /// <p>The name to be assigned to the new <code>DevEndpoint</code>.</p>
    public let endpointName: String?
    /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded
    ///       in your <code>DevEndpoint</code>.</p>
    public let extraJarsS3Path: String?
    /// <p>The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in
    ///       your <code>DevEndpoint</code>. Multiple values must be complete paths separated by a
    ///       comma.</p>
    ///          <note>
    ///             <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on
    ///         C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data
    ///         analysis library, are not yet supported.</p>
    ///          </note>
    public let extraPythonLibsS3Path: String?
    /// <p>Glue version determines the versions of Apache Spark and Python that AWS Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. </p>
    ///
    ///          <p>For more information about the available AWS Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    /// 	
    /// 	        <p>Development endpoints that are created without specifying a Glue version default to Glue 0.9.</p>
    /// 	
    /// 	        <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
    public let glueVersion: String?
    /// <p>The number of AWS Glue Data Processing Units (DPUs) to allocate to this
    ///         <code>DevEndpoint</code>.</p>
    public let numberOfNodes: Int
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated to the development endpoint.</p>
    /// 	
    /// 	        <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
    public let numberOfWorkers: Int?
    /// <p>The public key to be used by this <code>DevEndpoint</code> for authentication. This
    ///       attribute is provided for backward compatibility because the recommended attribute to use is
    ///       public keys.</p>
    public let publicKey: String?
    /// <p>A list of public keys to be used by the development endpoints for authentication. The use
    ///       of this attribute is preferred over a single public key because the public keys allow you to
    ///       have a different private key per client.</p>
    ///
    ///          <note>
    ///             <p>If you previously created an endpoint with a public key, you must remove that key to be able
    ///         to set a list of public keys. Call the <code>UpdateDevEndpoint</code> API with the public
    ///         key content in the <code>deletePublicKeys</code> attribute, and the list of new keys in the
    ///           <code>addPublicKeys</code> attribute.</p>
    ///          </note>
    public let publicKeys: [String]?
    /// <p>The IAM role for the <code>DevEndpoint</code>.</p>
    public let roleArn: String?
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this
    ///         <code>DevEndpoint</code>.</p>
    public let securityConfiguration: String?
    /// <p>Security group IDs for the security groups to be used by the new
    ///       <code>DevEndpoint</code>.</p>
    public let securityGroupIds: [String]?
    /// <p>The subnet ID for the new <code>DevEndpoint</code> to use.</p>
    public let subnetId: String?
    /// <p>The tags to use with this DevEndpoint. You may use tags to limit access to the DevEndpoint. For more information about tags in AWS Glue, see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">AWS Tags in AWS Glue</a> in the developer guide.</p>
    public let tags: [String:String]?
    /// <p>The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
    ///             </li>
    ///          </ul>
    /// 	        <p>Known issue: when a development endpoint is created with the <code>G.2X</code>
    ///             <code>WorkerType</code> configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk. </p>
    public let workerType: WorkerType?

    public init (
        arguments: [String:String]? = nil,
        endpointName: String? = nil,
        extraJarsS3Path: String? = nil,
        extraPythonLibsS3Path: String? = nil,
        glueVersion: String? = nil,
        numberOfNodes: Int = 0,
        numberOfWorkers: Int? = nil,
        publicKey: String? = nil,
        publicKeys: [String]? = nil,
        roleArn: String? = nil,
        securityConfiguration: String? = nil,
        securityGroupIds: [String]? = nil,
        subnetId: String? = nil,
        tags: [String:String]? = nil,
        workerType: WorkerType? = nil
    )
    {
        self.arguments = arguments
        self.endpointName = endpointName
        self.extraJarsS3Path = extraJarsS3Path
        self.extraPythonLibsS3Path = extraPythonLibsS3Path
        self.glueVersion = glueVersion
        self.numberOfNodes = numberOfNodes
        self.numberOfWorkers = numberOfWorkers
        self.publicKey = publicKey
        self.publicKeys = publicKeys
        self.roleArn = roleArn
        self.securityConfiguration = securityConfiguration
        self.securityGroupIds = securityGroupIds
        self.subnetId = subnetId
        self.tags = tags
        self.workerType = workerType
    }
}

struct CreateDevEndpointInputBody: Equatable {
    public let endpointName: String?
    public let roleArn: String?
    public let securityGroupIds: [String]?
    public let subnetId: String?
    public let publicKey: String?
    public let publicKeys: [String]?
    public let numberOfNodes: Int
    public let workerType: WorkerType?
    public let glueVersion: String?
    public let numberOfWorkers: Int?
    public let extraPythonLibsS3Path: String?
    public let extraJarsS3Path: String?
    public let securityConfiguration: String?
    public let tags: [String:String]?
    public let arguments: [String:String]?
}

extension CreateDevEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arguments = "Arguments"
        case endpointName = "EndpointName"
        case extraJarsS3Path = "ExtraJarsS3Path"
        case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
        case glueVersion = "GlueVersion"
        case numberOfNodes = "NumberOfNodes"
        case numberOfWorkers = "NumberOfWorkers"
        case publicKey = "PublicKey"
        case publicKeys = "PublicKeys"
        case roleArn = "RoleArn"
        case securityConfiguration = "SecurityConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case subnetId = "SubnetId"
        case tags = "Tags"
        case workerType = "WorkerType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let publicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
        let publicKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .publicKeys)
        var publicKeysDecoded0:[String]? = nil
        if let publicKeysContainer = publicKeysContainer {
            publicKeysDecoded0 = [String]()
            for string0 in publicKeysContainer {
                if let string0 = string0 {
                    publicKeysDecoded0?.append(string0)
                }
            }
        }
        publicKeys = publicKeysDecoded0
        let numberOfNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
        let extraPythonLibsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraPythonLibsS3Path)
        extraPythonLibsS3Path = extraPythonLibsS3PathDecoded
        let extraJarsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraJarsS3Path)
        extraJarsS3Path = extraJarsS3PathDecoded
        let securityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityConfiguration)
        securityConfiguration = securityConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let argumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .arguments)
        var argumentsDecoded0: [String:String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in argumentsContainer {
                if let genericstring0 = genericstring0 {
                    argumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        arguments = argumentsDecoded0
    }
}

extension CreateDevEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDevEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDevEndpointOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case alreadyExistsException(AlreadyExistsException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDevEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDevEndpointOutputResponse(arguments: \(String(describing: arguments)), availabilityZone: \(String(describing: availabilityZone)), createdTimestamp: \(String(describing: createdTimestamp)), endpointName: \(String(describing: endpointName)), extraJarsS3Path: \(String(describing: extraJarsS3Path)), extraPythonLibsS3Path: \(String(describing: extraPythonLibsS3Path)), failureReason: \(String(describing: failureReason)), glueVersion: \(String(describing: glueVersion)), numberOfNodes: \(String(describing: numberOfNodes)), numberOfWorkers: \(String(describing: numberOfWorkers)), roleArn: \(String(describing: roleArn)), securityConfiguration: \(String(describing: securityConfiguration)), securityGroupIds: \(String(describing: securityGroupIds)), status: \(String(describing: status)), subnetId: \(String(describing: subnetId)), vpcId: \(String(describing: vpcId)), workerType: \(String(describing: workerType)), yarnEndpointAddress: \(String(describing: yarnEndpointAddress)), zeppelinRemoteSparkInterpreterPort: \(String(describing: zeppelinRemoteSparkInterpreterPort)))"}
}

extension CreateDevEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDevEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arguments = output.arguments
            self.availabilityZone = output.availabilityZone
            self.createdTimestamp = output.createdTimestamp
            self.endpointName = output.endpointName
            self.extraJarsS3Path = output.extraJarsS3Path
            self.extraPythonLibsS3Path = output.extraPythonLibsS3Path
            self.failureReason = output.failureReason
            self.glueVersion = output.glueVersion
            self.numberOfNodes = output.numberOfNodes
            self.numberOfWorkers = output.numberOfWorkers
            self.roleArn = output.roleArn
            self.securityConfiguration = output.securityConfiguration
            self.securityGroupIds = output.securityGroupIds
            self.status = output.status
            self.subnetId = output.subnetId
            self.vpcId = output.vpcId
            self.workerType = output.workerType
            self.yarnEndpointAddress = output.yarnEndpointAddress
            self.zeppelinRemoteSparkInterpreterPort = output.zeppelinRemoteSparkInterpreterPort
        } else {
            self.arguments = nil
            self.availabilityZone = nil
            self.createdTimestamp = nil
            self.endpointName = nil
            self.extraJarsS3Path = nil
            self.extraPythonLibsS3Path = nil
            self.failureReason = nil
            self.glueVersion = nil
            self.numberOfNodes = 0
            self.numberOfWorkers = nil
            self.roleArn = nil
            self.securityConfiguration = nil
            self.securityGroupIds = nil
            self.status = nil
            self.subnetId = nil
            self.vpcId = nil
            self.workerType = nil
            self.yarnEndpointAddress = nil
            self.zeppelinRemoteSparkInterpreterPort = 0
        }
    }
}

public struct CreateDevEndpointOutputResponse: Equatable {
    /// <p>The map of arguments used to configure this <code>DevEndpoint</code>.</p>
    /// 	
    /// 	        <p>Valid arguments are:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>
    ///                   <code>"--enable-glue-datacatalog": ""</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"GLUE_PYTHON_VERSION": "3"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"GLUE_PYTHON_VERSION": "2"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    /// 	
    ///          <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
    public let arguments: [String:String]?
    /// <p>The AWS Availability Zone where this <code>DevEndpoint</code> is located.</p>
    public let availabilityZone: String?
    /// <p>The point in time at which this <code>DevEndpoint</code> was created.</p>
    public let createdTimestamp: Date?
    /// <p>The name assigned to the new <code>DevEndpoint</code>.</p>
    public let endpointName: String?
    /// <p>Path to one or more Java <code>.jar</code> files in an S3 bucket that will be loaded in
    ///       your <code>DevEndpoint</code>.</p>
    public let extraJarsS3Path: String?
    /// <p>The paths to one or more Python libraries in an S3 bucket that will be loaded in your
    ///         <code>DevEndpoint</code>.</p>
    public let extraPythonLibsS3Path: String?
    /// <p>The reason for a current failure in this <code>DevEndpoint</code>.</p>
    public let failureReason: String?
    /// <p>Glue version determines the versions of Apache Spark and Python that AWS Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. </p>
    public let glueVersion: String?
    /// <p>The number of AWS Glue Data Processing Units (DPUs) allocated to this DevEndpoint.</p>
    public let numberOfNodes: Int
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated to the development endpoint.</p>
    public let numberOfWorkers: Int?
    /// <p>The Amazon Resource Name (ARN) of the role assigned to the new
    ///       <code>DevEndpoint</code>.</p>
    public let roleArn: String?
    /// <p>The name of the <code>SecurityConfiguration</code> structure being used with this
    ///         <code>DevEndpoint</code>.</p>
    public let securityConfiguration: String?
    /// <p>The security groups assigned to the new <code>DevEndpoint</code>.</p>
    public let securityGroupIds: [String]?
    /// <p>The current status of the new <code>DevEndpoint</code>.</p>
    public let status: String?
    /// <p>The subnet ID assigned to the new <code>DevEndpoint</code>.</p>
    public let subnetId: String?
    /// <p>The ID of the virtual private cloud (VPC) used by this <code>DevEndpoint</code>.</p>
    public let vpcId: String?
    /// <p>The type of predefined worker that is allocated to the development endpoint. May be a value of Standard, G.1X, or G.2X.</p>
    public let workerType: WorkerType?
    /// <p>The address of the YARN endpoint used by this <code>DevEndpoint</code>.</p>
    public let yarnEndpointAddress: String?
    /// <p>The Apache Zeppelin port for the remote Apache Spark interpreter.</p>
    public let zeppelinRemoteSparkInterpreterPort: Int

    public init (
        arguments: [String:String]? = nil,
        availabilityZone: String? = nil,
        createdTimestamp: Date? = nil,
        endpointName: String? = nil,
        extraJarsS3Path: String? = nil,
        extraPythonLibsS3Path: String? = nil,
        failureReason: String? = nil,
        glueVersion: String? = nil,
        numberOfNodes: Int = 0,
        numberOfWorkers: Int? = nil,
        roleArn: String? = nil,
        securityConfiguration: String? = nil,
        securityGroupIds: [String]? = nil,
        status: String? = nil,
        subnetId: String? = nil,
        vpcId: String? = nil,
        workerType: WorkerType? = nil,
        yarnEndpointAddress: String? = nil,
        zeppelinRemoteSparkInterpreterPort: Int = 0
    )
    {
        self.arguments = arguments
        self.availabilityZone = availabilityZone
        self.createdTimestamp = createdTimestamp
        self.endpointName = endpointName
        self.extraJarsS3Path = extraJarsS3Path
        self.extraPythonLibsS3Path = extraPythonLibsS3Path
        self.failureReason = failureReason
        self.glueVersion = glueVersion
        self.numberOfNodes = numberOfNodes
        self.numberOfWorkers = numberOfWorkers
        self.roleArn = roleArn
        self.securityConfiguration = securityConfiguration
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.subnetId = subnetId
        self.vpcId = vpcId
        self.workerType = workerType
        self.yarnEndpointAddress = yarnEndpointAddress
        self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
    }
}

struct CreateDevEndpointOutputResponseBody: Equatable {
    public let endpointName: String?
    public let status: String?
    public let securityGroupIds: [String]?
    public let subnetId: String?
    public let roleArn: String?
    public let yarnEndpointAddress: String?
    public let zeppelinRemoteSparkInterpreterPort: Int
    public let numberOfNodes: Int
    public let workerType: WorkerType?
    public let glueVersion: String?
    public let numberOfWorkers: Int?
    public let availabilityZone: String?
    public let vpcId: String?
    public let extraPythonLibsS3Path: String?
    public let extraJarsS3Path: String?
    public let failureReason: String?
    public let securityConfiguration: String?
    public let createdTimestamp: Date?
    public let arguments: [String:String]?
}

extension CreateDevEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arguments = "Arguments"
        case availabilityZone = "AvailabilityZone"
        case createdTimestamp = "CreatedTimestamp"
        case endpointName = "EndpointName"
        case extraJarsS3Path = "ExtraJarsS3Path"
        case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
        case failureReason = "FailureReason"
        case glueVersion = "GlueVersion"
        case numberOfNodes = "NumberOfNodes"
        case numberOfWorkers = "NumberOfWorkers"
        case roleArn = "RoleArn"
        case securityConfiguration = "SecurityConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case status = "Status"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
        case workerType = "WorkerType"
        case yarnEndpointAddress = "YarnEndpointAddress"
        case zeppelinRemoteSparkInterpreterPort = "ZeppelinRemoteSparkInterpreterPort"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let yarnEndpointAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .yarnEndpointAddress)
        yarnEndpointAddress = yarnEndpointAddressDecoded
        let zeppelinRemoteSparkInterpreterPortDecoded = try containerValues.decode(Int.self, forKey: .zeppelinRemoteSparkInterpreterPort)
        zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPortDecoded
        let numberOfNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let extraPythonLibsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraPythonLibsS3Path)
        extraPythonLibsS3Path = extraPythonLibsS3PathDecoded
        let extraJarsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraJarsS3Path)
        extraJarsS3Path = extraJarsS3PathDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let securityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityConfiguration)
        securityConfiguration = securityConfigurationDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let argumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .arguments)
        var argumentsDecoded0: [String:String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in argumentsContainer {
                if let genericstring0 = genericstring0 {
                    argumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        arguments = argumentsDecoded0
    }
}

extension CreateGrokClassifierRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classification = "Classification"
        case customPatterns = "CustomPatterns"
        case grokPattern = "GrokPattern"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let customPatterns = customPatterns {
            try encodeContainer.encode(customPatterns, forKey: .customPatterns)
        }
        if let grokPattern = grokPattern {
            try encodeContainer.encode(grokPattern, forKey: .grokPattern)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classificationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .classification)
        classification = classificationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let grokPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grokPattern)
        grokPattern = grokPatternDecoded
        let customPatternsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customPatterns)
        customPatterns = customPatternsDecoded
    }
}

extension CreateGrokClassifierRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGrokClassifierRequest(classification: \(String(describing: classification)), customPatterns: \(String(describing: customPatterns)), grokPattern: \(String(describing: grokPattern)), name: \(String(describing: name)))"}
}

/// <p>Specifies a <code>grok</code> classifier for <code>CreateClassifier</code>
///       to create.</p>
public struct CreateGrokClassifierRequest: Equatable {
    /// <p>An identifier of the data format that the classifier matches,
    ///       such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.</p>
    public let classification: String?
    /// <p>Optional custom grok patterns used by this classifier.</p>
    public let customPatterns: String?
    /// <p>The grok pattern used by this classifier.</p>
    public let grokPattern: String?
    /// <p>The name of the new classifier.</p>
    public let name: String?

    public init (
        classification: String? = nil,
        customPatterns: String? = nil,
        grokPattern: String? = nil,
        name: String? = nil
    )
    {
        self.classification = classification
        self.customPatterns = customPatterns
        self.grokPattern = grokPattern
        self.name = name
    }
}

public struct CreateJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

extension CreateJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobInput(allocatedCapacity: \(String(describing: allocatedCapacity)), command: \(String(describing: command)), connections: \(String(describing: connections)), defaultArguments: \(String(describing: defaultArguments)), description: \(String(describing: description)), executionProperty: \(String(describing: executionProperty)), glueVersion: \(String(describing: glueVersion)), logUri: \(String(describing: logUri)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), nonOverridableArguments: \(String(describing: nonOverridableArguments)), notificationProperty: \(String(describing: notificationProperty)), numberOfWorkers: \(String(describing: numberOfWorkers)), role: \(String(describing: role)), securityConfiguration: \(String(describing: securityConfiguration)), tags: \(String(describing: tags)), timeout: \(String(describing: timeout)), workerType: \(String(describing: workerType)))"}
}

extension CreateJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedCapacity = "AllocatedCapacity"
        case command = "Command"
        case connections = "Connections"
        case defaultArguments = "DefaultArguments"
        case description = "Description"
        case executionProperty = "ExecutionProperty"
        case glueVersion = "GlueVersion"
        case logUri = "LogUri"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case nonOverridableArguments = "NonOverridableArguments"
        case notificationProperty = "NotificationProperty"
        case numberOfWorkers = "NumberOfWorkers"
        case role = "Role"
        case securityConfiguration = "SecurityConfiguration"
        case tags = "Tags"
        case timeout = "Timeout"
        case workerType = "WorkerType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedCapacity != 0 {
            try encodeContainer.encode(allocatedCapacity, forKey: .allocatedCapacity)
        }
        if let command = command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let connections = connections {
            try encodeContainer.encode(connections, forKey: .connections)
        }
        if let defaultArguments = defaultArguments {
            var defaultArgumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .defaultArguments)
            for (dictKey0, genericmap0) in defaultArguments {
                try defaultArgumentsContainer.encode(genericmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionProperty = executionProperty {
            try encodeContainer.encode(executionProperty, forKey: .executionProperty)
        }
        if let glueVersion = glueVersion {
            try encodeContainer.encode(glueVersion, forKey: .glueVersion)
        }
        if let logUri = logUri {
            try encodeContainer.encode(logUri, forKey: .logUri)
        }
        if let maxCapacity = maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if maxRetries != 0 {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nonOverridableArguments = nonOverridableArguments {
            var nonOverridableArgumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .nonOverridableArguments)
            for (dictKey0, genericmap0) in nonOverridableArguments {
                try nonOverridableArgumentsContainer.encode(genericmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let notificationProperty = notificationProperty {
            try encodeContainer.encode(notificationProperty, forKey: .notificationProperty)
        }
        if let numberOfWorkers = numberOfWorkers {
            try encodeContainer.encode(numberOfWorkers, forKey: .numberOfWorkers)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let securityConfiguration = securityConfiguration {
            try encodeContainer.encode(securityConfiguration, forKey: .securityConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let workerType = workerType {
            try encodeContainer.encode(workerType.rawValue, forKey: .workerType)
        }
    }
}

public struct CreateJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

public struct CreateJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

public struct CreateJobInput: Equatable {
    /// <p>This parameter is deprecated. Use <code>MaxCapacity</code> instead.</p>
    /// 	
    ///          <p>The number of AWS Glue data processing units (DPUs) to allocate to this Job. You can
    ///       allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing
    ///       power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information,
    ///       see the <a href="https://aws.amazon.com/glue/pricing/">AWS Glue pricing
    ///       page</a>.</p>
    @available(*, deprecated, message: "This property is deprecated, use MaxCapacity instead.")
    public let allocatedCapacity: Int
    /// <p>The <code>JobCommand</code> that executes this job.</p>
    public let command: JobCommand?
    /// <p>The connections used for this job.</p>
    public let connections: ConnectionsList?
    /// <p>The default arguments for this job.</p>
    ///          <p>You can specify arguments here that your own job-execution script
    ///       consumes, as well as arguments that AWS Glue itself consumes.</p>
    ///          <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling AWS Glue APIs in Python</a> topic in the developer guide.</p>
    ///          <p>For information about the key-value pairs that AWS Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by AWS Glue</a> topic in the developer guide.</p>
    public let defaultArguments: [String:String]?
    /// <p>Description of the job being defined.</p>
    public let description: String?
    /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed
    ///       for this job.</p>
    public let executionProperty: ExecutionProperty?
    /// <p>Glue version determines the versions of Apache Spark and Python that AWS Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
    ///
    ///          <p>For more information about the available AWS Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    /// 	
    /// 	        <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
    public let glueVersion: String?
    /// <p>This field is reserved for future use.</p>
    public let logUri: String?
    /// <p>The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure
    ///        of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
    ///        For more information, see the <a href="https://aws.amazon.com/glue/pricing/">AWS Glue
    ///          pricing page</a>.</p>
    /// 		
    /// 	        <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
    ///
    ///          <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are
    ///       running a Python shell job or an Apache Spark ETL job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can
    ///           allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p>
    ///             </li>
    ///             <li>
    ///                <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache
    ///          Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate from 2 to 100 DPUs.
    ///          The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p>
    ///             </li>
    ///          </ul>
    public let maxCapacity: Double?
    /// <p>The maximum number of times to retry this job if it fails.</p>
    public let maxRetries: Int
    /// <p>The name you assign to this job definition. It must be unique in your account.</p>
    public let name: String?
    /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
    public let nonOverridableArguments: [String:String]?
    /// <p>Specifies configuration properties of a job notification.</p>
    public let notificationProperty: NotificationProperty?
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
    /// 	
    /// 	        <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
    public let numberOfWorkers: Int?
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job.</p>
    public let role: String?
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this
    ///       job.</p>
    public let securityConfiguration: String?
    /// <p>The tags to use with this job. You may use tags to limit access to the job. For more information about tags in AWS Glue, see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">AWS Tags in AWS Glue</a> in the developer guide.</p>
    public let tags: [String:String]?
    /// <p>The job timeout in minutes.  This is the maximum time that a job run
    ///       can consume resources before it is terminated and enters <code>TIMEOUT</code>
    ///       status. The default is 2,880 minutes (48 hours).</p>
    public let timeout: Int?
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
    ///             </li>
    ///          </ul>
    public let workerType: WorkerType?

    public init (
        allocatedCapacity: Int = 0,
        command: JobCommand? = nil,
        connections: ConnectionsList? = nil,
        defaultArguments: [String:String]? = nil,
        description: String? = nil,
        executionProperty: ExecutionProperty? = nil,
        glueVersion: String? = nil,
        logUri: String? = nil,
        maxCapacity: Double? = nil,
        maxRetries: Int = 0,
        name: String? = nil,
        nonOverridableArguments: [String:String]? = nil,
        notificationProperty: NotificationProperty? = nil,
        numberOfWorkers: Int? = nil,
        role: String? = nil,
        securityConfiguration: String? = nil,
        tags: [String:String]? = nil,
        timeout: Int? = nil,
        workerType: WorkerType? = nil
    )
    {
        self.allocatedCapacity = allocatedCapacity
        self.command = command
        self.connections = connections
        self.defaultArguments = defaultArguments
        self.description = description
        self.executionProperty = executionProperty
        self.glueVersion = glueVersion
        self.logUri = logUri
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.nonOverridableArguments = nonOverridableArguments
        self.notificationProperty = notificationProperty
        self.numberOfWorkers = numberOfWorkers
        self.role = role
        self.securityConfiguration = securityConfiguration
        self.tags = tags
        self.timeout = timeout
        self.workerType = workerType
    }
}

struct CreateJobInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let logUri: String?
    public let role: String?
    public let executionProperty: ExecutionProperty?
    public let command: JobCommand?
    public let defaultArguments: [String:String]?
    public let nonOverridableArguments: [String:String]?
    public let connections: ConnectionsList?
    public let maxRetries: Int
    public let allocatedCapacity: Int
    public let timeout: Int?
    public let maxCapacity: Double?
    public let securityConfiguration: String?
    public let tags: [String:String]?
    public let notificationProperty: NotificationProperty?
    public let glueVersion: String?
    public let numberOfWorkers: Int?
    public let workerType: WorkerType?
}

extension CreateJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allocatedCapacity = "AllocatedCapacity"
        case command = "Command"
        case connections = "Connections"
        case defaultArguments = "DefaultArguments"
        case description = "Description"
        case executionProperty = "ExecutionProperty"
        case glueVersion = "GlueVersion"
        case logUri = "LogUri"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case nonOverridableArguments = "NonOverridableArguments"
        case notificationProperty = "NotificationProperty"
        case numberOfWorkers = "NumberOfWorkers"
        case role = "Role"
        case securityConfiguration = "SecurityConfiguration"
        case tags = "Tags"
        case timeout = "Timeout"
        case workerType = "WorkerType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let logUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logUri)
        logUri = logUriDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let executionPropertyDecoded = try containerValues.decodeIfPresent(ExecutionProperty.self, forKey: .executionProperty)
        executionProperty = executionPropertyDecoded
        let commandDecoded = try containerValues.decodeIfPresent(JobCommand.self, forKey: .command)
        command = commandDecoded
        let defaultArgumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .defaultArguments)
        var defaultArgumentsDecoded0: [String:String]? = nil
        if let defaultArgumentsContainer = defaultArgumentsContainer {
            defaultArgumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in defaultArgumentsContainer {
                if let genericstring0 = genericstring0 {
                    defaultArgumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        defaultArguments = defaultArgumentsDecoded0
        let nonOverridableArgumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .nonOverridableArguments)
        var nonOverridableArgumentsDecoded0: [String:String]? = nil
        if let nonOverridableArgumentsContainer = nonOverridableArgumentsContainer {
            nonOverridableArgumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in nonOverridableArgumentsContainer {
                if let genericstring0 = genericstring0 {
                    nonOverridableArgumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        nonOverridableArguments = nonOverridableArgumentsDecoded0
        let connectionsDecoded = try containerValues.decodeIfPresent(ConnectionsList.self, forKey: .connections)
        connections = connectionsDecoded
        let maxRetriesDecoded = try containerValues.decode(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let allocatedCapacityDecoded = try containerValues.decode(Int.self, forKey: .allocatedCapacity)
        allocatedCapacity = allocatedCapacityDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let securityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityConfiguration)
        securityConfiguration = securityConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let notificationPropertyDecoded = try containerValues.decodeIfPresent(NotificationProperty.self, forKey: .notificationProperty)
        notificationProperty = notificationPropertyDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
    }
}

extension CreateJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJobOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case concurrentModificationException(ConcurrentModificationException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobOutputResponse(name: \(String(describing: name)))"}
}

extension CreateJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateJobOutputResponse: Equatable {
    /// <p>The unique name that was provided for this job definition.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateJobOutputResponseBody: Equatable {
    public let name: String?
}

extension CreateJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateJsonClassifierRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jsonPath = "JsonPath"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonPath = jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let jsonPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
    }
}

extension CreateJsonClassifierRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJsonClassifierRequest(jsonPath: \(String(describing: jsonPath)), name: \(String(describing: name)))"}
}

/// <p>Specifies a JSON classifier for <code>CreateClassifier</code> to create.</p>
public struct CreateJsonClassifierRequest: Equatable {
    /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify.
    ///       AWS Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
    public let jsonPath: String?
    /// <p>The name of the classifier.</p>
    public let name: String?

    public init (
        jsonPath: String? = nil,
        name: String? = nil
    )
    {
        self.jsonPath = jsonPath
        self.name = name
    }
}

public struct CreateMLTransformInputBodyMiddleware: Middleware {
    public let id: String = "CreateMLTransformInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMLTransformInput>
    public typealias MOutput = OperationOutput<CreateMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMLTransformOutputError>
}

extension CreateMLTransformInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMLTransformInput(description: \(String(describing: description)), glueVersion: \(String(describing: glueVersion)), inputRecordTables: \(String(describing: inputRecordTables)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), numberOfWorkers: \(String(describing: numberOfWorkers)), parameters: \(String(describing: parameters)), role: \(String(describing: role)), tags: \(String(describing: tags)), timeout: \(String(describing: timeout)), transformEncryption: \(String(describing: transformEncryption)), workerType: \(String(describing: workerType)))"}
}

extension CreateMLTransformInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case glueVersion = "GlueVersion"
        case inputRecordTables = "InputRecordTables"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case numberOfWorkers = "NumberOfWorkers"
        case parameters = "Parameters"
        case role = "Role"
        case tags = "Tags"
        case timeout = "Timeout"
        case transformEncryption = "TransformEncryption"
        case workerType = "WorkerType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let glueVersion = glueVersion {
            try encodeContainer.encode(glueVersion, forKey: .glueVersion)
        }
        if let inputRecordTables = inputRecordTables {
            var inputRecordTablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputRecordTables)
            for gluetables0 in inputRecordTables {
                try inputRecordTablesContainer.encode(gluetables0)
            }
        }
        if let maxCapacity = maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let maxRetries = maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberOfWorkers = numberOfWorkers {
            try encodeContainer.encode(numberOfWorkers, forKey: .numberOfWorkers)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let transformEncryption = transformEncryption {
            try encodeContainer.encode(transformEncryption, forKey: .transformEncryption)
        }
        if let workerType = workerType {
            try encodeContainer.encode(workerType.rawValue, forKey: .workerType)
        }
    }
}

public struct CreateMLTransformInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMLTransformInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMLTransformInput>
    public typealias MOutput = OperationOutput<CreateMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMLTransformOutputError>
}

public struct CreateMLTransformInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMLTransformInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMLTransformInput>
    public typealias MOutput = OperationOutput<CreateMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMLTransformOutputError>
}

public struct CreateMLTransformInput: Equatable {
    /// <p>A description of the machine learning transform that is being defined. The default is an
    ///       empty string.</p>
    public let description: String?
    /// <p>This value determines which version of AWS Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">AWS Glue Versions</a> in the developer guide.</p>
    public let glueVersion: String?
    /// <p>A list of AWS Glue table definitions used by the transform.</p>
    public let inputRecordTables: [GlueTable]?
    /// <p>The number of AWS Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of
    ///       processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
    ///       information, see the <a href="https://aws.amazon.com/glue/pricing/">AWS Glue pricing
    ///         page</a>. </p>
    /// 		
    /// 			      <p>
    ///             <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
    ///         <ul>
    ///             <li>
    ///                <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p>
    ///             </li>
    ///          </ul>
    /// 		
    /// 	        <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>	
    ///
    /// 		
    ///          <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
    public let maxCapacity: Double?
    /// <p>The maximum number of times to retry a task for this transform after a task run fails.</p>
    public let maxRetries: Int?
    /// <p>The unique name that you give the transform when you create it.</p>
    public let name: String?
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when this task runs.</p>
    /// 	
    /// 		       <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
    public let numberOfWorkers: Int?
    /// <p>The algorithmic parameters that are specific to the transform type used. Conditionally
    ///       dependent on the transform type.</p>
    public let parameters: TransformParameters?
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both AWS Glue service role permissions to AWS Glue resources, and Amazon S3 permissions required by the transform. </p>
    ///
    /// 		       <ul>
    ///             <li>
    ///                <p>This role needs AWS Glue service role permissions to allow access to resources in AWS Glue. See <a href="https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html">Attach a Policy to IAM Users That Access AWS Glue</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.</p>
    ///             </li>
    ///          </ul>
    public let role: String?
    /// <p>The tags to use with this machine learning transform. You may use tags to limit access to the machine learning transform. For more information about tags in AWS Glue, see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">AWS Tags in AWS Glue</a> in the developer guide.</p>
    public let tags: [String:String]?
    /// <p>The timeout of the task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
    public let timeout: Int?
    /// <p>The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.</p>
    public let transformEncryption: TransformEncryption?
    /// <p>The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///          </ul>
    /// 	
    /// 	        <p>
    ///             <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
    ///         <ul>
    ///             <li>
    ///                <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p>
    ///             </li>
    ///          </ul>
    public let workerType: WorkerType?

    public init (
        description: String? = nil,
        glueVersion: String? = nil,
        inputRecordTables: [GlueTable]? = nil,
        maxCapacity: Double? = nil,
        maxRetries: Int? = nil,
        name: String? = nil,
        numberOfWorkers: Int? = nil,
        parameters: TransformParameters? = nil,
        role: String? = nil,
        tags: [String:String]? = nil,
        timeout: Int? = nil,
        transformEncryption: TransformEncryption? = nil,
        workerType: WorkerType? = nil
    )
    {
        self.description = description
        self.glueVersion = glueVersion
        self.inputRecordTables = inputRecordTables
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.numberOfWorkers = numberOfWorkers
        self.parameters = parameters
        self.role = role
        self.tags = tags
        self.timeout = timeout
        self.transformEncryption = transformEncryption
        self.workerType = workerType
    }
}

struct CreateMLTransformInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let inputRecordTables: [GlueTable]?
    public let parameters: TransformParameters?
    public let role: String?
    public let glueVersion: String?
    public let maxCapacity: Double?
    public let workerType: WorkerType?
    public let numberOfWorkers: Int?
    public let timeout: Int?
    public let maxRetries: Int?
    public let tags: [String:String]?
    public let transformEncryption: TransformEncryption?
}

extension CreateMLTransformInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case glueVersion = "GlueVersion"
        case inputRecordTables = "InputRecordTables"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case numberOfWorkers = "NumberOfWorkers"
        case parameters = "Parameters"
        case role = "Role"
        case tags = "Tags"
        case timeout = "Timeout"
        case transformEncryption = "TransformEncryption"
        case workerType = "WorkerType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let inputRecordTablesContainer = try containerValues.decodeIfPresent([GlueTable?].self, forKey: .inputRecordTables)
        var inputRecordTablesDecoded0:[GlueTable]? = nil
        if let inputRecordTablesContainer = inputRecordTablesContainer {
            inputRecordTablesDecoded0 = [GlueTable]()
            for structure0 in inputRecordTablesContainer {
                if let structure0 = structure0 {
                    inputRecordTablesDecoded0?.append(structure0)
                }
            }
        }
        inputRecordTables = inputRecordTablesDecoded0
        let parametersDecoded = try containerValues.decodeIfPresent(TransformParameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let transformEncryptionDecoded = try containerValues.decodeIfPresent(TransformEncryption.self, forKey: .transformEncryption)
        transformEncryption = transformEncryptionDecoded
    }
}

extension CreateMLTransformOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMLTransformOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMLTransformOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case alreadyExistsException(AlreadyExistsException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMLTransformOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMLTransformOutputResponse(transformId: \(String(describing: transformId)))"}
}

extension CreateMLTransformOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMLTransformOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transformId = output.transformId
        } else {
            self.transformId = nil
        }
    }
}

public struct CreateMLTransformOutputResponse: Equatable {
    /// <p>A unique identifier that is generated for the transform.</p>
    public let transformId: String?

    public init (
        transformId: String? = nil
    )
    {
        self.transformId = transformId
    }
}

struct CreateMLTransformOutputResponseBody: Equatable {
    public let transformId: String?
}

extension CreateMLTransformOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
    }
}

public struct CreatePartitionIndexInputBodyMiddleware: Middleware {
    public let id: String = "CreatePartitionIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePartitionIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePartitionIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePartitionIndexInput>
    public typealias MOutput = OperationOutput<CreatePartitionIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePartitionIndexOutputError>
}

extension CreatePartitionIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePartitionIndexInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), partitionIndex: \(String(describing: partitionIndex)), tableName: \(String(describing: tableName)))"}
}

extension CreatePartitionIndexInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionIndex = "PartitionIndex"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionIndex = partitionIndex {
            try encodeContainer.encode(partitionIndex, forKey: .partitionIndex)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct CreatePartitionIndexInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePartitionIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePartitionIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePartitionIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePartitionIndexInput>
    public typealias MOutput = OperationOutput<CreatePartitionIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePartitionIndexOutputError>
}

public struct CreatePartitionIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePartitionIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePartitionIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePartitionIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePartitionIndexInput>
    public typealias MOutput = OperationOutput<CreatePartitionIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePartitionIndexOutputError>
}

public struct CreatePartitionIndexInput: Equatable {
    /// <p>The catalog ID where the table resides.</p>
    public let catalogId: String?
    /// <p>Specifies the name of a database in which you want to create a partition index.</p>
    public let databaseName: String?
    /// <p>Specifies a <code>PartitionIndex</code> structure to create a partition index in an existing table.</p>
    public let partitionIndex: PartitionIndex?
    /// <p>Specifies the name of a table in which you want to create a partition index.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        partitionIndex: PartitionIndex? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionIndex = partitionIndex
        self.tableName = tableName
    }
}

struct CreatePartitionIndexInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let partitionIndex: PartitionIndex?
}

extension CreatePartitionIndexInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionIndex = "PartitionIndex"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let partitionIndexDecoded = try containerValues.decodeIfPresent(PartitionIndex.self, forKey: .partitionIndex)
        partitionIndex = partitionIndexDecoded
    }
}

extension CreatePartitionIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePartitionIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePartitionIndexOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePartitionIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePartitionIndexOutputResponse()"}
}

extension CreatePartitionIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreatePartitionIndexOutputResponse: Equatable {

    public init() {}
}

struct CreatePartitionIndexOutputResponseBody: Equatable {
}

extension CreatePartitionIndexOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreatePartitionInputBodyMiddleware: Middleware {
    public let id: String = "CreatePartitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePartitionInput>
    public typealias MOutput = OperationOutput<CreatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePartitionOutputError>
}

extension CreatePartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePartitionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), partitionInput: \(String(describing: partitionInput)), tableName: \(String(describing: tableName)))"}
}

extension CreatePartitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionInput = "PartitionInput"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionInput = partitionInput {
            try encodeContainer.encode(partitionInput, forKey: .partitionInput)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct CreatePartitionInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePartitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePartitionInput>
    public typealias MOutput = OperationOutput<CreatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePartitionOutputError>
}

public struct CreatePartitionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePartitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePartitionInput>
    public typealias MOutput = OperationOutput<CreatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePartitionOutputError>
}

public struct CreatePartitionInput: Equatable {
    /// <p>The AWS account ID of the catalog in which the partition is to be created.</p>
    public let catalogId: String?
    /// <p>The name of the metadata database in which the partition is
    ///       to be created.</p>
    public let databaseName: String?
    /// <p>A <code>PartitionInput</code> structure defining the partition
    ///       to be created.</p>
    public let partitionInput: PartitionInput?
    /// <p>The name of the metadata table in which the partition is to be created.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        partitionInput: PartitionInput? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionInput = partitionInput
        self.tableName = tableName
    }
}

struct CreatePartitionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let partitionInput: PartitionInput?
}

extension CreatePartitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionInput = "PartitionInput"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let partitionInputDecoded = try containerValues.decodeIfPresent(PartitionInput.self, forKey: .partitionInput)
        partitionInput = partitionInputDecoded
    }
}

extension CreatePartitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePartitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePartitionOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePartitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePartitionOutputResponse()"}
}

extension CreatePartitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreatePartitionOutputResponse: Equatable {

    public init() {}
}

struct CreatePartitionOutputResponseBody: Equatable {
}

extension CreatePartitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateRegistryInputBodyMiddleware: Middleware {
    public let id: String = "CreateRegistryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegistryInput>
    public typealias MOutput = OperationOutput<CreateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegistryOutputError>
}

extension CreateRegistryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRegistryInput(description: \(String(describing: description)), registryName: \(String(describing: registryName)), tags: \(String(describing: tags)))"}
}

extension CreateRegistryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case registryName = "RegistryName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let registryName = registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRegistryInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRegistryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegistryInput>
    public typealias MOutput = OperationOutput<CreateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegistryOutputError>
}

public struct CreateRegistryInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRegistryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegistryInput>
    public typealias MOutput = OperationOutput<CreateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegistryOutputError>
}

public struct CreateRegistryInput: Equatable {
    /// <p>A description of the registry. If description is not provided, there will not be any default value for this.</p>
    public let description: String?
    /// <p>Name of the registry to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark.  No whitespace.</p>
    public let registryName: String?
    /// <p>AWS tags that contain a key value pair and may be searched by console, command line, or API.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        registryName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.registryName = registryName
        self.tags = tags
    }
}

struct CreateRegistryInputBody: Equatable {
    public let registryName: String?
    public let description: String?
    public let tags: [String:String]?
}

extension CreateRegistryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case registryName = "RegistryName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRegistryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRegistryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRegistryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case alreadyExistsException(AlreadyExistsException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRegistryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRegistryOutputResponse(description: \(String(describing: description)), registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)), tags: \(String(describing: tags)))"}
}

extension CreateRegistryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRegistryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct CreateRegistryOutputResponse: Equatable {
    /// <p>A description of the registry.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the newly created registry.</p>
    public let registryArn: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The tags for the registry.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        registryArn: String? = nil,
        registryName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct CreateRegistryOutputResponseBody: Equatable {
    public let registryArn: String?
    public let registryName: String?
    public let description: String?
    public let tags: [String:String]?
}

extension CreateRegistryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateSchemaInputBodyMiddleware: Middleware {
    public let id: String = "CreateSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

extension CreateSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSchemaInput(compatibility: \(String(describing: compatibility)), dataFormat: \(String(describing: dataFormat)), description: \(String(describing: description)), registryId: \(String(describing: registryId)), schemaDefinition: \(String(describing: schemaDefinition)), schemaName: \(String(describing: schemaName)), tags: \(String(describing: tags)))"}
}

extension CreateSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compatibility = "Compatibility"
        case dataFormat = "DataFormat"
        case description = "Description"
        case registryId = "RegistryId"
        case schemaDefinition = "SchemaDefinition"
        case schemaName = "SchemaName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibility = compatibility {
            try encodeContainer.encode(compatibility.rawValue, forKey: .compatibility)
        }
        if let dataFormat = dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let schemaDefinition = schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInput: Equatable {
    /// <p>The compatibility mode of the schema. The possible values are:</p>
    /// 	
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <i>NONE</i>: No compatibility mode applies. You can use this choice in development scenarios or if you do not know the compatibility mode that you want to apply to schemas. Any new version added will be accepted without undergoing a compatibility check.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>DISABLED</i>: This compatibility choice prevents versioning for a particular schema. You can use this choice to prevent future versioning of a schema.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>BACKWARD</i>: This compatibility choice is recommended as it allows data receivers to read both the current and one previous schema version. This means that for instance, a new schema version cannot drop data fields or change the type of these fields, so they can't be read by readers using the previous version.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>BACKWARD_ALL</i>: This compatibility choice allows data receivers to read both the current and all previous schema versions. You can use this choice when you need to delete fields or add optional fields, and check compatibility against all previous schema versions. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>FORWARD</i>: This compatibility choice allows data receivers to read both the current and one next schema version, but not necessarily later versions. You can use this choice when you need to add fields or delete optional fields, but only check compatibility against the last schema version.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>FORWARD_ALL</i>: This compatibility choice allows data receivers to read written by producers of any new registered schema. You can use this choice when you need to add fields or delete optional fields, and check compatibility against all previous schema versions.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>FULL</i>: This compatibility choice allows data receivers to read data written by producers using the previous or next version of the schema, but not necessarily earlier or later versions. You can use this choice when you need to add or remove optional fields, but only check compatibility against the last schema version.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>FULL_ALL</i>: This compatibility choice allows data receivers to read data written by producers using all previous schema versions. You can use this choice when you need to add or remove optional fields, and check compatibility against all previous schema versions.</p>
    ///             </li>
    ///          </ul>
    public let compatibility: Compatibility?
    /// <p>The data format of the schema definition. Currently only <code>AVRO</code> is supported.</p>
    public let dataFormat: DataFormat?
    /// <p>An optional description of the schema. If description is not provided, there will not be any automatic default value for this.</p>
    public let description: String?
    /// <p> This is a wrapper shape to contain the registry identity fields. If this is not provided, the default registry will be used. The ARN format for the same will be: <code>arn:aws:glue:us-east-2:<customer id>:registry/default-registry:random-5-letter-id</code>.</p>
    public let registryId: RegistryId?
    /// <p>The schema definition using the <code>DataFormat</code> setting for <code>SchemaName</code>.</p>
    public let schemaDefinition: String?
    /// <p>Name of the schema to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark. No whitespace.</p>
    public let schemaName: String?
    /// <p>AWS tags that contain a key value pair and may be searched by console, command line, or API. If specified, follows the AWS tags-on-create pattern.</p>
    public let tags: [String:String]?

    public init (
        compatibility: Compatibility? = nil,
        dataFormat: DataFormat? = nil,
        description: String? = nil,
        registryId: RegistryId? = nil,
        schemaDefinition: String? = nil,
        schemaName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.compatibility = compatibility
        self.dataFormat = dataFormat
        self.description = description
        self.registryId = registryId
        self.schemaDefinition = schemaDefinition
        self.schemaName = schemaName
        self.tags = tags
    }
}

struct CreateSchemaInputBody: Equatable {
    public let registryId: RegistryId?
    public let schemaName: String?
    public let dataFormat: DataFormat?
    public let compatibility: Compatibility?
    public let description: String?
    public let tags: [String:String]?
    public let schemaDefinition: String?
}

extension CreateSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibility = "Compatibility"
        case dataFormat = "DataFormat"
        case description = "Description"
        case registryId = "RegistryId"
        case schemaDefinition = "SchemaDefinition"
        case schemaName = "SchemaName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(RegistryId.self, forKey: .registryId)
        registryId = registryIdDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let compatibilityDecoded = try containerValues.decodeIfPresent(Compatibility.self, forKey: .compatibility)
        compatibility = compatibilityDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension CreateSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSchemaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case alreadyExistsException(AlreadyExistsException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSchemaOutputResponse(compatibility: \(String(describing: compatibility)), dataFormat: \(String(describing: dataFormat)), description: \(String(describing: description)), latestSchemaVersion: \(String(describing: latestSchemaVersion)), nextSchemaVersion: \(String(describing: nextSchemaVersion)), registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)), schemaArn: \(String(describing: schemaArn)), schemaCheckpoint: \(String(describing: schemaCheckpoint)), schemaName: \(String(describing: schemaName)), schemaStatus: \(String(describing: schemaStatus)), schemaVersionId: \(String(describing: schemaVersionId)), schemaVersionStatus: \(String(describing: schemaVersionStatus)), tags: \(String(describing: tags)))"}
}

extension CreateSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.compatibility = output.compatibility
            self.dataFormat = output.dataFormat
            self.description = output.description
            self.latestSchemaVersion = output.latestSchemaVersion
            self.nextSchemaVersion = output.nextSchemaVersion
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.schemaArn = output.schemaArn
            self.schemaCheckpoint = output.schemaCheckpoint
            self.schemaName = output.schemaName
            self.schemaStatus = output.schemaStatus
            self.schemaVersionId = output.schemaVersionId
            self.schemaVersionStatus = output.schemaVersionStatus
            self.tags = output.tags
        } else {
            self.compatibility = nil
            self.dataFormat = nil
            self.description = nil
            self.latestSchemaVersion = 0
            self.nextSchemaVersion = 0
            self.registryArn = nil
            self.registryName = nil
            self.schemaArn = nil
            self.schemaCheckpoint = 0
            self.schemaName = nil
            self.schemaStatus = nil
            self.schemaVersionId = nil
            self.schemaVersionStatus = nil
            self.tags = nil
        }
    }
}

public struct CreateSchemaOutputResponse: Equatable {
    /// <p>The schema compatibility mode.</p>
    public let compatibility: Compatibility?
    /// <p>The data format of the schema definition. Currently only <code>AVRO</code> is supported.</p>
    public let dataFormat: DataFormat?
    /// <p>A description of the schema if specified when created.</p>
    public let description: String?
    /// <p>The latest version of the schema associated with the returned schema definition.</p>
    public let latestSchemaVersion: Int
    /// <p>The next version of the schema associated with the returned schema definition.</p>
    public let nextSchemaVersion: Int
    /// <p>The Amazon Resource Name (ARN) of the registry.</p>
    public let registryArn: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The Amazon Resource Name (ARN) of the schema.</p>
    public let schemaArn: String?
    /// <p>The version number of the checkpoint (the last time the compatibility mode was changed).</p>
    public let schemaCheckpoint: Int
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>The status of the schema. </p>
    public let schemaStatus: SchemaStatus?
    /// <p>The unique identifier of the first schema version.</p>
    public let schemaVersionId: String?
    /// <p>The status of the first schema version created.</p>
    public let schemaVersionStatus: SchemaVersionStatus?
    /// <p>The tags for the schema.</p>
    public let tags: [String:String]?

    public init (
        compatibility: Compatibility? = nil,
        dataFormat: DataFormat? = nil,
        description: String? = nil,
        latestSchemaVersion: Int = 0,
        nextSchemaVersion: Int = 0,
        registryArn: String? = nil,
        registryName: String? = nil,
        schemaArn: String? = nil,
        schemaCheckpoint: Int = 0,
        schemaName: String? = nil,
        schemaStatus: SchemaStatus? = nil,
        schemaVersionId: String? = nil,
        schemaVersionStatus: SchemaVersionStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.compatibility = compatibility
        self.dataFormat = dataFormat
        self.description = description
        self.latestSchemaVersion = latestSchemaVersion
        self.nextSchemaVersion = nextSchemaVersion
        self.registryArn = registryArn
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaCheckpoint = schemaCheckpoint
        self.schemaName = schemaName
        self.schemaStatus = schemaStatus
        self.schemaVersionId = schemaVersionId
        self.schemaVersionStatus = schemaVersionStatus
        self.tags = tags
    }
}

struct CreateSchemaOutputResponseBody: Equatable {
    public let registryName: String?
    public let registryArn: String?
    public let schemaName: String?
    public let schemaArn: String?
    public let description: String?
    public let dataFormat: DataFormat?
    public let compatibility: Compatibility?
    public let schemaCheckpoint: Int
    public let latestSchemaVersion: Int
    public let nextSchemaVersion: Int
    public let schemaStatus: SchemaStatus?
    public let tags: [String:String]?
    public let schemaVersionId: String?
    public let schemaVersionStatus: SchemaVersionStatus?
}

extension CreateSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibility = "Compatibility"
        case dataFormat = "DataFormat"
        case description = "Description"
        case latestSchemaVersion = "LatestSchemaVersion"
        case nextSchemaVersion = "NextSchemaVersion"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case schemaArn = "SchemaArn"
        case schemaCheckpoint = "SchemaCheckpoint"
        case schemaName = "SchemaName"
        case schemaStatus = "SchemaStatus"
        case schemaVersionId = "SchemaVersionId"
        case schemaVersionStatus = "SchemaVersionStatus"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let compatibilityDecoded = try containerValues.decodeIfPresent(Compatibility.self, forKey: .compatibility)
        compatibility = compatibilityDecoded
        let schemaCheckpointDecoded = try containerValues.decode(Int.self, forKey: .schemaCheckpoint)
        schemaCheckpoint = schemaCheckpointDecoded
        let latestSchemaVersionDecoded = try containerValues.decode(Int.self, forKey: .latestSchemaVersion)
        latestSchemaVersion = latestSchemaVersionDecoded
        let nextSchemaVersionDecoded = try containerValues.decode(Int.self, forKey: .nextSchemaVersion)
        nextSchemaVersion = nextSchemaVersionDecoded
        let schemaStatusDecoded = try containerValues.decodeIfPresent(SchemaStatus.self, forKey: .schemaStatus)
        schemaStatus = schemaStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let schemaVersionStatusDecoded = try containerValues.decodeIfPresent(SchemaVersionStatus.self, forKey: .schemaVersionStatus)
        schemaVersionStatus = schemaVersionStatusDecoded
    }
}

public struct CreateScriptInputBodyMiddleware: Middleware {
    public let id: String = "CreateScriptInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScriptInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScriptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScriptInput>
    public typealias MOutput = OperationOutput<CreateScriptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScriptOutputError>
}

extension CreateScriptInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateScriptInput(dagEdges: \(String(describing: dagEdges)), dagNodes: \(String(describing: dagNodes)), language: \(String(describing: language)))"}
}

extension CreateScriptInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dagEdges = "DagEdges"
        case dagNodes = "DagNodes"
        case language = "Language"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dagEdges = dagEdges {
            var dagEdgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dagEdges)
            for dagedges0 in dagEdges {
                try dagEdgesContainer.encode(dagedges0)
            }
        }
        if let dagNodes = dagNodes {
            var dagNodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dagNodes)
            for dagnodes0 in dagNodes {
                try dagNodesContainer.encode(dagnodes0)
            }
        }
        if let language = language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
    }
}

public struct CreateScriptInputHeadersMiddleware: Middleware {
    public let id: String = "CreateScriptInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScriptInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScriptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScriptInput>
    public typealias MOutput = OperationOutput<CreateScriptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScriptOutputError>
}

public struct CreateScriptInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateScriptInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScriptInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScriptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScriptInput>
    public typealias MOutput = OperationOutput<CreateScriptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScriptOutputError>
}

public struct CreateScriptInput: Equatable {
    /// <p>A list of the edges in the DAG.</p>
    public let dagEdges: [CodeGenEdge]?
    /// <p>A list of the nodes in the DAG.</p>
    public let dagNodes: [CodeGenNode]?
    /// <p>The programming language of the resulting code from the DAG.</p>
    public let language: Language?

    public init (
        dagEdges: [CodeGenEdge]? = nil,
        dagNodes: [CodeGenNode]? = nil,
        language: Language? = nil
    )
    {
        self.dagEdges = dagEdges
        self.dagNodes = dagNodes
        self.language = language
    }
}

struct CreateScriptInputBody: Equatable {
    public let dagNodes: [CodeGenNode]?
    public let dagEdges: [CodeGenEdge]?
    public let language: Language?
}

extension CreateScriptInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dagEdges = "DagEdges"
        case dagNodes = "DagNodes"
        case language = "Language"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dagNodesContainer = try containerValues.decodeIfPresent([CodeGenNode?].self, forKey: .dagNodes)
        var dagNodesDecoded0:[CodeGenNode]? = nil
        if let dagNodesContainer = dagNodesContainer {
            dagNodesDecoded0 = [CodeGenNode]()
            for structure0 in dagNodesContainer {
                if let structure0 = structure0 {
                    dagNodesDecoded0?.append(structure0)
                }
            }
        }
        dagNodes = dagNodesDecoded0
        let dagEdgesContainer = try containerValues.decodeIfPresent([CodeGenEdge?].self, forKey: .dagEdges)
        var dagEdgesDecoded0:[CodeGenEdge]? = nil
        if let dagEdgesContainer = dagEdgesContainer {
            dagEdgesDecoded0 = [CodeGenEdge]()
            for structure0 in dagEdgesContainer {
                if let structure0 = structure0 {
                    dagEdgesDecoded0?.append(structure0)
                }
            }
        }
        dagEdges = dagEdgesDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(Language.self, forKey: .language)
        language = languageDecoded
    }
}

extension CreateScriptOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateScriptOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateScriptOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateScriptOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateScriptOutputResponse(pythonScript: \(String(describing: pythonScript)), scalaCode: \(String(describing: scalaCode)))"}
}

extension CreateScriptOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateScriptOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pythonScript = output.pythonScript
            self.scalaCode = output.scalaCode
        } else {
            self.pythonScript = nil
            self.scalaCode = nil
        }
    }
}

public struct CreateScriptOutputResponse: Equatable {
    /// <p>The Python script generated from the DAG.</p>
    public let pythonScript: String?
    /// <p>The Scala code generated from the DAG.</p>
    public let scalaCode: String?

    public init (
        pythonScript: String? = nil,
        scalaCode: String? = nil
    )
    {
        self.pythonScript = pythonScript
        self.scalaCode = scalaCode
    }
}

struct CreateScriptOutputResponseBody: Equatable {
    public let pythonScript: String?
    public let scalaCode: String?
}

extension CreateScriptOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pythonScript = "PythonScript"
        case scalaCode = "ScalaCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pythonScriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pythonScript)
        pythonScript = pythonScriptDecoded
        let scalaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scalaCode)
        scalaCode = scalaCodeDecoded
    }
}

public struct CreateSecurityConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateSecurityConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSecurityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSecurityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSecurityConfigurationInput>
    public typealias MOutput = OperationOutput<CreateSecurityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSecurityConfigurationOutputError>
}

extension CreateSecurityConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSecurityConfigurationInput(encryptionConfiguration: \(String(describing: encryptionConfiguration)), name: \(String(describing: name)))"}
}

extension CreateSecurityConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionConfiguration = "EncryptionConfiguration"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateSecurityConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSecurityConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSecurityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSecurityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSecurityConfigurationInput>
    public typealias MOutput = OperationOutput<CreateSecurityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSecurityConfigurationOutputError>
}

public struct CreateSecurityConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSecurityConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSecurityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSecurityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSecurityConfigurationInput>
    public typealias MOutput = OperationOutput<CreateSecurityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSecurityConfigurationOutputError>
}

public struct CreateSecurityConfigurationInput: Equatable {
    /// <p>The encryption configuration for the new security configuration.</p>
    public let encryptionConfiguration: EncryptionConfiguration?
    /// <p>The name for the new security configuration.</p>
    public let name: String?

    public init (
        encryptionConfiguration: EncryptionConfiguration? = nil,
        name: String? = nil
    )
    {
        self.encryptionConfiguration = encryptionConfiguration
        self.name = name
    }
}

struct CreateSecurityConfigurationInputBody: Equatable {
    public let name: String?
    public let encryptionConfiguration: EncryptionConfiguration?
}

extension CreateSecurityConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionConfiguration = "EncryptionConfiguration"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension CreateSecurityConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSecurityConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSecurityConfigurationOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSecurityConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSecurityConfigurationOutputResponse(createdTimestamp: \(String(describing: createdTimestamp)), name: \(String(describing: name)))"}
}

extension CreateSecurityConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSecurityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdTimestamp = output.createdTimestamp
            self.name = output.name
        } else {
            self.createdTimestamp = nil
            self.name = nil
        }
    }
}

public struct CreateSecurityConfigurationOutputResponse: Equatable {
    /// <p>The time at which the new security configuration was created.</p>
    public let createdTimestamp: Date?
    /// <p>The name assigned to the new security configuration.</p>
    public let name: String?

    public init (
        createdTimestamp: Date? = nil,
        name: String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.name = name
    }
}

struct CreateSecurityConfigurationOutputResponseBody: Equatable {
    public let name: String?
    public let createdTimestamp: Date?
}

extension CreateSecurityConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

public struct CreateTableInputBodyMiddleware: Middleware {
    public let id: String = "CreateTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTableInput>
    public typealias MOutput = OperationOutput<CreateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTableOutputError>
}

extension CreateTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTableInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), partitionIndexes: \(String(describing: partitionIndexes)), tableInput: \(String(describing: tableInput)))"}
}

extension CreateTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionIndexes = "PartitionIndexes"
        case tableInput = "TableInput"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionIndexes = partitionIndexes {
            var partitionIndexesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionIndexes)
            for partitionindexlist0 in partitionIndexes {
                try partitionIndexesContainer.encode(partitionindexlist0)
            }
        }
        if let tableInput = tableInput {
            try encodeContainer.encode(tableInput, forKey: .tableInput)
        }
    }
}

public struct CreateTableInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTableInput>
    public typealias MOutput = OperationOutput<CreateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTableOutputError>
}

public struct CreateTableInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTableInput>
    public typealias MOutput = OperationOutput<CreateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTableOutputError>
}

public struct CreateTableInput: Equatable {
    /// <p>The ID of the Data Catalog in which to create the <code>Table</code>.
    ///       If none is supplied, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The catalog database in which to create the new table. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let databaseName: String?
    /// <p>A list of partition indexes, <code>PartitionIndex</code> structures, to create in the table.</p>
    public let partitionIndexes: [PartitionIndex]?
    /// <p>The <code>TableInput</code> object that defines the metadata table
    ///       to create in the catalog.</p>
    public let tableInput: TableInput?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        partitionIndexes: [PartitionIndex]? = nil,
        tableInput: TableInput? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionIndexes = partitionIndexes
        self.tableInput = tableInput
    }
}

struct CreateTableInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableInput: TableInput?
    public let partitionIndexes: [PartitionIndex]?
}

extension CreateTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionIndexes = "PartitionIndexes"
        case tableInput = "TableInput"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableInputDecoded = try containerValues.decodeIfPresent(TableInput.self, forKey: .tableInput)
        tableInput = tableInputDecoded
        let partitionIndexesContainer = try containerValues.decodeIfPresent([PartitionIndex?].self, forKey: .partitionIndexes)
        var partitionIndexesDecoded0:[PartitionIndex]? = nil
        if let partitionIndexesContainer = partitionIndexesContainer {
            partitionIndexesDecoded0 = [PartitionIndex]()
            for structure0 in partitionIndexesContainer {
                if let structure0 = structure0 {
                    partitionIndexesDecoded0?.append(structure0)
                }
            }
        }
        partitionIndexes = partitionIndexesDecoded0
    }
}

extension CreateTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTableOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTableOutputResponse()"}
}

extension CreateTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateTableOutputResponse: Equatable {

    public init() {}
}

struct CreateTableOutputResponseBody: Equatable {
}

extension CreateTableOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateTriggerInputBodyMiddleware: Middleware {
    public let id: String = "CreateTriggerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTriggerInput>
    public typealias MOutput = OperationOutput<CreateTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTriggerOutputError>
}

extension CreateTriggerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTriggerInput(actions: \(String(describing: actions)), description: \(String(describing: description)), name: \(String(describing: name)), predicate: \(String(describing: predicate)), schedule: \(String(describing: schedule)), startOnCreation: \(String(describing: startOnCreation)), tags: \(String(describing: tags)), type: \(String(describing: type)), workflowName: \(String(describing: workflowName)))"}
}

extension CreateTriggerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case description = "Description"
        case name = "Name"
        case predicate = "Predicate"
        case schedule = "Schedule"
        case startOnCreation = "StartOnCreation"
        case tags = "Tags"
        case type = "Type"
        case workflowName = "WorkflowName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predicate = predicate {
            try encodeContainer.encode(predicate, forKey: .predicate)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if startOnCreation != false {
            try encodeContainer.encode(startOnCreation, forKey: .startOnCreation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let workflowName = workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }
}

public struct CreateTriggerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTriggerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTriggerInput>
    public typealias MOutput = OperationOutput<CreateTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTriggerOutputError>
}

public struct CreateTriggerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTriggerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTriggerInput>
    public typealias MOutput = OperationOutput<CreateTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTriggerOutputError>
}

public struct CreateTriggerInput: Equatable {
    /// <p>The actions initiated by this trigger when it fires.</p>
    public let actions: [Action]?
    /// <p>A description of the new trigger.</p>
    public let description: String?
    /// <p>The name of the trigger.</p>
    public let name: String?
    /// <p>A predicate to specify when the new trigger should fire.</p>
    ///          <p>This field is required when the trigger type is <code>CONDITIONAL</code>.</p>
    public let predicate: Predicate?
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run
    ///       something every day at 12:15 UTC, you would specify:
    ///       <code>cron(15 12 * * ? *)</code>.</p>
    ///          <p>This field is required when the trigger type is SCHEDULED.</p>
    public let schedule: String?
    /// <p>Set to <code>true</code> to start <code>SCHEDULED</code> and <code>CONDITIONAL</code>
    ///       triggers when created. True is not supported for <code>ON_DEMAND</code> triggers.</p>
    public let startOnCreation: Bool
    /// <p>The tags to use with this trigger. You may use tags to limit access to the trigger.
    ///       For more information about tags in AWS Glue, see
    ///       <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">AWS Tags in AWS
    ///         Glue</a> in the developer guide. </p>
    public let tags: [String:String]?
    /// <p>The type of the new trigger.</p>
    public let type: TriggerType?
    /// <p>The name of the workflow associated with the trigger.</p>
    public let workflowName: String?

    public init (
        actions: [Action]? = nil,
        description: String? = nil,
        name: String? = nil,
        predicate: Predicate? = nil,
        schedule: String? = nil,
        startOnCreation: Bool = false,
        tags: [String:String]? = nil,
        type: TriggerType? = nil,
        workflowName: String? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.name = name
        self.predicate = predicate
        self.schedule = schedule
        self.startOnCreation = startOnCreation
        self.tags = tags
        self.type = type
        self.workflowName = workflowName
    }
}

struct CreateTriggerInputBody: Equatable {
    public let name: String?
    public let workflowName: String?
    public let type: TriggerType?
    public let schedule: String?
    public let predicate: Predicate?
    public let actions: [Action]?
    public let description: String?
    public let startOnCreation: Bool
    public let tags: [String:String]?
}

extension CreateTriggerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case description = "Description"
        case name = "Name"
        case predicate = "Predicate"
        case schedule = "Schedule"
        case startOnCreation = "StartOnCreation"
        case tags = "Tags"
        case type = "Type"
        case workflowName = "WorkflowName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let workflowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TriggerType.self, forKey: .type)
        type = typeDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let predicateDecoded = try containerValues.decodeIfPresent(Predicate.self, forKey: .predicate)
        predicate = predicateDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let startOnCreationDecoded = try containerValues.decode(Bool.self, forKey: .startOnCreation)
        startOnCreation = startOnCreationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTriggerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTriggerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTriggerOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTriggerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTriggerOutputResponse(name: \(String(describing: name)))"}
}

extension CreateTriggerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTriggerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateTriggerOutputResponse: Equatable {
    /// <p>The name of the trigger.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateTriggerOutputResponseBody: Equatable {
    public let name: String?
}

extension CreateTriggerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateUserDefinedFunctionInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserDefinedFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<CreateUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserDefinedFunctionOutputError>
}

extension CreateUserDefinedFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserDefinedFunctionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), functionInput: \(String(describing: functionInput)))"}
}

extension CreateUserDefinedFunctionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case functionInput = "FunctionInput"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let functionInput = functionInput {
            try encodeContainer.encode(functionInput, forKey: .functionInput)
        }
    }
}

public struct CreateUserDefinedFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserDefinedFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<CreateUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserDefinedFunctionOutputError>
}

public struct CreateUserDefinedFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserDefinedFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<CreateUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserDefinedFunctionOutputError>
}

public struct CreateUserDefinedFunctionInput: Equatable {
    /// <p>The ID of the Data Catalog in which to create the function. If none is provided, the AWS
    ///       account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database in which to create the function.</p>
    public let databaseName: String?
    /// <p>A <code>FunctionInput</code> object that defines the function
    ///       to create in the Data Catalog.</p>
    public let functionInput: UserDefinedFunctionInput?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        functionInput: UserDefinedFunctionInput? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.functionInput = functionInput
    }
}

struct CreateUserDefinedFunctionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let functionInput: UserDefinedFunctionInput?
}

extension CreateUserDefinedFunctionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case functionInput = "FunctionInput"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let functionInputDecoded = try containerValues.decodeIfPresent(UserDefinedFunctionInput.self, forKey: .functionInput)
        functionInput = functionInputDecoded
    }
}

extension CreateUserDefinedFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserDefinedFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserDefinedFunctionOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserDefinedFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserDefinedFunctionOutputResponse()"}
}

extension CreateUserDefinedFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateUserDefinedFunctionOutputResponse: Equatable {

    public init() {}
}

struct CreateUserDefinedFunctionOutputResponseBody: Equatable {
}

extension CreateUserDefinedFunctionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateWorkflowInputBodyMiddleware: Middleware {
    public let id: String = "CreateWorkflowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkflowInput>
    public typealias MOutput = OperationOutput<CreateWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkflowOutputError>
}

extension CreateWorkflowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkflowInput(defaultRunProperties: \(String(describing: defaultRunProperties)), description: \(String(describing: description)), maxConcurrentRuns: \(String(describing: maxConcurrentRuns)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateWorkflowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultRunProperties = "DefaultRunProperties"
        case description = "Description"
        case maxConcurrentRuns = "MaxConcurrentRuns"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultRunProperties = defaultRunProperties {
            var defaultRunPropertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .defaultRunProperties)
            for (dictKey0, workflowrunproperties0) in defaultRunProperties {
                try defaultRunPropertiesContainer.encode(workflowrunproperties0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxConcurrentRuns = maxConcurrentRuns {
            try encodeContainer.encode(maxConcurrentRuns, forKey: .maxConcurrentRuns)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateWorkflowInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWorkflowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkflowInput>
    public typealias MOutput = OperationOutput<CreateWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkflowOutputError>
}

public struct CreateWorkflowInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWorkflowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkflowInput>
    public typealias MOutput = OperationOutput<CreateWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkflowOutputError>
}

public struct CreateWorkflowInput: Equatable {
    /// <p>A collection of properties to be used as part of each execution of the workflow.</p>
    public let defaultRunProperties: [String:String]?
    /// <p>A description of the workflow.</p>
    public let description: String?
    /// <p>You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.</p>
    public let maxConcurrentRuns: Int?
    /// <p>The name to be assigned to the workflow. It should be unique within your account.</p>
    public let name: String?
    /// <p>The tags to be used with this workflow.</p>
    public let tags: [String:String]?

    public init (
        defaultRunProperties: [String:String]? = nil,
        description: String? = nil,
        maxConcurrentRuns: Int? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.defaultRunProperties = defaultRunProperties
        self.description = description
        self.maxConcurrentRuns = maxConcurrentRuns
        self.name = name
        self.tags = tags
    }
}

struct CreateWorkflowInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let defaultRunProperties: [String:String]?
    public let tags: [String:String]?
    public let maxConcurrentRuns: Int?
}

extension CreateWorkflowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultRunProperties = "DefaultRunProperties"
        case description = "Description"
        case maxConcurrentRuns = "MaxConcurrentRuns"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let defaultRunPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .defaultRunProperties)
        var defaultRunPropertiesDecoded0: [String:String]? = nil
        if let defaultRunPropertiesContainer = defaultRunPropertiesContainer {
            defaultRunPropertiesDecoded0 = [String:String]()
            for (key0, genericstring0) in defaultRunPropertiesContainer {
                if let genericstring0 = genericstring0 {
                    defaultRunPropertiesDecoded0?[key0] = genericstring0
                }
            }
        }
        defaultRunProperties = defaultRunPropertiesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let maxConcurrentRunsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxConcurrentRuns)
        maxConcurrentRuns = maxConcurrentRunsDecoded
    }
}

extension CreateWorkflowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkflowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkflowOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkflowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkflowOutputResponse(name: \(String(describing: name)))"}
}

extension CreateWorkflowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateWorkflowOutputResponse: Equatable {
    /// <p>The name of the workflow which was provided as part of the request.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateWorkflowOutputResponseBody: Equatable {
    public let name: String?
}

extension CreateWorkflowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateXMLClassifierRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classification = "Classification"
        case name = "Name"
        case rowTag = "RowTag"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rowTag = rowTag {
            try encodeContainer.encode(rowTag, forKey: .rowTag)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classificationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .classification)
        classification = classificationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let rowTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rowTag)
        rowTag = rowTagDecoded
    }
}

extension CreateXMLClassifierRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateXMLClassifierRequest(classification: \(String(describing: classification)), name: \(String(describing: name)), rowTag: \(String(describing: rowTag)))"}
}

/// <p>Specifies an XML classifier for <code>CreateClassifier</code> to create.</p>
public struct CreateXMLClassifierRequest: Equatable {
    /// <p>An identifier of the data format that the classifier matches.</p>
    public let classification: String?
    /// <p>The name of the classifier.</p>
    public let name: String?
    /// <p>The XML tag designating the element that contains each record in an XML document being
    ///       parsed. This can't identify a self-closing element (closed by <code>/></code>). An empty
    ///       row element that contains only attributes can be parsed as long as it ends with a closing tag
    ///       (for example, <code><row item_a="A" item_b="B"></row></code> is okay, but
    ///         <code><row item_a="A" item_b="B" /></code> is not).</p>
    public let rowTag: String?

    public init (
        classification: String? = nil,
        name: String? = nil,
        rowTag: String? = nil
    )
    {
        self.classification = classification
        self.name = name
        self.rowTag = rowTag
    }
}

extension CsvClassifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowSingleColumn = "AllowSingleColumn"
        case containsHeader = "ContainsHeader"
        case creationTime = "CreationTime"
        case delimiter = "Delimiter"
        case disableValueTrimming = "DisableValueTrimming"
        case header = "Header"
        case lastUpdated = "LastUpdated"
        case name = "Name"
        case quoteSymbol = "QuoteSymbol"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSingleColumn = allowSingleColumn {
            try encodeContainer.encode(allowSingleColumn, forKey: .allowSingleColumn)
        }
        if let containsHeader = containsHeader {
            try encodeContainer.encode(containsHeader.rawValue, forKey: .containsHeader)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let delimiter = delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let disableValueTrimming = disableValueTrimming {
            try encodeContainer.encode(disableValueTrimming, forKey: .disableValueTrimming)
        }
        if let header = header {
            var headerContainer = encodeContainer.nestedUnkeyedContainer(forKey: .header)
            for csvheader0 in header {
                try headerContainer.encode(csvheader0)
            }
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quoteSymbol = quoteSymbol {
            try encodeContainer.encode(quoteSymbol, forKey: .quoteSymbol)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let quoteSymbolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteSymbol)
        quoteSymbol = quoteSymbolDecoded
        let containsHeaderDecoded = try containerValues.decodeIfPresent(CsvHeaderOption.self, forKey: .containsHeader)
        containsHeader = containsHeaderDecoded
        let headerContainer = try containerValues.decodeIfPresent([String?].self, forKey: .header)
        var headerDecoded0:[String]? = nil
        if let headerContainer = headerContainer {
            headerDecoded0 = [String]()
            for string0 in headerContainer {
                if let string0 = string0 {
                    headerDecoded0?.append(string0)
                }
            }
        }
        header = headerDecoded0
        let disableValueTrimmingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableValueTrimming)
        disableValueTrimming = disableValueTrimmingDecoded
        let allowSingleColumnDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSingleColumn)
        allowSingleColumn = allowSingleColumnDecoded
    }
}

extension CsvClassifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CsvClassifier(allowSingleColumn: \(String(describing: allowSingleColumn)), containsHeader: \(String(describing: containsHeader)), creationTime: \(String(describing: creationTime)), delimiter: \(String(describing: delimiter)), disableValueTrimming: \(String(describing: disableValueTrimming)), header: \(String(describing: header)), lastUpdated: \(String(describing: lastUpdated)), name: \(String(describing: name)), quoteSymbol: \(String(describing: quoteSymbol)), version: \(String(describing: version)))"}
}

/// <p>A classifier for custom <code>CSV</code> content.</p>
public struct CsvClassifier: Equatable {
    /// <p>Enables the processing of files that contain only one column.</p>
    public let allowSingleColumn: Bool?
    /// <p>Indicates whether the CSV file contains a header.</p>
    public let containsHeader: CsvHeaderOption?
    /// <p>The time that this classifier was registered.</p>
    public let creationTime: Date?
    /// <p>A custom symbol to denote what separates each column entry in the row.</p>
    public let delimiter: String?
    /// <p>Specifies not to trim values before identifying the type of column values. The default
    ///       value is <code>true</code>.</p>
    public let disableValueTrimming: Bool?
    /// <p>A list of strings representing column names.</p>
    public let header: [String]?
    /// <p>The time that this classifier was last updated.</p>
    public let lastUpdated: Date?
    /// <p>The name of the classifier.</p>
    public let name: String?
    /// <p>A custom symbol to denote what combines content into a single column value. It must be
    ///       different from the column delimiter.</p>
    public let quoteSymbol: String?
    /// <p>The version of this classifier.</p>
    public let version: Int

    public init (
        allowSingleColumn: Bool? = nil,
        containsHeader: CsvHeaderOption? = nil,
        creationTime: Date? = nil,
        delimiter: String? = nil,
        disableValueTrimming: Bool? = nil,
        header: [String]? = nil,
        lastUpdated: Date? = nil,
        name: String? = nil,
        quoteSymbol: String? = nil,
        version: Int = 0
    )
    {
        self.allowSingleColumn = allowSingleColumn
        self.containsHeader = containsHeader
        self.creationTime = creationTime
        self.delimiter = delimiter
        self.disableValueTrimming = disableValueTrimming
        self.header = header
        self.lastUpdated = lastUpdated
        self.name = name
        self.quoteSymbol = quoteSymbol
        self.version = version
    }
}

public enum CsvHeaderOption {
    case absent
    case present
    case unknown
    case sdkUnknown(String)
}

extension CsvHeaderOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CsvHeaderOption] {
        return [
            .absent,
            .present,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .absent: return "ABSENT"
        case .present: return "PRESENT"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CsvHeaderOption(rawValue: rawValue) ?? CsvHeaderOption.sdkUnknown(rawValue)
    }
}

extension DataCatalogEncryptionSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionPasswordEncryption = "ConnectionPasswordEncryption"
        case encryptionAtRest = "EncryptionAtRest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionPasswordEncryption = connectionPasswordEncryption {
            try encodeContainer.encode(connectionPasswordEncryption, forKey: .connectionPasswordEncryption)
        }
        if let encryptionAtRest = encryptionAtRest {
            try encodeContainer.encode(encryptionAtRest, forKey: .encryptionAtRest)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionAtRestDecoded = try containerValues.decodeIfPresent(EncryptionAtRest.self, forKey: .encryptionAtRest)
        encryptionAtRest = encryptionAtRestDecoded
        let connectionPasswordEncryptionDecoded = try containerValues.decodeIfPresent(ConnectionPasswordEncryption.self, forKey: .connectionPasswordEncryption)
        connectionPasswordEncryption = connectionPasswordEncryptionDecoded
    }
}

extension DataCatalogEncryptionSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataCatalogEncryptionSettings(connectionPasswordEncryption: \(String(describing: connectionPasswordEncryption)), encryptionAtRest: \(String(describing: encryptionAtRest)))"}
}

/// <p>Contains configuration information for maintaining Data Catalog security.</p>
public struct DataCatalogEncryptionSettings: Equatable {
    /// <p>When connection password protection is enabled, the Data Catalog uses a customer-provided
    ///       key to encrypt the password as part of <code>CreateConnection</code> or
    ///         <code>UpdateConnection</code> and store it in the <code>ENCRYPTED_PASSWORD</code> field in
    ///       the connection properties. You can enable catalog encryption or only password
    ///       encryption.</p>
    public let connectionPasswordEncryption: ConnectionPasswordEncryption?
    /// <p>Specifies the encryption-at-rest configuration for the Data Catalog.</p>
    public let encryptionAtRest: EncryptionAtRest?

    public init (
        connectionPasswordEncryption: ConnectionPasswordEncryption? = nil,
        encryptionAtRest: EncryptionAtRest? = nil
    )
    {
        self.connectionPasswordEncryption = connectionPasswordEncryption
        self.encryptionAtRest = encryptionAtRest
    }
}

public enum DataFormat {
    case avro
    case sdkUnknown(String)
}

extension DataFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataFormat] {
        return [
            .avro,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .avro: return "AVRO"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataFormat(rawValue: rawValue) ?? DataFormat.sdkUnknown(rawValue)
    }
}

extension DataLakePrincipal: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataLakePrincipalIdentifier = "DataLakePrincipalIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLakePrincipalIdentifier = dataLakePrincipalIdentifier {
            try encodeContainer.encode(dataLakePrincipalIdentifier, forKey: .dataLakePrincipalIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakePrincipalIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataLakePrincipalIdentifier)
        dataLakePrincipalIdentifier = dataLakePrincipalIdentifierDecoded
    }
}

extension DataLakePrincipal: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataLakePrincipal(dataLakePrincipalIdentifier: \(String(describing: dataLakePrincipalIdentifier)))"}
}

/// <p>The AWS Lake Formation principal.</p>
public struct DataLakePrincipal: Equatable {
    /// <p>An identifier for the AWS Lake Formation principal.</p>
    public let dataLakePrincipalIdentifier: String?

    public init (
        dataLakePrincipalIdentifier: String? = nil
    )
    {
        self.dataLakePrincipalIdentifier = dataLakePrincipalIdentifier
    }
}

extension Database: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case createTableDefaultPermissions = "CreateTableDefaultPermissions"
        case createTime = "CreateTime"
        case description = "Description"
        case locationUri = "LocationUri"
        case name = "Name"
        case parameters = "Parameters"
        case targetDatabase = "TargetDatabase"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let createTableDefaultPermissions = createTableDefaultPermissions {
            var createTableDefaultPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createTableDefaultPermissions)
            for principalpermissionslist0 in createTableDefaultPermissions {
                try createTableDefaultPermissionsContainer.encode(principalpermissionslist0)
            }
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let locationUri = locationUri {
            try encodeContainer.encode(locationUri, forKey: .locationUri)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targetDatabase = targetDatabase {
            try encodeContainer.encode(targetDatabase, forKey: .targetDatabase)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let createTableDefaultPermissionsContainer = try containerValues.decodeIfPresent([PrincipalPermissions?].self, forKey: .createTableDefaultPermissions)
        var createTableDefaultPermissionsDecoded0:[PrincipalPermissions]? = nil
        if let createTableDefaultPermissionsContainer = createTableDefaultPermissionsContainer {
            createTableDefaultPermissionsDecoded0 = [PrincipalPermissions]()
            for structure0 in createTableDefaultPermissionsContainer {
                if let structure0 = structure0 {
                    createTableDefaultPermissionsDecoded0?.append(structure0)
                }
            }
        }
        createTableDefaultPermissions = createTableDefaultPermissionsDecoded0
        let targetDatabaseDecoded = try containerValues.decodeIfPresent(DatabaseIdentifier.self, forKey: .targetDatabase)
        targetDatabase = targetDatabaseDecoded
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension Database: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Database(catalogId: \(String(describing: catalogId)), createTableDefaultPermissions: \(String(describing: createTableDefaultPermissions)), createTime: \(String(describing: createTime)), description: \(String(describing: description)), locationUri: \(String(describing: locationUri)), name: \(String(describing: name)), parameters: \(String(describing: parameters)), targetDatabase: \(String(describing: targetDatabase)))"}
}

/// <p>The <code>Database</code> object represents a logical grouping of tables that might reside
///       in a Hive metastore or an RDBMS.</p>
public struct Database: Equatable {
    /// <p>The ID of the Data Catalog in which the database resides.</p>
    public let catalogId: String?
    /// <p>Creates a set of default permissions on the table for principals. </p>
    public let createTableDefaultPermissions: [PrincipalPermissions]?
    /// <p>The time at which the metadata database was created in the catalog.</p>
    public let createTime: Date?
    /// <p>A description of the database.</p>
    public let description: String?
    /// <p>The location of the database (for example, an HDFS path).</p>
    public let locationUri: String?
    /// <p>The name of the database. For Hive compatibility, this is folded to lowercase when it is
    ///       stored.</p>
    public let name: String?
    /// <p>These key-value pairs define parameters and properties
    ///       of the database.</p>
    public let parameters: [String:String]?
    /// <p>A <code>DatabaseIdentifier</code> structure that describes a target database for resource linking.</p>
    public let targetDatabase: DatabaseIdentifier?

    public init (
        catalogId: String? = nil,
        createTableDefaultPermissions: [PrincipalPermissions]? = nil,
        createTime: Date? = nil,
        description: String? = nil,
        locationUri: String? = nil,
        name: String? = nil,
        parameters: [String:String]? = nil,
        targetDatabase: DatabaseIdentifier? = nil
    )
    {
        self.catalogId = catalogId
        self.createTableDefaultPermissions = createTableDefaultPermissions
        self.createTime = createTime
        self.description = description
        self.locationUri = locationUri
        self.name = name
        self.parameters = parameters
        self.targetDatabase = targetDatabase
    }
}

extension DatabaseIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension DatabaseIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatabaseIdentifier(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)))"}
}

/// <p>A structure that describes a target database for resource linking.</p>
public struct DatabaseIdentifier: Equatable {
    /// <p>The ID of the Data Catalog in which the database resides.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database.</p>
    public let databaseName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
    }
}

extension DatabaseInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createTableDefaultPermissions = "CreateTableDefaultPermissions"
        case description = "Description"
        case locationUri = "LocationUri"
        case name = "Name"
        case parameters = "Parameters"
        case targetDatabase = "TargetDatabase"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTableDefaultPermissions = createTableDefaultPermissions {
            var createTableDefaultPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createTableDefaultPermissions)
            for principalpermissionslist0 in createTableDefaultPermissions {
                try createTableDefaultPermissionsContainer.encode(principalpermissionslist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let locationUri = locationUri {
            try encodeContainer.encode(locationUri, forKey: .locationUri)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targetDatabase = targetDatabase {
            try encodeContainer.encode(targetDatabase, forKey: .targetDatabase)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let createTableDefaultPermissionsContainer = try containerValues.decodeIfPresent([PrincipalPermissions?].self, forKey: .createTableDefaultPermissions)
        var createTableDefaultPermissionsDecoded0:[PrincipalPermissions]? = nil
        if let createTableDefaultPermissionsContainer = createTableDefaultPermissionsContainer {
            createTableDefaultPermissionsDecoded0 = [PrincipalPermissions]()
            for structure0 in createTableDefaultPermissionsContainer {
                if let structure0 = structure0 {
                    createTableDefaultPermissionsDecoded0?.append(structure0)
                }
            }
        }
        createTableDefaultPermissions = createTableDefaultPermissionsDecoded0
        let targetDatabaseDecoded = try containerValues.decodeIfPresent(DatabaseIdentifier.self, forKey: .targetDatabase)
        targetDatabase = targetDatabaseDecoded
    }
}

extension DatabaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatabaseInput(createTableDefaultPermissions: \(String(describing: createTableDefaultPermissions)), description: \(String(describing: description)), locationUri: \(String(describing: locationUri)), name: \(String(describing: name)), parameters: \(String(describing: parameters)), targetDatabase: \(String(describing: targetDatabase)))"}
}

/// <p>The structure used to create or update a database.</p>
public struct DatabaseInput: Equatable {
    /// <p>Creates a set of default permissions on the table for principals. </p>
    public let createTableDefaultPermissions: [PrincipalPermissions]?
    /// <p>A description of the database.</p>
    public let description: String?
    /// <p>The location of the database (for example, an HDFS path). </p>
    public let locationUri: String?
    /// <p>The name of the database. For Hive compatibility, this is folded to lowercase when it is
    ///       stored.</p>
    public let name: String?
    /// <p>These key-value pairs define parameters and properties
    ///       of the database.</p>
    ///          <p>These key-value pairs define parameters and properties of the database.</p>
    public let parameters: [String:String]?
    /// <p>A <code>DatabaseIdentifier</code> structure that describes a target database for resource linking.</p>
    public let targetDatabase: DatabaseIdentifier?

    public init (
        createTableDefaultPermissions: [PrincipalPermissions]? = nil,
        description: String? = nil,
        locationUri: String? = nil,
        name: String? = nil,
        parameters: [String:String]? = nil,
        targetDatabase: DatabaseIdentifier? = nil
    )
    {
        self.createTableDefaultPermissions = createTableDefaultPermissions
        self.description = description
        self.locationUri = locationUri
        self.name = name
        self.parameters = parameters
        self.targetDatabase = targetDatabase
    }
}

extension DateColumnStatisticsData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maximumValue = "MaximumValue"
        case minimumValue = "MinimumValue"
        case numberOfDistinctValues = "NumberOfDistinctValues"
        case numberOfNulls = "NumberOfNulls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumValue = maximumValue {
            try encodeContainer.encode(maximumValue.timeIntervalSince1970, forKey: .maximumValue)
        }
        if let minimumValue = minimumValue {
            try encodeContainer.encode(minimumValue.timeIntervalSince1970, forKey: .minimumValue)
        }
        if numberOfDistinctValues != 0 {
            try encodeContainer.encode(numberOfDistinctValues, forKey: .numberOfDistinctValues)
        }
        if numberOfNulls != 0 {
            try encodeContainer.encode(numberOfNulls, forKey: .numberOfNulls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumValueDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .minimumValue)
        minimumValue = minimumValueDecoded
        let maximumValueDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .maximumValue)
        maximumValue = maximumValueDecoded
        let numberOfNullsDecoded = try containerValues.decode(Int.self, forKey: .numberOfNulls)
        numberOfNulls = numberOfNullsDecoded
        let numberOfDistinctValuesDecoded = try containerValues.decode(Int.self, forKey: .numberOfDistinctValues)
        numberOfDistinctValues = numberOfDistinctValuesDecoded
    }
}

extension DateColumnStatisticsData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DateColumnStatisticsData(maximumValue: \(String(describing: maximumValue)), minimumValue: \(String(describing: minimumValue)), numberOfDistinctValues: \(String(describing: numberOfDistinctValues)), numberOfNulls: \(String(describing: numberOfNulls)))"}
}

/// <p>Defines column statistics supported for timestamp data columns.</p>
public struct DateColumnStatisticsData: Equatable {
    /// <p>The highest value in the column.</p>
    public let maximumValue: Date?
    /// <p>The lowest value in the column.</p>
    public let minimumValue: Date?
    /// <p>The number of distinct values in a column.</p>
    public let numberOfDistinctValues: Int
    /// <p>The number of null values in the column.</p>
    public let numberOfNulls: Int

    public init (
        maximumValue: Date? = nil,
        minimumValue: Date? = nil,
        numberOfDistinctValues: Int = 0,
        numberOfNulls: Int = 0
    )
    {
        self.maximumValue = maximumValue
        self.minimumValue = minimumValue
        self.numberOfDistinctValues = numberOfDistinctValues
        self.numberOfNulls = numberOfNulls
    }
}

extension DecimalColumnStatisticsData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maximumValue = "MaximumValue"
        case minimumValue = "MinimumValue"
        case numberOfDistinctValues = "NumberOfDistinctValues"
        case numberOfNulls = "NumberOfNulls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumValue = maximumValue {
            try encodeContainer.encode(maximumValue, forKey: .maximumValue)
        }
        if let minimumValue = minimumValue {
            try encodeContainer.encode(minimumValue, forKey: .minimumValue)
        }
        if numberOfDistinctValues != 0 {
            try encodeContainer.encode(numberOfDistinctValues, forKey: .numberOfDistinctValues)
        }
        if numberOfNulls != 0 {
            try encodeContainer.encode(numberOfNulls, forKey: .numberOfNulls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumValueDecoded = try containerValues.decodeIfPresent(DecimalNumber.self, forKey: .minimumValue)
        minimumValue = minimumValueDecoded
        let maximumValueDecoded = try containerValues.decodeIfPresent(DecimalNumber.self, forKey: .maximumValue)
        maximumValue = maximumValueDecoded
        let numberOfNullsDecoded = try containerValues.decode(Int.self, forKey: .numberOfNulls)
        numberOfNulls = numberOfNullsDecoded
        let numberOfDistinctValuesDecoded = try containerValues.decode(Int.self, forKey: .numberOfDistinctValues)
        numberOfDistinctValues = numberOfDistinctValuesDecoded
    }
}

extension DecimalColumnStatisticsData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecimalColumnStatisticsData(maximumValue: \(String(describing: maximumValue)), minimumValue: \(String(describing: minimumValue)), numberOfDistinctValues: \(String(describing: numberOfDistinctValues)), numberOfNulls: \(String(describing: numberOfNulls)))"}
}

/// <p>Defines column statistics supported for fixed-point number data columns.</p>
public struct DecimalColumnStatisticsData: Equatable {
    /// <p>The highest value in the column.</p>
    public let maximumValue: DecimalNumber?
    /// <p>The lowest value in the column.</p>
    public let minimumValue: DecimalNumber?
    /// <p>The number of distinct values in a column.</p>
    public let numberOfDistinctValues: Int
    /// <p>The number of null values in the column.</p>
    public let numberOfNulls: Int

    public init (
        maximumValue: DecimalNumber? = nil,
        minimumValue: DecimalNumber? = nil,
        numberOfDistinctValues: Int = 0,
        numberOfNulls: Int = 0
    )
    {
        self.maximumValue = maximumValue
        self.minimumValue = minimumValue
        self.numberOfDistinctValues = numberOfDistinctValues
        self.numberOfNulls = numberOfNulls
    }
}

extension DecimalNumber: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scale = "Scale"
        case unscaledValue = "UnscaledValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if scale != 0 {
            try encodeContainer.encode(scale, forKey: .scale)
        }
        if let unscaledValue = unscaledValue {
            try encodeContainer.encode(unscaledValue.base64EncodedString(), forKey: .unscaledValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unscaledValueDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .unscaledValue)
        unscaledValue = unscaledValueDecoded
        let scaleDecoded = try containerValues.decode(Int.self, forKey: .scale)
        scale = scaleDecoded
    }
}

extension DecimalNumber: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecimalNumber(scale: \(String(describing: scale)), unscaledValue: \(String(describing: unscaledValue)))"}
}

/// <p>Contains a numeric value in decimal format.</p>
public struct DecimalNumber: Equatable {
    /// <p>The scale that determines where the decimal point falls in the
    ///       unscaled value.</p>
    public let scale: Int
    /// <p>The unscaled numeric value.</p>
    public let unscaledValue: Data?

    public init (
        scale: Int = 0,
        unscaledValue: Data? = nil
    )
    {
        self.scale = scale
        self.unscaledValue = unscaledValue
    }
}

public enum DeleteBehavior {
    case deleteFromDatabase
    case deprecateInDatabase
    case log
    case sdkUnknown(String)
}

extension DeleteBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeleteBehavior] {
        return [
            .deleteFromDatabase,
            .deprecateInDatabase,
            .log,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleteFromDatabase: return "DELETE_FROM_DATABASE"
        case .deprecateInDatabase: return "DEPRECATE_IN_DATABASE"
        case .log: return "LOG"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeleteBehavior(rawValue: rawValue) ?? DeleteBehavior.sdkUnknown(rawValue)
    }
}

public struct DeleteClassifierInputBodyMiddleware: Middleware {
    public let id: String = "DeleteClassifierInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClassifierInput>
    public typealias MOutput = OperationOutput<DeleteClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClassifierOutputError>
}

extension DeleteClassifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClassifierInput(name: \(String(describing: name)))"}
}

extension DeleteClassifierInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteClassifierInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteClassifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClassifierInput>
    public typealias MOutput = OperationOutput<DeleteClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClassifierOutputError>
}

public struct DeleteClassifierInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteClassifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClassifierInput>
    public typealias MOutput = OperationOutput<DeleteClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClassifierOutputError>
}

public struct DeleteClassifierInput: Equatable {
    /// <p>Name of the classifier to remove.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteClassifierInputBody: Equatable {
    public let name: String?
}

extension DeleteClassifierInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteClassifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteClassifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClassifierOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClassifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClassifierOutputResponse()"}
}

extension DeleteClassifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteClassifierOutputResponse: Equatable {

    public init() {}
}

struct DeleteClassifierOutputResponseBody: Equatable {
}

extension DeleteClassifierOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteColumnStatisticsForPartitionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteColumnStatisticsForPartitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteColumnStatisticsForPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteColumnStatisticsForPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteColumnStatisticsForPartitionInput>
    public typealias MOutput = OperationOutput<DeleteColumnStatisticsForPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteColumnStatisticsForPartitionOutputError>
}

extension DeleteColumnStatisticsForPartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteColumnStatisticsForPartitionInput(catalogId: \(String(describing: catalogId)), columnName: \(String(describing: columnName)), databaseName: \(String(describing: databaseName)), partitionValues: \(String(describing: partitionValues)), tableName: \(String(describing: tableName)))"}
}

extension DeleteColumnStatisticsForPartitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnName = "ColumnName"
        case databaseName = "DatabaseName"
        case partitionValues = "PartitionValues"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionValues = partitionValues {
            var partitionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValues)
            for valuestringlist0 in partitionValues {
                try partitionValuesContainer.encode(valuestringlist0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct DeleteColumnStatisticsForPartitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteColumnStatisticsForPartitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteColumnStatisticsForPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteColumnStatisticsForPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteColumnStatisticsForPartitionInput>
    public typealias MOutput = OperationOutput<DeleteColumnStatisticsForPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteColumnStatisticsForPartitionOutputError>
}

public struct DeleteColumnStatisticsForPartitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteColumnStatisticsForPartitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteColumnStatisticsForPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteColumnStatisticsForPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteColumnStatisticsForPartitionInput>
    public typealias MOutput = OperationOutput<DeleteColumnStatisticsForPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteColumnStatisticsForPartitionOutputError>
}

public struct DeleteColumnStatisticsForPartitionInput: Equatable {
    /// <p>The ID of the Data Catalog where the partitions in question reside.
    ///       If none is supplied, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>Name of the column.</p>
    public let columnName: String?
    /// <p>The name of the catalog database where the partitions reside.</p>
    public let databaseName: String?
    /// <p>A list of partition values identifying the partition.</p>
    public let partitionValues: [String]?
    /// <p>The name of the partitions' table.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        columnName: String? = nil,
        databaseName: String? = nil,
        partitionValues: [String]? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnName = columnName
        self.databaseName = databaseName
        self.partitionValues = partitionValues
        self.tableName = tableName
    }
}

struct DeleteColumnStatisticsForPartitionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let partitionValues: [String]?
    public let columnName: String?
}

extension DeleteColumnStatisticsForPartitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnName = "ColumnName"
        case databaseName = "DatabaseName"
        case partitionValues = "PartitionValues"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let partitionValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionValues)
        var partitionValuesDecoded0:[String]? = nil
        if let partitionValuesContainer = partitionValuesContainer {
            partitionValuesDecoded0 = [String]()
            for string0 in partitionValuesContainer {
                if let string0 = string0 {
                    partitionValuesDecoded0?.append(string0)
                }
            }
        }
        partitionValues = partitionValuesDecoded0
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
    }
}

extension DeleteColumnStatisticsForPartitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteColumnStatisticsForPartitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteColumnStatisticsForPartitionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteColumnStatisticsForPartitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteColumnStatisticsForPartitionOutputResponse()"}
}

extension DeleteColumnStatisticsForPartitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteColumnStatisticsForPartitionOutputResponse: Equatable {

    public init() {}
}

struct DeleteColumnStatisticsForPartitionOutputResponseBody: Equatable {
}

extension DeleteColumnStatisticsForPartitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteColumnStatisticsForTableInputBodyMiddleware: Middleware {
    public let id: String = "DeleteColumnStatisticsForTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteColumnStatisticsForTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteColumnStatisticsForTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteColumnStatisticsForTableInput>
    public typealias MOutput = OperationOutput<DeleteColumnStatisticsForTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteColumnStatisticsForTableOutputError>
}

extension DeleteColumnStatisticsForTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteColumnStatisticsForTableInput(catalogId: \(String(describing: catalogId)), columnName: \(String(describing: columnName)), databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)))"}
}

extension DeleteColumnStatisticsForTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnName = "ColumnName"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct DeleteColumnStatisticsForTableInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteColumnStatisticsForTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteColumnStatisticsForTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteColumnStatisticsForTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteColumnStatisticsForTableInput>
    public typealias MOutput = OperationOutput<DeleteColumnStatisticsForTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteColumnStatisticsForTableOutputError>
}

public struct DeleteColumnStatisticsForTableInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteColumnStatisticsForTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteColumnStatisticsForTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteColumnStatisticsForTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteColumnStatisticsForTableInput>
    public typealias MOutput = OperationOutput<DeleteColumnStatisticsForTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteColumnStatisticsForTableOutputError>
}

public struct DeleteColumnStatisticsForTableInput: Equatable {
    /// <p>The ID of the Data Catalog where the partitions in question reside.
    ///       If none is supplied, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the column.</p>
    public let columnName: String?
    /// <p>The name of the catalog database where the partitions reside.</p>
    public let databaseName: String?
    /// <p>The name of the partitions' table.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        columnName: String? = nil,
        databaseName: String? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnName = columnName
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct DeleteColumnStatisticsForTableInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let columnName: String?
}

extension DeleteColumnStatisticsForTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnName = "ColumnName"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
    }
}

extension DeleteColumnStatisticsForTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteColumnStatisticsForTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteColumnStatisticsForTableOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteColumnStatisticsForTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteColumnStatisticsForTableOutputResponse()"}
}

extension DeleteColumnStatisticsForTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteColumnStatisticsForTableOutputResponse: Equatable {

    public init() {}
}

struct DeleteColumnStatisticsForTableOutputResponseBody: Equatable {
}

extension DeleteColumnStatisticsForTableOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteConnectionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

extension DeleteConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionInput(catalogId: \(String(describing: catalogId)), connectionName: \(String(describing: connectionName)))"}
}

extension DeleteConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case connectionName = "ConnectionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
    }
}

public struct DeleteConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInput: Equatable {
    /// <p>The ID of the Data Catalog in which the connection resides. If none is provided, the AWS
    ///       account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the connection to delete.</p>
    public let connectionName: String?

    public init (
        catalogId: String? = nil,
        connectionName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.connectionName = connectionName
    }
}

struct DeleteConnectionInputBody: Equatable {
    public let catalogId: String?
    public let connectionName: String?
}

extension DeleteConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case connectionName = "ConnectionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
    }
}

extension DeleteConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionOutputResponse()"}
}

extension DeleteConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectionOutputResponse: Equatable {

    public init() {}
}

struct DeleteConnectionOutputResponseBody: Equatable {
}

extension DeleteConnectionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteCrawlerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCrawlerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCrawlerInput>
    public typealias MOutput = OperationOutput<DeleteCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCrawlerOutputError>
}

extension DeleteCrawlerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCrawlerInput(name: \(String(describing: name)))"}
}

extension DeleteCrawlerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteCrawlerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCrawlerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCrawlerInput>
    public typealias MOutput = OperationOutput<DeleteCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCrawlerOutputError>
}

public struct DeleteCrawlerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCrawlerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCrawlerInput>
    public typealias MOutput = OperationOutput<DeleteCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCrawlerOutputError>
}

public struct DeleteCrawlerInput: Equatable {
    /// <p>The name of the crawler to remove.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteCrawlerInputBody: Equatable {
    public let name: String?
}

extension DeleteCrawlerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteCrawlerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCrawlerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CrawlerRunningException" : self = .crawlerRunningException(try CrawlerRunningException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchedulerTransitioningException" : self = .schedulerTransitioningException(try SchedulerTransitioningException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCrawlerOutputError: Equatable {
    case crawlerRunningException(CrawlerRunningException)
    case entityNotFoundException(EntityNotFoundException)
    case operationTimeoutException(OperationTimeoutException)
    case schedulerTransitioningException(SchedulerTransitioningException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCrawlerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCrawlerOutputResponse()"}
}

extension DeleteCrawlerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCrawlerOutputResponse: Equatable {

    public init() {}
}

struct DeleteCrawlerOutputResponseBody: Equatable {
}

extension DeleteCrawlerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDatabaseInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatabaseInput>
    public typealias MOutput = OperationOutput<DeleteDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatabaseOutputError>
}

extension DeleteDatabaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatabaseInput(catalogId: \(String(describing: catalogId)), name: \(String(describing: name)))"}
}

extension DeleteDatabaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteDatabaseInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatabaseInput>
    public typealias MOutput = OperationOutput<DeleteDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatabaseOutputError>
}

public struct DeleteDatabaseInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatabaseInput>
    public typealias MOutput = OperationOutput<DeleteDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatabaseOutputError>
}

public struct DeleteDatabaseInput: Equatable {
    /// <p>The ID of the Data Catalog in which the database resides. If none is provided, the AWS
    ///       account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the database to delete. For Hive compatibility, this must be all
    ///       lowercase.</p>
    public let name: String?

    public init (
        catalogId: String? = nil,
        name: String? = nil
    )
    {
        self.catalogId = catalogId
        self.name = name
    }
}

struct DeleteDatabaseInputBody: Equatable {
    public let catalogId: String?
    public let name: String?
}

extension DeleteDatabaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteDatabaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatabaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatabaseOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatabaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatabaseOutputResponse()"}
}

extension DeleteDatabaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatabaseOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatabaseOutputResponseBody: Equatable {
}

extension DeleteDatabaseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDevEndpointInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDevEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDevEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDevEndpointOutputError>
}

extension DeleteDevEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDevEndpointInput(endpointName: \(String(describing: endpointName)))"}
}

extension DeleteDevEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointName = "EndpointName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointName = endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
    }
}

public struct DeleteDevEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDevEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDevEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDevEndpointOutputError>
}

public struct DeleteDevEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDevEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDevEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDevEndpointOutputError>
}

public struct DeleteDevEndpointInput: Equatable {
    /// <p>The name of the <code>DevEndpoint</code>.</p>
    public let endpointName: String?

    public init (
        endpointName: String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

struct DeleteDevEndpointInputBody: Equatable {
    public let endpointName: String?
}

extension DeleteDevEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointName = "EndpointName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
    }
}

extension DeleteDevEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDevEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDevEndpointOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDevEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDevEndpointOutputResponse()"}
}

extension DeleteDevEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDevEndpointOutputResponse: Equatable {

    public init() {}
}

struct DeleteDevEndpointOutputResponseBody: Equatable {
}

extension DeleteDevEndpointOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteJobInputBodyMiddleware: Middleware {
    public let id: String = "DeleteJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

extension DeleteJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobInput(jobName: \(String(describing: jobName)))"}
}

extension DeleteJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
    }
}

public struct DeleteJobInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

public struct DeleteJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

public struct DeleteJobInput: Equatable {
    /// <p>The name of the job definition to delete.</p>
    public let jobName: String?

    public init (
        jobName: String? = nil
    )
    {
        self.jobName = jobName
    }
}

struct DeleteJobInputBody: Equatable {
    public let jobName: String?
}

extension DeleteJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
    }
}

extension DeleteJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteJobOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobOutputResponse(jobName: \(String(describing: jobName)))"}
}

extension DeleteJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobName = output.jobName
        } else {
            self.jobName = nil
        }
    }
}

public struct DeleteJobOutputResponse: Equatable {
    /// <p>The name of the job definition that was deleted.</p>
    public let jobName: String?

    public init (
        jobName: String? = nil
    )
    {
        self.jobName = jobName
    }
}

struct DeleteJobOutputResponseBody: Equatable {
    public let jobName: String?
}

extension DeleteJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
    }
}

public struct DeleteMLTransformInputBodyMiddleware: Middleware {
    public let id: String = "DeleteMLTransformInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMLTransformInput>
    public typealias MOutput = OperationOutput<DeleteMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMLTransformOutputError>
}

extension DeleteMLTransformInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMLTransformInput(transformId: \(String(describing: transformId)))"}
}

extension DeleteMLTransformInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case transformId = "TransformId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
    }
}

public struct DeleteMLTransformInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMLTransformInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMLTransformInput>
    public typealias MOutput = OperationOutput<DeleteMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMLTransformOutputError>
}

public struct DeleteMLTransformInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMLTransformInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMLTransformInput>
    public typealias MOutput = OperationOutput<DeleteMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMLTransformOutputError>
}

public struct DeleteMLTransformInput: Equatable {
    /// <p>The unique identifier of the transform to delete.</p>
    public let transformId: String?

    public init (
        transformId: String? = nil
    )
    {
        self.transformId = transformId
    }
}

struct DeleteMLTransformInputBody: Equatable {
    public let transformId: String?
}

extension DeleteMLTransformInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
    }
}

extension DeleteMLTransformOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMLTransformOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMLTransformOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMLTransformOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMLTransformOutputResponse(transformId: \(String(describing: transformId)))"}
}

extension DeleteMLTransformOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteMLTransformOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transformId = output.transformId
        } else {
            self.transformId = nil
        }
    }
}

public struct DeleteMLTransformOutputResponse: Equatable {
    /// <p>The unique identifier of the transform that was deleted.</p>
    public let transformId: String?

    public init (
        transformId: String? = nil
    )
    {
        self.transformId = transformId
    }
}

struct DeleteMLTransformOutputResponseBody: Equatable {
    public let transformId: String?
}

extension DeleteMLTransformOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
    }
}

public struct DeletePartitionIndexInputBodyMiddleware: Middleware {
    public let id: String = "DeletePartitionIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartitionIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartitionIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartitionIndexInput>
    public typealias MOutput = OperationOutput<DeletePartitionIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartitionIndexOutputError>
}

extension DeletePartitionIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePartitionIndexInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), indexName: \(String(describing: indexName)), tableName: \(String(describing: tableName)))"}
}

extension DeletePartitionIndexInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case indexName = "IndexName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct DeletePartitionIndexInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePartitionIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartitionIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartitionIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartitionIndexInput>
    public typealias MOutput = OperationOutput<DeletePartitionIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartitionIndexOutputError>
}

public struct DeletePartitionIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePartitionIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartitionIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartitionIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartitionIndexInput>
    public typealias MOutput = OperationOutput<DeletePartitionIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartitionIndexOutputError>
}

public struct DeletePartitionIndexInput: Equatable {
    /// <p>The catalog ID where the table resides.</p>
    public let catalogId: String?
    /// <p>Specifies the name of a database from which you want to delete a partition index.</p>
    public let databaseName: String?
    /// <p>The name of the partition index to be deleted.</p>
    public let indexName: String?
    /// <p>Specifies the name of a table from which you want to delete a partition index.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        indexName: String? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.indexName = indexName
        self.tableName = tableName
    }
}

struct DeletePartitionIndexInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let indexName: String?
}

extension DeletePartitionIndexInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case indexName = "IndexName"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
    }
}

extension DeletePartitionIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePartitionIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePartitionIndexOutputError: Equatable {
    case conflictException(ConflictException)
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePartitionIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePartitionIndexOutputResponse()"}
}

extension DeletePartitionIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePartitionIndexOutputResponse: Equatable {

    public init() {}
}

struct DeletePartitionIndexOutputResponseBody: Equatable {
}

extension DeletePartitionIndexOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePartitionInputBodyMiddleware: Middleware {
    public let id: String = "DeletePartitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartitionInput>
    public typealias MOutput = OperationOutput<DeletePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartitionOutputError>
}

extension DeletePartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePartitionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), partitionValues: \(String(describing: partitionValues)), tableName: \(String(describing: tableName)))"}
}

extension DeletePartitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionValues = "PartitionValues"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionValues = partitionValues {
            var partitionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValues)
            for valuestringlist0 in partitionValues {
                try partitionValuesContainer.encode(valuestringlist0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct DeletePartitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePartitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartitionInput>
    public typealias MOutput = OperationOutput<DeletePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartitionOutputError>
}

public struct DeletePartitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePartitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartitionInput>
    public typealias MOutput = OperationOutput<DeletePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartitionOutputError>
}

public struct DeletePartitionInput: Equatable {
    /// <p>The ID of the Data Catalog where the partition to be deleted resides. If none is provided,
    ///       the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database in which the table in question
    ///       resides.</p>
    public let databaseName: String?
    /// <p>The values that define the partition.</p>
    public let partitionValues: [String]?
    /// <p>The name of the table that contains the partition to be deleted.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        partitionValues: [String]? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionValues = partitionValues
        self.tableName = tableName
    }
}

struct DeletePartitionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let partitionValues: [String]?
}

extension DeletePartitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionValues = "PartitionValues"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let partitionValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionValues)
        var partitionValuesDecoded0:[String]? = nil
        if let partitionValuesContainer = partitionValuesContainer {
            partitionValuesDecoded0 = [String]()
            for string0 in partitionValuesContainer {
                if let string0 = string0 {
                    partitionValuesDecoded0?.append(string0)
                }
            }
        }
        partitionValues = partitionValuesDecoded0
    }
}

extension DeletePartitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePartitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePartitionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePartitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePartitionOutputResponse()"}
}

extension DeletePartitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePartitionOutputResponse: Equatable {

    public init() {}
}

struct DeletePartitionOutputResponseBody: Equatable {
}

extension DeletePartitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRegistryInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRegistryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegistryInput>
    public typealias MOutput = OperationOutput<DeleteRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegistryOutputError>
}

extension DeleteRegistryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegistryInput(registryId: \(String(describing: registryId)))"}
}

extension DeleteRegistryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryId = "RegistryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
    }
}

public struct DeleteRegistryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRegistryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegistryInput>
    public typealias MOutput = OperationOutput<DeleteRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegistryOutputError>
}

public struct DeleteRegistryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRegistryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegistryInput>
    public typealias MOutput = OperationOutput<DeleteRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegistryOutputError>
}

public struct DeleteRegistryInput: Equatable {
    /// <p>This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).</p>
    public let registryId: RegistryId?

    public init (
        registryId: RegistryId? = nil
    )
    {
        self.registryId = registryId
    }
}

struct DeleteRegistryInputBody: Equatable {
    public let registryId: RegistryId?
}

extension DeleteRegistryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId = "RegistryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(RegistryId.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

extension DeleteRegistryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRegistryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRegistryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRegistryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegistryOutputResponse(registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)), status: \(String(describing: status)))"}
}

extension DeleteRegistryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRegistryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.status = output.status
        } else {
            self.registryArn = nil
            self.registryName = nil
            self.status = nil
        }
    }
}

public struct DeleteRegistryOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the registry being deleted.</p>
    public let registryArn: String?
    /// <p>The name of the registry being deleted.</p>
    public let registryName: String?
    /// <p>The status of the registry. A successful operation will return the <code>Deleting</code> status.</p>
    public let status: RegistryStatus?

    public init (
        registryArn: String? = nil,
        registryName: String? = nil,
        status: RegistryStatus? = nil
    )
    {
        self.registryArn = registryArn
        self.registryName = registryName
        self.status = status
    }
}

struct DeleteRegistryOutputResponseBody: Equatable {
    public let registryName: String?
    public let registryArn: String?
    public let status: RegistryStatus?
}

extension DeleteRegistryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RegistryStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

extension DeleteResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyInput(policyHashCondition: \(String(describing: policyHashCondition)), resourceArn: \(String(describing: resourceArn)))"}
}

extension DeleteResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyHashCondition = "PolicyHashCondition"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyHashCondition = policyHashCondition {
            try encodeContainer.encode(policyHashCondition, forKey: .policyHashCondition)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeleteResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInput: Equatable {
    /// <p>The hash value returned when this policy was set.</p>
    public let policyHashCondition: String?
    /// <p>The ARN of the AWS Glue resource for the resource policy to be deleted.</p>
    public let resourceArn: String?

    public init (
        policyHashCondition: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.policyHashCondition = policyHashCondition
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Equatable {
    public let policyHashCondition: String?
    public let resourceArn: String?
}

extension DeleteResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyHashCondition = "PolicyHashCondition"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyHashConditionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyHashCondition)
        policyHashCondition = policyHashConditionDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConditionCheckFailureException" : self = .conditionCheckFailureException(try ConditionCheckFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Equatable {
    case conditionCheckFailureException(ConditionCheckFailureException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyOutputResponse()"}
}

extension DeleteResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourcePolicyOutputResponseBody: Equatable {
}

extension DeleteResourcePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSchemaInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaOutputError>
}

extension DeleteSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaInput(schemaId: \(String(describing: schemaId)))"}
}

extension DeleteSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaId = "SchemaId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
    }
}

public struct DeleteSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInput: Equatable {
    /// <p>This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).</p>
    public let schemaId: SchemaId?

    public init (
        schemaId: SchemaId? = nil
    )
    {
        self.schemaId = schemaId
    }
}

struct DeleteSchemaInputBody: Equatable {
    public let schemaId: SchemaId?
}

extension DeleteSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaId = "SchemaId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
    }
}

extension DeleteSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSchemaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaOutputResponse(schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)), status: \(String(describing: status)))"}
}

extension DeleteSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.status = output.status
        } else {
            self.schemaArn = nil
            self.schemaName = nil
            self.status = nil
        }
    }
}

public struct DeleteSchemaOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the schema being deleted.</p>
    public let schemaArn: String?
    /// <p>The name of the schema being deleted.</p>
    public let schemaName: String?
    /// <p>The status of the schema.</p>
    public let status: SchemaStatus?

    public init (
        schemaArn: String? = nil,
        schemaName: String? = nil,
        status: SchemaStatus? = nil
    )
    {
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.status = status
    }
}

struct DeleteSchemaOutputResponseBody: Equatable {
    public let schemaArn: String?
    public let schemaName: String?
    public let status: SchemaStatus?
}

extension DeleteSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SchemaStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteSchemaVersionsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSchemaVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaVersionsInput>
    public typealias MOutput = OperationOutput<DeleteSchemaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaVersionsOutputError>
}

extension DeleteSchemaVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaVersionsInput(schemaId: \(String(describing: schemaId)), versions: \(String(describing: versions)))"}
}

extension DeleteSchemaVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaId = "SchemaId"
        case versions = "Versions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let versions = versions {
            try encodeContainer.encode(versions, forKey: .versions)
        }
    }
}

public struct DeleteSchemaVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSchemaVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaVersionsInput>
    public typealias MOutput = OperationOutput<DeleteSchemaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaVersionsOutputError>
}

public struct DeleteSchemaVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSchemaVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSchemaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSchemaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSchemaVersionsInput>
    public typealias MOutput = OperationOutput<DeleteSchemaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSchemaVersionsOutputError>
}

public struct DeleteSchemaVersionsInput: Equatable {
    /// <p>This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).</p>
    public let schemaId: SchemaId?
    /// <p>A version range may be supplied which may be of the format:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>a single version number, 5</p>
    ///             </li>
    ///             <li>
    ///                <p>a range, 5-8 : deletes versions 5, 6, 7, 8</p>
    ///             </li>
    ///          </ul>
    public let versions: String?

    public init (
        schemaId: SchemaId? = nil,
        versions: String? = nil
    )
    {
        self.schemaId = schemaId
        self.versions = versions
    }
}

struct DeleteSchemaVersionsInputBody: Equatable {
    public let schemaId: SchemaId?
    public let versions: String?
}

extension DeleteSchemaVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaId = "SchemaId"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let versionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versions)
        versions = versionsDecoded
    }
}

extension DeleteSchemaVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSchemaVersionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSchemaVersionsOutputResponse(schemaVersionErrors: \(String(describing: schemaVersionErrors)))"}
}

extension DeleteSchemaVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSchemaVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.schemaVersionErrors = output.schemaVersionErrors
        } else {
            self.schemaVersionErrors = nil
        }
    }
}

public struct DeleteSchemaVersionsOutputResponse: Equatable {
    /// <p>A list of <code>SchemaVersionErrorItem</code> objects, each containing an error and schema version.</p>
    public let schemaVersionErrors: [SchemaVersionErrorItem]?

    public init (
        schemaVersionErrors: [SchemaVersionErrorItem]? = nil
    )
    {
        self.schemaVersionErrors = schemaVersionErrors
    }
}

struct DeleteSchemaVersionsOutputResponseBody: Equatable {
    public let schemaVersionErrors: [SchemaVersionErrorItem]?
}

extension DeleteSchemaVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaVersionErrors = "SchemaVersionErrors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionErrorsContainer = try containerValues.decodeIfPresent([SchemaVersionErrorItem?].self, forKey: .schemaVersionErrors)
        var schemaVersionErrorsDecoded0:[SchemaVersionErrorItem]? = nil
        if let schemaVersionErrorsContainer = schemaVersionErrorsContainer {
            schemaVersionErrorsDecoded0 = [SchemaVersionErrorItem]()
            for structure0 in schemaVersionErrorsContainer {
                if let structure0 = structure0 {
                    schemaVersionErrorsDecoded0?.append(structure0)
                }
            }
        }
        schemaVersionErrors = schemaVersionErrorsDecoded0
    }
}

public struct DeleteSecurityConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSecurityConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSecurityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSecurityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSecurityConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteSecurityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSecurityConfigurationOutputError>
}

extension DeleteSecurityConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSecurityConfigurationInput(name: \(String(describing: name)))"}
}

extension DeleteSecurityConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteSecurityConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSecurityConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSecurityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSecurityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSecurityConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteSecurityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSecurityConfigurationOutputError>
}

public struct DeleteSecurityConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSecurityConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSecurityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSecurityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSecurityConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteSecurityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSecurityConfigurationOutputError>
}

public struct DeleteSecurityConfigurationInput: Equatable {
    /// <p>The name of the security configuration to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteSecurityConfigurationInputBody: Equatable {
    public let name: String?
}

extension DeleteSecurityConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteSecurityConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSecurityConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSecurityConfigurationOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSecurityConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSecurityConfigurationOutputResponse()"}
}

extension DeleteSecurityConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSecurityConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteSecurityConfigurationOutputResponseBody: Equatable {
}

extension DeleteSecurityConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTableInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTableInput>
    public typealias MOutput = OperationOutput<DeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTableOutputError>
}

extension DeleteTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTableInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), name: \(String(describing: name)))"}
}

extension DeleteTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteTableInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTableInput>
    public typealias MOutput = OperationOutput<DeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTableOutputError>
}

public struct DeleteTableInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTableInput>
    public typealias MOutput = OperationOutput<DeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTableOutputError>
}

public struct DeleteTableInput: Equatable {
    /// <p>The ID of the Data Catalog where the table resides. If none is provided, the AWS account
    ///       ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database in which the table resides. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let databaseName: String?
    /// <p>The name of the table to be deleted. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let name: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        name: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.name = name
    }
}

struct DeleteTableInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let name: String?
}

extension DeleteTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTableOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTableOutputResponse()"}
}

extension DeleteTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTableOutputResponse: Equatable {

    public init() {}
}

struct DeleteTableOutputResponseBody: Equatable {
}

extension DeleteTableOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTableVersionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTableVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTableVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTableVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTableVersionInput>
    public typealias MOutput = OperationOutput<DeleteTableVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTableVersionOutputError>
}

extension DeleteTableVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTableVersionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)), versionId: \(String(describing: versionId)))"}
}

extension DeleteTableVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }
}

public struct DeleteTableVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTableVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTableVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTableVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTableVersionInput>
    public typealias MOutput = OperationOutput<DeleteTableVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTableVersionOutputError>
}

public struct DeleteTableVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTableVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTableVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTableVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTableVersionInput>
    public typealias MOutput = OperationOutput<DeleteTableVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTableVersionOutputError>
}

public struct DeleteTableVersionInput: Equatable {
    /// <p>The ID of the Data Catalog where the tables reside. If none is provided, the AWS account
    ///       ID is used by default.</p>
    public let catalogId: String?
    /// <p>The database in the catalog in which the table resides. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let databaseName: String?
    /// <p>The name of the table. For Hive compatibility,
    ///       this name is entirely lowercase.</p>
    public let tableName: String?
    /// <p>The ID of the table version to be deleted. A <code>VersionID</code> is a string representation of an integer. Each version is incremented by 1.</p>
    public let versionId: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        tableName: String? = nil,
        versionId: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.versionId = versionId
    }
}

struct DeleteTableVersionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let versionId: String?
}

extension DeleteTableVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
        case versionId = "VersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension DeleteTableVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTableVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTableVersionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTableVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTableVersionOutputResponse()"}
}

extension DeleteTableVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTableVersionOutputResponse: Equatable {

    public init() {}
}

struct DeleteTableVersionOutputResponseBody: Equatable {
}

extension DeleteTableVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTriggerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTriggerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTriggerInput>
    public typealias MOutput = OperationOutput<DeleteTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTriggerOutputError>
}

extension DeleteTriggerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTriggerInput(name: \(String(describing: name)))"}
}

extension DeleteTriggerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteTriggerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTriggerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTriggerInput>
    public typealias MOutput = OperationOutput<DeleteTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTriggerOutputError>
}

public struct DeleteTriggerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTriggerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTriggerInput>
    public typealias MOutput = OperationOutput<DeleteTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTriggerOutputError>
}

public struct DeleteTriggerInput: Equatable {
    /// <p>The name of the trigger to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteTriggerInputBody: Equatable {
    public let name: String?
}

extension DeleteTriggerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteTriggerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTriggerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTriggerOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTriggerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTriggerOutputResponse(name: \(String(describing: name)))"}
}

extension DeleteTriggerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteTriggerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct DeleteTriggerOutputResponse: Equatable {
    /// <p>The name of the trigger that was deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteTriggerOutputResponseBody: Equatable {
    public let name: String?
}

extension DeleteTriggerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct DeleteUserDefinedFunctionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserDefinedFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<DeleteUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserDefinedFunctionOutputError>
}

extension DeleteUserDefinedFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserDefinedFunctionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), functionName: \(String(describing: functionName)))"}
}

extension DeleteUserDefinedFunctionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case functionName = "FunctionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
    }
}

public struct DeleteUserDefinedFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserDefinedFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<DeleteUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserDefinedFunctionOutputError>
}

public struct DeleteUserDefinedFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserDefinedFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<DeleteUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserDefinedFunctionOutputError>
}

public struct DeleteUserDefinedFunctionInput: Equatable {
    /// <p>The ID of the Data Catalog where the function to be deleted is
    ///       located. If none is supplied, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database where the function is located.</p>
    public let databaseName: String?
    /// <p>The name of the function definition to be deleted.</p>
    public let functionName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        functionName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.functionName = functionName
    }
}

struct DeleteUserDefinedFunctionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let functionName: String?
}

extension DeleteUserDefinedFunctionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case functionName = "FunctionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
    }
}

extension DeleteUserDefinedFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserDefinedFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserDefinedFunctionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserDefinedFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserDefinedFunctionOutputResponse()"}
}

extension DeleteUserDefinedFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserDefinedFunctionOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserDefinedFunctionOutputResponseBody: Equatable {
}

extension DeleteUserDefinedFunctionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteWorkflowInputBodyMiddleware: Middleware {
    public let id: String = "DeleteWorkflowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkflowInput>
    public typealias MOutput = OperationOutput<DeleteWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkflowOutputError>
}

extension DeleteWorkflowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkflowInput(name: \(String(describing: name)))"}
}

extension DeleteWorkflowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteWorkflowInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWorkflowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkflowInput>
    public typealias MOutput = OperationOutput<DeleteWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkflowOutputError>
}

public struct DeleteWorkflowInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWorkflowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkflowInput>
    public typealias MOutput = OperationOutput<DeleteWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkflowOutputError>
}

public struct DeleteWorkflowInput: Equatable {
    /// <p>Name of the workflow to be deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteWorkflowInputBody: Equatable {
    public let name: String?
}

extension DeleteWorkflowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteWorkflowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkflowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkflowOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkflowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkflowOutputResponse(name: \(String(describing: name)))"}
}

extension DeleteWorkflowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct DeleteWorkflowOutputResponse: Equatable {
    /// <p>Name of the workflow specified in input.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteWorkflowOutputResponseBody: Equatable {
    public let name: String?
}

extension DeleteWorkflowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DevEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arguments = "Arguments"
        case availabilityZone = "AvailabilityZone"
        case createdTimestamp = "CreatedTimestamp"
        case endpointName = "EndpointName"
        case extraJarsS3Path = "ExtraJarsS3Path"
        case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
        case failureReason = "FailureReason"
        case glueVersion = "GlueVersion"
        case lastModifiedTimestamp = "LastModifiedTimestamp"
        case lastUpdateStatus = "LastUpdateStatus"
        case numberOfNodes = "NumberOfNodes"
        case numberOfWorkers = "NumberOfWorkers"
        case privateAddress = "PrivateAddress"
        case publicAddress = "PublicAddress"
        case publicKey = "PublicKey"
        case publicKeys = "PublicKeys"
        case roleArn = "RoleArn"
        case securityConfiguration = "SecurityConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case status = "Status"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
        case workerType = "WorkerType"
        case yarnEndpointAddress = "YarnEndpointAddress"
        case zeppelinRemoteSparkInterpreterPort = "ZeppelinRemoteSparkInterpreterPort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .arguments)
            for (dictKey0, mapvalue0) in arguments {
                try argumentsContainer.encode(mapvalue0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let endpointName = endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
        if let extraJarsS3Path = extraJarsS3Path {
            try encodeContainer.encode(extraJarsS3Path, forKey: .extraJarsS3Path)
        }
        if let extraPythonLibsS3Path = extraPythonLibsS3Path {
            try encodeContainer.encode(extraPythonLibsS3Path, forKey: .extraPythonLibsS3Path)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let glueVersion = glueVersion {
            try encodeContainer.encode(glueVersion, forKey: .glueVersion)
        }
        if let lastModifiedTimestamp = lastModifiedTimestamp {
            try encodeContainer.encode(lastModifiedTimestamp.timeIntervalSince1970, forKey: .lastModifiedTimestamp)
        }
        if let lastUpdateStatus = lastUpdateStatus {
            try encodeContainer.encode(lastUpdateStatus, forKey: .lastUpdateStatus)
        }
        if numberOfNodes != 0 {
            try encodeContainer.encode(numberOfNodes, forKey: .numberOfNodes)
        }
        if let numberOfWorkers = numberOfWorkers {
            try encodeContainer.encode(numberOfWorkers, forKey: .numberOfWorkers)
        }
        if let privateAddress = privateAddress {
            try encodeContainer.encode(privateAddress, forKey: .privateAddress)
        }
        if let publicAddress = publicAddress {
            try encodeContainer.encode(publicAddress, forKey: .publicAddress)
        }
        if let publicKey = publicKey {
            try encodeContainer.encode(publicKey, forKey: .publicKey)
        }
        if let publicKeys = publicKeys {
            var publicKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .publicKeys)
            for publickeyslist0 in publicKeys {
                try publicKeysContainer.encode(publickeyslist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityConfiguration = securityConfiguration {
            try encodeContainer.encode(securityConfiguration, forKey: .securityConfiguration)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for stringlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(stringlist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let workerType = workerType {
            try encodeContainer.encode(workerType.rawValue, forKey: .workerType)
        }
        if let yarnEndpointAddress = yarnEndpointAddress {
            try encodeContainer.encode(yarnEndpointAddress, forKey: .yarnEndpointAddress)
        }
        if zeppelinRemoteSparkInterpreterPort != 0 {
            try encodeContainer.encode(zeppelinRemoteSparkInterpreterPort, forKey: .zeppelinRemoteSparkInterpreterPort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let yarnEndpointAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .yarnEndpointAddress)
        yarnEndpointAddress = yarnEndpointAddressDecoded
        let privateAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateAddress)
        privateAddress = privateAddressDecoded
        let zeppelinRemoteSparkInterpreterPortDecoded = try containerValues.decode(Int.self, forKey: .zeppelinRemoteSparkInterpreterPort)
        zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPortDecoded
        let publicAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicAddress)
        publicAddress = publicAddressDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
        let numberOfNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let extraPythonLibsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraPythonLibsS3Path)
        extraPythonLibsS3Path = extraPythonLibsS3PathDecoded
        let extraJarsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraJarsS3Path)
        extraJarsS3Path = extraJarsS3PathDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let publicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
        let publicKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .publicKeys)
        var publicKeysDecoded0:[String]? = nil
        if let publicKeysContainer = publicKeysContainer {
            publicKeysDecoded0 = [String]()
            for string0 in publicKeysContainer {
                if let string0 = string0 {
                    publicKeysDecoded0?.append(string0)
                }
            }
        }
        publicKeys = publicKeysDecoded0
        let securityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityConfiguration)
        securityConfiguration = securityConfigurationDecoded
        let argumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .arguments)
        var argumentsDecoded0: [String:String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in argumentsContainer {
                if let genericstring0 = genericstring0 {
                    argumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        arguments = argumentsDecoded0
    }
}

extension DevEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DevEndpoint(arguments: \(String(describing: arguments)), availabilityZone: \(String(describing: availabilityZone)), createdTimestamp: \(String(describing: createdTimestamp)), endpointName: \(String(describing: endpointName)), extraJarsS3Path: \(String(describing: extraJarsS3Path)), extraPythonLibsS3Path: \(String(describing: extraPythonLibsS3Path)), failureReason: \(String(describing: failureReason)), glueVersion: \(String(describing: glueVersion)), lastModifiedTimestamp: \(String(describing: lastModifiedTimestamp)), lastUpdateStatus: \(String(describing: lastUpdateStatus)), numberOfNodes: \(String(describing: numberOfNodes)), numberOfWorkers: \(String(describing: numberOfWorkers)), privateAddress: \(String(describing: privateAddress)), publicAddress: \(String(describing: publicAddress)), publicKey: \(String(describing: publicKey)), publicKeys: \(String(describing: publicKeys)), roleArn: \(String(describing: roleArn)), securityConfiguration: \(String(describing: securityConfiguration)), securityGroupIds: \(String(describing: securityGroupIds)), status: \(String(describing: status)), subnetId: \(String(describing: subnetId)), vpcId: \(String(describing: vpcId)), workerType: \(String(describing: workerType)), yarnEndpointAddress: \(String(describing: yarnEndpointAddress)), zeppelinRemoteSparkInterpreterPort: \(String(describing: zeppelinRemoteSparkInterpreterPort)))"}
}

/// <p>A development endpoint where a developer can remotely debug extract, transform, and load
///       (ETL) scripts.</p>
public struct DevEndpoint: Equatable {
    /// <p>A map of arguments used to configure the <code>DevEndpoint</code>.</p>
    ///          <p>Valid arguments are:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>
    ///                   <code>"--enable-glue-datacatalog": ""</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"GLUE_PYTHON_VERSION": "3"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"GLUE_PYTHON_VERSION": "2"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    /// 	
    ///          <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
    public let arguments: [String:String]?
    /// <p>The AWS Availability Zone where this <code>DevEndpoint</code> is located.</p>
    public let availabilityZone: String?
    /// <p>The point in time at which this DevEndpoint was created.</p>
    public let createdTimestamp: Date?
    /// <p>The name of the <code>DevEndpoint</code>.</p>
    public let endpointName: String?
    /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded
    ///       in your <code>DevEndpoint</code>.</p>
    ///          <note>
    ///             <p>You can only use pure Java/Scala libraries with a <code>DevEndpoint</code>.</p>
    ///          </note>
    public let extraJarsS3Path: String?
    /// <p>The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in
    ///       your <code>DevEndpoint</code>. Multiple values must be complete paths separated by a
    ///       comma.</p>
    ///
    ///          <note>
    ///             <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on
    ///         C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data
    ///         analysis library, are not currently supported.</p>
    ///          </note>
    public let extraPythonLibsS3Path: String?
    /// <p>The reason for a current failure in this <code>DevEndpoint</code>.</p>
    public let failureReason: String?
    /// <p>Glue version determines the versions of Apache Spark and Python that AWS Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. </p>
    ///
    ///          <p>For more information about the available AWS Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    /// 	
    /// 	        <p>Development endpoints that are created without specifying a Glue version default to Glue 0.9.</p>
    /// 	
    /// 	        <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
    public let glueVersion: String?
    /// <p>The point in time at which this <code>DevEndpoint</code> was last modified.</p>
    public let lastModifiedTimestamp: Date?
    /// <p>The status of the last update.</p>
    public let lastUpdateStatus: String?
    /// <p>The number of AWS Glue Data Processing Units (DPUs) allocated to this
    ///         <code>DevEndpoint</code>.</p>
    public let numberOfNodes: Int
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated to the development endpoint.</p>
    /// 	
    /// 		       <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
    public let numberOfWorkers: Int?
    /// <p>A private IP address to access the <code>DevEndpoint</code> within a VPC if the
    ///         <code>DevEndpoint</code> is created within one. The <code>PrivateAddress</code> field is
    ///       present only when you create the <code>DevEndpoint</code> within your VPC.</p>
    public let privateAddress: String?
    /// <p>The public IP address used by this <code>DevEndpoint</code>. The
    ///         <code>PublicAddress</code> field is present only when you create a non-virtual private cloud
    ///       (VPC) <code>DevEndpoint</code>.</p>
    public let publicAddress: String?
    /// <p>The public key to be used by this <code>DevEndpoint</code> for authentication. This
    ///       attribute is provided for backward compatibility because the recommended attribute to use is
    ///       public keys.</p>
    public let publicKey: String?
    /// <p>A list of public keys to be used by the <code>DevEndpoints</code> for authentication.
    ///       Using this attribute is preferred over a single public key because the public keys allow you
    ///       to have a different private key per client.</p>
    ///          <note>
    ///             <p>If you previously created an endpoint with a public key, you must remove that key to be
    ///         able to set a list of public keys. Call the <code>UpdateDevEndpoint</code> API operation
    ///         with the public key content in the <code>deletePublicKeys</code> attribute, and the list of
    ///         new keys in the <code>addPublicKeys</code> attribute.</p>
    ///          </note>
    public let publicKeys: [String]?
    /// <p>The Amazon Resource Name (ARN) of the IAM role used in this
    ///       <code>DevEndpoint</code>.</p>
    public let roleArn: String?
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this
    ///         <code>DevEndpoint</code>.</p>
    public let securityConfiguration: String?
    /// <p>A list of security group identifiers used in this <code>DevEndpoint</code>.</p>
    public let securityGroupIds: [String]?
    /// <p>The current status of this <code>DevEndpoint</code>.</p>
    public let status: String?
    /// <p>The subnet ID for this <code>DevEndpoint</code>.</p>
    public let subnetId: String?
    /// <p>The ID of the virtual private cloud (VPC) used by this <code>DevEndpoint</code>.</p>
    public let vpcId: String?
    /// <p>The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
    ///             </li>
    ///          </ul>
    /// 	
    /// 	        <p>Known issue: when a development endpoint is created with the <code>G.2X</code>
    ///             <code>WorkerType</code> configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk. </p>
    public let workerType: WorkerType?
    /// <p>The YARN endpoint address used by this <code>DevEndpoint</code>.</p>
    public let yarnEndpointAddress: String?
    /// <p>The Apache Zeppelin port for the remote Apache Spark interpreter.</p>
    public let zeppelinRemoteSparkInterpreterPort: Int

    public init (
        arguments: [String:String]? = nil,
        availabilityZone: String? = nil,
        createdTimestamp: Date? = nil,
        endpointName: String? = nil,
        extraJarsS3Path: String? = nil,
        extraPythonLibsS3Path: String? = nil,
        failureReason: String? = nil,
        glueVersion: String? = nil,
        lastModifiedTimestamp: Date? = nil,
        lastUpdateStatus: String? = nil,
        numberOfNodes: Int = 0,
        numberOfWorkers: Int? = nil,
        privateAddress: String? = nil,
        publicAddress: String? = nil,
        publicKey: String? = nil,
        publicKeys: [String]? = nil,
        roleArn: String? = nil,
        securityConfiguration: String? = nil,
        securityGroupIds: [String]? = nil,
        status: String? = nil,
        subnetId: String? = nil,
        vpcId: String? = nil,
        workerType: WorkerType? = nil,
        yarnEndpointAddress: String? = nil,
        zeppelinRemoteSparkInterpreterPort: Int = 0
    )
    {
        self.arguments = arguments
        self.availabilityZone = availabilityZone
        self.createdTimestamp = createdTimestamp
        self.endpointName = endpointName
        self.extraJarsS3Path = extraJarsS3Path
        self.extraPythonLibsS3Path = extraPythonLibsS3Path
        self.failureReason = failureReason
        self.glueVersion = glueVersion
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.lastUpdateStatus = lastUpdateStatus
        self.numberOfNodes = numberOfNodes
        self.numberOfWorkers = numberOfWorkers
        self.privateAddress = privateAddress
        self.publicAddress = publicAddress
        self.publicKey = publicKey
        self.publicKeys = publicKeys
        self.roleArn = roleArn
        self.securityConfiguration = securityConfiguration
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.subnetId = subnetId
        self.vpcId = vpcId
        self.workerType = workerType
        self.yarnEndpointAddress = yarnEndpointAddress
        self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
    }
}

extension DevEndpointCustomLibraries: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case extraJarsS3Path = "ExtraJarsS3Path"
        case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let extraJarsS3Path = extraJarsS3Path {
            try encodeContainer.encode(extraJarsS3Path, forKey: .extraJarsS3Path)
        }
        if let extraPythonLibsS3Path = extraPythonLibsS3Path {
            try encodeContainer.encode(extraPythonLibsS3Path, forKey: .extraPythonLibsS3Path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extraPythonLibsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraPythonLibsS3Path)
        extraPythonLibsS3Path = extraPythonLibsS3PathDecoded
        let extraJarsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraJarsS3Path)
        extraJarsS3Path = extraJarsS3PathDecoded
    }
}

extension DevEndpointCustomLibraries: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DevEndpointCustomLibraries(extraJarsS3Path: \(String(describing: extraJarsS3Path)), extraPythonLibsS3Path: \(String(describing: extraPythonLibsS3Path)))"}
}

/// <p>Custom libraries to be loaded into a development endpoint.</p>
public struct DevEndpointCustomLibraries: Equatable {
    /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded
    ///       in your <code>DevEndpoint</code>.</p>
    ///          <note>
    ///             <p>You can only use pure Java/Scala libraries with a <code>DevEndpoint</code>.</p>
    ///          </note>
    public let extraJarsS3Path: String?
    /// <p>The paths to one or more Python libraries in an Amazon Simple Storage Service (Amazon S3)
    ///       bucket that should be loaded in your <code>DevEndpoint</code>. Multiple values must be
    ///       complete paths separated by a comma.</p>
    ///          <note>
    ///             <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on
    ///         C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data
    ///         analysis library, are not currently supported.</p>
    ///          </note>
    public let extraPythonLibsS3Path: String?

    public init (
        extraJarsS3Path: String? = nil,
        extraPythonLibsS3Path: String? = nil
    )
    {
        self.extraJarsS3Path = extraJarsS3Path
        self.extraPythonLibsS3Path = extraPythonLibsS3Path
    }
}

extension DoubleColumnStatisticsData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maximumValue = "MaximumValue"
        case minimumValue = "MinimumValue"
        case numberOfDistinctValues = "NumberOfDistinctValues"
        case numberOfNulls = "NumberOfNulls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maximumValue != 0.0 {
            try encodeContainer.encode(maximumValue, forKey: .maximumValue)
        }
        if minimumValue != 0.0 {
            try encodeContainer.encode(minimumValue, forKey: .minimumValue)
        }
        if numberOfDistinctValues != 0 {
            try encodeContainer.encode(numberOfDistinctValues, forKey: .numberOfDistinctValues)
        }
        if numberOfNulls != 0 {
            try encodeContainer.encode(numberOfNulls, forKey: .numberOfNulls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumValueDecoded = try containerValues.decode(Double.self, forKey: .minimumValue)
        minimumValue = minimumValueDecoded
        let maximumValueDecoded = try containerValues.decode(Double.self, forKey: .maximumValue)
        maximumValue = maximumValueDecoded
        let numberOfNullsDecoded = try containerValues.decode(Int.self, forKey: .numberOfNulls)
        numberOfNulls = numberOfNullsDecoded
        let numberOfDistinctValuesDecoded = try containerValues.decode(Int.self, forKey: .numberOfDistinctValues)
        numberOfDistinctValues = numberOfDistinctValuesDecoded
    }
}

extension DoubleColumnStatisticsData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DoubleColumnStatisticsData(maximumValue: \(String(describing: maximumValue)), minimumValue: \(String(describing: minimumValue)), numberOfDistinctValues: \(String(describing: numberOfDistinctValues)), numberOfNulls: \(String(describing: numberOfNulls)))"}
}

/// <p>Defines column statistics supported for floating-point number data columns.</p>
public struct DoubleColumnStatisticsData: Equatable {
    /// <p>The highest value in the column.</p>
    public let maximumValue: Double
    /// <p>The lowest value in the column.</p>
    public let minimumValue: Double
    /// <p>The number of distinct values in a column.</p>
    public let numberOfDistinctValues: Int
    /// <p>The number of null values in the column.</p>
    public let numberOfNulls: Int

    public init (
        maximumValue: Double = 0.0,
        minimumValue: Double = 0.0,
        numberOfDistinctValues: Int = 0,
        numberOfNulls: Int = 0
    )
    {
        self.maximumValue = maximumValue
        self.minimumValue = minimumValue
        self.numberOfDistinctValues = numberOfDistinctValues
        self.numberOfNulls = numberOfNulls
    }
}

extension DynamoDBTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case path = "Path"
        case scanAll
        case scanRate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let scanAll = scanAll {
            try encodeContainer.encode(scanAll, forKey: .scanAll)
        }
        if let scanRate = scanRate {
            try encodeContainer.encode(scanRate, forKey: .scanRate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let scanAllDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .scanAll)
        scanAll = scanAllDecoded
        let scanRateDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .scanRate)
        scanRate = scanRateDecoded
    }
}

extension DynamoDBTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DynamoDBTarget(path: \(String(describing: path)), scanAll: \(String(describing: scanAll)), scanRate: \(String(describing: scanRate)))"}
}

/// <p>Specifies an Amazon DynamoDB table to crawl.</p>
public struct DynamoDBTarget: Equatable {
    /// <p>The name of the DynamoDB table to crawl.</p>
    public let path: String?
    /// <p>Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.</p>
    /// 	
    /// 	        <p>A value of <code>true</code> means to scan all records, while a value of <code>false</code> means to sample the records. If no value is specified, the value defaults to <code>true</code>.</p>
    public let scanAll: Bool?
    /// <p>The percentage of the configured read capacity units to use by the AWS Glue crawler. Read capacity units is a term defined by DynamoDB, and is a numeric value that acts as rate limiter for the number of reads that can be performed on that table per second.</p>
    /// 	
    /// 	        <p>The valid values are null or a value between 0.1 to 1.5. A null value is used when user does not provide a value, and defaults to 0.5 of the configured Read Capacity Unit (for provisioned tables), or 0.25 of the max configured Read Capacity Unit (for tables using on-demand mode).</p>
    public let scanRate: Double?

    public init (
        path: String? = nil,
        scanAll: Bool? = nil,
        scanRate: Double? = nil
    )
    {
        self.path = path
        self.scanAll = scanAll
        self.scanRate = scanRate
    }
}

extension Edge: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationId = "DestinationId"
        case sourceId = "SourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationId = destinationId {
            try encodeContainer.encode(destinationId, forKey: .destinationId)
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let destinationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
    }
}

extension Edge: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Edge(destinationId: \(String(describing: destinationId)), sourceId: \(String(describing: sourceId)))"}
}

/// <p>An edge represents a directed connection between two AWS Glue components that are part of the workflow the
///       edge belongs to.</p>
public struct Edge: Equatable {
    /// <p>The unique of the node within the workflow where the edge ends.</p>
    public let destinationId: String?
    /// <p>The unique of the node within the workflow where the edge starts.</p>
    public let sourceId: String?

    public init (
        destinationId: String? = nil,
        sourceId: String? = nil
    )
    {
        self.destinationId = destinationId
        self.sourceId = sourceId
    }
}

public enum EnableHybridValues {
    case `false`
    case `true`
    case sdkUnknown(String)
}

extension EnableHybridValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnableHybridValues] {
        return [
            .false,
            .true,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .false: return "FALSE"
        case .true: return "TRUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnableHybridValues(rawValue: rawValue) ?? EnableHybridValues.sdkUnknown(rawValue)
    }
}

extension EncryptionAtRest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogEncryptionMode = "CatalogEncryptionMode"
        case sseAwsKmsKeyId = "SseAwsKmsKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogEncryptionMode = catalogEncryptionMode {
            try encodeContainer.encode(catalogEncryptionMode.rawValue, forKey: .catalogEncryptionMode)
        }
        if let sseAwsKmsKeyId = sseAwsKmsKeyId {
            try encodeContainer.encode(sseAwsKmsKeyId, forKey: .sseAwsKmsKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogEncryptionModeDecoded = try containerValues.decodeIfPresent(CatalogEncryptionMode.self, forKey: .catalogEncryptionMode)
        catalogEncryptionMode = catalogEncryptionModeDecoded
        let sseAwsKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sseAwsKmsKeyId)
        sseAwsKmsKeyId = sseAwsKmsKeyIdDecoded
    }
}

extension EncryptionAtRest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionAtRest(catalogEncryptionMode: \(String(describing: catalogEncryptionMode)), sseAwsKmsKeyId: \(String(describing: sseAwsKmsKeyId)))"}
}

/// <p>Specifies the encryption-at-rest configuration for the Data Catalog.</p>
public struct EncryptionAtRest: Equatable {
    /// <p>The encryption-at-rest mode for encrypting Data Catalog data.</p>
    public let catalogEncryptionMode: CatalogEncryptionMode?
    /// <p>The ID of the AWS KMS key to use for encryption at rest.</p>
    public let sseAwsKmsKeyId: String?

    public init (
        catalogEncryptionMode: CatalogEncryptionMode? = nil,
        sseAwsKmsKeyId: String? = nil
    )
    {
        self.catalogEncryptionMode = catalogEncryptionMode
        self.sseAwsKmsKeyId = sseAwsKmsKeyId
    }
}

extension EncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchEncryption = "CloudWatchEncryption"
        case jobBookmarksEncryption = "JobBookmarksEncryption"
        case s3Encryption = "S3Encryption"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchEncryption = cloudWatchEncryption {
            try encodeContainer.encode(cloudWatchEncryption, forKey: .cloudWatchEncryption)
        }
        if let jobBookmarksEncryption = jobBookmarksEncryption {
            try encodeContainer.encode(jobBookmarksEncryption, forKey: .jobBookmarksEncryption)
        }
        if let s3Encryption = s3Encryption {
            var s3EncryptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Encryption)
            for s3encryptionlist0 in s3Encryption {
                try s3EncryptionContainer.encode(s3encryptionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3EncryptionContainer = try containerValues.decodeIfPresent([S3Encryption?].self, forKey: .s3Encryption)
        var s3EncryptionDecoded0:[S3Encryption]? = nil
        if let s3EncryptionContainer = s3EncryptionContainer {
            s3EncryptionDecoded0 = [S3Encryption]()
            for structure0 in s3EncryptionContainer {
                if let structure0 = structure0 {
                    s3EncryptionDecoded0?.append(structure0)
                }
            }
        }
        s3Encryption = s3EncryptionDecoded0
        let cloudWatchEncryptionDecoded = try containerValues.decodeIfPresent(CloudWatchEncryption.self, forKey: .cloudWatchEncryption)
        cloudWatchEncryption = cloudWatchEncryptionDecoded
        let jobBookmarksEncryptionDecoded = try containerValues.decodeIfPresent(JobBookmarksEncryption.self, forKey: .jobBookmarksEncryption)
        jobBookmarksEncryption = jobBookmarksEncryptionDecoded
    }
}

extension EncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionConfiguration(cloudWatchEncryption: \(String(describing: cloudWatchEncryption)), jobBookmarksEncryption: \(String(describing: jobBookmarksEncryption)), s3Encryption: \(String(describing: s3Encryption)))"}
}

/// <p>Specifies an encryption configuration.</p>
public struct EncryptionConfiguration: Equatable {
    /// <p>The encryption configuration for Amazon CloudWatch.</p>
    public let cloudWatchEncryption: CloudWatchEncryption?
    /// <p>The encryption configuration for job bookmarks.</p>
    public let jobBookmarksEncryption: JobBookmarksEncryption?
    /// <p>The encryption configuration for Amazon Simple Storage Service (Amazon S3) data.</p>
    public let s3Encryption: [S3Encryption]?

    public init (
        cloudWatchEncryption: CloudWatchEncryption? = nil,
        jobBookmarksEncryption: JobBookmarksEncryption? = nil,
        s3Encryption: [S3Encryption]? = nil
    )
    {
        self.cloudWatchEncryption = cloudWatchEncryption
        self.jobBookmarksEncryption = jobBookmarksEncryption
        self.s3Encryption = s3Encryption
    }
}

extension EntityNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityNotFoundException(message: \(String(describing: message)))"}
}

extension EntityNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EntityNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified entity does not exist</p>
public struct EntityNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EntityNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension EntityNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ErrorDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ErrorDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorDetail(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>Contains details about an error.</p>
public struct ErrorDetail: Equatable {
    /// <p>The code associated with this error.</p>
    public let errorCode: String?
    /// <p>A message describing the error.</p>
    public let errorMessage: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

extension ErrorDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ErrorDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorDetails(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>An object containing error details.</p>
public struct ErrorDetails: Equatable {
    /// <p>The error code for an error.</p>
    public let errorCode: String?
    /// <p>The error message for an error.</p>
    public let errorMessage: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

extension EvaluationMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findMatchesMetrics = "FindMatchesMetrics"
        case transformType = "TransformType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findMatchesMetrics = findMatchesMetrics {
            try encodeContainer.encode(findMatchesMetrics, forKey: .findMatchesMetrics)
        }
        if let transformType = transformType {
            try encodeContainer.encode(transformType.rawValue, forKey: .transformType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformTypeDecoded = try containerValues.decodeIfPresent(TransformType.self, forKey: .transformType)
        transformType = transformTypeDecoded
        let findMatchesMetricsDecoded = try containerValues.decodeIfPresent(FindMatchesMetrics.self, forKey: .findMatchesMetrics)
        findMatchesMetrics = findMatchesMetricsDecoded
    }
}

extension EvaluationMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluationMetrics(findMatchesMetrics: \(String(describing: findMatchesMetrics)), transformType: \(String(describing: transformType)))"}
}

/// <p>Evaluation metrics provide an estimate of the quality of your machine learning transform.</p>
public struct EvaluationMetrics: Equatable {
    /// <p>The evaluation metrics for the find matches algorithm.</p>
    public let findMatchesMetrics: FindMatchesMetrics?
    /// <p>The type of machine learning transform.</p>
    public let transformType: TransformType?

    public init (
        findMatchesMetrics: FindMatchesMetrics? = nil,
        transformType: TransformType? = nil
    )
    {
        self.findMatchesMetrics = findMatchesMetrics
        self.transformType = transformType
    }
}

extension ExecutionProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxConcurrentRuns = "MaxConcurrentRuns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxConcurrentRuns != 0 {
            try encodeContainer.encode(maxConcurrentRuns, forKey: .maxConcurrentRuns)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConcurrentRunsDecoded = try containerValues.decode(Int.self, forKey: .maxConcurrentRuns)
        maxConcurrentRuns = maxConcurrentRunsDecoded
    }
}

extension ExecutionProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionProperty(maxConcurrentRuns: \(String(describing: maxConcurrentRuns)))"}
}

/// <p>An execution property of a job.</p>
public struct ExecutionProperty: Equatable {
    /// <p>The maximum number of concurrent runs allowed for the job.
    ///       The default is 1. An error is returned when this threshold is reached.
    ///       The maximum value you can specify is controlled by a service limit.</p>
    public let maxConcurrentRuns: Int

    public init (
        maxConcurrentRuns: Int = 0
    )
    {
        self.maxConcurrentRuns = maxConcurrentRuns
    }
}

public enum ExistCondition {
    case mustExist
    case `none`
    case notExist
    case sdkUnknown(String)
}

extension ExistCondition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExistCondition] {
        return [
            .mustExist,
            .none,
            .notExist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .mustExist: return "MUST_EXIST"
        case .none: return "NONE"
        case .notExist: return "NOT_EXIST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExistCondition(rawValue: rawValue) ?? ExistCondition.sdkUnknown(rawValue)
    }
}

extension ExportLabelsTaskRunProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputS3Path = "OutputS3Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3Path = outputS3Path {
            try encodeContainer.encode(outputS3Path, forKey: .outputS3Path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Path)
        outputS3Path = outputS3PathDecoded
    }
}

extension ExportLabelsTaskRunProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportLabelsTaskRunProperties(outputS3Path: \(String(describing: outputS3Path)))"}
}

/// <p>Specifies configuration properties for an exporting labels task run.</p>
public struct ExportLabelsTaskRunProperties: Equatable {
    /// <p>The Amazon Simple Storage Service (Amazon S3) path where you will export the
    ///       labels.</p>
    public let outputS3Path: String?

    public init (
        outputS3Path: String? = nil
    )
    {
        self.outputS3Path = outputS3Path
    }
}

extension FindMatchesMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case areaUnderPRCurve = "AreaUnderPRCurve"
        case columnImportances = "ColumnImportances"
        case confusionMatrix = "ConfusionMatrix"
        case f1 = "F1"
        case precision = "Precision"
        case recall = "Recall"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaUnderPRCurve = areaUnderPRCurve {
            try encodeContainer.encode(areaUnderPRCurve, forKey: .areaUnderPRCurve)
        }
        if let columnImportances = columnImportances {
            var columnImportancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnImportances)
            for columnimportancelist0 in columnImportances {
                try columnImportancesContainer.encode(columnimportancelist0)
            }
        }
        if let confusionMatrix = confusionMatrix {
            try encodeContainer.encode(confusionMatrix, forKey: .confusionMatrix)
        }
        if let f1 = f1 {
            try encodeContainer.encode(f1, forKey: .f1)
        }
        if let precision = precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let recall = recall {
            try encodeContainer.encode(recall, forKey: .recall)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let areaUnderPRCurveDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .areaUnderPRCurve)
        areaUnderPRCurve = areaUnderPRCurveDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .precision)
        precision = precisionDecoded
        let recallDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .recall)
        recall = recallDecoded
        let f1Decoded = try containerValues.decodeIfPresent(Double.self, forKey: .f1)
        f1 = f1Decoded
        let confusionMatrixDecoded = try containerValues.decodeIfPresent(ConfusionMatrix.self, forKey: .confusionMatrix)
        confusionMatrix = confusionMatrixDecoded
        let columnImportancesContainer = try containerValues.decodeIfPresent([ColumnImportance?].self, forKey: .columnImportances)
        var columnImportancesDecoded0:[ColumnImportance]? = nil
        if let columnImportancesContainer = columnImportancesContainer {
            columnImportancesDecoded0 = [ColumnImportance]()
            for structure0 in columnImportancesContainer {
                if let structure0 = structure0 {
                    columnImportancesDecoded0?.append(structure0)
                }
            }
        }
        columnImportances = columnImportancesDecoded0
    }
}

extension FindMatchesMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindMatchesMetrics(areaUnderPRCurve: \(String(describing: areaUnderPRCurve)), columnImportances: \(String(describing: columnImportances)), confusionMatrix: \(String(describing: confusionMatrix)), f1: \(String(describing: f1)), precision: \(String(describing: precision)), recall: \(String(describing: recall)))"}
}

/// <p>The evaluation metrics for the find matches algorithm. The quality of your machine
///       learning transform is measured by getting your transform to predict some matches and comparing
///       the results to known matches from the same dataset. The quality metrics are based on a subset
///       of your data, so they are not precise.</p>
public struct FindMatchesMetrics: Equatable {
    /// <p>The area under the precision/recall curve (AUPRC) is a single number measuring the overall
    ///       quality of the transform, that is independent of the choice made for precision vs. recall.
    ///       Higher values indicate that you have a more attractive precision vs. recall tradeoff.</p>
    /// 	        <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
    public let areaUnderPRCurve: Double?
    /// <p>A list of <code>ColumnImportance</code> structures containing column importance metrics, sorted in order of descending importance.</p>
    public let columnImportances: [ColumnImportance]?
    /// <p>The confusion matrix shows you what your transform is predicting accurately and what types of errors it is making.</p>
    /// 	        <p>For more information, see <a href="https://en.wikipedia.org/wiki/Confusion_matrix">Confusion matrix</a> in Wikipedia.</p>
    public let confusionMatrix: ConfusionMatrix?
    /// <p>The maximum F1 metric indicates the transform's accuracy between 0 and 1, where 1 is the best accuracy.</p>
    ///          <p>For more information, see <a href="https://en.wikipedia.org/wiki/F1_score">F1 score</a> in Wikipedia.</p>
    public let f1: Double?
    /// <p>The precision metric indicates when often your transform is correct when it predicts a match. Specifically, it measures how well the transform finds true positives from the total true positives possible.</p>
    ///          <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
    public let precision: Double?
    /// <p>The recall metric indicates that for an actual match, how often your transform predicts
    ///       the match. Specifically, it measures how well the transform finds true positives from the
    ///       total records in the source data.</p>
    ///          <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
    public let recall: Double?

    public init (
        areaUnderPRCurve: Double? = nil,
        columnImportances: [ColumnImportance]? = nil,
        confusionMatrix: ConfusionMatrix? = nil,
        f1: Double? = nil,
        precision: Double? = nil,
        recall: Double? = nil
    )
    {
        self.areaUnderPRCurve = areaUnderPRCurve
        self.columnImportances = columnImportances
        self.confusionMatrix = confusionMatrix
        self.f1 = f1
        self.precision = precision
        self.recall = recall
    }
}

extension FindMatchesParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accuracyCostTradeoff = "AccuracyCostTradeoff"
        case enforceProvidedLabels = "EnforceProvidedLabels"
        case precisionRecallTradeoff = "PrecisionRecallTradeoff"
        case primaryKeyColumnName = "PrimaryKeyColumnName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accuracyCostTradeoff = accuracyCostTradeoff {
            try encodeContainer.encode(accuracyCostTradeoff, forKey: .accuracyCostTradeoff)
        }
        if let enforceProvidedLabels = enforceProvidedLabels {
            try encodeContainer.encode(enforceProvidedLabels, forKey: .enforceProvidedLabels)
        }
        if let precisionRecallTradeoff = precisionRecallTradeoff {
            try encodeContainer.encode(precisionRecallTradeoff, forKey: .precisionRecallTradeoff)
        }
        if let primaryKeyColumnName = primaryKeyColumnName {
            try encodeContainer.encode(primaryKeyColumnName, forKey: .primaryKeyColumnName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryKeyColumnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .primaryKeyColumnName)
        primaryKeyColumnName = primaryKeyColumnNameDecoded
        let precisionRecallTradeoffDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .precisionRecallTradeoff)
        precisionRecallTradeoff = precisionRecallTradeoffDecoded
        let accuracyCostTradeoffDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .accuracyCostTradeoff)
        accuracyCostTradeoff = accuracyCostTradeoffDecoded
        let enforceProvidedLabelsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enforceProvidedLabels)
        enforceProvidedLabels = enforceProvidedLabelsDecoded
    }
}

extension FindMatchesParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindMatchesParameters(accuracyCostTradeoff: \(String(describing: accuracyCostTradeoff)), enforceProvidedLabels: \(String(describing: enforceProvidedLabels)), precisionRecallTradeoff: \(String(describing: precisionRecallTradeoff)), primaryKeyColumnName: \(String(describing: primaryKeyColumnName)))"}
}

/// <p>The parameters to configure the find matches transform.</p>
public struct FindMatchesParameters: Equatable {
    /// <p>The value that is selected when tuning your transform for a balance between accuracy and
    ///       cost. A value of 0.5 means that the system balances accuracy and cost concerns. A value of 1.0
    ///       means a bias purely for accuracy, which typically results in a higher cost, sometimes
    ///       substantially higher. A value of 0.0 means a bias purely for cost, which results in a less
    ///       accurate <code>FindMatches</code> transform, sometimes with unacceptable accuracy.</p>
    /// 	
    /// 	        <p>Accuracy measures how well the transform finds true positives and true negatives. Increasing accuracy requires more machine resources and cost. But it also results in increased recall. </p>
    /// 	
    /// 	        <p>Cost measures how many compute resources, and thus money, are consumed to run the
    ///       transform.</p>
    public let accuracyCostTradeoff: Double?
    /// <p>The value to switch on or off to force the output to match the provided labels from users. If the value is <code>True</code>, the <code>find matches</code> transform forces the output to match the provided labels. The results override the normal conflation results. If the value is <code>False</code>, the <code>find matches</code> transform does not ensure all the labels provided are respected, and the results rely on the trained model.</p>
    ///          <p>Note that setting this value to true may increase the conflation execution time.</p>
    public let enforceProvidedLabels: Bool?
    /// <p>The value selected when tuning your transform for a balance between precision and recall.
    ///       A value of 0.5 means no preference; a value of 1.0 means a bias purely for precision, and a
    ///       value of 0.0 means a bias for recall. Because this is a tradeoff, choosing values close to 1.0
    ///       means very low recall, and choosing values close to 0.0 results in very low precision.</p>
    /// 	
    /// 	        <p>The precision metric indicates how often your model is correct when it predicts a match. </p>
    /// 	
    /// 	        <p>The recall metric indicates that for an actual match, how often your model predicts the
    ///       match.</p>
    public let precisionRecallTradeoff: Double?
    /// <p>The name of a column that uniquely identifies rows in the source table. Used to help identify matching records.</p>
    public let primaryKeyColumnName: String?

    public init (
        accuracyCostTradeoff: Double? = nil,
        enforceProvidedLabels: Bool? = nil,
        precisionRecallTradeoff: Double? = nil,
        primaryKeyColumnName: String? = nil
    )
    {
        self.accuracyCostTradeoff = accuracyCostTradeoff
        self.enforceProvidedLabels = enforceProvidedLabels
        self.precisionRecallTradeoff = precisionRecallTradeoff
        self.primaryKeyColumnName = primaryKeyColumnName
    }
}

extension FindMatchesTaskRunProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case jobName = "JobName"
        case jobRunId = "JobRunId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobRunId = jobRunId {
            try encodeContainer.encode(jobRunId, forKey: .jobRunId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobRunId)
        jobRunId = jobRunIdDecoded
    }
}

extension FindMatchesTaskRunProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindMatchesTaskRunProperties(jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobRunId: \(String(describing: jobRunId)))"}
}

/// <p>Specifies configuration properties for a Find Matches task run.</p>
public struct FindMatchesTaskRunProperties: Equatable {
    /// <p>The job ID for the Find Matches task run.</p>
    public let jobId: String?
    /// <p>The name assigned to the job for the Find Matches task run.</p>
    public let jobName: String?
    /// <p>The job run ID for the Find Matches task run.</p>
    public let jobRunId: String?

    public init (
        jobId: String? = nil,
        jobName: String? = nil,
        jobRunId: String? = nil
    )
    {
        self.jobId = jobId
        self.jobName = jobName
        self.jobRunId = jobRunId
    }
}

public struct GetCatalogImportStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetCatalogImportStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCatalogImportStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCatalogImportStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCatalogImportStatusInput>
    public typealias MOutput = OperationOutput<GetCatalogImportStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCatalogImportStatusOutputError>
}

extension GetCatalogImportStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCatalogImportStatusInput(catalogId: \(String(describing: catalogId)))"}
}

extension GetCatalogImportStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
    }
}

public struct GetCatalogImportStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetCatalogImportStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCatalogImportStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCatalogImportStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCatalogImportStatusInput>
    public typealias MOutput = OperationOutput<GetCatalogImportStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCatalogImportStatusOutputError>
}

public struct GetCatalogImportStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCatalogImportStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCatalogImportStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCatalogImportStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCatalogImportStatusInput>
    public typealias MOutput = OperationOutput<GetCatalogImportStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCatalogImportStatusOutputError>
}

public struct GetCatalogImportStatusInput: Equatable {
    /// <p>The ID of the catalog to migrate. Currently, this should be the AWS account ID.</p>
    public let catalogId: String?

    public init (
        catalogId: String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

struct GetCatalogImportStatusInputBody: Equatable {
    public let catalogId: String?
}

extension GetCatalogImportStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension GetCatalogImportStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCatalogImportStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCatalogImportStatusOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCatalogImportStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCatalogImportStatusOutputResponse(importStatus: \(String(describing: importStatus)))"}
}

extension GetCatalogImportStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCatalogImportStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.importStatus = output.importStatus
        } else {
            self.importStatus = nil
        }
    }
}

public struct GetCatalogImportStatusOutputResponse: Equatable {
    /// <p>The status of the specified catalog migration.</p>
    public let importStatus: CatalogImportStatus?

    public init (
        importStatus: CatalogImportStatus? = nil
    )
    {
        self.importStatus = importStatus
    }
}

struct GetCatalogImportStatusOutputResponseBody: Equatable {
    public let importStatus: CatalogImportStatus?
}

extension GetCatalogImportStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importStatus = "ImportStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importStatusDecoded = try containerValues.decodeIfPresent(CatalogImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
    }
}

public struct GetClassifierInputBodyMiddleware: Middleware {
    public let id: String = "GetClassifierInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClassifierInput>
    public typealias MOutput = OperationOutput<GetClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClassifierOutputError>
}

extension GetClassifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClassifierInput(name: \(String(describing: name)))"}
}

extension GetClassifierInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetClassifierInputHeadersMiddleware: Middleware {
    public let id: String = "GetClassifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClassifierInput>
    public typealias MOutput = OperationOutput<GetClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClassifierOutputError>
}

public struct GetClassifierInputQueryItemMiddleware: Middleware {
    public let id: String = "GetClassifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClassifierInput>
    public typealias MOutput = OperationOutput<GetClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClassifierOutputError>
}

public struct GetClassifierInput: Equatable {
    /// <p>Name of the classifier to retrieve.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetClassifierInputBody: Equatable {
    public let name: String?
}

extension GetClassifierInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetClassifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetClassifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetClassifierOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetClassifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClassifierOutputResponse(classifier: \(String(describing: classifier)))"}
}

extension GetClassifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetClassifierOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.classifier = output.classifier
        } else {
            self.classifier = nil
        }
    }
}

public struct GetClassifierOutputResponse: Equatable {
    /// <p>The requested classifier.</p>
    public let classifier: Classifier?

    public init (
        classifier: Classifier? = nil
    )
    {
        self.classifier = classifier
    }
}

struct GetClassifierOutputResponseBody: Equatable {
    public let classifier: Classifier?
}

extension GetClassifierOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case classifier = "Classifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classifierDecoded = try containerValues.decodeIfPresent(Classifier.self, forKey: .classifier)
        classifier = classifierDecoded
    }
}

public struct GetClassifiersInputBodyMiddleware: Middleware {
    public let id: String = "GetClassifiersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClassifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClassifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClassifiersInput>
    public typealias MOutput = OperationOutput<GetClassifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClassifiersOutputError>
}

extension GetClassifiersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClassifiersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetClassifiersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetClassifiersInputHeadersMiddleware: Middleware {
    public let id: String = "GetClassifiersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClassifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClassifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClassifiersInput>
    public typealias MOutput = OperationOutput<GetClassifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClassifiersOutputError>
}

public struct GetClassifiersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetClassifiersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClassifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClassifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClassifiersInput>
    public typealias MOutput = OperationOutput<GetClassifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClassifiersOutputError>
}

public struct GetClassifiersInput: Equatable {
    /// <p>The size of the list to return (optional).</p>
    public let maxResults: Int?
    /// <p>An optional continuation token.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetClassifiersInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetClassifiersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetClassifiersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetClassifiersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetClassifiersOutputError: Equatable {
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetClassifiersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClassifiersOutputResponse(classifiers: \(String(describing: classifiers)), nextToken: \(String(describing: nextToken)))"}
}

extension GetClassifiersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetClassifiersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.classifiers = output.classifiers
            self.nextToken = output.nextToken
        } else {
            self.classifiers = nil
            self.nextToken = nil
        }
    }
}

public struct GetClassifiersOutputResponse: Equatable {
    /// <p>The requested list of classifier
    ///       objects.</p>
    public let classifiers: [Classifier]?
    /// <p>A continuation token.</p>
    public let nextToken: String?

    public init (
        classifiers: [Classifier]? = nil,
        nextToken: String? = nil
    )
    {
        self.classifiers = classifiers
        self.nextToken = nextToken
    }
}

struct GetClassifiersOutputResponseBody: Equatable {
    public let classifiers: [Classifier]?
    public let nextToken: String?
}

extension GetClassifiersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case classifiers = "Classifiers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classifiersContainer = try containerValues.decodeIfPresent([Classifier?].self, forKey: .classifiers)
        var classifiersDecoded0:[Classifier]? = nil
        if let classifiersContainer = classifiersContainer {
            classifiersDecoded0 = [Classifier]()
            for structure0 in classifiersContainer {
                if let structure0 = structure0 {
                    classifiersDecoded0?.append(structure0)
                }
            }
        }
        classifiers = classifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetColumnStatisticsForPartitionInputBodyMiddleware: Middleware {
    public let id: String = "GetColumnStatisticsForPartitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetColumnStatisticsForPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetColumnStatisticsForPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetColumnStatisticsForPartitionInput>
    public typealias MOutput = OperationOutput<GetColumnStatisticsForPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetColumnStatisticsForPartitionOutputError>
}

extension GetColumnStatisticsForPartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetColumnStatisticsForPartitionInput(catalogId: \(String(describing: catalogId)), columnNames: \(String(describing: columnNames)), databaseName: \(String(describing: databaseName)), partitionValues: \(String(describing: partitionValues)), tableName: \(String(describing: tableName)))"}
}

extension GetColumnStatisticsForPartitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnNames = "ColumnNames"
        case databaseName = "DatabaseName"
        case partitionValues = "PartitionValues"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let columnNames = columnNames {
            var columnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnNames)
            for getcolumnnameslist0 in columnNames {
                try columnNamesContainer.encode(getcolumnnameslist0)
            }
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionValues = partitionValues {
            var partitionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValues)
            for valuestringlist0 in partitionValues {
                try partitionValuesContainer.encode(valuestringlist0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct GetColumnStatisticsForPartitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetColumnStatisticsForPartitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetColumnStatisticsForPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetColumnStatisticsForPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetColumnStatisticsForPartitionInput>
    public typealias MOutput = OperationOutput<GetColumnStatisticsForPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetColumnStatisticsForPartitionOutputError>
}

public struct GetColumnStatisticsForPartitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetColumnStatisticsForPartitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetColumnStatisticsForPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetColumnStatisticsForPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetColumnStatisticsForPartitionInput>
    public typealias MOutput = OperationOutput<GetColumnStatisticsForPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetColumnStatisticsForPartitionOutputError>
}

public struct GetColumnStatisticsForPartitionInput: Equatable {
    /// <p>The ID of the Data Catalog where the partitions in question reside.
    ///       If none is supplied, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>A list of the column names.</p>
    public let columnNames: [String]?
    /// <p>The name of the catalog database where the partitions reside.</p>
    public let databaseName: String?
    /// <p>A list of partition values identifying the partition.</p>
    public let partitionValues: [String]?
    /// <p>The name of the partitions' table.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        columnNames: [String]? = nil,
        databaseName: String? = nil,
        partitionValues: [String]? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnNames = columnNames
        self.databaseName = databaseName
        self.partitionValues = partitionValues
        self.tableName = tableName
    }
}

struct GetColumnStatisticsForPartitionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let partitionValues: [String]?
    public let columnNames: [String]?
}

extension GetColumnStatisticsForPartitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnNames = "ColumnNames"
        case databaseName = "DatabaseName"
        case partitionValues = "PartitionValues"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let partitionValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionValues)
        var partitionValuesDecoded0:[String]? = nil
        if let partitionValuesContainer = partitionValuesContainer {
            partitionValuesDecoded0 = [String]()
            for string0 in partitionValuesContainer {
                if let string0 = string0 {
                    partitionValuesDecoded0?.append(string0)
                }
            }
        }
        partitionValues = partitionValuesDecoded0
        let columnNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .columnNames)
        var columnNamesDecoded0:[String]? = nil
        if let columnNamesContainer = columnNamesContainer {
            columnNamesDecoded0 = [String]()
            for string0 in columnNamesContainer {
                if let string0 = string0 {
                    columnNamesDecoded0?.append(string0)
                }
            }
        }
        columnNames = columnNamesDecoded0
    }
}

extension GetColumnStatisticsForPartitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetColumnStatisticsForPartitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetColumnStatisticsForPartitionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetColumnStatisticsForPartitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetColumnStatisticsForPartitionOutputResponse(columnStatisticsList: \(String(describing: columnStatisticsList)), errors: \(String(describing: errors)))"}
}

extension GetColumnStatisticsForPartitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetColumnStatisticsForPartitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.columnStatisticsList = output.columnStatisticsList
            self.errors = output.errors
        } else {
            self.columnStatisticsList = nil
            self.errors = nil
        }
    }
}

public struct GetColumnStatisticsForPartitionOutputResponse: Equatable {
    /// <p>List of ColumnStatistics that failed to be retrieved.</p>
    public let columnStatisticsList: [ColumnStatistics]?
    /// <p>Error occurred during retrieving column statistics data.</p>
    public let errors: [ColumnError]?

    public init (
        columnStatisticsList: [ColumnStatistics]? = nil,
        errors: [ColumnError]? = nil
    )
    {
        self.columnStatisticsList = columnStatisticsList
        self.errors = errors
    }
}

struct GetColumnStatisticsForPartitionOutputResponseBody: Equatable {
    public let columnStatisticsList: [ColumnStatistics]?
    public let errors: [ColumnError]?
}

extension GetColumnStatisticsForPartitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case columnStatisticsList = "ColumnStatisticsList"
        case errors = "Errors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnStatisticsListContainer = try containerValues.decodeIfPresent([ColumnStatistics?].self, forKey: .columnStatisticsList)
        var columnStatisticsListDecoded0:[ColumnStatistics]? = nil
        if let columnStatisticsListContainer = columnStatisticsListContainer {
            columnStatisticsListDecoded0 = [ColumnStatistics]()
            for structure0 in columnStatisticsListContainer {
                if let structure0 = structure0 {
                    columnStatisticsListDecoded0?.append(structure0)
                }
            }
        }
        columnStatisticsList = columnStatisticsListDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ColumnError?].self, forKey: .errors)
        var errorsDecoded0:[ColumnError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ColumnError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct GetColumnStatisticsForTableInputBodyMiddleware: Middleware {
    public let id: String = "GetColumnStatisticsForTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetColumnStatisticsForTableInput>,
                  next: H) -> Swift.Result<OperationOutput<GetColumnStatisticsForTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetColumnStatisticsForTableInput>
    public typealias MOutput = OperationOutput<GetColumnStatisticsForTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetColumnStatisticsForTableOutputError>
}

extension GetColumnStatisticsForTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetColumnStatisticsForTableInput(catalogId: \(String(describing: catalogId)), columnNames: \(String(describing: columnNames)), databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)))"}
}

extension GetColumnStatisticsForTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnNames = "ColumnNames"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let columnNames = columnNames {
            var columnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnNames)
            for getcolumnnameslist0 in columnNames {
                try columnNamesContainer.encode(getcolumnnameslist0)
            }
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct GetColumnStatisticsForTableInputHeadersMiddleware: Middleware {
    public let id: String = "GetColumnStatisticsForTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetColumnStatisticsForTableInput>,
                  next: H) -> Swift.Result<OperationOutput<GetColumnStatisticsForTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetColumnStatisticsForTableInput>
    public typealias MOutput = OperationOutput<GetColumnStatisticsForTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetColumnStatisticsForTableOutputError>
}

public struct GetColumnStatisticsForTableInputQueryItemMiddleware: Middleware {
    public let id: String = "GetColumnStatisticsForTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetColumnStatisticsForTableInput>,
                  next: H) -> Swift.Result<OperationOutput<GetColumnStatisticsForTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetColumnStatisticsForTableInput>
    public typealias MOutput = OperationOutput<GetColumnStatisticsForTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetColumnStatisticsForTableOutputError>
}

public struct GetColumnStatisticsForTableInput: Equatable {
    /// <p>The ID of the Data Catalog where the partitions in question reside.
    ///       If none is supplied, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>A list of the column names.</p>
    public let columnNames: [String]?
    /// <p>The name of the catalog database where the partitions reside.</p>
    public let databaseName: String?
    /// <p>The name of the partitions' table.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        columnNames: [String]? = nil,
        databaseName: String? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnNames = columnNames
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct GetColumnStatisticsForTableInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let columnNames: [String]?
}

extension GetColumnStatisticsForTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnNames = "ColumnNames"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let columnNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .columnNames)
        var columnNamesDecoded0:[String]? = nil
        if let columnNamesContainer = columnNamesContainer {
            columnNamesDecoded0 = [String]()
            for string0 in columnNamesContainer {
                if let string0 = string0 {
                    columnNamesDecoded0?.append(string0)
                }
            }
        }
        columnNames = columnNamesDecoded0
    }
}

extension GetColumnStatisticsForTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetColumnStatisticsForTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetColumnStatisticsForTableOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetColumnStatisticsForTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetColumnStatisticsForTableOutputResponse(columnStatisticsList: \(String(describing: columnStatisticsList)), errors: \(String(describing: errors)))"}
}

extension GetColumnStatisticsForTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetColumnStatisticsForTableOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.columnStatisticsList = output.columnStatisticsList
            self.errors = output.errors
        } else {
            self.columnStatisticsList = nil
            self.errors = nil
        }
    }
}

public struct GetColumnStatisticsForTableOutputResponse: Equatable {
    /// <p>List of ColumnStatistics that failed to be retrieved.</p>
    public let columnStatisticsList: [ColumnStatistics]?
    /// <p>List of ColumnStatistics that failed to be retrieved.</p>
    public let errors: [ColumnError]?

    public init (
        columnStatisticsList: [ColumnStatistics]? = nil,
        errors: [ColumnError]? = nil
    )
    {
        self.columnStatisticsList = columnStatisticsList
        self.errors = errors
    }
}

struct GetColumnStatisticsForTableOutputResponseBody: Equatable {
    public let columnStatisticsList: [ColumnStatistics]?
    public let errors: [ColumnError]?
}

extension GetColumnStatisticsForTableOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case columnStatisticsList = "ColumnStatisticsList"
        case errors = "Errors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnStatisticsListContainer = try containerValues.decodeIfPresent([ColumnStatistics?].self, forKey: .columnStatisticsList)
        var columnStatisticsListDecoded0:[ColumnStatistics]? = nil
        if let columnStatisticsListContainer = columnStatisticsListContainer {
            columnStatisticsListDecoded0 = [ColumnStatistics]()
            for structure0 in columnStatisticsListContainer {
                if let structure0 = structure0 {
                    columnStatisticsListDecoded0?.append(structure0)
                }
            }
        }
        columnStatisticsList = columnStatisticsListDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ColumnError?].self, forKey: .errors)
        var errorsDecoded0:[ColumnError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ColumnError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct GetConnectionInputBodyMiddleware: Middleware {
    public let id: String = "GetConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionInput>
    public typealias MOutput = OperationOutput<GetConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionOutputError>
}

extension GetConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectionInput(catalogId: \(String(describing: catalogId)), hidePassword: \(String(describing: hidePassword)), name: \(String(describing: name)))"}
}

extension GetConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case hidePassword = "HidePassword"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if hidePassword != false {
            try encodeContainer.encode(hidePassword, forKey: .hidePassword)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "GetConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionInput>
    public typealias MOutput = OperationOutput<GetConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionOutputError>
}

public struct GetConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionInput>
    public typealias MOutput = OperationOutput<GetConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionOutputError>
}

public struct GetConnectionInput: Equatable {
    /// <p>The ID of the Data Catalog in which the connection resides. If none is provided, the AWS
    ///       account ID is used by default.</p>
    public let catalogId: String?
    /// <p>Allows you to retrieve the connection metadata without returning the password. For
    ///       instance, the AWS Glue console uses this flag to retrieve the connection, and does not display
    ///       the password. Set this parameter when the caller might not have permission to use the AWS KMS
    ///       key to decrypt the password, but it does have permission to access the rest of the connection
    ///       properties.</p>
    public let hidePassword: Bool
    /// <p>The name of the connection definition to retrieve.</p>
    public let name: String?

    public init (
        catalogId: String? = nil,
        hidePassword: Bool = false,
        name: String? = nil
    )
    {
        self.catalogId = catalogId
        self.hidePassword = hidePassword
        self.name = name
    }
}

struct GetConnectionInputBody: Equatable {
    public let catalogId: String?
    public let name: String?
    public let hidePassword: Bool
}

extension GetConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case hidePassword = "HidePassword"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let hidePasswordDecoded = try containerValues.decode(Bool.self, forKey: .hidePassword)
        hidePassword = hidePasswordDecoded
    }
}

extension GetConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectionOutputResponse(connection: \(String(describing: connection)))"}
}

extension GetConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct GetConnectionOutputResponse: Equatable {
    /// <p>The requested connection definition.</p>
    public let connection: Connection?

    public init (
        connection: Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct GetConnectionOutputResponseBody: Equatable {
    public let connection: Connection?
}

extension GetConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension GetConnectionsFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionType = "ConnectionType"
        case matchCriteria = "MatchCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let matchCriteria = matchCriteria {
            var matchCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchCriteria)
            for matchcriteria0 in matchCriteria {
                try matchCriteriaContainer.encode(matchcriteria0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchCriteriaContainer = try containerValues.decodeIfPresent([String?].self, forKey: .matchCriteria)
        var matchCriteriaDecoded0:[String]? = nil
        if let matchCriteriaContainer = matchCriteriaContainer {
            matchCriteriaDecoded0 = [String]()
            for string0 in matchCriteriaContainer {
                if let string0 = string0 {
                    matchCriteriaDecoded0?.append(string0)
                }
            }
        }
        matchCriteria = matchCriteriaDecoded0
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
    }
}

extension GetConnectionsFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectionsFilter(connectionType: \(String(describing: connectionType)), matchCriteria: \(String(describing: matchCriteria)))"}
}

/// <p>Filters the connection definitions that are returned by the <code>GetConnections</code>
///       API operation.</p>
public struct GetConnectionsFilter: Equatable {
    /// <p>The type of connections to return. Currently, SFTP is not supported.</p>
    public let connectionType: ConnectionType?
    /// <p>A criteria string that must match the criteria recorded in the
    ///        connection definition for that connection definition to be returned.</p>
    public let matchCriteria: [String]?

    public init (
        connectionType: ConnectionType? = nil,
        matchCriteria: [String]? = nil
    )
    {
        self.connectionType = connectionType
        self.matchCriteria = matchCriteria
    }
}

public struct GetConnectionsInputBodyMiddleware: Middleware {
    public let id: String = "GetConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionsInput>
    public typealias MOutput = OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionsOutputError>
}

extension GetConnectionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectionsInput(catalogId: \(String(describing: catalogId)), filter: \(String(describing: filter)), hidePassword: \(String(describing: hidePassword)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetConnectionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case filter = "Filter"
        case hidePassword = "HidePassword"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if hidePassword != false {
            try encodeContainer.encode(hidePassword, forKey: .hidePassword)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetConnectionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionsInput>
    public typealias MOutput = OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionsInput>
    public typealias MOutput = OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInput: Equatable {
    /// <p>The ID of the Data Catalog in which the connections reside. If none is provided, the AWS
    ///       account ID is used by default.</p>
    public let catalogId: String?
    /// <p>A filter that controls which connections are returned.</p>
    public let filter: GetConnectionsFilter?
    /// <p>Allows you to retrieve the connection metadata without returning the password. For
    ///       instance, the AWS Glue console uses this flag to retrieve the connection, and does not display
    ///       the password. Set this parameter when the caller might not have permission to use the AWS KMS
    ///       key to decrypt the password, but it does have permission to access the rest of the connection
    ///       properties.</p>
    public let hidePassword: Bool
    /// <p>The maximum number of connections to return in one response.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?

    public init (
        catalogId: String? = nil,
        filter: GetConnectionsFilter? = nil,
        hidePassword: Bool = false,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.catalogId = catalogId
        self.filter = filter
        self.hidePassword = hidePassword
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetConnectionsInputBody: Equatable {
    public let catalogId: String?
    public let filter: GetConnectionsFilter?
    public let hidePassword: Bool
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetConnectionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case filter = "Filter"
        case hidePassword = "HidePassword"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let filterDecoded = try containerValues.decodeIfPresent(GetConnectionsFilter.self, forKey: .filter)
        filter = filterDecoded
        let hidePasswordDecoded = try containerValues.decode(Bool.self, forKey: .hidePassword)
        hidePassword = hidePasswordDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetConnectionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectionsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectionsOutputResponse(connectionList: \(String(describing: connectionList)), nextToken: \(String(describing: nextToken)))"}
}

extension GetConnectionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectionList = output.connectionList
            self.nextToken = output.nextToken
        } else {
            self.connectionList = nil
            self.nextToken = nil
        }
    }
}

public struct GetConnectionsOutputResponse: Equatable {
    /// <p>A list of requested connection definitions.</p>
    public let connectionList: [Connection]?
    /// <p>A continuation token, if the list of connections returned does not
    ///       include the last of the filtered connections.</p>
    public let nextToken: String?

    public init (
        connectionList: [Connection]? = nil,
        nextToken: String? = nil
    )
    {
        self.connectionList = connectionList
        self.nextToken = nextToken
    }
}

struct GetConnectionsOutputResponseBody: Equatable {
    public let connectionList: [Connection]?
    public let nextToken: String?
}

extension GetConnectionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionList = "ConnectionList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionListContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connectionList)
        var connectionListDecoded0:[Connection]? = nil
        if let connectionListContainer = connectionListContainer {
            connectionListDecoded0 = [Connection]()
            for structure0 in connectionListContainer {
                if let structure0 = structure0 {
                    connectionListDecoded0?.append(structure0)
                }
            }
        }
        connectionList = connectionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetCrawlerInputBodyMiddleware: Middleware {
    public let id: String = "GetCrawlerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCrawlerInput>
    public typealias MOutput = OperationOutput<GetCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCrawlerOutputError>
}

extension GetCrawlerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCrawlerInput(name: \(String(describing: name)))"}
}

extension GetCrawlerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetCrawlerInputHeadersMiddleware: Middleware {
    public let id: String = "GetCrawlerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCrawlerInput>
    public typealias MOutput = OperationOutput<GetCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCrawlerOutputError>
}

public struct GetCrawlerInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCrawlerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCrawlerInput>
    public typealias MOutput = OperationOutput<GetCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCrawlerOutputError>
}

public struct GetCrawlerInput: Equatable {
    /// <p>The name of the crawler to retrieve metadata for.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetCrawlerInputBody: Equatable {
    public let name: String?
}

extension GetCrawlerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct GetCrawlerMetricsInputBodyMiddleware: Middleware {
    public let id: String = "GetCrawlerMetricsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCrawlerMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCrawlerMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCrawlerMetricsInput>
    public typealias MOutput = OperationOutput<GetCrawlerMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCrawlerMetricsOutputError>
}

extension GetCrawlerMetricsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCrawlerMetricsInput(crawlerNameList: \(String(describing: crawlerNameList)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCrawlerMetricsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlerNameList = "CrawlerNameList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawlerNameList = crawlerNameList {
            var crawlerNameListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crawlerNameList)
            for crawlernamelist0 in crawlerNameList {
                try crawlerNameListContainer.encode(crawlernamelist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetCrawlerMetricsInputHeadersMiddleware: Middleware {
    public let id: String = "GetCrawlerMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCrawlerMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCrawlerMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCrawlerMetricsInput>
    public typealias MOutput = OperationOutput<GetCrawlerMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCrawlerMetricsOutputError>
}

public struct GetCrawlerMetricsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCrawlerMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCrawlerMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCrawlerMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCrawlerMetricsInput>
    public typealias MOutput = OperationOutput<GetCrawlerMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCrawlerMetricsOutputError>
}

public struct GetCrawlerMetricsInput: Equatable {
    /// <p>A list of the names of crawlers about which to retrieve metrics.</p>
    public let crawlerNameList: [String]?
    /// <p>The maximum size of a list to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?

    public init (
        crawlerNameList: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.crawlerNameList = crawlerNameList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCrawlerMetricsInputBody: Equatable {
    public let crawlerNameList: [String]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetCrawlerMetricsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case crawlerNameList = "CrawlerNameList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerNameListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .crawlerNameList)
        var crawlerNameListDecoded0:[String]? = nil
        if let crawlerNameListContainer = crawlerNameListContainer {
            crawlerNameListDecoded0 = [String]()
            for string0 in crawlerNameListContainer {
                if let string0 = string0 {
                    crawlerNameListDecoded0?.append(string0)
                }
            }
        }
        crawlerNameList = crawlerNameListDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCrawlerMetricsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCrawlerMetricsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCrawlerMetricsOutputError: Equatable {
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCrawlerMetricsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCrawlerMetricsOutputResponse(crawlerMetricsList: \(String(describing: crawlerMetricsList)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCrawlerMetricsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCrawlerMetricsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.crawlerMetricsList = output.crawlerMetricsList
            self.nextToken = output.nextToken
        } else {
            self.crawlerMetricsList = nil
            self.nextToken = nil
        }
    }
}

public struct GetCrawlerMetricsOutputResponse: Equatable {
    /// <p>A list of metrics for the specified crawler.</p>
    public let crawlerMetricsList: [CrawlerMetrics]?
    /// <p>A continuation token, if the returned list does not contain the
    ///       last metric available.</p>
    public let nextToken: String?

    public init (
        crawlerMetricsList: [CrawlerMetrics]? = nil,
        nextToken: String? = nil
    )
    {
        self.crawlerMetricsList = crawlerMetricsList
        self.nextToken = nextToken
    }
}

struct GetCrawlerMetricsOutputResponseBody: Equatable {
    public let crawlerMetricsList: [CrawlerMetrics]?
    public let nextToken: String?
}

extension GetCrawlerMetricsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case crawlerMetricsList = "CrawlerMetricsList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerMetricsListContainer = try containerValues.decodeIfPresent([CrawlerMetrics?].self, forKey: .crawlerMetricsList)
        var crawlerMetricsListDecoded0:[CrawlerMetrics]? = nil
        if let crawlerMetricsListContainer = crawlerMetricsListContainer {
            crawlerMetricsListDecoded0 = [CrawlerMetrics]()
            for structure0 in crawlerMetricsListContainer {
                if let structure0 = structure0 {
                    crawlerMetricsListDecoded0?.append(structure0)
                }
            }
        }
        crawlerMetricsList = crawlerMetricsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCrawlerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCrawlerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCrawlerOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCrawlerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCrawlerOutputResponse(crawler: \(String(describing: crawler)))"}
}

extension GetCrawlerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCrawlerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.crawler = output.crawler
        } else {
            self.crawler = nil
        }
    }
}

public struct GetCrawlerOutputResponse: Equatable {
    /// <p>The metadata for the specified crawler.</p>
    public let crawler: Crawler?

    public init (
        crawler: Crawler? = nil
    )
    {
        self.crawler = crawler
    }
}

struct GetCrawlerOutputResponseBody: Equatable {
    public let crawler: Crawler?
}

extension GetCrawlerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case crawler = "Crawler"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerDecoded = try containerValues.decodeIfPresent(Crawler.self, forKey: .crawler)
        crawler = crawlerDecoded
    }
}

public struct GetCrawlersInputBodyMiddleware: Middleware {
    public let id: String = "GetCrawlersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCrawlersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCrawlersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCrawlersInput>
    public typealias MOutput = OperationOutput<GetCrawlersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCrawlersOutputError>
}

extension GetCrawlersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCrawlersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCrawlersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetCrawlersInputHeadersMiddleware: Middleware {
    public let id: String = "GetCrawlersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCrawlersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCrawlersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCrawlersInput>
    public typealias MOutput = OperationOutput<GetCrawlersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCrawlersOutputError>
}

public struct GetCrawlersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCrawlersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCrawlersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCrawlersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCrawlersInput>
    public typealias MOutput = OperationOutput<GetCrawlersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCrawlersOutputError>
}

public struct GetCrawlersInput: Equatable {
    /// <p>The number of crawlers to return on each call.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCrawlersInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetCrawlersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCrawlersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCrawlersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCrawlersOutputError: Equatable {
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCrawlersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCrawlersOutputResponse(crawlers: \(String(describing: crawlers)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCrawlersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCrawlersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.crawlers = output.crawlers
            self.nextToken = output.nextToken
        } else {
            self.crawlers = nil
            self.nextToken = nil
        }
    }
}

public struct GetCrawlersOutputResponse: Equatable {
    /// <p>A list of crawler metadata.</p>
    public let crawlers: [Crawler]?
    /// <p>A continuation token, if the returned list has not reached the end
    ///       of those defined in this customer account.</p>
    public let nextToken: String?

    public init (
        crawlers: [Crawler]? = nil,
        nextToken: String? = nil
    )
    {
        self.crawlers = crawlers
        self.nextToken = nextToken
    }
}

struct GetCrawlersOutputResponseBody: Equatable {
    public let crawlers: [Crawler]?
    public let nextToken: String?
}

extension GetCrawlersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case crawlers = "Crawlers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlersContainer = try containerValues.decodeIfPresent([Crawler?].self, forKey: .crawlers)
        var crawlersDecoded0:[Crawler]? = nil
        if let crawlersContainer = crawlersContainer {
            crawlersDecoded0 = [Crawler]()
            for structure0 in crawlersContainer {
                if let structure0 = structure0 {
                    crawlersDecoded0?.append(structure0)
                }
            }
        }
        crawlers = crawlersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetDataCatalogEncryptionSettingsInputBodyMiddleware: Middleware {
    public let id: String = "GetDataCatalogEncryptionSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataCatalogEncryptionSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataCatalogEncryptionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataCatalogEncryptionSettingsInput>
    public typealias MOutput = OperationOutput<GetDataCatalogEncryptionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataCatalogEncryptionSettingsOutputError>
}

extension GetDataCatalogEncryptionSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataCatalogEncryptionSettingsInput(catalogId: \(String(describing: catalogId)))"}
}

extension GetDataCatalogEncryptionSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
    }
}

public struct GetDataCatalogEncryptionSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDataCatalogEncryptionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataCatalogEncryptionSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataCatalogEncryptionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataCatalogEncryptionSettingsInput>
    public typealias MOutput = OperationOutput<GetDataCatalogEncryptionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataCatalogEncryptionSettingsOutputError>
}

public struct GetDataCatalogEncryptionSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDataCatalogEncryptionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataCatalogEncryptionSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataCatalogEncryptionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataCatalogEncryptionSettingsInput>
    public typealias MOutput = OperationOutput<GetDataCatalogEncryptionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataCatalogEncryptionSettingsOutputError>
}

public struct GetDataCatalogEncryptionSettingsInput: Equatable {
    /// <p>The ID of the Data Catalog to retrieve the security configuration for. If none is
    ///       provided, the AWS account ID is used by default.</p>
    public let catalogId: String?

    public init (
        catalogId: String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

struct GetDataCatalogEncryptionSettingsInputBody: Equatable {
    public let catalogId: String?
}

extension GetDataCatalogEncryptionSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension GetDataCatalogEncryptionSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataCatalogEncryptionSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataCatalogEncryptionSettingsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataCatalogEncryptionSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataCatalogEncryptionSettingsOutputResponse(dataCatalogEncryptionSettings: \(String(describing: dataCatalogEncryptionSettings)))"}
}

extension GetDataCatalogEncryptionSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDataCatalogEncryptionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataCatalogEncryptionSettings = output.dataCatalogEncryptionSettings
        } else {
            self.dataCatalogEncryptionSettings = nil
        }
    }
}

public struct GetDataCatalogEncryptionSettingsOutputResponse: Equatable {
    /// <p>The requested security configuration.</p>
    public let dataCatalogEncryptionSettings: DataCatalogEncryptionSettings?

    public init (
        dataCatalogEncryptionSettings: DataCatalogEncryptionSettings? = nil
    )
    {
        self.dataCatalogEncryptionSettings = dataCatalogEncryptionSettings
    }
}

struct GetDataCatalogEncryptionSettingsOutputResponseBody: Equatable {
    public let dataCatalogEncryptionSettings: DataCatalogEncryptionSettings?
}

extension GetDataCatalogEncryptionSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataCatalogEncryptionSettings = "DataCatalogEncryptionSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataCatalogEncryptionSettingsDecoded = try containerValues.decodeIfPresent(DataCatalogEncryptionSettings.self, forKey: .dataCatalogEncryptionSettings)
        dataCatalogEncryptionSettings = dataCatalogEncryptionSettingsDecoded
    }
}

public struct GetDatabaseInputBodyMiddleware: Middleware {
    public let id: String = "GetDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDatabaseInput>
    public typealias MOutput = OperationOutput<GetDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDatabaseOutputError>
}

extension GetDatabaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDatabaseInput(catalogId: \(String(describing: catalogId)), name: \(String(describing: name)))"}
}

extension GetDatabaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetDatabaseInputHeadersMiddleware: Middleware {
    public let id: String = "GetDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDatabaseInput>
    public typealias MOutput = OperationOutput<GetDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDatabaseOutputError>
}

public struct GetDatabaseInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDatabaseInput>
    public typealias MOutput = OperationOutput<GetDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDatabaseOutputError>
}

public struct GetDatabaseInput: Equatable {
    /// <p>The ID of the Data Catalog in which the database resides. If none is provided, the AWS
    ///       account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the database to retrieve. For Hive compatibility, this
    ///       should be all lowercase.</p>
    public let name: String?

    public init (
        catalogId: String? = nil,
        name: String? = nil
    )
    {
        self.catalogId = catalogId
        self.name = name
    }
}

struct GetDatabaseInputBody: Equatable {
    public let catalogId: String?
    public let name: String?
}

extension GetDatabaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetDatabaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatabaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDatabaseOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatabaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDatabaseOutputResponse(database: \(String(describing: database)))"}
}

extension GetDatabaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct GetDatabaseOutputResponse: Equatable {
    /// <p>The definition of the specified database in the Data Catalog.</p>
    public let database: Database?

    public init (
        database: Database? = nil
    )
    {
        self.database = database
    }
}

struct GetDatabaseOutputResponseBody: Equatable {
    public let database: Database?
}

extension GetDatabaseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(Database.self, forKey: .database)
        database = databaseDecoded
    }
}

public struct GetDatabasesInputBodyMiddleware: Middleware {
    public let id: String = "GetDatabasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDatabasesInput>
    public typealias MOutput = OperationOutput<GetDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDatabasesOutputError>
}

extension GetDatabasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDatabasesInput(catalogId: \(String(describing: catalogId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceShareType: \(String(describing: resourceShareType)))"}
}

extension GetDatabasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceShareType = "ResourceShareType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareType = resourceShareType {
            try encodeContainer.encode(resourceShareType.rawValue, forKey: .resourceShareType)
        }
    }
}

public struct GetDatabasesInputHeadersMiddleware: Middleware {
    public let id: String = "GetDatabasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDatabasesInput>
    public typealias MOutput = OperationOutput<GetDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDatabasesOutputError>
}

public struct GetDatabasesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDatabasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDatabasesInput>
    public typealias MOutput = OperationOutput<GetDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDatabasesOutputError>
}

public struct GetDatabasesInput: Equatable {
    /// <p>The ID of the Data Catalog from which to retrieve <code>Databases</code>. If none is
    ///       provided, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The maximum number of databases to return in one response.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?
    /// <p>Allows you to specify that you want to list the databases shared with your account. The allowable values are <code>FOREIGN</code> or <code>ALL</code>. </p>
    /// 	
    /// 	        <ul>
    ///             <li>
    ///                <p>If set to <code>FOREIGN</code>, will list the databases shared with your account. </p>
    ///             </li>
    ///             <li>
    ///                <p>If set to <code>ALL</code>, will list the databases shared with your account, as well as the databases in yor local account. </p>
    ///             </li>
    ///          </ul>
    public let resourceShareType: ResourceShareType?

    public init (
        catalogId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceShareType: ResourceShareType? = nil
    )
    {
        self.catalogId = catalogId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareType = resourceShareType
    }
}

struct GetDatabasesInputBody: Equatable {
    public let catalogId: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let resourceShareType: ResourceShareType?
}

extension GetDatabasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceShareType = "ResourceShareType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceShareTypeDecoded = try containerValues.decodeIfPresent(ResourceShareType.self, forKey: .resourceShareType)
        resourceShareType = resourceShareTypeDecoded
    }
}

extension GetDatabasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatabasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDatabasesOutputError: Equatable {
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatabasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDatabasesOutputResponse(databaseList: \(String(describing: databaseList)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDatabasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDatabasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.databaseList = output.databaseList
            self.nextToken = output.nextToken
        } else {
            self.databaseList = nil
            self.nextToken = nil
        }
    }
}

public struct GetDatabasesOutputResponse: Equatable {
    /// <p>A list of <code>Database</code> objects from the specified catalog.</p>
    public let databaseList: [Database]?
    /// <p>A continuation token for paginating the returned list of tokens,
    ///       returned if the current segment of the list is not the last.</p>
    public let nextToken: String?

    public init (
        databaseList: [Database]? = nil,
        nextToken: String? = nil
    )
    {
        self.databaseList = databaseList
        self.nextToken = nextToken
    }
}

struct GetDatabasesOutputResponseBody: Equatable {
    public let databaseList: [Database]?
    public let nextToken: String?
}

extension GetDatabasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseList = "DatabaseList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseListContainer = try containerValues.decodeIfPresent([Database?].self, forKey: .databaseList)
        var databaseListDecoded0:[Database]? = nil
        if let databaseListContainer = databaseListContainer {
            databaseListDecoded0 = [Database]()
            for structure0 in databaseListContainer {
                if let structure0 = structure0 {
                    databaseListDecoded0?.append(structure0)
                }
            }
        }
        databaseList = databaseListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetDataflowGraphInputBodyMiddleware: Middleware {
    public let id: String = "GetDataflowGraphInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataflowGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataflowGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataflowGraphInput>
    public typealias MOutput = OperationOutput<GetDataflowGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataflowGraphOutputError>
}

extension GetDataflowGraphInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataflowGraphInput(pythonScript: \(String(describing: pythonScript)))"}
}

extension GetDataflowGraphInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pythonScript = "PythonScript"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pythonScript = pythonScript {
            try encodeContainer.encode(pythonScript, forKey: .pythonScript)
        }
    }
}

public struct GetDataflowGraphInputHeadersMiddleware: Middleware {
    public let id: String = "GetDataflowGraphInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataflowGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataflowGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataflowGraphInput>
    public typealias MOutput = OperationOutput<GetDataflowGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataflowGraphOutputError>
}

public struct GetDataflowGraphInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDataflowGraphInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataflowGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataflowGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataflowGraphInput>
    public typealias MOutput = OperationOutput<GetDataflowGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataflowGraphOutputError>
}

public struct GetDataflowGraphInput: Equatable {
    /// <p>The Python script to transform.</p>
    public let pythonScript: String?

    public init (
        pythonScript: String? = nil
    )
    {
        self.pythonScript = pythonScript
    }
}

struct GetDataflowGraphInputBody: Equatable {
    public let pythonScript: String?
}

extension GetDataflowGraphInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pythonScript = "PythonScript"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pythonScriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pythonScript)
        pythonScript = pythonScriptDecoded
    }
}

extension GetDataflowGraphOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataflowGraphOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataflowGraphOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataflowGraphOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataflowGraphOutputResponse(dagEdges: \(String(describing: dagEdges)), dagNodes: \(String(describing: dagNodes)))"}
}

extension GetDataflowGraphOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDataflowGraphOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dagEdges = output.dagEdges
            self.dagNodes = output.dagNodes
        } else {
            self.dagEdges = nil
            self.dagNodes = nil
        }
    }
}

public struct GetDataflowGraphOutputResponse: Equatable {
    /// <p>A list of the edges in the resulting DAG.</p>
    public let dagEdges: [CodeGenEdge]?
    /// <p>A list of the nodes in the resulting DAG.</p>
    public let dagNodes: [CodeGenNode]?

    public init (
        dagEdges: [CodeGenEdge]? = nil,
        dagNodes: [CodeGenNode]? = nil
    )
    {
        self.dagEdges = dagEdges
        self.dagNodes = dagNodes
    }
}

struct GetDataflowGraphOutputResponseBody: Equatable {
    public let dagNodes: [CodeGenNode]?
    public let dagEdges: [CodeGenEdge]?
}

extension GetDataflowGraphOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dagEdges = "DagEdges"
        case dagNodes = "DagNodes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dagNodesContainer = try containerValues.decodeIfPresent([CodeGenNode?].self, forKey: .dagNodes)
        var dagNodesDecoded0:[CodeGenNode]? = nil
        if let dagNodesContainer = dagNodesContainer {
            dagNodesDecoded0 = [CodeGenNode]()
            for structure0 in dagNodesContainer {
                if let structure0 = structure0 {
                    dagNodesDecoded0?.append(structure0)
                }
            }
        }
        dagNodes = dagNodesDecoded0
        let dagEdgesContainer = try containerValues.decodeIfPresent([CodeGenEdge?].self, forKey: .dagEdges)
        var dagEdgesDecoded0:[CodeGenEdge]? = nil
        if let dagEdgesContainer = dagEdgesContainer {
            dagEdgesDecoded0 = [CodeGenEdge]()
            for structure0 in dagEdgesContainer {
                if let structure0 = structure0 {
                    dagEdgesDecoded0?.append(structure0)
                }
            }
        }
        dagEdges = dagEdgesDecoded0
    }
}

public struct GetDevEndpointInputBodyMiddleware: Middleware {
    public let id: String = "GetDevEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevEndpointInput>
    public typealias MOutput = OperationOutput<GetDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevEndpointOutputError>
}

extension GetDevEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevEndpointInput(endpointName: \(String(describing: endpointName)))"}
}

extension GetDevEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointName = "EndpointName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointName = endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
    }
}

public struct GetDevEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "GetDevEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevEndpointInput>
    public typealias MOutput = OperationOutput<GetDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevEndpointOutputError>
}

public struct GetDevEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDevEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevEndpointInput>
    public typealias MOutput = OperationOutput<GetDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevEndpointOutputError>
}

public struct GetDevEndpointInput: Equatable {
    /// <p>Name of the <code>DevEndpoint</code> to retrieve information for.</p>
    public let endpointName: String?

    public init (
        endpointName: String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

struct GetDevEndpointInputBody: Equatable {
    public let endpointName: String?
}

extension GetDevEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointName = "EndpointName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
    }
}

extension GetDevEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevEndpointOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevEndpointOutputResponse(devEndpoint: \(String(describing: devEndpoint)))"}
}

extension GetDevEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDevEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devEndpoint = output.devEndpoint
        } else {
            self.devEndpoint = nil
        }
    }
}

public struct GetDevEndpointOutputResponse: Equatable {
    /// <p>A <code>DevEndpoint</code> definition.</p>
    public let devEndpoint: DevEndpoint?

    public init (
        devEndpoint: DevEndpoint? = nil
    )
    {
        self.devEndpoint = devEndpoint
    }
}

struct GetDevEndpointOutputResponseBody: Equatable {
    public let devEndpoint: DevEndpoint?
}

extension GetDevEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devEndpoint = "DevEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEndpointDecoded = try containerValues.decodeIfPresent(DevEndpoint.self, forKey: .devEndpoint)
        devEndpoint = devEndpointDecoded
    }
}

public struct GetDevEndpointsInputBodyMiddleware: Middleware {
    public let id: String = "GetDevEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevEndpointsInput>
    public typealias MOutput = OperationOutput<GetDevEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevEndpointsOutputError>
}

extension GetDevEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevEndpointsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDevEndpointsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetDevEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDevEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevEndpointsInput>
    public typealias MOutput = OperationOutput<GetDevEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevEndpointsOutputError>
}

public struct GetDevEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDevEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevEndpointsInput>
    public typealias MOutput = OperationOutput<GetDevEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevEndpointsOutputError>
}

public struct GetDevEndpointsInput: Equatable {
    /// <p>The maximum size of information to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDevEndpointsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetDevEndpointsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDevEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevEndpointsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevEndpointsOutputResponse(devEndpoints: \(String(describing: devEndpoints)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDevEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDevEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devEndpoints = output.devEndpoints
            self.nextToken = output.nextToken
        } else {
            self.devEndpoints = nil
            self.nextToken = nil
        }
    }
}

public struct GetDevEndpointsOutputResponse: Equatable {
    /// <p>A list of <code>DevEndpoint</code> definitions.</p>
    public let devEndpoints: [DevEndpoint]?
    /// <p>A continuation token, if not all <code>DevEndpoint</code> definitions have yet been
    ///       returned.</p>
    public let nextToken: String?

    public init (
        devEndpoints: [DevEndpoint]? = nil,
        nextToken: String? = nil
    )
    {
        self.devEndpoints = devEndpoints
        self.nextToken = nextToken
    }
}

struct GetDevEndpointsOutputResponseBody: Equatable {
    public let devEndpoints: [DevEndpoint]?
    public let nextToken: String?
}

extension GetDevEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devEndpoints = "DevEndpoints"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEndpointsContainer = try containerValues.decodeIfPresent([DevEndpoint?].self, forKey: .devEndpoints)
        var devEndpointsDecoded0:[DevEndpoint]? = nil
        if let devEndpointsContainer = devEndpointsContainer {
            devEndpointsDecoded0 = [DevEndpoint]()
            for structure0 in devEndpointsContainer {
                if let structure0 = structure0 {
                    devEndpointsDecoded0?.append(structure0)
                }
            }
        }
        devEndpoints = devEndpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetJobBookmarkInputBodyMiddleware: Middleware {
    public let id: String = "GetJobBookmarkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobBookmarkInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobBookmarkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobBookmarkInput>
    public typealias MOutput = OperationOutput<GetJobBookmarkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobBookmarkOutputError>
}

extension GetJobBookmarkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobBookmarkInput(jobName: \(String(describing: jobName)), runId: \(String(describing: runId)))"}
}

extension GetJobBookmarkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case runId = "RunId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let runId = runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
    }
}

public struct GetJobBookmarkInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobBookmarkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobBookmarkInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobBookmarkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobBookmarkInput>
    public typealias MOutput = OperationOutput<GetJobBookmarkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobBookmarkOutputError>
}

public struct GetJobBookmarkInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobBookmarkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobBookmarkInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobBookmarkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobBookmarkInput>
    public typealias MOutput = OperationOutput<GetJobBookmarkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobBookmarkOutputError>
}

public struct GetJobBookmarkInput: Equatable {
    /// <p>The name of the job in question.</p>
    public let jobName: String?
    /// <p>The unique run identifier associated with this job run.</p>
    public let runId: String?

    public init (
        jobName: String? = nil,
        runId: String? = nil
    )
    {
        self.jobName = jobName
        self.runId = runId
    }
}

struct GetJobBookmarkInputBody: Equatable {
    public let jobName: String?
    public let runId: String?
}

extension GetJobBookmarkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case runId = "RunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
    }
}

extension GetJobBookmarkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobBookmarkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobBookmarkOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobBookmarkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobBookmarkOutputResponse(jobBookmarkEntry: \(String(describing: jobBookmarkEntry)))"}
}

extension GetJobBookmarkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetJobBookmarkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobBookmarkEntry = output.jobBookmarkEntry
        } else {
            self.jobBookmarkEntry = nil
        }
    }
}

public struct GetJobBookmarkOutputResponse: Equatable {
    /// <p>A structure that defines a point that a job can resume processing.</p>
    public let jobBookmarkEntry: JobBookmarkEntry?

    public init (
        jobBookmarkEntry: JobBookmarkEntry? = nil
    )
    {
        self.jobBookmarkEntry = jobBookmarkEntry
    }
}

struct GetJobBookmarkOutputResponseBody: Equatable {
    public let jobBookmarkEntry: JobBookmarkEntry?
}

extension GetJobBookmarkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobBookmarkEntry = "JobBookmarkEntry"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobBookmarkEntryDecoded = try containerValues.decodeIfPresent(JobBookmarkEntry.self, forKey: .jobBookmarkEntry)
        jobBookmarkEntry = jobBookmarkEntryDecoded
    }
}

public struct GetJobInputBodyMiddleware: Middleware {
    public let id: String = "GetJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobInput>
    public typealias MOutput = OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputError>
}

extension GetJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobInput(jobName: \(String(describing: jobName)))"}
}

extension GetJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
    }
}

public struct GetJobInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobInput>
    public typealias MOutput = OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputError>
}

public struct GetJobInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobInput>
    public typealias MOutput = OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputError>
}

public struct GetJobInput: Equatable {
    /// <p>The name of the job definition to retrieve.</p>
    public let jobName: String?

    public init (
        jobName: String? = nil
    )
    {
        self.jobName = jobName
    }
}

struct GetJobInputBody: Equatable {
    public let jobName: String?
}

extension GetJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
    }
}

extension GetJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobOutputResponse(job: \(String(describing: job)))"}
}

extension GetJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct GetJobOutputResponse: Equatable {
    /// <p>The requested job definition.</p>
    public let job: Job?

    public init (
        job: Job? = nil
    )
    {
        self.job = job
    }
}

struct GetJobOutputResponseBody: Equatable {
    public let job: Job?
}

extension GetJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job = "Job"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Job.self, forKey: .job)
        job = jobDecoded
    }
}

public struct GetJobRunInputBodyMiddleware: Middleware {
    public let id: String = "GetJobRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobRunInput>
    public typealias MOutput = OperationOutput<GetJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobRunOutputError>
}

extension GetJobRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobRunInput(jobName: \(String(describing: jobName)), predecessorsIncluded: \(String(describing: predecessorsIncluded)), runId: \(String(describing: runId)))"}
}

extension GetJobRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case predecessorsIncluded = "PredecessorsIncluded"
        case runId = "RunId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if predecessorsIncluded != false {
            try encodeContainer.encode(predecessorsIncluded, forKey: .predecessorsIncluded)
        }
        if let runId = runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
    }
}

public struct GetJobRunInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobRunInput>
    public typealias MOutput = OperationOutput<GetJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobRunOutputError>
}

public struct GetJobRunInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobRunInput>
    public typealias MOutput = OperationOutput<GetJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobRunOutputError>
}

public struct GetJobRunInput: Equatable {
    /// <p>Name of the job definition being run.</p>
    public let jobName: String?
    /// <p>True if a list of predecessor runs should be returned.</p>
    public let predecessorsIncluded: Bool
    /// <p>The ID of the job run.</p>
    public let runId: String?

    public init (
        jobName: String? = nil,
        predecessorsIncluded: Bool = false,
        runId: String? = nil
    )
    {
        self.jobName = jobName
        self.predecessorsIncluded = predecessorsIncluded
        self.runId = runId
    }
}

struct GetJobRunInputBody: Equatable {
    public let jobName: String?
    public let runId: String?
    public let predecessorsIncluded: Bool
}

extension GetJobRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case predecessorsIncluded = "PredecessorsIncluded"
        case runId = "RunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
        let predecessorsIncludedDecoded = try containerValues.decode(Bool.self, forKey: .predecessorsIncluded)
        predecessorsIncluded = predecessorsIncludedDecoded
    }
}

extension GetJobRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobRunOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobRunOutputResponse(jobRun: \(String(describing: jobRun)))"}
}

extension GetJobRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetJobRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobRun = output.jobRun
        } else {
            self.jobRun = nil
        }
    }
}

public struct GetJobRunOutputResponse: Equatable {
    /// <p>The requested job-run metadata.</p>
    public let jobRun: JobRun?

    public init (
        jobRun: JobRun? = nil
    )
    {
        self.jobRun = jobRun
    }
}

struct GetJobRunOutputResponseBody: Equatable {
    public let jobRun: JobRun?
}

extension GetJobRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobRun = "JobRun"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunDecoded = try containerValues.decodeIfPresent(JobRun.self, forKey: .jobRun)
        jobRun = jobRunDecoded
    }
}

public struct GetJobRunsInputBodyMiddleware: Middleware {
    public let id: String = "GetJobRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobRunsInput>
    public typealias MOutput = OperationOutput<GetJobRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobRunsOutputError>
}

extension GetJobRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobRunsInput(jobName: \(String(describing: jobName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetJobRunsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetJobRunsInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobRunsInput>
    public typealias MOutput = OperationOutput<GetJobRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobRunsOutputError>
}

public struct GetJobRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobRunsInput>
    public typealias MOutput = OperationOutput<GetJobRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobRunsOutputError>
}

public struct GetJobRunsInput: Equatable {
    /// <p>The name of the job definition for which to retrieve all job runs.</p>
    public let jobName: String?
    /// <p>The maximum size of the response.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?

    public init (
        jobName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.jobName = jobName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetJobRunsInputBody: Equatable {
    public let jobName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetJobRunsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetJobRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobRunsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobRunsOutputResponse(jobRuns: \(String(describing: jobRuns)), nextToken: \(String(describing: nextToken)))"}
}

extension GetJobRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetJobRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobRuns = output.jobRuns
            self.nextToken = output.nextToken
        } else {
            self.jobRuns = nil
            self.nextToken = nil
        }
    }
}

public struct GetJobRunsOutputResponse: Equatable {
    /// <p>A list of job-run metadata objects.</p>
    public let jobRuns: [JobRun]?
    /// <p>A continuation token, if not all requested job runs have been returned.</p>
    public let nextToken: String?

    public init (
        jobRuns: [JobRun]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobRuns = jobRuns
        self.nextToken = nextToken
    }
}

struct GetJobRunsOutputResponseBody: Equatable {
    public let jobRuns: [JobRun]?
    public let nextToken: String?
}

extension GetJobRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobRuns = "JobRuns"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunsContainer = try containerValues.decodeIfPresent([JobRun?].self, forKey: .jobRuns)
        var jobRunsDecoded0:[JobRun]? = nil
        if let jobRunsContainer = jobRunsContainer {
            jobRunsDecoded0 = [JobRun]()
            for structure0 in jobRunsContainer {
                if let structure0 = structure0 {
                    jobRunsDecoded0?.append(structure0)
                }
            }
        }
        jobRuns = jobRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetJobsInputBodyMiddleware: Middleware {
    public let id: String = "GetJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobsInput>
    public typealias MOutput = OperationOutput<GetJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobsOutputError>
}

extension GetJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetJobsInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobsInput>
    public typealias MOutput = OperationOutput<GetJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobsOutputError>
}

public struct GetJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobsInput>
    public typealias MOutput = OperationOutput<GetJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobsOutputError>
}

public struct GetJobsInput: Equatable {
    /// <p>The maximum size of the response.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetJobsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobsOutputResponse(jobs: \(String(describing: jobs)), nextToken: \(String(describing: nextToken)))"}
}

extension GetJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct GetJobsOutputResponse: Equatable {
    /// <p>A list of job definitions.</p>
    public let jobs: [Job]?
    /// <p>A continuation token, if not all job definitions have yet been returned.</p>
    public let nextToken: String?

    public init (
        jobs: [Job]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct GetJobsOutputResponseBody: Equatable {
    public let jobs: [Job]?
    public let nextToken: String?
}

extension GetJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([Job?].self, forKey: .jobs)
        var jobsDecoded0:[Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetMLTaskRunInputBodyMiddleware: Middleware {
    public let id: String = "GetMLTaskRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTaskRunInput>
    public typealias MOutput = OperationOutput<GetMLTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTaskRunOutputError>
}

extension GetMLTaskRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMLTaskRunInput(taskRunId: \(String(describing: taskRunId)), transformId: \(String(describing: transformId)))"}
}

extension GetMLTaskRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case taskRunId = "TaskRunId"
        case transformId = "TransformId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskRunId = taskRunId {
            try encodeContainer.encode(taskRunId, forKey: .taskRunId)
        }
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
    }
}

public struct GetMLTaskRunInputHeadersMiddleware: Middleware {
    public let id: String = "GetMLTaskRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTaskRunInput>
    public typealias MOutput = OperationOutput<GetMLTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTaskRunOutputError>
}

public struct GetMLTaskRunInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMLTaskRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTaskRunInput>
    public typealias MOutput = OperationOutput<GetMLTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTaskRunOutputError>
}

public struct GetMLTaskRunInput: Equatable {
    /// <p>The unique identifier of the task run.</p>
    public let taskRunId: String?
    /// <p>The unique identifier of the machine learning transform.</p>
    public let transformId: String?

    public init (
        taskRunId: String? = nil,
        transformId: String? = nil
    )
    {
        self.taskRunId = taskRunId
        self.transformId = transformId
    }
}

struct GetMLTaskRunInputBody: Equatable {
    public let transformId: String?
    public let taskRunId: String?
}

extension GetMLTaskRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskRunId = "TaskRunId"
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let taskRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRunId)
        taskRunId = taskRunIdDecoded
    }
}

extension GetMLTaskRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMLTaskRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMLTaskRunOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMLTaskRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMLTaskRunOutputResponse(completedOn: \(String(describing: completedOn)), errorString: \(String(describing: errorString)), executionTime: \(String(describing: executionTime)), lastModifiedOn: \(String(describing: lastModifiedOn)), logGroupName: \(String(describing: logGroupName)), properties: \(String(describing: properties)), startedOn: \(String(describing: startedOn)), status: \(String(describing: status)), taskRunId: \(String(describing: taskRunId)), transformId: \(String(describing: transformId)))"}
}

extension GetMLTaskRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMLTaskRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.completedOn = output.completedOn
            self.errorString = output.errorString
            self.executionTime = output.executionTime
            self.lastModifiedOn = output.lastModifiedOn
            self.logGroupName = output.logGroupName
            self.properties = output.properties
            self.startedOn = output.startedOn
            self.status = output.status
            self.taskRunId = output.taskRunId
            self.transformId = output.transformId
        } else {
            self.completedOn = nil
            self.errorString = nil
            self.executionTime = 0
            self.lastModifiedOn = nil
            self.logGroupName = nil
            self.properties = nil
            self.startedOn = nil
            self.status = nil
            self.taskRunId = nil
            self.transformId = nil
        }
    }
}

public struct GetMLTaskRunOutputResponse: Equatable {
    /// <p>The date and time when this task run was completed.</p>
    public let completedOn: Date?
    /// <p>The error strings that are associated with the task run.</p>
    public let errorString: String?
    /// <p>The amount of time (in seconds) that the task run consumed resources.</p>
    public let executionTime: Int
    /// <p>The date and time when this task run was last modified.</p>
    public let lastModifiedOn: Date?
    /// <p>The names of the log groups that are associated with the task run.</p>
    public let logGroupName: String?
    /// <p>The list of properties that are associated with the task run.</p>
    public let properties: TaskRunProperties?
    /// <p>The date and time when this task run started.</p>
    public let startedOn: Date?
    /// <p>The status for this task run.</p>
    public let status: TaskStatusType?
    /// <p>The unique run identifier associated with this run.</p>
    public let taskRunId: String?
    /// <p>The unique identifier of the task run.</p>
    public let transformId: String?

    public init (
        completedOn: Date? = nil,
        errorString: String? = nil,
        executionTime: Int = 0,
        lastModifiedOn: Date? = nil,
        logGroupName: String? = nil,
        properties: TaskRunProperties? = nil,
        startedOn: Date? = nil,
        status: TaskStatusType? = nil,
        taskRunId: String? = nil,
        transformId: String? = nil
    )
    {
        self.completedOn = completedOn
        self.errorString = errorString
        self.executionTime = executionTime
        self.lastModifiedOn = lastModifiedOn
        self.logGroupName = logGroupName
        self.properties = properties
        self.startedOn = startedOn
        self.status = status
        self.taskRunId = taskRunId
        self.transformId = transformId
    }
}

struct GetMLTaskRunOutputResponseBody: Equatable {
    public let transformId: String?
    public let taskRunId: String?
    public let status: TaskStatusType?
    public let logGroupName: String?
    public let properties: TaskRunProperties?
    public let errorString: String?
    public let startedOn: Date?
    public let lastModifiedOn: Date?
    public let completedOn: Date?
    public let executionTime: Int
}

extension GetMLTaskRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case completedOn = "CompletedOn"
        case errorString = "ErrorString"
        case executionTime = "ExecutionTime"
        case lastModifiedOn = "LastModifiedOn"
        case logGroupName = "LogGroupName"
        case properties = "Properties"
        case startedOn = "StartedOn"
        case status = "Status"
        case taskRunId = "TaskRunId"
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let taskRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRunId)
        taskRunId = taskRunIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TaskStatusType.self, forKey: .status)
        status = statusDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(TaskRunProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let errorStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorString)
        errorString = errorStringDecoded
        let startedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedOn)
        startedOn = startedOnDecoded
        let lastModifiedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedOn)
        lastModifiedOn = lastModifiedOnDecoded
        let completedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedOn)
        completedOn = completedOnDecoded
        let executionTimeDecoded = try containerValues.decode(Int.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
    }
}

public struct GetMLTaskRunsInputBodyMiddleware: Middleware {
    public let id: String = "GetMLTaskRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTaskRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTaskRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTaskRunsInput>
    public typealias MOutput = OperationOutput<GetMLTaskRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTaskRunsOutputError>
}

extension GetMLTaskRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMLTaskRunsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sort: \(String(describing: sort)), transformId: \(String(describing: transformId)))"}
}

extension GetMLTaskRunsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
        case transformId = "TransformId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
    }
}

public struct GetMLTaskRunsInputHeadersMiddleware: Middleware {
    public let id: String = "GetMLTaskRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTaskRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTaskRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTaskRunsInput>
    public typealias MOutput = OperationOutput<GetMLTaskRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTaskRunsOutputError>
}

public struct GetMLTaskRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMLTaskRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTaskRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTaskRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTaskRunsInput>
    public typealias MOutput = OperationOutput<GetMLTaskRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTaskRunsOutputError>
}

public struct GetMLTaskRunsInput: Equatable {
    /// <p>The filter criteria, in the <code>TaskRunFilterCriteria</code> structure, for the task run.</p>
    public let filter: TaskRunFilterCriteria?
    /// <p>The maximum number of results to return. </p>
    public let maxResults: Int?
    /// <p>A token for pagination of the results. The default is empty.</p>
    public let nextToken: String?
    /// <p>The sorting criteria, in the <code>TaskRunSortCriteria</code> structure, for the task run.</p>
    public let sort: TaskRunSortCriteria?
    /// <p>The unique identifier of the machine learning transform.</p>
    public let transformId: String?

    public init (
        filter: TaskRunFilterCriteria? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sort: TaskRunSortCriteria? = nil,
        transformId: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
        self.transformId = transformId
    }
}

struct GetMLTaskRunsInputBody: Equatable {
    public let transformId: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let filter: TaskRunFilterCriteria?
    public let sort: TaskRunSortCriteria?
}

extension GetMLTaskRunsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(TaskRunFilterCriteria.self, forKey: .filter)
        filter = filterDecoded
        let sortDecoded = try containerValues.decodeIfPresent(TaskRunSortCriteria.self, forKey: .sort)
        sort = sortDecoded
    }
}

extension GetMLTaskRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMLTaskRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMLTaskRunsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMLTaskRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMLTaskRunsOutputResponse(nextToken: \(String(describing: nextToken)), taskRuns: \(String(describing: taskRuns)))"}
}

extension GetMLTaskRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMLTaskRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.taskRuns = output.taskRuns
        } else {
            self.nextToken = nil
            self.taskRuns = nil
        }
    }
}

public struct GetMLTaskRunsOutputResponse: Equatable {
    /// <p>A pagination token, if more results are available.</p>
    public let nextToken: String?
    /// <p>A list of task runs that are associated with the transform.</p>
    public let taskRuns: [TaskRun]?

    public init (
        nextToken: String? = nil,
        taskRuns: [TaskRun]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskRuns = taskRuns
    }
}

struct GetMLTaskRunsOutputResponseBody: Equatable {
    public let taskRuns: [TaskRun]?
    public let nextToken: String?
}

extension GetMLTaskRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case taskRuns = "TaskRuns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskRunsContainer = try containerValues.decodeIfPresent([TaskRun?].self, forKey: .taskRuns)
        var taskRunsDecoded0:[TaskRun]? = nil
        if let taskRunsContainer = taskRunsContainer {
            taskRunsDecoded0 = [TaskRun]()
            for structure0 in taskRunsContainer {
                if let structure0 = structure0 {
                    taskRunsDecoded0?.append(structure0)
                }
            }
        }
        taskRuns = taskRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetMLTransformInputBodyMiddleware: Middleware {
    public let id: String = "GetMLTransformInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTransformInput>
    public typealias MOutput = OperationOutput<GetMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTransformOutputError>
}

extension GetMLTransformInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMLTransformInput(transformId: \(String(describing: transformId)))"}
}

extension GetMLTransformInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case transformId = "TransformId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
    }
}

public struct GetMLTransformInputHeadersMiddleware: Middleware {
    public let id: String = "GetMLTransformInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTransformInput>
    public typealias MOutput = OperationOutput<GetMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTransformOutputError>
}

public struct GetMLTransformInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMLTransformInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTransformInput>
    public typealias MOutput = OperationOutput<GetMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTransformOutputError>
}

public struct GetMLTransformInput: Equatable {
    /// <p>The unique identifier of the transform, generated at the time that the transform was
    ///       created.</p>
    public let transformId: String?

    public init (
        transformId: String? = nil
    )
    {
        self.transformId = transformId
    }
}

struct GetMLTransformInputBody: Equatable {
    public let transformId: String?
}

extension GetMLTransformInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
    }
}

extension GetMLTransformOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMLTransformOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMLTransformOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMLTransformOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMLTransformOutputResponse(createdOn: \(String(describing: createdOn)), description: \(String(describing: description)), evaluationMetrics: \(String(describing: evaluationMetrics)), glueVersion: \(String(describing: glueVersion)), inputRecordTables: \(String(describing: inputRecordTables)), labelCount: \(String(describing: labelCount)), lastModifiedOn: \(String(describing: lastModifiedOn)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), numberOfWorkers: \(String(describing: numberOfWorkers)), parameters: \(String(describing: parameters)), role: \(String(describing: role)), schema: \(String(describing: schema)), status: \(String(describing: status)), timeout: \(String(describing: timeout)), transformEncryption: \(String(describing: transformEncryption)), transformId: \(String(describing: transformId)), workerType: \(String(describing: workerType)))"}
}

extension GetMLTransformOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMLTransformOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdOn = output.createdOn
            self.description = output.description
            self.evaluationMetrics = output.evaluationMetrics
            self.glueVersion = output.glueVersion
            self.inputRecordTables = output.inputRecordTables
            self.labelCount = output.labelCount
            self.lastModifiedOn = output.lastModifiedOn
            self.maxCapacity = output.maxCapacity
            self.maxRetries = output.maxRetries
            self.name = output.name
            self.numberOfWorkers = output.numberOfWorkers
            self.parameters = output.parameters
            self.role = output.role
            self.schema = output.schema
            self.status = output.status
            self.timeout = output.timeout
            self.transformEncryption = output.transformEncryption
            self.transformId = output.transformId
            self.workerType = output.workerType
        } else {
            self.createdOn = nil
            self.description = nil
            self.evaluationMetrics = nil
            self.glueVersion = nil
            self.inputRecordTables = nil
            self.labelCount = 0
            self.lastModifiedOn = nil
            self.maxCapacity = nil
            self.maxRetries = nil
            self.name = nil
            self.numberOfWorkers = nil
            self.parameters = nil
            self.role = nil
            self.schema = nil
            self.status = nil
            self.timeout = nil
            self.transformEncryption = nil
            self.transformId = nil
            self.workerType = nil
        }
    }
}

public struct GetMLTransformOutputResponse: Equatable {
    /// <p>The date and time when the transform was created.</p>
    public let createdOn: Date?
    /// <p>A description of the transform.</p>
    public let description: String?
    /// <p>The latest evaluation metrics.</p>
    public let evaluationMetrics: EvaluationMetrics?
    /// <p>This value determines which version of AWS Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">AWS Glue Versions</a> in the developer guide.</p>
    public let glueVersion: String?
    /// <p>A list of AWS Glue table definitions used by the transform.</p>
    public let inputRecordTables: [GlueTable]?
    /// <p>The number of labels available for this transform.</p>
    public let labelCount: Int
    /// <p>The date and time when the transform was last modified.</p>
    public let lastModifiedOn: Date?
    /// <p>The number of AWS Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of
    ///       processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
    ///       information, see the <a href="https://aws.amazon.com/glue/pricing/">AWS Glue pricing
    ///         page</a>. </p>
    /// 		
    ///          <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
    public let maxCapacity: Double?
    /// <p>The maximum number of times to retry a task for this transform after a task run fails.</p>
    public let maxRetries: Int?
    /// <p>The unique name given to the transform when it was created.</p>
    public let name: String?
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when this task runs.</p>
    public let numberOfWorkers: Int?
    /// <p>The configuration parameters that are specific to the algorithm used.</p>
    public let parameters: TransformParameters?
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required
    ///       permissions.</p>
    public let role: String?
    /// <p>The <code>Map<Column, Type></code> object that represents the schema that this
    ///       transform accepts. Has an upper bound of 100 columns.</p>
    public let schema: [SchemaColumn]?
    /// <p>The last known status of the transform (to indicate whether it can be used or not). One of "NOT_READY", "READY", or "DELETING".</p>
    public let status: TransformStatusType?
    /// <p>The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
    public let timeout: Int?
    /// <p>The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.</p>
    public let transformEncryption: TransformEncryption?
    /// <p>The unique identifier of the transform, generated at the time that the transform was
    ///       created.</p>
    public let transformId: String?
    /// <p>The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///          </ul>
    public let workerType: WorkerType?

    public init (
        createdOn: Date? = nil,
        description: String? = nil,
        evaluationMetrics: EvaluationMetrics? = nil,
        glueVersion: String? = nil,
        inputRecordTables: [GlueTable]? = nil,
        labelCount: Int = 0,
        lastModifiedOn: Date? = nil,
        maxCapacity: Double? = nil,
        maxRetries: Int? = nil,
        name: String? = nil,
        numberOfWorkers: Int? = nil,
        parameters: TransformParameters? = nil,
        role: String? = nil,
        schema: [SchemaColumn]? = nil,
        status: TransformStatusType? = nil,
        timeout: Int? = nil,
        transformEncryption: TransformEncryption? = nil,
        transformId: String? = nil,
        workerType: WorkerType? = nil
    )
    {
        self.createdOn = createdOn
        self.description = description
        self.evaluationMetrics = evaluationMetrics
        self.glueVersion = glueVersion
        self.inputRecordTables = inputRecordTables
        self.labelCount = labelCount
        self.lastModifiedOn = lastModifiedOn
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.numberOfWorkers = numberOfWorkers
        self.parameters = parameters
        self.role = role
        self.schema = schema
        self.status = status
        self.timeout = timeout
        self.transformEncryption = transformEncryption
        self.transformId = transformId
        self.workerType = workerType
    }
}

struct GetMLTransformOutputResponseBody: Equatable {
    public let transformId: String?
    public let name: String?
    public let description: String?
    public let status: TransformStatusType?
    public let createdOn: Date?
    public let lastModifiedOn: Date?
    public let inputRecordTables: [GlueTable]?
    public let parameters: TransformParameters?
    public let evaluationMetrics: EvaluationMetrics?
    public let labelCount: Int
    public let schema: [SchemaColumn]?
    public let role: String?
    public let glueVersion: String?
    public let maxCapacity: Double?
    public let workerType: WorkerType?
    public let numberOfWorkers: Int?
    public let timeout: Int?
    public let maxRetries: Int?
    public let transformEncryption: TransformEncryption?
}

extension GetMLTransformOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdOn = "CreatedOn"
        case description = "Description"
        case evaluationMetrics = "EvaluationMetrics"
        case glueVersion = "GlueVersion"
        case inputRecordTables = "InputRecordTables"
        case labelCount = "LabelCount"
        case lastModifiedOn = "LastModifiedOn"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case numberOfWorkers = "NumberOfWorkers"
        case parameters = "Parameters"
        case role = "Role"
        case schema = "Schema"
        case status = "Status"
        case timeout = "Timeout"
        case transformEncryption = "TransformEncryption"
        case transformId = "TransformId"
        case workerType = "WorkerType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransformStatusType.self, forKey: .status)
        status = statusDecoded
        let createdOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdOn)
        createdOn = createdOnDecoded
        let lastModifiedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedOn)
        lastModifiedOn = lastModifiedOnDecoded
        let inputRecordTablesContainer = try containerValues.decodeIfPresent([GlueTable?].self, forKey: .inputRecordTables)
        var inputRecordTablesDecoded0:[GlueTable]? = nil
        if let inputRecordTablesContainer = inputRecordTablesContainer {
            inputRecordTablesDecoded0 = [GlueTable]()
            for structure0 in inputRecordTablesContainer {
                if let structure0 = structure0 {
                    inputRecordTablesDecoded0?.append(structure0)
                }
            }
        }
        inputRecordTables = inputRecordTablesDecoded0
        let parametersDecoded = try containerValues.decodeIfPresent(TransformParameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let evaluationMetricsDecoded = try containerValues.decodeIfPresent(EvaluationMetrics.self, forKey: .evaluationMetrics)
        evaluationMetrics = evaluationMetricsDecoded
        let labelCountDecoded = try containerValues.decode(Int.self, forKey: .labelCount)
        labelCount = labelCountDecoded
        let schemaContainer = try containerValues.decodeIfPresent([SchemaColumn?].self, forKey: .schema)
        var schemaDecoded0:[SchemaColumn]? = nil
        if let schemaContainer = schemaContainer {
            schemaDecoded0 = [SchemaColumn]()
            for structure0 in schemaContainer {
                if let structure0 = structure0 {
                    schemaDecoded0?.append(structure0)
                }
            }
        }
        schema = schemaDecoded0
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let transformEncryptionDecoded = try containerValues.decodeIfPresent(TransformEncryption.self, forKey: .transformEncryption)
        transformEncryption = transformEncryptionDecoded
    }
}

public struct GetMLTransformsInputBodyMiddleware: Middleware {
    public let id: String = "GetMLTransformsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTransformsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTransformsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTransformsInput>
    public typealias MOutput = OperationOutput<GetMLTransformsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTransformsOutputError>
}

extension GetMLTransformsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMLTransformsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sort: \(String(describing: sort)))"}
}

extension GetMLTransformsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

public struct GetMLTransformsInputHeadersMiddleware: Middleware {
    public let id: String = "GetMLTransformsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTransformsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTransformsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTransformsInput>
    public typealias MOutput = OperationOutput<GetMLTransformsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTransformsOutputError>
}

public struct GetMLTransformsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMLTransformsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMLTransformsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMLTransformsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMLTransformsInput>
    public typealias MOutput = OperationOutput<GetMLTransformsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMLTransformsOutputError>
}

public struct GetMLTransformsInput: Equatable {
    /// <p>The filter transformation criteria.</p>
    public let filter: TransformFilterCriteria?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>A paginated token to offset the results.</p>
    public let nextToken: String?
    /// <p>The sorting criteria.</p>
    public let sort: TransformSortCriteria?

    public init (
        filter: TransformFilterCriteria? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sort: TransformSortCriteria? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct GetMLTransformsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filter: TransformFilterCriteria?
    public let sort: TransformSortCriteria?
}

extension GetMLTransformsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(TransformFilterCriteria.self, forKey: .filter)
        filter = filterDecoded
        let sortDecoded = try containerValues.decodeIfPresent(TransformSortCriteria.self, forKey: .sort)
        sort = sortDecoded
    }
}

extension GetMLTransformsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMLTransformsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMLTransformsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMLTransformsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMLTransformsOutputResponse(nextToken: \(String(describing: nextToken)), transforms: \(String(describing: transforms)))"}
}

extension GetMLTransformsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMLTransformsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.transforms = output.transforms
        } else {
            self.nextToken = nil
            self.transforms = nil
        }
    }
}

public struct GetMLTransformsOutputResponse: Equatable {
    /// <p>A pagination token, if more results are available.</p>
    public let nextToken: String?
    /// <p>A list of machine learning transforms.</p>
    public let transforms: [MLTransform]?

    public init (
        nextToken: String? = nil,
        transforms: [MLTransform]? = nil
    )
    {
        self.nextToken = nextToken
        self.transforms = transforms
    }
}

struct GetMLTransformsOutputResponseBody: Equatable {
    public let transforms: [MLTransform]?
    public let nextToken: String?
}

extension GetMLTransformsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case transforms = "Transforms"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformsContainer = try containerValues.decodeIfPresent([MLTransform?].self, forKey: .transforms)
        var transformsDecoded0:[MLTransform]? = nil
        if let transformsContainer = transformsContainer {
            transformsDecoded0 = [MLTransform]()
            for structure0 in transformsContainer {
                if let structure0 = structure0 {
                    transformsDecoded0?.append(structure0)
                }
            }
        }
        transforms = transformsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetMappingInputBodyMiddleware: Middleware {
    public let id: String = "GetMappingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMappingInput>
    public typealias MOutput = OperationOutput<GetMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMappingOutputError>
}

extension GetMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMappingInput(location: \(String(describing: location)), sinks: \(String(describing: sinks)), source: \(String(describing: source)))"}
}

extension GetMappingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case location = "Location"
        case sinks = "Sinks"
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for catalogentries0 in sinks {
                try sinksContainer.encode(catalogentries0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

public struct GetMappingInputHeadersMiddleware: Middleware {
    public let id: String = "GetMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMappingInput>
    public typealias MOutput = OperationOutput<GetMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMappingOutputError>
}

public struct GetMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMappingInput>
    public typealias MOutput = OperationOutput<GetMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMappingOutputError>
}

public struct GetMappingInput: Equatable {
    /// <p>Parameters for the mapping.</p>
    public let location: Location?
    /// <p>A list of target tables.</p>
    public let sinks: [CatalogEntry]?
    /// <p>Specifies the source table.</p>
    public let source: CatalogEntry?

    public init (
        location: Location? = nil,
        sinks: [CatalogEntry]? = nil,
        source: CatalogEntry? = nil
    )
    {
        self.location = location
        self.sinks = sinks
        self.source = source
    }
}

struct GetMappingInputBody: Equatable {
    public let source: CatalogEntry?
    public let sinks: [CatalogEntry]?
    public let location: Location?
}

extension GetMappingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case location = "Location"
        case sinks = "Sinks"
        case source = "Source"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CatalogEntry.self, forKey: .source)
        source = sourceDecoded
        let sinksContainer = try containerValues.decodeIfPresent([CatalogEntry?].self, forKey: .sinks)
        var sinksDecoded0:[CatalogEntry]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [CatalogEntry]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
    }
}

extension GetMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMappingOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMappingOutputResponse(mapping: \(String(describing: mapping)))"}
}

extension GetMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMappingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.mapping = output.mapping
        } else {
            self.mapping = nil
        }
    }
}

public struct GetMappingOutputResponse: Equatable {
    /// <p>A list of mappings to the specified targets.</p>
    public let mapping: [MappingEntry]?

    public init (
        mapping: [MappingEntry]? = nil
    )
    {
        self.mapping = mapping
    }
}

struct GetMappingOutputResponseBody: Equatable {
    public let mapping: [MappingEntry]?
}

extension GetMappingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mapping = "Mapping"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mappingContainer = try containerValues.decodeIfPresent([MappingEntry?].self, forKey: .mapping)
        var mappingDecoded0:[MappingEntry]? = nil
        if let mappingContainer = mappingContainer {
            mappingDecoded0 = [MappingEntry]()
            for structure0 in mappingContainer {
                if let structure0 = structure0 {
                    mappingDecoded0?.append(structure0)
                }
            }
        }
        mapping = mappingDecoded0
    }
}

public struct GetPartitionIndexesInputBodyMiddleware: Middleware {
    public let id: String = "GetPartitionIndexesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPartitionIndexesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPartitionIndexesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPartitionIndexesInput>
    public typealias MOutput = OperationOutput<GetPartitionIndexesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPartitionIndexesOutputError>
}

extension GetPartitionIndexesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPartitionIndexesInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), nextToken: \(String(describing: nextToken)), tableName: \(String(describing: tableName)))"}
}

extension GetPartitionIndexesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case nextToken = "NextToken"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct GetPartitionIndexesInputHeadersMiddleware: Middleware {
    public let id: String = "GetPartitionIndexesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPartitionIndexesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPartitionIndexesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPartitionIndexesInput>
    public typealias MOutput = OperationOutput<GetPartitionIndexesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPartitionIndexesOutputError>
}

public struct GetPartitionIndexesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPartitionIndexesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPartitionIndexesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPartitionIndexesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPartitionIndexesInput>
    public typealias MOutput = OperationOutput<GetPartitionIndexesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPartitionIndexesOutputError>
}

public struct GetPartitionIndexesInput: Equatable {
    /// <p>The catalog ID where the table resides.</p>
    public let catalogId: String?
    /// <p>Specifies the name of a database from which you want to retrieve partition indexes.</p>
    public let databaseName: String?
    /// <p>A continuation token, included if this is a continuation call.</p>
    public let nextToken: String?
    /// <p>Specifies the name of a table for which you want to retrieve the partition indexes.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        nextToken: String? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.nextToken = nextToken
        self.tableName = tableName
    }
}

struct GetPartitionIndexesInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let nextToken: String?
}

extension GetPartitionIndexesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case nextToken = "NextToken"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetPartitionIndexesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPartitionIndexesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPartitionIndexesOutputError: Equatable {
    case conflictException(ConflictException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPartitionIndexesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPartitionIndexesOutputResponse(nextToken: \(String(describing: nextToken)), partitionIndexDescriptorList: \(String(describing: partitionIndexDescriptorList)))"}
}

extension GetPartitionIndexesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPartitionIndexesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.partitionIndexDescriptorList = output.partitionIndexDescriptorList
        } else {
            self.nextToken = nil
            self.partitionIndexDescriptorList = nil
        }
    }
}

public struct GetPartitionIndexesOutputResponse: Equatable {
    /// <p>A continuation token, present if the current list segment is not the last.</p>
    public let nextToken: String?
    /// <p>A list of index descriptors.</p>
    public let partitionIndexDescriptorList: [PartitionIndexDescriptor]?

    public init (
        nextToken: String? = nil,
        partitionIndexDescriptorList: [PartitionIndexDescriptor]? = nil
    )
    {
        self.nextToken = nextToken
        self.partitionIndexDescriptorList = partitionIndexDescriptorList
    }
}

struct GetPartitionIndexesOutputResponseBody: Equatable {
    public let partitionIndexDescriptorList: [PartitionIndexDescriptor]?
    public let nextToken: String?
}

extension GetPartitionIndexesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case partitionIndexDescriptorList = "PartitionIndexDescriptorList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionIndexDescriptorListContainer = try containerValues.decodeIfPresent([PartitionIndexDescriptor?].self, forKey: .partitionIndexDescriptorList)
        var partitionIndexDescriptorListDecoded0:[PartitionIndexDescriptor]? = nil
        if let partitionIndexDescriptorListContainer = partitionIndexDescriptorListContainer {
            partitionIndexDescriptorListDecoded0 = [PartitionIndexDescriptor]()
            for structure0 in partitionIndexDescriptorListContainer {
                if let structure0 = structure0 {
                    partitionIndexDescriptorListDecoded0?.append(structure0)
                }
            }
        }
        partitionIndexDescriptorList = partitionIndexDescriptorListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetPartitionInputBodyMiddleware: Middleware {
    public let id: String = "GetPartitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPartitionInput>
    public typealias MOutput = OperationOutput<GetPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPartitionOutputError>
}

extension GetPartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPartitionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), partitionValues: \(String(describing: partitionValues)), tableName: \(String(describing: tableName)))"}
}

extension GetPartitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionValues = "PartitionValues"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionValues = partitionValues {
            var partitionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValues)
            for valuestringlist0 in partitionValues {
                try partitionValuesContainer.encode(valuestringlist0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct GetPartitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetPartitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPartitionInput>
    public typealias MOutput = OperationOutput<GetPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPartitionOutputError>
}

public struct GetPartitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPartitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPartitionInput>
    public typealias MOutput = OperationOutput<GetPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPartitionOutputError>
}

public struct GetPartitionInput: Equatable {
    /// <p>The ID of the Data Catalog where the partition in question resides. If none is provided,
    ///       the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database where the partition resides.</p>
    public let databaseName: String?
    /// <p>The values that define the partition.</p>
    public let partitionValues: [String]?
    /// <p>The name of the partition's table.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        partitionValues: [String]? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionValues = partitionValues
        self.tableName = tableName
    }
}

struct GetPartitionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let partitionValues: [String]?
}

extension GetPartitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionValues = "PartitionValues"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let partitionValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionValues)
        var partitionValuesDecoded0:[String]? = nil
        if let partitionValuesContainer = partitionValuesContainer {
            partitionValuesDecoded0 = [String]()
            for string0 in partitionValuesContainer {
                if let string0 = string0 {
                    partitionValuesDecoded0?.append(string0)
                }
            }
        }
        partitionValues = partitionValuesDecoded0
    }
}

extension GetPartitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPartitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPartitionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPartitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPartitionOutputResponse(partition: \(String(describing: partition)))"}
}

extension GetPartitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPartitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.partition = output.partition
        } else {
            self.partition = nil
        }
    }
}

public struct GetPartitionOutputResponse: Equatable {
    /// <p>The requested information, in the form of a <code>Partition</code>
    ///       object.</p>
    public let partition: Partition?

    public init (
        partition: Partition? = nil
    )
    {
        self.partition = partition
    }
}

struct GetPartitionOutputResponseBody: Equatable {
    public let partition: Partition?
}

extension GetPartitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case partition = "Partition"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionDecoded = try containerValues.decodeIfPresent(Partition.self, forKey: .partition)
        partition = partitionDecoded
    }
}

public struct GetPartitionsInputBodyMiddleware: Middleware {
    public let id: String = "GetPartitionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPartitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPartitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPartitionsInput>
    public typealias MOutput = OperationOutput<GetPartitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPartitionsOutputError>
}

extension GetPartitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPartitionsInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), excludeColumnSchema: \(String(describing: excludeColumnSchema)), expression: \(String(describing: expression)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), segment: \(String(describing: segment)), tableName: \(String(describing: tableName)))"}
}

extension GetPartitionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case excludeColumnSchema = "ExcludeColumnSchema"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case segment = "Segment"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let excludeColumnSchema = excludeColumnSchema {
            try encodeContainer.encode(excludeColumnSchema, forKey: .excludeColumnSchema)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let segment = segment {
            try encodeContainer.encode(segment, forKey: .segment)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct GetPartitionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetPartitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPartitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPartitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPartitionsInput>
    public typealias MOutput = OperationOutput<GetPartitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPartitionsOutputError>
}

public struct GetPartitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPartitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPartitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPartitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPartitionsInput>
    public typealias MOutput = OperationOutput<GetPartitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPartitionsOutputError>
}

public struct GetPartitionsInput: Equatable {
    /// <p>The ID of the Data Catalog where the partitions in question reside. If none is provided,
    ///       the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database where the partitions reside.</p>
    public let databaseName: String?
    public let excludeColumnSchema: Bool?
    /// <p>An expression that filters the partitions to be returned.</p>
    ///          <p>The expression uses SQL syntax similar to the SQL <code>WHERE</code> filter clause. The
    ///       SQL statement parser <a href="http://jsqlparser.sourceforge.net/home.php">JSQLParser</a> parses the expression. </p>
    ///          <p>
    ///             <i>Operators</i>: The following are the operators that you can use in the
    ///         <code>Expression</code> API call:</p>
    ///          <dl>
    ///             <dt>=</dt>
    ///             <dd>
    ///                <p>Checks whether the values of the two operands are equal; if yes, then the condition becomes
    ///             true.</p>
    ///                <p>Example: Assume 'variable a' holds 10 and 'variable b' holds 20. </p>
    ///                <p>(a = b) is not true.</p>
    ///             </dd>
    ///             <dt>< ></dt>
    ///             <dd>
    ///                <p>Checks whether the values of two operands are equal; if the values are not equal,
    ///             then the condition becomes true.</p>
    ///                <p>Example: (a < > b) is true.</p>
    ///             </dd>
    ///             <dt>></dt>
    ///             <dd>
    ///                <p>Checks whether the value of the left operand is greater than the value of the right
    ///             operand; if yes, then the condition becomes true.</p>
    ///                <p>Example: (a > b) is not true.</p>
    ///             </dd>
    ///             <dt><</dt>
    ///             <dd>
    ///                <p>Checks whether the value of the left operand is less than the value of the right
    ///             operand; if yes, then the condition becomes true.</p>
    ///                <p>Example: (a < b) is true.</p>
    ///             </dd>
    ///             <dt>>=</dt>
    ///             <dd>
    ///                <p>Checks whether the value of the left operand is greater than or equal to the value
    ///             of the right operand; if yes, then the condition becomes true.</p>
    ///                <p>Example: (a >= b) is not true.</p>
    ///             </dd>
    ///             <dt><=</dt>
    ///             <dd>
    ///                <p>Checks whether the value of the left operand is less than or equal to the value of
    ///             the right operand; if yes, then the condition becomes true.</p>
    ///                <p>Example: (a <= b) is true.</p>
    ///             </dd>
    ///             <dt>AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL</dt>
    ///             <dd>
    ///                <p>Logical operators.</p>
    ///             </dd>
    ///          </dl>
    ///          <p>
    ///             <i>Supported Partition Key Types</i>: The following are the supported
    ///       partition keys.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>string</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>date</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>timestamp</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>int</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>bigint</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>long</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>tinyint</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>smallint</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>decimal</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>If an invalid type is encountered, an exception is thrown. </p>
    ///          <p>The following list shows the valid operators on each type. When you define a crawler, the
    ///         <code>partitionKey</code> type is created as a <code>STRING</code>, to be compatible with the catalog
    ///       partitions. </p>
    ///
    ///          <p>
    ///             <i>Sample API Call</i>: </p>
    public let expression: String?
    /// <p>The maximum number of partitions to return in a single response.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is not the first call to retrieve
    ///       these partitions.</p>
    public let nextToken: String?
    /// <p>The segment of the table's partitions to scan in this request.</p>
    public let segment: Segment?
    /// <p>The name of the partitions' table.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        excludeColumnSchema: Bool? = nil,
        expression: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        segment: Segment? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.excludeColumnSchema = excludeColumnSchema
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.segment = segment
        self.tableName = tableName
    }
}

struct GetPartitionsInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let expression: String?
    public let nextToken: String?
    public let segment: Segment?
    public let maxResults: Int?
    public let excludeColumnSchema: Bool?
}

extension GetPartitionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case excludeColumnSchema = "ExcludeColumnSchema"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case segment = "Segment"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(Segment.self, forKey: .segment)
        segment = segmentDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let excludeColumnSchemaDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .excludeColumnSchema)
        excludeColumnSchema = excludeColumnSchemaDecoded
    }
}

extension GetPartitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPartitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPartitionsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPartitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPartitionsOutputResponse(nextToken: \(String(describing: nextToken)), partitions: \(String(describing: partitions)))"}
}

extension GetPartitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPartitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.partitions = output.partitions
        } else {
            self.nextToken = nil
            self.partitions = nil
        }
    }
}

public struct GetPartitionsOutputResponse: Equatable {
    /// <p>A continuation token, if the returned list of partitions does not include the last
    ///       one.</p>
    public let nextToken: String?
    /// <p>A list of requested partitions.</p>
    public let partitions: [Partition]?

    public init (
        nextToken: String? = nil,
        partitions: [Partition]? = nil
    )
    {
        self.nextToken = nextToken
        self.partitions = partitions
    }
}

struct GetPartitionsOutputResponseBody: Equatable {
    public let partitions: [Partition]?
    public let nextToken: String?
}

extension GetPartitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case partitions = "Partitions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionsContainer = try containerValues.decodeIfPresent([Partition?].self, forKey: .partitions)
        var partitionsDecoded0:[Partition]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [Partition]()
            for structure0 in partitionsContainer {
                if let structure0 = structure0 {
                    partitionsDecoded0?.append(structure0)
                }
            }
        }
        partitions = partitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetPlanInputBodyMiddleware: Middleware {
    public let id: String = "GetPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPlanInput>
    public typealias MOutput = OperationOutput<GetPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPlanOutputError>
}

extension GetPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPlanInput(additionalPlanOptionsMap: \(String(describing: additionalPlanOptionsMap)), language: \(String(describing: language)), location: \(String(describing: location)), mapping: \(String(describing: mapping)), sinks: \(String(describing: sinks)), source: \(String(describing: source)))"}
}

extension GetPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalPlanOptionsMap = "AdditionalPlanOptionsMap"
        case language = "Language"
        case location = "Location"
        case mapping = "Mapping"
        case sinks = "Sinks"
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalPlanOptionsMap = additionalPlanOptionsMap {
            var additionalPlanOptionsMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .additionalPlanOptionsMap)
            for (dictKey0, additionalplanoptionsmap0) in additionalPlanOptionsMap {
                try additionalPlanOptionsMapContainer.encode(additionalplanoptionsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let language = language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let mapping = mapping {
            var mappingContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mapping)
            for mappinglist0 in mapping {
                try mappingContainer.encode(mappinglist0)
            }
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for catalogentries0 in sinks {
                try sinksContainer.encode(catalogentries0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

public struct GetPlanInputHeadersMiddleware: Middleware {
    public let id: String = "GetPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPlanInput>
    public typealias MOutput = OperationOutput<GetPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPlanOutputError>
}

public struct GetPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPlanInput>
    public typealias MOutput = OperationOutput<GetPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPlanOutputError>
}

public struct GetPlanInput: Equatable {
    /// <p>A map to hold additional optional key-value parameters.</p>
    /// 	
    /// 	        <p>Currently, these key-value pairs are supported:</p>
    /// 	
    /// 	        <ul>
    ///             <li>
    ///                <p>
    ///                   <code>inferSchema</code>  —  Specifies whether to set <code>inferSchema</code> to true or false for the default script generated by an AWS Glue job. For example, to set <code>inferSchema</code> to true, pass the following key value pair:</p>
    /// 	              <p>
    ///                   <code>--additional-plan-options-map '{"inferSchema":"true"}'</code>
    ///                </p>
    /// 	           </li>
    ///          </ul>
    public let additionalPlanOptionsMap: [String:String]?
    /// <p>The programming language of the code to perform the mapping.</p>
    public let language: Language?
    /// <p>The parameters for the mapping.</p>
    public let location: Location?
    /// <p>The list of mappings from a source table to target tables.</p>
    public let mapping: [MappingEntry]?
    /// <p>The target tables.</p>
    public let sinks: [CatalogEntry]?
    /// <p>The source table.</p>
    public let source: CatalogEntry?

    public init (
        additionalPlanOptionsMap: [String:String]? = nil,
        language: Language? = nil,
        location: Location? = nil,
        mapping: [MappingEntry]? = nil,
        sinks: [CatalogEntry]? = nil,
        source: CatalogEntry? = nil
    )
    {
        self.additionalPlanOptionsMap = additionalPlanOptionsMap
        self.language = language
        self.location = location
        self.mapping = mapping
        self.sinks = sinks
        self.source = source
    }
}

struct GetPlanInputBody: Equatable {
    public let mapping: [MappingEntry]?
    public let source: CatalogEntry?
    public let sinks: [CatalogEntry]?
    public let location: Location?
    public let language: Language?
    public let additionalPlanOptionsMap: [String:String]?
}

extension GetPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case additionalPlanOptionsMap = "AdditionalPlanOptionsMap"
        case language = "Language"
        case location = "Location"
        case mapping = "Mapping"
        case sinks = "Sinks"
        case source = "Source"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mappingContainer = try containerValues.decodeIfPresent([MappingEntry?].self, forKey: .mapping)
        var mappingDecoded0:[MappingEntry]? = nil
        if let mappingContainer = mappingContainer {
            mappingDecoded0 = [MappingEntry]()
            for structure0 in mappingContainer {
                if let structure0 = structure0 {
                    mappingDecoded0?.append(structure0)
                }
            }
        }
        mapping = mappingDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(CatalogEntry.self, forKey: .source)
        source = sourceDecoded
        let sinksContainer = try containerValues.decodeIfPresent([CatalogEntry?].self, forKey: .sinks)
        var sinksDecoded0:[CatalogEntry]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [CatalogEntry]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Language.self, forKey: .language)
        language = languageDecoded
        let additionalPlanOptionsMapContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .additionalPlanOptionsMap)
        var additionalPlanOptionsMapDecoded0: [String:String]? = nil
        if let additionalPlanOptionsMapContainer = additionalPlanOptionsMapContainer {
            additionalPlanOptionsMapDecoded0 = [String:String]()
            for (key0, genericstring0) in additionalPlanOptionsMapContainer {
                if let genericstring0 = genericstring0 {
                    additionalPlanOptionsMapDecoded0?[key0] = genericstring0
                }
            }
        }
        additionalPlanOptionsMap = additionalPlanOptionsMapDecoded0
    }
}

extension GetPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPlanOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPlanOutputResponse(pythonScript: \(String(describing: pythonScript)), scalaCode: \(String(describing: scalaCode)))"}
}

extension GetPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pythonScript = output.pythonScript
            self.scalaCode = output.scalaCode
        } else {
            self.pythonScript = nil
            self.scalaCode = nil
        }
    }
}

public struct GetPlanOutputResponse: Equatable {
    /// <p>A Python script to perform the mapping.</p>
    public let pythonScript: String?
    /// <p>The Scala code to perform the mapping.</p>
    public let scalaCode: String?

    public init (
        pythonScript: String? = nil,
        scalaCode: String? = nil
    )
    {
        self.pythonScript = pythonScript
        self.scalaCode = scalaCode
    }
}

struct GetPlanOutputResponseBody: Equatable {
    public let pythonScript: String?
    public let scalaCode: String?
}

extension GetPlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pythonScript = "PythonScript"
        case scalaCode = "ScalaCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pythonScriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pythonScript)
        pythonScript = pythonScriptDecoded
        let scalaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scalaCode)
        scalaCode = scalaCodeDecoded
    }
}

public struct GetRegistryInputBodyMiddleware: Middleware {
    public let id: String = "GetRegistryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegistryInput>
    public typealias MOutput = OperationOutput<GetRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegistryOutputError>
}

extension GetRegistryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegistryInput(registryId: \(String(describing: registryId)))"}
}

extension GetRegistryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryId = "RegistryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
    }
}

public struct GetRegistryInputHeadersMiddleware: Middleware {
    public let id: String = "GetRegistryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegistryInput>
    public typealias MOutput = OperationOutput<GetRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegistryOutputError>
}

public struct GetRegistryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRegistryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegistryInput>
    public typealias MOutput = OperationOutput<GetRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegistryOutputError>
}

public struct GetRegistryInput: Equatable {
    /// <p>This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).</p>
    public let registryId: RegistryId?

    public init (
        registryId: RegistryId? = nil
    )
    {
        self.registryId = registryId
    }
}

struct GetRegistryInputBody: Equatable {
    public let registryId: RegistryId?
}

extension GetRegistryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId = "RegistryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(RegistryId.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

extension GetRegistryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegistryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRegistryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegistryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegistryOutputResponse(createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)), status: \(String(describing: status)), updatedTime: \(String(describing: updatedTime)))"}
}

extension GetRegistryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRegistryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdTime = output.createdTime
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.status = output.status
            self.updatedTime = output.updatedTime
        } else {
            self.createdTime = nil
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.status = nil
            self.updatedTime = nil
        }
    }
}

public struct GetRegistryOutputResponse: Equatable {
    /// <p>The date and time the registry was created.</p>
    public let createdTime: String?
    /// <p>A description of the registry.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the registry.</p>
    public let registryArn: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The status of the registry.</p>
    public let status: RegistryStatus?
    /// <p>The date and time the registry was updated.</p>
    public let updatedTime: String?

    public init (
        createdTime: String? = nil,
        description: String? = nil,
        registryArn: String? = nil,
        registryName: String? = nil,
        status: RegistryStatus? = nil,
        updatedTime: String? = nil
    )
    {
        self.createdTime = createdTime
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.status = status
        self.updatedTime = updatedTime
    }
}

struct GetRegistryOutputResponseBody: Equatable {
    public let registryName: String?
    public let registryArn: String?
    public let description: String?
    public let status: RegistryStatus?
    public let createdTime: String?
    public let updatedTime: String?
}

extension GetRegistryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case status = "Status"
        case updatedTime = "UpdatedTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RegistryStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
    }
}

public struct GetResourcePoliciesInputBodyMiddleware: Middleware {
    public let id: String = "GetResourcePoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePoliciesOutputError>
}

extension GetResourcePoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePoliciesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetResourcePoliciesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetResourcePoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourcePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourcePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInput: Equatable {
    /// <p>The maximum size of a list to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetResourcePoliciesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetResourcePoliciesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourcePoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePoliciesOutputError: Equatable {
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePoliciesOutputResponse(getResourcePoliciesResponseList: \(String(describing: getResourcePoliciesResponseList)), nextToken: \(String(describing: nextToken)))"}
}

extension GetResourcePoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourcePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.getResourcePoliciesResponseList = output.getResourcePoliciesResponseList
            self.nextToken = output.nextToken
        } else {
            self.getResourcePoliciesResponseList = nil
            self.nextToken = nil
        }
    }
}

public struct GetResourcePoliciesOutputResponse: Equatable {
    /// <p>A list of the individual resource policies and the account-level resource policy.</p>
    public let getResourcePoliciesResponseList: [GluePolicy]?
    /// <p>A continuation token, if the returned list does not contain the last resource policy available.</p>
    public let nextToken: String?

    public init (
        getResourcePoliciesResponseList: [GluePolicy]? = nil,
        nextToken: String? = nil
    )
    {
        self.getResourcePoliciesResponseList = getResourcePoliciesResponseList
        self.nextToken = nextToken
    }
}

struct GetResourcePoliciesOutputResponseBody: Equatable {
    public let getResourcePoliciesResponseList: [GluePolicy]?
    public let nextToken: String?
}

extension GetResourcePoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case getResourcePoliciesResponseList = "GetResourcePoliciesResponseList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let getResourcePoliciesResponseListContainer = try containerValues.decodeIfPresent([GluePolicy?].self, forKey: .getResourcePoliciesResponseList)
        var getResourcePoliciesResponseListDecoded0:[GluePolicy]? = nil
        if let getResourcePoliciesResponseListContainer = getResourcePoliciesResponseListContainer {
            getResourcePoliciesResponseListDecoded0 = [GluePolicy]()
            for structure0 in getResourcePoliciesResponseListContainer {
                if let structure0 = structure0 {
                    getResourcePoliciesResponseListDecoded0?.append(structure0)
                }
            }
        }
        getResourcePoliciesResponseList = getResourcePoliciesResponseListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePolicyOutputError>
}

extension GetResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension GetResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct GetResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePolicyInput>
    public typealias MOutput = OperationOutput<GetResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePolicyOutputError>
}

public struct GetResourcePolicyInput: Equatable {
    /// <p>The ARN of the AWS Glue resource for which to retrieve the resource policy. If not
    ///       supplied, the Data Catalog resource policy is returned. Use <code>GetResourcePolicies</code>
    ///       to view all existing resource policies. For more information see <a href="https://docs.aws.amazon.com/glue/latest/dg/glue-specifying-resource-arns.html">Specifying AWS Glue Resource ARNs</a>.
    ///     </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourcePolicyInputBody: Equatable {
    public let resourceArn: String?
}

extension GetResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePolicyOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePolicyOutputResponse(createTime: \(String(describing: createTime)), policyHash: \(String(describing: policyHash)), policyInJson: \(String(describing: policyInJson)), updateTime: \(String(describing: updateTime)))"}
}

extension GetResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createTime = output.createTime
            self.policyHash = output.policyHash
            self.policyInJson = output.policyInJson
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.policyHash = nil
            self.policyInJson = nil
            self.updateTime = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Equatable {
    /// <p>The date and time at which the policy was created.</p>
    public let createTime: Date?
    /// <p>Contains the hash value associated with this policy.</p>
    public let policyHash: String?
    /// <p>Contains the requested policy document, in JSON format.</p>
    public let policyInJson: String?
    /// <p>The date and time at which the policy was last updated.</p>
    public let updateTime: Date?

    public init (
        createTime: Date? = nil,
        policyHash: String? = nil,
        policyInJson: String? = nil,
        updateTime: Date? = nil
    )
    {
        self.createTime = createTime
        self.policyHash = policyHash
        self.policyInJson = policyInJson
        self.updateTime = updateTime
    }
}

struct GetResourcePolicyOutputResponseBody: Equatable {
    public let policyInJson: String?
    public let policyHash: String?
    public let createTime: Date?
    public let updateTime: Date?
}

extension GetResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createTime = "CreateTime"
        case policyHash = "PolicyHash"
        case policyInJson = "PolicyInJson"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyInJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyInJson)
        policyInJson = policyInJsonDecoded
        let policyHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyHash)
        policyHash = policyHashDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

public struct GetSchemaByDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "GetSchemaByDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaByDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaByDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaByDefinitionInput>
    public typealias MOutput = OperationOutput<GetSchemaByDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaByDefinitionOutputError>
}

extension GetSchemaByDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaByDefinitionInput(schemaDefinition: \(String(describing: schemaDefinition)), schemaId: \(String(describing: schemaId)))"}
}

extension GetSchemaByDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaDefinition = "SchemaDefinition"
        case schemaId = "SchemaId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaDefinition = schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
    }
}

public struct GetSchemaByDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetSchemaByDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaByDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaByDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaByDefinitionInput>
    public typealias MOutput = OperationOutput<GetSchemaByDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaByDefinitionOutputError>
}

public struct GetSchemaByDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSchemaByDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaByDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaByDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaByDefinitionInput>
    public typealias MOutput = OperationOutput<GetSchemaByDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaByDefinitionOutputError>
}

public struct GetSchemaByDefinitionInput: Equatable {
    /// <p>The definition of the schema for which schema details are required.</p>
    public let schemaDefinition: String?
    /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>SchemaId$SchemaName: The name of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    ///             </li>
    ///          </ul>
    public let schemaId: SchemaId?

    public init (
        schemaDefinition: String? = nil,
        schemaId: SchemaId? = nil
    )
    {
        self.schemaDefinition = schemaDefinition
        self.schemaId = schemaId
    }
}

struct GetSchemaByDefinitionInputBody: Equatable {
    public let schemaId: SchemaId?
    public let schemaDefinition: String?
}

extension GetSchemaByDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaDefinition = "SchemaDefinition"
        case schemaId = "SchemaId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension GetSchemaByDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSchemaByDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSchemaByDefinitionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSchemaByDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaByDefinitionOutputResponse(createdTime: \(String(describing: createdTime)), dataFormat: \(String(describing: dataFormat)), schemaArn: \(String(describing: schemaArn)), schemaVersionId: \(String(describing: schemaVersionId)), status: \(String(describing: status)))"}
}

extension GetSchemaByDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSchemaByDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdTime = output.createdTime
            self.dataFormat = output.dataFormat
            self.schemaArn = output.schemaArn
            self.schemaVersionId = output.schemaVersionId
            self.status = output.status
        } else {
            self.createdTime = nil
            self.dataFormat = nil
            self.schemaArn = nil
            self.schemaVersionId = nil
            self.status = nil
        }
    }
}

public struct GetSchemaByDefinitionOutputResponse: Equatable {
    /// <p>The date and time the schema was created.</p>
    public let createdTime: String?
    /// <p>The data format of the schema definition. Currently only <code>AVRO</code> is supported.</p>
    public let dataFormat: DataFormat?
    /// <p>The Amazon Resource Name (ARN) of the schema.</p>
    public let schemaArn: String?
    /// <p>The schema ID of the schema version.</p>
    public let schemaVersionId: String?
    /// <p>The status of the schema version.</p>
    public let status: SchemaVersionStatus?

    public init (
        createdTime: String? = nil,
        dataFormat: DataFormat? = nil,
        schemaArn: String? = nil,
        schemaVersionId: String? = nil,
        status: SchemaVersionStatus? = nil
    )
    {
        self.createdTime = createdTime
        self.dataFormat = dataFormat
        self.schemaArn = schemaArn
        self.schemaVersionId = schemaVersionId
        self.status = status
    }
}

struct GetSchemaByDefinitionOutputResponseBody: Equatable {
    public let schemaVersionId: String?
    public let schemaArn: String?
    public let dataFormat: DataFormat?
    public let status: SchemaVersionStatus?
    public let createdTime: String?
}

extension GetSchemaByDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case dataFormat = "DataFormat"
        case schemaArn = "SchemaArn"
        case schemaVersionId = "SchemaVersionId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SchemaVersionStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

public struct GetSchemaInputBodyMiddleware: Middleware {
    public let id: String = "GetSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaInput>
    public typealias MOutput = OperationOutput<GetSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaOutputError>
}

extension GetSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaInput(schemaId: \(String(describing: schemaId)))"}
}

extension GetSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaId = "SchemaId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
    }
}

public struct GetSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "GetSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaInput>
    public typealias MOutput = OperationOutput<GetSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaOutputError>
}

public struct GetSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaInput>
    public typealias MOutput = OperationOutput<GetSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaOutputError>
}

public struct GetSchemaInput: Equatable {
    /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>SchemaId$SchemaName: The name of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
    ///             </li>
    ///          </ul>
    public let schemaId: SchemaId?

    public init (
        schemaId: SchemaId? = nil
    )
    {
        self.schemaId = schemaId
    }
}

struct GetSchemaInputBody: Equatable {
    public let schemaId: SchemaId?
}

extension GetSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaId = "SchemaId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
    }
}

extension GetSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSchemaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaOutputResponse(compatibility: \(String(describing: compatibility)), createdTime: \(String(describing: createdTime)), dataFormat: \(String(describing: dataFormat)), description: \(String(describing: description)), latestSchemaVersion: \(String(describing: latestSchemaVersion)), nextSchemaVersion: \(String(describing: nextSchemaVersion)), registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)), schemaArn: \(String(describing: schemaArn)), schemaCheckpoint: \(String(describing: schemaCheckpoint)), schemaName: \(String(describing: schemaName)), schemaStatus: \(String(describing: schemaStatus)), updatedTime: \(String(describing: updatedTime)))"}
}

extension GetSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.compatibility = output.compatibility
            self.createdTime = output.createdTime
            self.dataFormat = output.dataFormat
            self.description = output.description
            self.latestSchemaVersion = output.latestSchemaVersion
            self.nextSchemaVersion = output.nextSchemaVersion
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.schemaArn = output.schemaArn
            self.schemaCheckpoint = output.schemaCheckpoint
            self.schemaName = output.schemaName
            self.schemaStatus = output.schemaStatus
            self.updatedTime = output.updatedTime
        } else {
            self.compatibility = nil
            self.createdTime = nil
            self.dataFormat = nil
            self.description = nil
            self.latestSchemaVersion = 0
            self.nextSchemaVersion = 0
            self.registryArn = nil
            self.registryName = nil
            self.schemaArn = nil
            self.schemaCheckpoint = 0
            self.schemaName = nil
            self.schemaStatus = nil
            self.updatedTime = nil
        }
    }
}

public struct GetSchemaOutputResponse: Equatable {
    /// <p>The compatibility mode of the schema.</p>
    public let compatibility: Compatibility?
    /// <p>The date and time the schema was created.</p>
    public let createdTime: String?
    /// <p>The data format of the schema definition. Currently only <code>AVRO</code> is supported.</p>
    public let dataFormat: DataFormat?
    /// <p>A description of schema if specified when created</p>
    public let description: String?
    /// <p>The latest version of the schema associated with the returned schema definition.</p>
    public let latestSchemaVersion: Int
    /// <p>The next version of the schema associated with the returned schema definition.</p>
    public let nextSchemaVersion: Int
    /// <p>The Amazon Resource Name (ARN) of the registry.</p>
    public let registryArn: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The Amazon Resource Name (ARN) of the schema.</p>
    public let schemaArn: String?
    /// <p>The version number of the checkpoint (the last time the compatibility mode was changed).</p>
    public let schemaCheckpoint: Int
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>The status of the schema.</p>
    public let schemaStatus: SchemaStatus?
    /// <p>The date and time the schema was updated.</p>
    public let updatedTime: String?

    public init (
        compatibility: Compatibility? = nil,
        createdTime: String? = nil,
        dataFormat: DataFormat? = nil,
        description: String? = nil,
        latestSchemaVersion: Int = 0,
        nextSchemaVersion: Int = 0,
        registryArn: String? = nil,
        registryName: String? = nil,
        schemaArn: String? = nil,
        schemaCheckpoint: Int = 0,
        schemaName: String? = nil,
        schemaStatus: SchemaStatus? = nil,
        updatedTime: String? = nil
    )
    {
        self.compatibility = compatibility
        self.createdTime = createdTime
        self.dataFormat = dataFormat
        self.description = description
        self.latestSchemaVersion = latestSchemaVersion
        self.nextSchemaVersion = nextSchemaVersion
        self.registryArn = registryArn
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaCheckpoint = schemaCheckpoint
        self.schemaName = schemaName
        self.schemaStatus = schemaStatus
        self.updatedTime = updatedTime
    }
}

struct GetSchemaOutputResponseBody: Equatable {
    public let registryName: String?
    public let registryArn: String?
    public let schemaName: String?
    public let schemaArn: String?
    public let description: String?
    public let dataFormat: DataFormat?
    public let compatibility: Compatibility?
    public let schemaCheckpoint: Int
    public let latestSchemaVersion: Int
    public let nextSchemaVersion: Int
    public let schemaStatus: SchemaStatus?
    public let createdTime: String?
    public let updatedTime: String?
}

extension GetSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibility = "Compatibility"
        case createdTime = "CreatedTime"
        case dataFormat = "DataFormat"
        case description = "Description"
        case latestSchemaVersion = "LatestSchemaVersion"
        case nextSchemaVersion = "NextSchemaVersion"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case schemaArn = "SchemaArn"
        case schemaCheckpoint = "SchemaCheckpoint"
        case schemaName = "SchemaName"
        case schemaStatus = "SchemaStatus"
        case updatedTime = "UpdatedTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let compatibilityDecoded = try containerValues.decodeIfPresent(Compatibility.self, forKey: .compatibility)
        compatibility = compatibilityDecoded
        let schemaCheckpointDecoded = try containerValues.decode(Int.self, forKey: .schemaCheckpoint)
        schemaCheckpoint = schemaCheckpointDecoded
        let latestSchemaVersionDecoded = try containerValues.decode(Int.self, forKey: .latestSchemaVersion)
        latestSchemaVersion = latestSchemaVersionDecoded
        let nextSchemaVersionDecoded = try containerValues.decode(Int.self, forKey: .nextSchemaVersion)
        nextSchemaVersion = nextSchemaVersionDecoded
        let schemaStatusDecoded = try containerValues.decodeIfPresent(SchemaStatus.self, forKey: .schemaStatus)
        schemaStatus = schemaStatusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
    }
}

public struct GetSchemaVersionInputBodyMiddleware: Middleware {
    public let id: String = "GetSchemaVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaVersionInput>
    public typealias MOutput = OperationOutput<GetSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaVersionOutputError>
}

extension GetSchemaVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaVersionInput(schemaId: \(String(describing: schemaId)), schemaVersionId: \(String(describing: schemaVersionId)), schemaVersionNumber: \(String(describing: schemaVersionNumber)))"}
}

extension GetSchemaVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaId = "SchemaId"
        case schemaVersionId = "SchemaVersionId"
        case schemaVersionNumber = "SchemaVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let schemaVersionId = schemaVersionId {
            try encodeContainer.encode(schemaVersionId, forKey: .schemaVersionId)
        }
        if let schemaVersionNumber = schemaVersionNumber {
            try encodeContainer.encode(schemaVersionNumber, forKey: .schemaVersionNumber)
        }
    }
}

public struct GetSchemaVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetSchemaVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaVersionInput>
    public typealias MOutput = OperationOutput<GetSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaVersionOutputError>
}

public struct GetSchemaVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSchemaVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaVersionInput>
    public typealias MOutput = OperationOutput<GetSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaVersionOutputError>
}

public struct GetSchemaVersionInput: Equatable {
    /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>SchemaId$SchemaName: The name of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
    ///             </li>
    ///          </ul>
    public let schemaId: SchemaId?
    /// <p>The <code>SchemaVersionId</code> of the schema version. This field is required for fetching by schema ID. Either this or the <code>SchemaId</code> wrapper has to be provided.</p>
    public let schemaVersionId: String?
    /// <p>The version number of the schema.</p>
    public let schemaVersionNumber: SchemaVersionNumber?

    public init (
        schemaId: SchemaId? = nil,
        schemaVersionId: String? = nil,
        schemaVersionNumber: SchemaVersionNumber? = nil
    )
    {
        self.schemaId = schemaId
        self.schemaVersionId = schemaVersionId
        self.schemaVersionNumber = schemaVersionNumber
    }
}

struct GetSchemaVersionInputBody: Equatable {
    public let schemaId: SchemaId?
    public let schemaVersionId: String?
    public let schemaVersionNumber: SchemaVersionNumber?
}

extension GetSchemaVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaId = "SchemaId"
        case schemaVersionId = "SchemaVersionId"
        case schemaVersionNumber = "SchemaVersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let schemaVersionNumberDecoded = try containerValues.decodeIfPresent(SchemaVersionNumber.self, forKey: .schemaVersionNumber)
        schemaVersionNumber = schemaVersionNumberDecoded
    }
}

extension GetSchemaVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSchemaVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSchemaVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSchemaVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaVersionOutputResponse(createdTime: \(String(describing: createdTime)), dataFormat: \(String(describing: dataFormat)), schemaArn: \(String(describing: schemaArn)), schemaDefinition: \(String(describing: schemaDefinition)), schemaVersionId: \(String(describing: schemaVersionId)), status: \(String(describing: status)), versionNumber: \(String(describing: versionNumber)))"}
}

extension GetSchemaVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSchemaVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdTime = output.createdTime
            self.dataFormat = output.dataFormat
            self.schemaArn = output.schemaArn
            self.schemaDefinition = output.schemaDefinition
            self.schemaVersionId = output.schemaVersionId
            self.status = output.status
            self.versionNumber = output.versionNumber
        } else {
            self.createdTime = nil
            self.dataFormat = nil
            self.schemaArn = nil
            self.schemaDefinition = nil
            self.schemaVersionId = nil
            self.status = nil
            self.versionNumber = 0
        }
    }
}

public struct GetSchemaVersionOutputResponse: Equatable {
    /// <p>The date and time the schema version was created.</p>
    public let createdTime: String?
    /// <p>The data format of the schema definition. Currently only <code>AVRO</code> is supported.</p>
    public let dataFormat: DataFormat?
    /// <p>The Amazon Resource Name (ARN) of the schema.</p>
    public let schemaArn: String?
    /// <p>The schema definition for the schema ID.</p>
    public let schemaDefinition: String?
    /// <p>The <code>SchemaVersionId</code> of the schema version.</p>
    public let schemaVersionId: String?
    /// <p>The status of the schema version. </p>
    public let status: SchemaVersionStatus?
    /// <p>The version number of the schema.</p>
    public let versionNumber: Int

    public init (
        createdTime: String? = nil,
        dataFormat: DataFormat? = nil,
        schemaArn: String? = nil,
        schemaDefinition: String? = nil,
        schemaVersionId: String? = nil,
        status: SchemaVersionStatus? = nil,
        versionNumber: Int = 0
    )
    {
        self.createdTime = createdTime
        self.dataFormat = dataFormat
        self.schemaArn = schemaArn
        self.schemaDefinition = schemaDefinition
        self.schemaVersionId = schemaVersionId
        self.status = status
        self.versionNumber = versionNumber
    }
}

struct GetSchemaVersionOutputResponseBody: Equatable {
    public let schemaVersionId: String?
    public let schemaDefinition: String?
    public let dataFormat: DataFormat?
    public let schemaArn: String?
    public let versionNumber: Int
    public let status: SchemaVersionStatus?
    public let createdTime: String?
}

extension GetSchemaVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case dataFormat = "DataFormat"
        case schemaArn = "SchemaArn"
        case schemaDefinition = "SchemaDefinition"
        case schemaVersionId = "SchemaVersionId"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SchemaVersionStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

public struct GetSchemaVersionsDiffInputBodyMiddleware: Middleware {
    public let id: String = "GetSchemaVersionsDiffInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaVersionsDiffInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaVersionsDiffOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaVersionsDiffInput>
    public typealias MOutput = OperationOutput<GetSchemaVersionsDiffOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaVersionsDiffOutputError>
}

extension GetSchemaVersionsDiffInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaVersionsDiffInput(firstSchemaVersionNumber: \(String(describing: firstSchemaVersionNumber)), schemaDiffType: \(String(describing: schemaDiffType)), schemaId: \(String(describing: schemaId)), secondSchemaVersionNumber: \(String(describing: secondSchemaVersionNumber)))"}
}

extension GetSchemaVersionsDiffInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firstSchemaVersionNumber = "FirstSchemaVersionNumber"
        case schemaDiffType = "SchemaDiffType"
        case schemaId = "SchemaId"
        case secondSchemaVersionNumber = "SecondSchemaVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firstSchemaVersionNumber = firstSchemaVersionNumber {
            try encodeContainer.encode(firstSchemaVersionNumber, forKey: .firstSchemaVersionNumber)
        }
        if let schemaDiffType = schemaDiffType {
            try encodeContainer.encode(schemaDiffType.rawValue, forKey: .schemaDiffType)
        }
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let secondSchemaVersionNumber = secondSchemaVersionNumber {
            try encodeContainer.encode(secondSchemaVersionNumber, forKey: .secondSchemaVersionNumber)
        }
    }
}

public struct GetSchemaVersionsDiffInputHeadersMiddleware: Middleware {
    public let id: String = "GetSchemaVersionsDiffInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaVersionsDiffInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaVersionsDiffOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaVersionsDiffInput>
    public typealias MOutput = OperationOutput<GetSchemaVersionsDiffOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaVersionsDiffOutputError>
}

public struct GetSchemaVersionsDiffInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSchemaVersionsDiffInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaVersionsDiffInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaVersionsDiffOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaVersionsDiffInput>
    public typealias MOutput = OperationOutput<GetSchemaVersionsDiffOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaVersionsDiffOutputError>
}

public struct GetSchemaVersionsDiffInput: Equatable {
    /// <p>The first of the two schema versions to be compared.</p>
    public let firstSchemaVersionNumber: SchemaVersionNumber?
    /// <p>Refers to <code>SYNTAX_DIFF</code>, which is the currently supported diff type.</p>
    public let schemaDiffType: SchemaDiffType?
    /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>SchemaId$SchemaName: The name of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    ///             </li>
    ///          </ul>
    public let schemaId: SchemaId?
    /// <p>The second of the two schema versions to be compared.</p>
    public let secondSchemaVersionNumber: SchemaVersionNumber?

    public init (
        firstSchemaVersionNumber: SchemaVersionNumber? = nil,
        schemaDiffType: SchemaDiffType? = nil,
        schemaId: SchemaId? = nil,
        secondSchemaVersionNumber: SchemaVersionNumber? = nil
    )
    {
        self.firstSchemaVersionNumber = firstSchemaVersionNumber
        self.schemaDiffType = schemaDiffType
        self.schemaId = schemaId
        self.secondSchemaVersionNumber = secondSchemaVersionNumber
    }
}

struct GetSchemaVersionsDiffInputBody: Equatable {
    public let schemaId: SchemaId?
    public let firstSchemaVersionNumber: SchemaVersionNumber?
    public let secondSchemaVersionNumber: SchemaVersionNumber?
    public let schemaDiffType: SchemaDiffType?
}

extension GetSchemaVersionsDiffInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firstSchemaVersionNumber = "FirstSchemaVersionNumber"
        case schemaDiffType = "SchemaDiffType"
        case schemaId = "SchemaId"
        case secondSchemaVersionNumber = "SecondSchemaVersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let firstSchemaVersionNumberDecoded = try containerValues.decodeIfPresent(SchemaVersionNumber.self, forKey: .firstSchemaVersionNumber)
        firstSchemaVersionNumber = firstSchemaVersionNumberDecoded
        let secondSchemaVersionNumberDecoded = try containerValues.decodeIfPresent(SchemaVersionNumber.self, forKey: .secondSchemaVersionNumber)
        secondSchemaVersionNumber = secondSchemaVersionNumberDecoded
        let schemaDiffTypeDecoded = try containerValues.decodeIfPresent(SchemaDiffType.self, forKey: .schemaDiffType)
        schemaDiffType = schemaDiffTypeDecoded
    }
}

extension GetSchemaVersionsDiffOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSchemaVersionsDiffOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSchemaVersionsDiffOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSchemaVersionsDiffOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaVersionsDiffOutputResponse(diff: \(String(describing: diff)))"}
}

extension GetSchemaVersionsDiffOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSchemaVersionsDiffOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.diff = output.diff
        } else {
            self.diff = nil
        }
    }
}

public struct GetSchemaVersionsDiffOutputResponse: Equatable {
    /// <p>The difference between schemas as a string in JsonPatch format.</p>
    public let diff: String?

    public init (
        diff: String? = nil
    )
    {
        self.diff = diff
    }
}

struct GetSchemaVersionsDiffOutputResponseBody: Equatable {
    public let diff: String?
}

extension GetSchemaVersionsDiffOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case diff = "Diff"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let diffDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diff)
        diff = diffDecoded
    }
}

public struct GetSecurityConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetSecurityConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSecurityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSecurityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSecurityConfigurationInput>
    public typealias MOutput = OperationOutput<GetSecurityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSecurityConfigurationOutputError>
}

extension GetSecurityConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSecurityConfigurationInput(name: \(String(describing: name)))"}
}

extension GetSecurityConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetSecurityConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetSecurityConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSecurityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSecurityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSecurityConfigurationInput>
    public typealias MOutput = OperationOutput<GetSecurityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSecurityConfigurationOutputError>
}

public struct GetSecurityConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSecurityConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSecurityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSecurityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSecurityConfigurationInput>
    public typealias MOutput = OperationOutput<GetSecurityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSecurityConfigurationOutputError>
}

public struct GetSecurityConfigurationInput: Equatable {
    /// <p>The name of the security configuration to retrieve.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetSecurityConfigurationInputBody: Equatable {
    public let name: String?
}

extension GetSecurityConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetSecurityConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSecurityConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSecurityConfigurationOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSecurityConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSecurityConfigurationOutputResponse(securityConfiguration: \(String(describing: securityConfiguration)))"}
}

extension GetSecurityConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSecurityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.securityConfiguration = output.securityConfiguration
        } else {
            self.securityConfiguration = nil
        }
    }
}

public struct GetSecurityConfigurationOutputResponse: Equatable {
    /// <p>The requested security configuration.</p>
    public let securityConfiguration: SecurityConfiguration?

    public init (
        securityConfiguration: SecurityConfiguration? = nil
    )
    {
        self.securityConfiguration = securityConfiguration
    }
}

struct GetSecurityConfigurationOutputResponseBody: Equatable {
    public let securityConfiguration: SecurityConfiguration?
}

extension GetSecurityConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case securityConfiguration = "SecurityConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityConfigurationDecoded = try containerValues.decodeIfPresent(SecurityConfiguration.self, forKey: .securityConfiguration)
        securityConfiguration = securityConfigurationDecoded
    }
}

public struct GetSecurityConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "GetSecurityConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSecurityConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSecurityConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSecurityConfigurationsInput>
    public typealias MOutput = OperationOutput<GetSecurityConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSecurityConfigurationsOutputError>
}

extension GetSecurityConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSecurityConfigurationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetSecurityConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetSecurityConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSecurityConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSecurityConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSecurityConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSecurityConfigurationsInput>
    public typealias MOutput = OperationOutput<GetSecurityConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSecurityConfigurationsOutputError>
}

public struct GetSecurityConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSecurityConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSecurityConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSecurityConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSecurityConfigurationsInput>
    public typealias MOutput = OperationOutput<GetSecurityConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSecurityConfigurationsOutputError>
}

public struct GetSecurityConfigurationsInput: Equatable {
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetSecurityConfigurationsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetSecurityConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSecurityConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSecurityConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSecurityConfigurationsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSecurityConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSecurityConfigurationsOutputResponse(nextToken: \(String(describing: nextToken)), securityConfigurations: \(String(describing: securityConfigurations)))"}
}

extension GetSecurityConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSecurityConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.securityConfigurations = output.securityConfigurations
        } else {
            self.nextToken = nil
            self.securityConfigurations = nil
        }
    }
}

public struct GetSecurityConfigurationsOutputResponse: Equatable {
    /// <p>A continuation token, if there are more security
    ///       configurations to return.</p>
    public let nextToken: String?
    /// <p>A list of security configurations.</p>
    public let securityConfigurations: [SecurityConfiguration]?

    public init (
        nextToken: String? = nil,
        securityConfigurations: [SecurityConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityConfigurations = securityConfigurations
    }
}

struct GetSecurityConfigurationsOutputResponseBody: Equatable {
    public let securityConfigurations: [SecurityConfiguration]?
    public let nextToken: String?
}

extension GetSecurityConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case securityConfigurations = "SecurityConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityConfigurationsContainer = try containerValues.decodeIfPresent([SecurityConfiguration?].self, forKey: .securityConfigurations)
        var securityConfigurationsDecoded0:[SecurityConfiguration]? = nil
        if let securityConfigurationsContainer = securityConfigurationsContainer {
            securityConfigurationsDecoded0 = [SecurityConfiguration]()
            for structure0 in securityConfigurationsContainer {
                if let structure0 = structure0 {
                    securityConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        securityConfigurations = securityConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetTableInputBodyMiddleware: Middleware {
    public let id: String = "GetTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableInput>
    public typealias MOutput = OperationOutput<GetTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableOutputError>
}

extension GetTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTableInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), name: \(String(describing: name)))"}
}

extension GetTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetTableInputHeadersMiddleware: Middleware {
    public let id: String = "GetTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableInput>
    public typealias MOutput = OperationOutput<GetTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableOutputError>
}

public struct GetTableInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableInput>
    public typealias MOutput = OperationOutput<GetTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableOutputError>
}

public struct GetTableInput: Equatable {
    /// <p>The ID of the Data Catalog where the table resides. If none is provided, the AWS account
    ///       ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the database in the catalog in which the table resides.
    ///       For Hive compatibility, this name is entirely lowercase.</p>
    public let databaseName: String?
    /// <p>The name of the table for which to retrieve the definition. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let name: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        name: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.name = name
    }
}

struct GetTableInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let name: String?
}

extension GetTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTableOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTableOutputResponse(table: \(String(describing: table)))"}
}

extension GetTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTableOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.table = output.table
        } else {
            self.table = nil
        }
    }
}

public struct GetTableOutputResponse: Equatable {
    /// <p>The <code>Table</code> object that defines the specified table.</p>
    public let table: Table?

    public init (
        table: Table? = nil
    )
    {
        self.table = table
    }
}

struct GetTableOutputResponseBody: Equatable {
    public let table: Table?
}

extension GetTableOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case table = "Table"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(Table.self, forKey: .table)
        table = tableDecoded
    }
}

public struct GetTableVersionInputBodyMiddleware: Middleware {
    public let id: String = "GetTableVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableVersionInput>
    public typealias MOutput = OperationOutput<GetTableVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableVersionOutputError>
}

extension GetTableVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTableVersionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)), versionId: \(String(describing: versionId)))"}
}

extension GetTableVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }
}

public struct GetTableVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetTableVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableVersionInput>
    public typealias MOutput = OperationOutput<GetTableVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableVersionOutputError>
}

public struct GetTableVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTableVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableVersionInput>
    public typealias MOutput = OperationOutput<GetTableVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableVersionOutputError>
}

public struct GetTableVersionInput: Equatable {
    /// <p>The ID of the Data Catalog where the tables reside. If none is provided, the AWS account
    ///       ID is used by default.</p>
    public let catalogId: String?
    /// <p>The database in the catalog in which the table resides. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let databaseName: String?
    /// <p>The name of the table. For Hive compatibility,
    ///       this name is entirely lowercase.</p>
    public let tableName: String?
    /// <p>The ID value of the table version to be retrieved. A <code>VersionID</code> is a string representation of an integer. Each version is incremented by 1. </p>
    public let versionId: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        tableName: String? = nil,
        versionId: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.versionId = versionId
    }
}

struct GetTableVersionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let versionId: String?
}

extension GetTableVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
        case versionId = "VersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension GetTableVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTableVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTableVersionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTableVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTableVersionOutputResponse(tableVersion: \(String(describing: tableVersion)))"}
}

extension GetTableVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTableVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tableVersion = output.tableVersion
        } else {
            self.tableVersion = nil
        }
    }
}

public struct GetTableVersionOutputResponse: Equatable {
    /// <p>The requested table version.</p>
    public let tableVersion: TableVersion?

    public init (
        tableVersion: TableVersion? = nil
    )
    {
        self.tableVersion = tableVersion
    }
}

struct GetTableVersionOutputResponseBody: Equatable {
    public let tableVersion: TableVersion?
}

extension GetTableVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tableVersion = "TableVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableVersionDecoded = try containerValues.decodeIfPresent(TableVersion.self, forKey: .tableVersion)
        tableVersion = tableVersionDecoded
    }
}

public struct GetTableVersionsInputBodyMiddleware: Middleware {
    public let id: String = "GetTableVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableVersionsInput>
    public typealias MOutput = OperationOutput<GetTableVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableVersionsOutputError>
}

extension GetTableVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTableVersionsInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), tableName: \(String(describing: tableName)))"}
}

extension GetTableVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct GetTableVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetTableVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableVersionsInput>
    public typealias MOutput = OperationOutput<GetTableVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableVersionsOutputError>
}

public struct GetTableVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTableVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableVersionsInput>
    public typealias MOutput = OperationOutput<GetTableVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableVersionsOutputError>
}

public struct GetTableVersionsInput: Equatable {
    /// <p>The ID of the Data Catalog where the tables reside. If none is provided, the AWS account
    ///       ID is used by default.</p>
    public let catalogId: String?
    /// <p>The database in the catalog in which the table resides. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let databaseName: String?
    /// <p>The maximum number of table versions to return in one response.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is not the first call.</p>
    public let nextToken: String?
    /// <p>The name of the table. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tableName = tableName
    }
}

struct GetTableVersionsInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetTableVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetTableVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTableVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTableVersionsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTableVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTableVersionsOutputResponse(nextToken: \(String(describing: nextToken)), tableVersions: \(String(describing: tableVersions)))"}
}

extension GetTableVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTableVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tableVersions = output.tableVersions
        } else {
            self.nextToken = nil
            self.tableVersions = nil
        }
    }
}

public struct GetTableVersionsOutputResponse: Equatable {
    /// <p>A continuation token, if the list of available versions does
    ///       not include the last one.</p>
    public let nextToken: String?
    /// <p>A list of strings identifying available versions of the
    ///       specified table.</p>
    public let tableVersions: [TableVersion]?

    public init (
        nextToken: String? = nil,
        tableVersions: [TableVersion]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableVersions = tableVersions
    }
}

struct GetTableVersionsOutputResponseBody: Equatable {
    public let tableVersions: [TableVersion]?
    public let nextToken: String?
}

extension GetTableVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tableVersions = "TableVersions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableVersionsContainer = try containerValues.decodeIfPresent([TableVersion?].self, forKey: .tableVersions)
        var tableVersionsDecoded0:[TableVersion]? = nil
        if let tableVersionsContainer = tableVersionsContainer {
            tableVersionsDecoded0 = [TableVersion]()
            for structure0 in tableVersionsContainer {
                if let structure0 = structure0 {
                    tableVersionsDecoded0?.append(structure0)
                }
            }
        }
        tableVersions = tableVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetTablesInputBodyMiddleware: Middleware {
    public let id: String = "GetTablesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTablesInput>
    public typealias MOutput = OperationOutput<GetTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTablesOutputError>
}

extension GetTablesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTablesInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), expression: \(String(describing: expression)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetTablesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetTablesInputHeadersMiddleware: Middleware {
    public let id: String = "GetTablesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTablesInput>
    public typealias MOutput = OperationOutput<GetTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTablesOutputError>
}

public struct GetTablesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTablesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTablesInput>
    public typealias MOutput = OperationOutput<GetTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTablesOutputError>
}

public struct GetTablesInput: Equatable {
    /// <p>The ID of the Data Catalog where the tables reside. If none is provided, the AWS account
    ///       ID is used by default.</p>
    public let catalogId: String?
    /// <p>The database in the catalog whose tables to list. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let databaseName: String?
    /// <p>A regular expression pattern. If present, only those tables
    ///       whose names match the pattern are returned.</p>
    public let expression: String?
    /// <p>The maximum number of tables to return in a single response.</p>
    public let maxResults: Int?
    /// <p>A continuation token, included if this is a continuation call.</p>
    public let nextToken: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        expression: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetTablesInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let expression: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetTablesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetTablesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTablesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTablesOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTablesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTablesOutputResponse(nextToken: \(String(describing: nextToken)), tableList: \(String(describing: tableList)))"}
}

extension GetTablesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTablesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tableList = output.tableList
        } else {
            self.nextToken = nil
            self.tableList = nil
        }
    }
}

public struct GetTablesOutputResponse: Equatable {
    /// <p>A continuation token, present if the current list segment is
    ///       not the last.</p>
    public let nextToken: String?
    /// <p>A list of the requested <code>Table</code> objects.</p>
    public let tableList: [Table]?

    public init (
        nextToken: String? = nil,
        tableList: [Table]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableList = tableList
    }
}

struct GetTablesOutputResponseBody: Equatable {
    public let tableList: [Table]?
    public let nextToken: String?
}

extension GetTablesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tableList = "TableList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableListContainer = try containerValues.decodeIfPresent([Table?].self, forKey: .tableList)
        var tableListDecoded0:[Table]? = nil
        if let tableListContainer = tableListContainer {
            tableListDecoded0 = [Table]()
            for structure0 in tableListContainer {
                if let structure0 = structure0 {
                    tableListDecoded0?.append(structure0)
                }
            }
        }
        tableList = tableListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetTagsInputBodyMiddleware: Middleware {
    public let id: String = "GetTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

extension GetTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagsInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension GetTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct GetTagsInputHeadersMiddleware: Middleware {
    public let id: String = "GetTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

public struct GetTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

public struct GetTagsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource for which to retrieve tags.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetTagsInputBody: Equatable {
    public let resourceArn: String?
}

extension GetTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTagsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagsOutputResponse(tags: \(String(describing: tags)))"}
}

extension GetTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct GetTagsOutputResponse: Equatable {
    /// <p>The requested tags.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetTagsOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension GetTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct GetTriggerInputBodyMiddleware: Middleware {
    public let id: String = "GetTriggerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTriggerInput>
    public typealias MOutput = OperationOutput<GetTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTriggerOutputError>
}

extension GetTriggerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTriggerInput(name: \(String(describing: name)))"}
}

extension GetTriggerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetTriggerInputHeadersMiddleware: Middleware {
    public let id: String = "GetTriggerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTriggerInput>
    public typealias MOutput = OperationOutput<GetTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTriggerOutputError>
}

public struct GetTriggerInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTriggerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTriggerInput>
    public typealias MOutput = OperationOutput<GetTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTriggerOutputError>
}

public struct GetTriggerInput: Equatable {
    /// <p>The name of the trigger to retrieve.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetTriggerInputBody: Equatable {
    public let name: String?
}

extension GetTriggerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTriggerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTriggerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTriggerOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTriggerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTriggerOutputResponse(trigger: \(String(describing: trigger)))"}
}

extension GetTriggerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTriggerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.trigger = output.trigger
        } else {
            self.trigger = nil
        }
    }
}

public struct GetTriggerOutputResponse: Equatable {
    /// <p>The requested trigger definition.</p>
    public let trigger: Trigger?

    public init (
        trigger: Trigger? = nil
    )
    {
        self.trigger = trigger
    }
}

struct GetTriggerOutputResponseBody: Equatable {
    public let trigger: Trigger?
}

extension GetTriggerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case trigger = "Trigger"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerDecoded = try containerValues.decodeIfPresent(Trigger.self, forKey: .trigger)
        trigger = triggerDecoded
    }
}

public struct GetTriggersInputBodyMiddleware: Middleware {
    public let id: String = "GetTriggersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTriggersInput>
    public typealias MOutput = OperationOutput<GetTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTriggersOutputError>
}

extension GetTriggersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTriggersInput(dependentJobName: \(String(describing: dependentJobName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetTriggersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dependentJobName = "DependentJobName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependentJobName = dependentJobName {
            try encodeContainer.encode(dependentJobName, forKey: .dependentJobName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetTriggersInputHeadersMiddleware: Middleware {
    public let id: String = "GetTriggersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTriggersInput>
    public typealias MOutput = OperationOutput<GetTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTriggersOutputError>
}

public struct GetTriggersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTriggersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTriggersInput>
    public typealias MOutput = OperationOutput<GetTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTriggersOutputError>
}

public struct GetTriggersInput: Equatable {
    /// <p>The name of the job to retrieve triggers for. The trigger that can start this job is
    ///       returned, and if there is no such trigger, all triggers are returned.</p>
    public let dependentJobName: String?
    /// <p>The maximum size of the response.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?

    public init (
        dependentJobName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.dependentJobName = dependentJobName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetTriggersInputBody: Equatable {
    public let nextToken: String?
    public let dependentJobName: String?
    public let maxResults: Int?
}

extension GetTriggersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dependentJobName = "DependentJobName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dependentJobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dependentJobName)
        dependentJobName = dependentJobNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetTriggersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTriggersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTriggersOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTriggersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTriggersOutputResponse(nextToken: \(String(describing: nextToken)), triggers: \(String(describing: triggers)))"}
}

extension GetTriggersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTriggersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.triggers = output.triggers
        } else {
            self.nextToken = nil
            self.triggers = nil
        }
    }
}

public struct GetTriggersOutputResponse: Equatable {
    /// <p>A continuation token, if not all the requested triggers
    ///       have yet been returned.</p>
    public let nextToken: String?
    /// <p>A list of triggers for the specified job.</p>
    public let triggers: [Trigger]?

    public init (
        nextToken: String? = nil,
        triggers: [Trigger]? = nil
    )
    {
        self.nextToken = nextToken
        self.triggers = triggers
    }
}

struct GetTriggersOutputResponseBody: Equatable {
    public let triggers: [Trigger]?
    public let nextToken: String?
}

extension GetTriggersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case triggers = "Triggers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggersContainer = try containerValues.decodeIfPresent([Trigger?].self, forKey: .triggers)
        var triggersDecoded0:[Trigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [Trigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetUserDefinedFunctionInputBodyMiddleware: Middleware {
    public let id: String = "GetUserDefinedFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<GetUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserDefinedFunctionOutputError>
}

extension GetUserDefinedFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserDefinedFunctionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), functionName: \(String(describing: functionName)))"}
}

extension GetUserDefinedFunctionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case functionName = "FunctionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
    }
}

public struct GetUserDefinedFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "GetUserDefinedFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<GetUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserDefinedFunctionOutputError>
}

public struct GetUserDefinedFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUserDefinedFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<GetUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserDefinedFunctionOutputError>
}

public struct GetUserDefinedFunctionInput: Equatable {
    /// <p>The ID of the Data Catalog where the function to be retrieved is located. If none is
    ///       provided, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database where the function is located.</p>
    public let databaseName: String?
    /// <p>The name of the function.</p>
    public let functionName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        functionName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.functionName = functionName
    }
}

struct GetUserDefinedFunctionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let functionName: String?
}

extension GetUserDefinedFunctionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case functionName = "FunctionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
    }
}

extension GetUserDefinedFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserDefinedFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUserDefinedFunctionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserDefinedFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserDefinedFunctionOutputResponse(userDefinedFunction: \(String(describing: userDefinedFunction)))"}
}

extension GetUserDefinedFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUserDefinedFunctionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userDefinedFunction = output.userDefinedFunction
        } else {
            self.userDefinedFunction = nil
        }
    }
}

public struct GetUserDefinedFunctionOutputResponse: Equatable {
    /// <p>The requested function definition.</p>
    public let userDefinedFunction: UserDefinedFunction?

    public init (
        userDefinedFunction: UserDefinedFunction? = nil
    )
    {
        self.userDefinedFunction = userDefinedFunction
    }
}

struct GetUserDefinedFunctionOutputResponseBody: Equatable {
    public let userDefinedFunction: UserDefinedFunction?
}

extension GetUserDefinedFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userDefinedFunction = "UserDefinedFunction"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDefinedFunctionDecoded = try containerValues.decodeIfPresent(UserDefinedFunction.self, forKey: .userDefinedFunction)
        userDefinedFunction = userDefinedFunctionDecoded
    }
}

public struct GetUserDefinedFunctionsInputBodyMiddleware: Middleware {
    public let id: String = "GetUserDefinedFunctionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserDefinedFunctionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserDefinedFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserDefinedFunctionsInput>
    public typealias MOutput = OperationOutput<GetUserDefinedFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserDefinedFunctionsOutputError>
}

extension GetUserDefinedFunctionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserDefinedFunctionsInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), pattern: \(String(describing: pattern)))"}
}

extension GetUserDefinedFunctionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pattern = "Pattern"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
    }
}

public struct GetUserDefinedFunctionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetUserDefinedFunctionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserDefinedFunctionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserDefinedFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserDefinedFunctionsInput>
    public typealias MOutput = OperationOutput<GetUserDefinedFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserDefinedFunctionsOutputError>
}

public struct GetUserDefinedFunctionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUserDefinedFunctionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserDefinedFunctionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserDefinedFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserDefinedFunctionsInput>
    public typealias MOutput = OperationOutput<GetUserDefinedFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserDefinedFunctionsOutputError>
}

public struct GetUserDefinedFunctionsInput: Equatable {
    /// <p>The ID of the Data Catalog where the functions to be retrieved are located. If none is
    ///       provided, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database where the functions are located. If none is provided, functions from all the
    ///       databases across the catalog will be returned.</p>
    public let databaseName: String?
    /// <p>The maximum number of functions to return in one response.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?
    /// <p>An optional function-name pattern string that filters the function
    ///       definitions returned.</p>
    public let pattern: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        pattern: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pattern = pattern
    }
}

struct GetUserDefinedFunctionsInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let pattern: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetUserDefinedFunctionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pattern = "Pattern"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pattern)
        pattern = patternDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetUserDefinedFunctionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserDefinedFunctionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUserDefinedFunctionsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserDefinedFunctionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserDefinedFunctionsOutputResponse(nextToken: \(String(describing: nextToken)), userDefinedFunctions: \(String(describing: userDefinedFunctions)))"}
}

extension GetUserDefinedFunctionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUserDefinedFunctionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.userDefinedFunctions = output.userDefinedFunctions
        } else {
            self.nextToken = nil
            self.userDefinedFunctions = nil
        }
    }
}

public struct GetUserDefinedFunctionsOutputResponse: Equatable {
    /// <p>A continuation token, if the list of functions returned does
    ///       not include the last requested function.</p>
    public let nextToken: String?
    /// <p>A list of requested function definitions.</p>
    public let userDefinedFunctions: [UserDefinedFunction]?

    public init (
        nextToken: String? = nil,
        userDefinedFunctions: [UserDefinedFunction]? = nil
    )
    {
        self.nextToken = nextToken
        self.userDefinedFunctions = userDefinedFunctions
    }
}

struct GetUserDefinedFunctionsOutputResponseBody: Equatable {
    public let userDefinedFunctions: [UserDefinedFunction]?
    public let nextToken: String?
}

extension GetUserDefinedFunctionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case userDefinedFunctions = "UserDefinedFunctions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDefinedFunctionsContainer = try containerValues.decodeIfPresent([UserDefinedFunction?].self, forKey: .userDefinedFunctions)
        var userDefinedFunctionsDecoded0:[UserDefinedFunction]? = nil
        if let userDefinedFunctionsContainer = userDefinedFunctionsContainer {
            userDefinedFunctionsDecoded0 = [UserDefinedFunction]()
            for structure0 in userDefinedFunctionsContainer {
                if let structure0 = structure0 {
                    userDefinedFunctionsDecoded0?.append(structure0)
                }
            }
        }
        userDefinedFunctions = userDefinedFunctionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetWorkflowInputBodyMiddleware: Middleware {
    public let id: String = "GetWorkflowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowInput>
    public typealias MOutput = OperationOutput<GetWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowOutputError>
}

extension GetWorkflowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkflowInput(includeGraph: \(String(describing: includeGraph)), name: \(String(describing: name)))"}
}

extension GetWorkflowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeGraph = "IncludeGraph"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeGraph = includeGraph {
            try encodeContainer.encode(includeGraph, forKey: .includeGraph)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetWorkflowInputHeadersMiddleware: Middleware {
    public let id: String = "GetWorkflowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowInput>
    public typealias MOutput = OperationOutput<GetWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowOutputError>
}

public struct GetWorkflowInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWorkflowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowInput>
    public typealias MOutput = OperationOutput<GetWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowOutputError>
}

public struct GetWorkflowInput: Equatable {
    /// <p>Specifies whether to include a graph when returning the workflow resource metadata.</p>
    public let includeGraph: Bool?
    /// <p>The name of the workflow to retrieve.</p>
    public let name: String?

    public init (
        includeGraph: Bool? = nil,
        name: String? = nil
    )
    {
        self.includeGraph = includeGraph
        self.name = name
    }
}

struct GetWorkflowInputBody: Equatable {
    public let name: String?
    public let includeGraph: Bool?
}

extension GetWorkflowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includeGraph = "IncludeGraph"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let includeGraphDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeGraph)
        includeGraph = includeGraphDecoded
    }
}

extension GetWorkflowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkflowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkflowOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkflowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkflowOutputResponse(workflow: \(String(describing: workflow)))"}
}

extension GetWorkflowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.workflow = output.workflow
        } else {
            self.workflow = nil
        }
    }
}

public struct GetWorkflowOutputResponse: Equatable {
    /// <p>The resource metadata for the workflow.</p>
    public let workflow: Workflow?

    public init (
        workflow: Workflow? = nil
    )
    {
        self.workflow = workflow
    }
}

struct GetWorkflowOutputResponseBody: Equatable {
    public let workflow: Workflow?
}

extension GetWorkflowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workflow = "Workflow"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowDecoded = try containerValues.decodeIfPresent(Workflow.self, forKey: .workflow)
        workflow = workflowDecoded
    }
}

public struct GetWorkflowRunInputBodyMiddleware: Middleware {
    public let id: String = "GetWorkflowRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowRunInput>
    public typealias MOutput = OperationOutput<GetWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowRunOutputError>
}

extension GetWorkflowRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkflowRunInput(includeGraph: \(String(describing: includeGraph)), name: \(String(describing: name)), runId: \(String(describing: runId)))"}
}

extension GetWorkflowRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeGraph = "IncludeGraph"
        case name = "Name"
        case runId = "RunId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeGraph = includeGraph {
            try encodeContainer.encode(includeGraph, forKey: .includeGraph)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runId = runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
    }
}

public struct GetWorkflowRunInputHeadersMiddleware: Middleware {
    public let id: String = "GetWorkflowRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowRunInput>
    public typealias MOutput = OperationOutput<GetWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowRunOutputError>
}

public struct GetWorkflowRunInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWorkflowRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowRunInput>
    public typealias MOutput = OperationOutput<GetWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowRunOutputError>
}

public struct GetWorkflowRunInput: Equatable {
    /// <p>Specifies whether to include the workflow graph in response or not.</p>
    public let includeGraph: Bool?
    /// <p>Name of the workflow being run.</p>
    public let name: String?
    /// <p>The ID of the workflow run.</p>
    public let runId: String?

    public init (
        includeGraph: Bool? = nil,
        name: String? = nil,
        runId: String? = nil
    )
    {
        self.includeGraph = includeGraph
        self.name = name
        self.runId = runId
    }
}

struct GetWorkflowRunInputBody: Equatable {
    public let name: String?
    public let runId: String?
    public let includeGraph: Bool?
}

extension GetWorkflowRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includeGraph = "IncludeGraph"
        case name = "Name"
        case runId = "RunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
        let includeGraphDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeGraph)
        includeGraph = includeGraphDecoded
    }
}

extension GetWorkflowRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkflowRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkflowRunOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkflowRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkflowRunOutputResponse(run: \(String(describing: run)))"}
}

extension GetWorkflowRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWorkflowRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.run = output.run
        } else {
            self.run = nil
        }
    }
}

public struct GetWorkflowRunOutputResponse: Equatable {
    /// <p>The requested workflow run metadata.</p>
    public let run: WorkflowRun?

    public init (
        run: WorkflowRun? = nil
    )
    {
        self.run = run
    }
}

struct GetWorkflowRunOutputResponseBody: Equatable {
    public let run: WorkflowRun?
}

extension GetWorkflowRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case run = "Run"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(WorkflowRun.self, forKey: .run)
        run = runDecoded
    }
}

public struct GetWorkflowRunPropertiesInputBodyMiddleware: Middleware {
    public let id: String = "GetWorkflowRunPropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowRunPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowRunPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowRunPropertiesInput>
    public typealias MOutput = OperationOutput<GetWorkflowRunPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowRunPropertiesOutputError>
}

extension GetWorkflowRunPropertiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkflowRunPropertiesInput(name: \(String(describing: name)), runId: \(String(describing: runId)))"}
}

extension GetWorkflowRunPropertiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case runId = "RunId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runId = runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
    }
}

public struct GetWorkflowRunPropertiesInputHeadersMiddleware: Middleware {
    public let id: String = "GetWorkflowRunPropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowRunPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowRunPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowRunPropertiesInput>
    public typealias MOutput = OperationOutput<GetWorkflowRunPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowRunPropertiesOutputError>
}

public struct GetWorkflowRunPropertiesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWorkflowRunPropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowRunPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowRunPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowRunPropertiesInput>
    public typealias MOutput = OperationOutput<GetWorkflowRunPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowRunPropertiesOutputError>
}

public struct GetWorkflowRunPropertiesInput: Equatable {
    /// <p>Name of the workflow which was run.</p>
    public let name: String?
    /// <p>The ID of the workflow run whose run properties should be returned.</p>
    public let runId: String?

    public init (
        name: String? = nil,
        runId: String? = nil
    )
    {
        self.name = name
        self.runId = runId
    }
}

struct GetWorkflowRunPropertiesInputBody: Equatable {
    public let name: String?
    public let runId: String?
}

extension GetWorkflowRunPropertiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case runId = "RunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
    }
}

extension GetWorkflowRunPropertiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkflowRunPropertiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkflowRunPropertiesOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkflowRunPropertiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkflowRunPropertiesOutputResponse(runProperties: \(String(describing: runProperties)))"}
}

extension GetWorkflowRunPropertiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWorkflowRunPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.runProperties = output.runProperties
        } else {
            self.runProperties = nil
        }
    }
}

public struct GetWorkflowRunPropertiesOutputResponse: Equatable {
    /// <p>The workflow run properties which were set during the specified run.</p>
    public let runProperties: [String:String]?

    public init (
        runProperties: [String:String]? = nil
    )
    {
        self.runProperties = runProperties
    }
}

struct GetWorkflowRunPropertiesOutputResponseBody: Equatable {
    public let runProperties: [String:String]?
}

extension GetWorkflowRunPropertiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case runProperties = "RunProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .runProperties)
        var runPropertiesDecoded0: [String:String]? = nil
        if let runPropertiesContainer = runPropertiesContainer {
            runPropertiesDecoded0 = [String:String]()
            for (key0, genericstring0) in runPropertiesContainer {
                if let genericstring0 = genericstring0 {
                    runPropertiesDecoded0?[key0] = genericstring0
                }
            }
        }
        runProperties = runPropertiesDecoded0
    }
}

public struct GetWorkflowRunsInputBodyMiddleware: Middleware {
    public let id: String = "GetWorkflowRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowRunsInput>
    public typealias MOutput = OperationOutput<GetWorkflowRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowRunsOutputError>
}

extension GetWorkflowRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkflowRunsInput(includeGraph: \(String(describing: includeGraph)), maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension GetWorkflowRunsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeGraph = "IncludeGraph"
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeGraph = includeGraph {
            try encodeContainer.encode(includeGraph, forKey: .includeGraph)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetWorkflowRunsInputHeadersMiddleware: Middleware {
    public let id: String = "GetWorkflowRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowRunsInput>
    public typealias MOutput = OperationOutput<GetWorkflowRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowRunsOutputError>
}

public struct GetWorkflowRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWorkflowRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkflowRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkflowRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkflowRunsInput>
    public typealias MOutput = OperationOutput<GetWorkflowRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkflowRunsOutputError>
}

public struct GetWorkflowRunsInput: Equatable {
    /// <p>Specifies whether to include the workflow graph in response or not.</p>
    public let includeGraph: Bool?
    /// <p>The maximum number of workflow runs to be included in the response.</p>
    public let maxResults: Int?
    /// <p>Name of the workflow whose metadata of runs should be returned.</p>
    public let name: String?
    /// <p>The maximum size of the response.</p>
    public let nextToken: String?

    public init (
        includeGraph: Bool? = nil,
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.includeGraph = includeGraph
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetWorkflowRunsInputBody: Equatable {
    public let name: String?
    public let includeGraph: Bool?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetWorkflowRunsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includeGraph = "IncludeGraph"
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let includeGraphDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeGraph)
        includeGraph = includeGraphDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetWorkflowRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkflowRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkflowRunsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkflowRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkflowRunsOutputResponse(nextToken: \(String(describing: nextToken)), runs: \(String(describing: runs)))"}
}

extension GetWorkflowRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWorkflowRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.runs = output.runs
        } else {
            self.nextToken = nil
            self.runs = nil
        }
    }
}

public struct GetWorkflowRunsOutputResponse: Equatable {
    /// <p>A continuation token, if not all requested workflow runs have been returned.</p>
    public let nextToken: String?
    /// <p>A list of workflow run metadata objects.</p>
    public let runs: [WorkflowRun]?

    public init (
        nextToken: String? = nil,
        runs: [WorkflowRun]? = nil
    )
    {
        self.nextToken = nextToken
        self.runs = runs
    }
}

struct GetWorkflowRunsOutputResponseBody: Equatable {
    public let runs: [WorkflowRun]?
    public let nextToken: String?
}

extension GetWorkflowRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case runs = "Runs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runsContainer = try containerValues.decodeIfPresent([WorkflowRun?].self, forKey: .runs)
        var runsDecoded0:[WorkflowRun]? = nil
        if let runsContainer = runsContainer {
            runsDecoded0 = [WorkflowRun]()
            for structure0 in runsContainer {
                if let structure0 = structure0 {
                    runsDecoded0?.append(structure0)
                }
            }
        }
        runs = runsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GlueEncryptionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlueEncryptionException(message: \(String(describing: message)))"}
}

extension GlueEncryptionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GlueEncryptionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An encryption operation failed.</p>
public struct GlueEncryptionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct GlueEncryptionExceptionBody: Equatable {
    public let message: String?
}

extension GlueEncryptionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GluePolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createTime = "CreateTime"
        case policyHash = "PolicyHash"
        case policyInJson = "PolicyInJson"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let policyHash = policyHash {
            try encodeContainer.encode(policyHash, forKey: .policyHash)
        }
        if let policyInJson = policyInJson {
            try encodeContainer.encode(policyInJson, forKey: .policyInJson)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyInJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyInJson)
        policyInJson = policyInJsonDecoded
        let policyHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyHash)
        policyHash = policyHashDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension GluePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GluePolicy(createTime: \(String(describing: createTime)), policyHash: \(String(describing: policyHash)), policyInJson: \(String(describing: policyInJson)), updateTime: \(String(describing: updateTime)))"}
}

/// <p>A structure for returning a resource policy.</p>
public struct GluePolicy: Equatable {
    /// <p>The date and time at which the policy was created.</p>
    public let createTime: Date?
    /// <p>Contains the hash value associated with this policy.</p>
    public let policyHash: String?
    /// <p>Contains the requested policy document, in JSON format.</p>
    public let policyInJson: String?
    /// <p>The date and time at which the policy was last updated.</p>
    public let updateTime: Date?

    public init (
        createTime: Date? = nil,
        policyHash: String? = nil,
        policyInJson: String? = nil,
        updateTime: Date? = nil
    )
    {
        self.createTime = createTime
        self.policyHash = policyHash
        self.policyInJson = policyInJson
        self.updateTime = updateTime
    }
}

extension GlueTable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case connectionName = "ConnectionName"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
    }
}

extension GlueTable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlueTable(catalogId: \(String(describing: catalogId)), connectionName: \(String(describing: connectionName)), databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)))"}
}

/// <p>The database and table in the AWS Glue Data Catalog that is used for input or output data.</p>
public struct GlueTable: Equatable {
    /// <p>A unique identifier for the AWS Glue Data Catalog.</p>
    public let catalogId: String?
    /// <p>The name of the connection to the AWS Glue Data Catalog.</p>
    public let connectionName: String?
    /// <p>A database name in the AWS Glue Data Catalog.</p>
    public let databaseName: String?
    /// <p>A table name in the AWS Glue Data Catalog.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        connectionName: String? = nil,
        databaseName: String? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.connectionName = connectionName
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

extension GrokClassifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classification = "Classification"
        case creationTime = "CreationTime"
        case customPatterns = "CustomPatterns"
        case grokPattern = "GrokPattern"
        case lastUpdated = "LastUpdated"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let customPatterns = customPatterns {
            try encodeContainer.encode(customPatterns, forKey: .customPatterns)
        }
        if let grokPattern = grokPattern {
            try encodeContainer.encode(grokPattern, forKey: .grokPattern)
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let classificationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .classification)
        classification = classificationDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let grokPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grokPattern)
        grokPattern = grokPatternDecoded
        let customPatternsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customPatterns)
        customPatterns = customPatternsDecoded
    }
}

extension GrokClassifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrokClassifier(classification: \(String(describing: classification)), creationTime: \(String(describing: creationTime)), customPatterns: \(String(describing: customPatterns)), grokPattern: \(String(describing: grokPattern)), lastUpdated: \(String(describing: lastUpdated)), name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>A classifier that uses <code>grok</code> patterns.</p>
public struct GrokClassifier: Equatable {
    /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, and
    ///       so on.</p>
    public let classification: String?
    /// <p>The time that this classifier was registered.</p>
    public let creationTime: Date?
    /// <p>Optional custom grok patterns defined by this classifier.
    ///       For more information, see custom patterns in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html">Writing Custom Classifiers</a>.</p>
    public let customPatterns: String?
    /// <p>The grok pattern applied to a data store by this classifier.
    ///        For more information, see built-in patterns in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html">Writing Custom Classifiers</a>.</p>
    public let grokPattern: String?
    /// <p>The time that this classifier was last updated.</p>
    public let lastUpdated: Date?
    /// <p>The name of the classifier.</p>
    public let name: String?
    /// <p>The version of this classifier.</p>
    public let version: Int

    public init (
        classification: String? = nil,
        creationTime: Date? = nil,
        customPatterns: String? = nil,
        grokPattern: String? = nil,
        lastUpdated: Date? = nil,
        name: String? = nil,
        version: Int = 0
    )
    {
        self.classification = classification
        self.creationTime = creationTime
        self.customPatterns = customPatterns
        self.grokPattern = grokPattern
        self.lastUpdated = lastUpdated
        self.name = name
        self.version = version
    }
}

extension IdempotentParameterMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdempotentParameterMismatchException(message: \(String(describing: message)))"}
}

extension IdempotentParameterMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The same unique identifier was associated with two different records.</p>
public struct IdempotentParameterMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Equatable {
    public let message: String?
}

extension IdempotentParameterMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalWorkflowStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IllegalWorkflowStateException(message: \(String(describing: message)))"}
}

extension IllegalWorkflowStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IllegalWorkflowStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The workflow is in an invalid state to perform a requested operation.</p>
public struct IllegalWorkflowStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalWorkflowStateExceptionBody: Equatable {
    public let message: String?
}

extension IllegalWorkflowStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ImportCatalogToGlueInputBodyMiddleware: Middleware {
    public let id: String = "ImportCatalogToGlueInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportCatalogToGlueInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportCatalogToGlueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportCatalogToGlueInput>
    public typealias MOutput = OperationOutput<ImportCatalogToGlueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportCatalogToGlueOutputError>
}

extension ImportCatalogToGlueInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportCatalogToGlueInput(catalogId: \(String(describing: catalogId)))"}
}

extension ImportCatalogToGlueInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
    }
}

public struct ImportCatalogToGlueInputHeadersMiddleware: Middleware {
    public let id: String = "ImportCatalogToGlueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportCatalogToGlueInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportCatalogToGlueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportCatalogToGlueInput>
    public typealias MOutput = OperationOutput<ImportCatalogToGlueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportCatalogToGlueOutputError>
}

public struct ImportCatalogToGlueInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportCatalogToGlueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportCatalogToGlueInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportCatalogToGlueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportCatalogToGlueInput>
    public typealias MOutput = OperationOutput<ImportCatalogToGlueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportCatalogToGlueOutputError>
}

public struct ImportCatalogToGlueInput: Equatable {
    /// <p>The ID of the catalog to import. Currently, this should be the AWS account ID.</p>
    public let catalogId: String?

    public init (
        catalogId: String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

struct ImportCatalogToGlueInputBody: Equatable {
    public let catalogId: String?
}

extension ImportCatalogToGlueInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension ImportCatalogToGlueOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportCatalogToGlueOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportCatalogToGlueOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportCatalogToGlueOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportCatalogToGlueOutputResponse()"}
}

extension ImportCatalogToGlueOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ImportCatalogToGlueOutputResponse: Equatable {

    public init() {}
}

struct ImportCatalogToGlueOutputResponseBody: Equatable {
}

extension ImportCatalogToGlueOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ImportLabelsTaskRunProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputS3Path = "InputS3Path"
        case replace = "Replace"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputS3Path = inputS3Path {
            try encodeContainer.encode(inputS3Path, forKey: .inputS3Path)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputS3Path)
        inputS3Path = inputS3PathDecoded
        let replaceDecoded = try containerValues.decode(Bool.self, forKey: .replace)
        replace = replaceDecoded
    }
}

extension ImportLabelsTaskRunProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportLabelsTaskRunProperties(inputS3Path: \(String(describing: inputS3Path)), replace: \(String(describing: replace)))"}
}

/// <p>Specifies configuration properties for an importing labels task run.</p>
public struct ImportLabelsTaskRunProperties: Equatable {
    /// <p>The Amazon Simple Storage Service (Amazon S3) path from where you will import the
    ///       labels.</p>
    public let inputS3Path: String?
    /// <p>Indicates whether to overwrite your existing labels.</p>
    public let replace: Bool

    public init (
        inputS3Path: String? = nil,
        replace: Bool = false
    )
    {
        self.inputS3Path = inputS3Path
        self.replace = replace
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal service error occurred.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input provided was not valid.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JdbcTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionName = "ConnectionName"
        case exclusions = "Exclusions"
        case path = "Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let exclusions = exclusions {
            var exclusionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusions)
            for pathlist0 in exclusions {
                try exclusionsContainer.encode(pathlist0)
            }
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let exclusionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exclusions)
        var exclusionsDecoded0:[String]? = nil
        if let exclusionsContainer = exclusionsContainer {
            exclusionsDecoded0 = [String]()
            for string0 in exclusionsContainer {
                if let string0 = string0 {
                    exclusionsDecoded0?.append(string0)
                }
            }
        }
        exclusions = exclusionsDecoded0
    }
}

extension JdbcTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JdbcTarget(connectionName: \(String(describing: connectionName)), exclusions: \(String(describing: exclusions)), path: \(String(describing: path)))"}
}

/// <p>Specifies a JDBC data store to crawl.</p>
public struct JdbcTarget: Equatable {
    /// <p>The name of the connection to use to connect to the JDBC target.</p>
    public let connectionName: String?
    /// <p>A list of glob patterns used to exclude from the crawl.
    ///       For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html">Catalog Tables with a Crawler</a>.</p>
    public let exclusions: [String]?
    /// <p>The path of the JDBC target.</p>
    public let path: String?

    public init (
        connectionName: String? = nil,
        exclusions: [String]? = nil,
        path: String? = nil
    )
    {
        self.connectionName = connectionName
        self.exclusions = exclusions
        self.path = path
    }
}

extension Job: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedCapacity = "AllocatedCapacity"
        case command = "Command"
        case connections = "Connections"
        case createdOn = "CreatedOn"
        case defaultArguments = "DefaultArguments"
        case description = "Description"
        case executionProperty = "ExecutionProperty"
        case glueVersion = "GlueVersion"
        case lastModifiedOn = "LastModifiedOn"
        case logUri = "LogUri"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case nonOverridableArguments = "NonOverridableArguments"
        case notificationProperty = "NotificationProperty"
        case numberOfWorkers = "NumberOfWorkers"
        case role = "Role"
        case securityConfiguration = "SecurityConfiguration"
        case timeout = "Timeout"
        case workerType = "WorkerType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedCapacity != 0 {
            try encodeContainer.encode(allocatedCapacity, forKey: .allocatedCapacity)
        }
        if let command = command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let connections = connections {
            try encodeContainer.encode(connections, forKey: .connections)
        }
        if let createdOn = createdOn {
            try encodeContainer.encode(createdOn.timeIntervalSince1970, forKey: .createdOn)
        }
        if let defaultArguments = defaultArguments {
            var defaultArgumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .defaultArguments)
            for (dictKey0, genericmap0) in defaultArguments {
                try defaultArgumentsContainer.encode(genericmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionProperty = executionProperty {
            try encodeContainer.encode(executionProperty, forKey: .executionProperty)
        }
        if let glueVersion = glueVersion {
            try encodeContainer.encode(glueVersion, forKey: .glueVersion)
        }
        if let lastModifiedOn = lastModifiedOn {
            try encodeContainer.encode(lastModifiedOn.timeIntervalSince1970, forKey: .lastModifiedOn)
        }
        if let logUri = logUri {
            try encodeContainer.encode(logUri, forKey: .logUri)
        }
        if let maxCapacity = maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if maxRetries != 0 {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nonOverridableArguments = nonOverridableArguments {
            var nonOverridableArgumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .nonOverridableArguments)
            for (dictKey0, genericmap0) in nonOverridableArguments {
                try nonOverridableArgumentsContainer.encode(genericmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let notificationProperty = notificationProperty {
            try encodeContainer.encode(notificationProperty, forKey: .notificationProperty)
        }
        if let numberOfWorkers = numberOfWorkers {
            try encodeContainer.encode(numberOfWorkers, forKey: .numberOfWorkers)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let securityConfiguration = securityConfiguration {
            try encodeContainer.encode(securityConfiguration, forKey: .securityConfiguration)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let workerType = workerType {
            try encodeContainer.encode(workerType.rawValue, forKey: .workerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let logUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logUri)
        logUri = logUriDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let createdOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdOn)
        createdOn = createdOnDecoded
        let lastModifiedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedOn)
        lastModifiedOn = lastModifiedOnDecoded
        let executionPropertyDecoded = try containerValues.decodeIfPresent(ExecutionProperty.self, forKey: .executionProperty)
        executionProperty = executionPropertyDecoded
        let commandDecoded = try containerValues.decodeIfPresent(JobCommand.self, forKey: .command)
        command = commandDecoded
        let defaultArgumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .defaultArguments)
        var defaultArgumentsDecoded0: [String:String]? = nil
        if let defaultArgumentsContainer = defaultArgumentsContainer {
            defaultArgumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in defaultArgumentsContainer {
                if let genericstring0 = genericstring0 {
                    defaultArgumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        defaultArguments = defaultArgumentsDecoded0
        let nonOverridableArgumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .nonOverridableArguments)
        var nonOverridableArgumentsDecoded0: [String:String]? = nil
        if let nonOverridableArgumentsContainer = nonOverridableArgumentsContainer {
            nonOverridableArgumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in nonOverridableArgumentsContainer {
                if let genericstring0 = genericstring0 {
                    nonOverridableArgumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        nonOverridableArguments = nonOverridableArgumentsDecoded0
        let connectionsDecoded = try containerValues.decodeIfPresent(ConnectionsList.self, forKey: .connections)
        connections = connectionsDecoded
        let maxRetriesDecoded = try containerValues.decode(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let allocatedCapacityDecoded = try containerValues.decode(Int.self, forKey: .allocatedCapacity)
        allocatedCapacity = allocatedCapacityDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
        let securityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityConfiguration)
        securityConfiguration = securityConfigurationDecoded
        let notificationPropertyDecoded = try containerValues.decodeIfPresent(NotificationProperty.self, forKey: .notificationProperty)
        notificationProperty = notificationPropertyDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
    }
}

extension Job: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Job(allocatedCapacity: \(String(describing: allocatedCapacity)), command: \(String(describing: command)), connections: \(String(describing: connections)), createdOn: \(String(describing: createdOn)), defaultArguments: \(String(describing: defaultArguments)), description: \(String(describing: description)), executionProperty: \(String(describing: executionProperty)), glueVersion: \(String(describing: glueVersion)), lastModifiedOn: \(String(describing: lastModifiedOn)), logUri: \(String(describing: logUri)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), nonOverridableArguments: \(String(describing: nonOverridableArguments)), notificationProperty: \(String(describing: notificationProperty)), numberOfWorkers: \(String(describing: numberOfWorkers)), role: \(String(describing: role)), securityConfiguration: \(String(describing: securityConfiguration)), timeout: \(String(describing: timeout)), workerType: \(String(describing: workerType)))"}
}

/// <p>Specifies a job definition.</p>
public struct Job: Equatable {
    /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
    /// 	
    ///          <p>The number of AWS Glue data processing units (DPUs) allocated to runs of this job. You can
    ///       allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing
    ///       power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information,
    ///       see the <a href="https://aws.amazon.com/glue/pricing/">AWS Glue pricing
    ///       page</a>.</p>
    /// 	        <p></p>
    @available(*, deprecated, message: "This property is deprecated, use MaxCapacity instead.")
    public let allocatedCapacity: Int
    /// <p>The <code>JobCommand</code> that executes this job.</p>
    public let command: JobCommand?
    /// <p>The connections used for this job.</p>
    public let connections: ConnectionsList?
    /// <p>The time and date that this job definition was created.</p>
    public let createdOn: Date?
    /// <p>The default arguments for this job, specified as name-value pairs.</p>
    ///          <p>You can specify arguments here that your own job-execution script
    ///       consumes, as well as arguments that AWS Glue itself consumes.</p>
    ///          <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling AWS Glue APIs in Python</a> topic in the developer guide.</p>
    ///          <p>For information about the key-value pairs that AWS Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by AWS Glue</a> topic in the developer guide.</p>
    public let defaultArguments: [String:String]?
    /// <p>A description of the job.</p>
    public let description: String?
    /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed
    ///       for this job.</p>
    public let executionProperty: ExecutionProperty?
    /// <p>Glue version determines the versions of Apache Spark and Python that AWS Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
    ///
    ///          <p>For more information about the available AWS Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    /// 	
    /// 	        <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
    public let glueVersion: String?
    /// <p>The last point in time when this job definition was modified.</p>
    public let lastModifiedOn: Date?
    /// <p>This field is reserved for future use.</p>
    public let logUri: String?
    /// <p>The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure
    ///       of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
    ///       For more information, see the <a href="https://aws.amazon.com/glue/pricing/">AWS Glue
    ///       pricing page</a>.</p>
    /// 	
    /// 	        <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
    /// 	
    /// 	        <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are
    ///       running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL
    ///       job:</p>
    ///         <ul>
    ///             <li>
    ///                <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can
    ///           allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p>
    ///             </li>
    ///             <li>
    ///                <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache
    ///             Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate from 2 to 100 DPUs.
    ///             The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p>
    ///             </li>
    ///          </ul>
    public let maxCapacity: Double?
    /// <p>The maximum number of times to retry this job after a JobRun fails.</p>
    public let maxRetries: Int
    /// <p>The name you assign to this job definition.</p>
    public let name: String?
    /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
    public let nonOverridableArguments: [String:String]?
    /// <p>Specifies configuration properties of a job notification.</p>
    public let notificationProperty: NotificationProperty?
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
    /// 	
    /// 		       <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
    public let numberOfWorkers: Int?
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job.</p>
    public let role: String?
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this
    ///       job.</p>
    public let securityConfiguration: String?
    /// <p>The job timeout in minutes.  This is the maximum time that a job run
    ///       can consume resources before it is terminated and enters <code>TIMEOUT</code>
    ///       status. The default is 2,880 minutes (48 hours).</p>
    public let timeout: Int?
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
    ///             </li>
    ///          </ul>
    public let workerType: WorkerType?

    public init (
        allocatedCapacity: Int = 0,
        command: JobCommand? = nil,
        connections: ConnectionsList? = nil,
        createdOn: Date? = nil,
        defaultArguments: [String:String]? = nil,
        description: String? = nil,
        executionProperty: ExecutionProperty? = nil,
        glueVersion: String? = nil,
        lastModifiedOn: Date? = nil,
        logUri: String? = nil,
        maxCapacity: Double? = nil,
        maxRetries: Int = 0,
        name: String? = nil,
        nonOverridableArguments: [String:String]? = nil,
        notificationProperty: NotificationProperty? = nil,
        numberOfWorkers: Int? = nil,
        role: String? = nil,
        securityConfiguration: String? = nil,
        timeout: Int? = nil,
        workerType: WorkerType? = nil
    )
    {
        self.allocatedCapacity = allocatedCapacity
        self.command = command
        self.connections = connections
        self.createdOn = createdOn
        self.defaultArguments = defaultArguments
        self.description = description
        self.executionProperty = executionProperty
        self.glueVersion = glueVersion
        self.lastModifiedOn = lastModifiedOn
        self.logUri = logUri
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.nonOverridableArguments = nonOverridableArguments
        self.notificationProperty = notificationProperty
        self.numberOfWorkers = numberOfWorkers
        self.role = role
        self.securityConfiguration = securityConfiguration
        self.timeout = timeout
        self.workerType = workerType
    }
}

extension JobBookmarkEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attempt = "Attempt"
        case jobBookmark = "JobBookmark"
        case jobName = "JobName"
        case previousRunId = "PreviousRunId"
        case run = "Run"
        case runId = "RunId"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if attempt != 0 {
            try encodeContainer.encode(attempt, forKey: .attempt)
        }
        if let jobBookmark = jobBookmark {
            try encodeContainer.encode(jobBookmark, forKey: .jobBookmark)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let previousRunId = previousRunId {
            try encodeContainer.encode(previousRunId, forKey: .previousRunId)
        }
        if run != 0 {
            try encodeContainer.encode(run, forKey: .run)
        }
        if let runId = runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let runDecoded = try containerValues.decode(Int.self, forKey: .run)
        run = runDecoded
        let attemptDecoded = try containerValues.decode(Int.self, forKey: .attempt)
        attempt = attemptDecoded
        let previousRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .previousRunId)
        previousRunId = previousRunIdDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
        let jobBookmarkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobBookmark)
        jobBookmark = jobBookmarkDecoded
    }
}

extension JobBookmarkEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobBookmarkEntry(attempt: \(String(describing: attempt)), jobBookmark: \(String(describing: jobBookmark)), jobName: \(String(describing: jobName)), previousRunId: \(String(describing: previousRunId)), run: \(String(describing: run)), runId: \(String(describing: runId)), version: \(String(describing: version)))"}
}

/// <p>Defines a point that a job can resume processing.</p>
public struct JobBookmarkEntry: Equatable {
    /// <p>The attempt ID number.</p>
    public let attempt: Int
    /// <p>The bookmark itself.</p>
    public let jobBookmark: String?
    /// <p>The name of the job in question.</p>
    public let jobName: String?
    /// <p>The unique run identifier associated with the previous job run.</p>
    public let previousRunId: String?
    /// <p>The run ID number.</p>
    public let run: Int
    /// <p>The run ID number.</p>
    public let runId: String?
    /// <p>The version of the job.</p>
    public let version: Int

    public init (
        attempt: Int = 0,
        jobBookmark: String? = nil,
        jobName: String? = nil,
        previousRunId: String? = nil,
        run: Int = 0,
        runId: String? = nil,
        version: Int = 0
    )
    {
        self.attempt = attempt
        self.jobBookmark = jobBookmark
        self.jobName = jobName
        self.previousRunId = previousRunId
        self.run = run
        self.runId = runId
        self.version = version
    }
}

extension JobBookmarksEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobBookmarksEncryptionMode = "JobBookmarksEncryptionMode"
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobBookmarksEncryptionMode = jobBookmarksEncryptionMode {
            try encodeContainer.encode(jobBookmarksEncryptionMode.rawValue, forKey: .jobBookmarksEncryptionMode)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobBookmarksEncryptionModeDecoded = try containerValues.decodeIfPresent(JobBookmarksEncryptionMode.self, forKey: .jobBookmarksEncryptionMode)
        jobBookmarksEncryptionMode = jobBookmarksEncryptionModeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension JobBookmarksEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobBookmarksEncryption(jobBookmarksEncryptionMode: \(String(describing: jobBookmarksEncryptionMode)), kmsKeyArn: \(String(describing: kmsKeyArn)))"}
}

/// <p>Specifies how job bookmark data should be encrypted.</p>
public struct JobBookmarksEncryption: Equatable {
    /// <p>The encryption mode to use for job bookmarks data.</p>
    public let jobBookmarksEncryptionMode: JobBookmarksEncryptionMode?
    /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
    public let kmsKeyArn: String?

    public init (
        jobBookmarksEncryptionMode: JobBookmarksEncryptionMode? = nil,
        kmsKeyArn: String? = nil
    )
    {
        self.jobBookmarksEncryptionMode = jobBookmarksEncryptionMode
        self.kmsKeyArn = kmsKeyArn
    }
}

public enum JobBookmarksEncryptionMode {
    case csekms
    case disabled
    case sdkUnknown(String)
}

extension JobBookmarksEncryptionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobBookmarksEncryptionMode] {
        return [
            .csekms,
            .disabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csekms: return "CSE-KMS"
        case .disabled: return "DISABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobBookmarksEncryptionMode(rawValue: rawValue) ?? JobBookmarksEncryptionMode.sdkUnknown(rawValue)
    }
}

extension JobCommand: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case pythonVersion = "PythonVersion"
        case scriptLocation = "ScriptLocation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pythonVersion = pythonVersion {
            try encodeContainer.encode(pythonVersion, forKey: .pythonVersion)
        }
        if let scriptLocation = scriptLocation {
            try encodeContainer.encode(scriptLocation, forKey: .scriptLocation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scriptLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scriptLocation)
        scriptLocation = scriptLocationDecoded
        let pythonVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pythonVersion)
        pythonVersion = pythonVersionDecoded
    }
}

extension JobCommand: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobCommand(name: \(String(describing: name)), pythonVersion: \(String(describing: pythonVersion)), scriptLocation: \(String(describing: scriptLocation)))"}
}

/// <p>Specifies code executed when a job is run.</p>
public struct JobCommand: Equatable {
    /// <p>The name of the job command. For an Apache Spark ETL job, this must be
    ///       <code>glueetl</code>. For a Python shell job, it must be <code>pythonshell</code>.
    ///       For an Apache Spark streaming ETL job, this must be <code>gluestreaming</code>.</p>
    public let name: String?
    /// <p>The Python version being used to execute a Python shell job. Allowed values are 2 or 3.</p>
    public let pythonVersion: String?
    /// <p>Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that executes a
    ///       job.</p>
    public let scriptLocation: String?

    public init (
        name: String? = nil,
        pythonVersion: String? = nil,
        scriptLocation: String? = nil
    )
    {
        self.name = name
        self.pythonVersion = pythonVersion
        self.scriptLocation = scriptLocation
    }
}

extension JobNodeDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobRuns = "JobRuns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobRuns = jobRuns {
            var jobRunsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobRuns)
            for jobrunlist0 in jobRuns {
                try jobRunsContainer.encode(jobrunlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunsContainer = try containerValues.decodeIfPresent([JobRun?].self, forKey: .jobRuns)
        var jobRunsDecoded0:[JobRun]? = nil
        if let jobRunsContainer = jobRunsContainer {
            jobRunsDecoded0 = [JobRun]()
            for structure0 in jobRunsContainer {
                if let structure0 = structure0 {
                    jobRunsDecoded0?.append(structure0)
                }
            }
        }
        jobRuns = jobRunsDecoded0
    }
}

extension JobNodeDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobNodeDetails(jobRuns: \(String(describing: jobRuns)))"}
}

/// <p>The details of a Job node present in the workflow.</p>
public struct JobNodeDetails: Equatable {
    /// <p>The information for the job runs represented by the job node.</p>
    public let jobRuns: [JobRun]?

    public init (
        jobRuns: [JobRun]? = nil
    )
    {
        self.jobRuns = jobRuns
    }
}

extension JobRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedCapacity = "AllocatedCapacity"
        case arguments = "Arguments"
        case attempt = "Attempt"
        case completedOn = "CompletedOn"
        case errorMessage = "ErrorMessage"
        case executionTime = "ExecutionTime"
        case glueVersion = "GlueVersion"
        case id = "Id"
        case jobName = "JobName"
        case jobRunState = "JobRunState"
        case lastModifiedOn = "LastModifiedOn"
        case logGroupName = "LogGroupName"
        case maxCapacity = "MaxCapacity"
        case notificationProperty = "NotificationProperty"
        case numberOfWorkers = "NumberOfWorkers"
        case predecessorRuns = "PredecessorRuns"
        case previousRunId = "PreviousRunId"
        case securityConfiguration = "SecurityConfiguration"
        case startedOn = "StartedOn"
        case timeout = "Timeout"
        case triggerName = "TriggerName"
        case workerType = "WorkerType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedCapacity != 0 {
            try encodeContainer.encode(allocatedCapacity, forKey: .allocatedCapacity)
        }
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .arguments)
            for (dictKey0, genericmap0) in arguments {
                try argumentsContainer.encode(genericmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if attempt != 0 {
            try encodeContainer.encode(attempt, forKey: .attempt)
        }
        if let completedOn = completedOn {
            try encodeContainer.encode(completedOn.timeIntervalSince1970, forKey: .completedOn)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if executionTime != 0 {
            try encodeContainer.encode(executionTime, forKey: .executionTime)
        }
        if let glueVersion = glueVersion {
            try encodeContainer.encode(glueVersion, forKey: .glueVersion)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobRunState = jobRunState {
            try encodeContainer.encode(jobRunState.rawValue, forKey: .jobRunState)
        }
        if let lastModifiedOn = lastModifiedOn {
            try encodeContainer.encode(lastModifiedOn.timeIntervalSince1970, forKey: .lastModifiedOn)
        }
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let maxCapacity = maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let notificationProperty = notificationProperty {
            try encodeContainer.encode(notificationProperty, forKey: .notificationProperty)
        }
        if let numberOfWorkers = numberOfWorkers {
            try encodeContainer.encode(numberOfWorkers, forKey: .numberOfWorkers)
        }
        if let predecessorRuns = predecessorRuns {
            var predecessorRunsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predecessorRuns)
            for predecessorlist0 in predecessorRuns {
                try predecessorRunsContainer.encode(predecessorlist0)
            }
        }
        if let previousRunId = previousRunId {
            try encodeContainer.encode(previousRunId, forKey: .previousRunId)
        }
        if let securityConfiguration = securityConfiguration {
            try encodeContainer.encode(securityConfiguration, forKey: .securityConfiguration)
        }
        if let startedOn = startedOn {
            try encodeContainer.encode(startedOn.timeIntervalSince1970, forKey: .startedOn)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let triggerName = triggerName {
            try encodeContainer.encode(triggerName, forKey: .triggerName)
        }
        if let workerType = workerType {
            try encodeContainer.encode(workerType.rawValue, forKey: .workerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let attemptDecoded = try containerValues.decode(Int.self, forKey: .attempt)
        attempt = attemptDecoded
        let previousRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .previousRunId)
        previousRunId = previousRunIdDecoded
        let triggerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .triggerName)
        triggerName = triggerNameDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let startedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedOn)
        startedOn = startedOnDecoded
        let lastModifiedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedOn)
        lastModifiedOn = lastModifiedOnDecoded
        let completedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedOn)
        completedOn = completedOnDecoded
        let jobRunStateDecoded = try containerValues.decodeIfPresent(JobRunState.self, forKey: .jobRunState)
        jobRunState = jobRunStateDecoded
        let argumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .arguments)
        var argumentsDecoded0: [String:String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in argumentsContainer {
                if let genericstring0 = genericstring0 {
                    argumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        arguments = argumentsDecoded0
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let predecessorRunsContainer = try containerValues.decodeIfPresent([Predecessor?].self, forKey: .predecessorRuns)
        var predecessorRunsDecoded0:[Predecessor]? = nil
        if let predecessorRunsContainer = predecessorRunsContainer {
            predecessorRunsDecoded0 = [Predecessor]()
            for structure0 in predecessorRunsContainer {
                if let structure0 = structure0 {
                    predecessorRunsDecoded0?.append(structure0)
                }
            }
        }
        predecessorRuns = predecessorRunsDecoded0
        let allocatedCapacityDecoded = try containerValues.decode(Int.self, forKey: .allocatedCapacity)
        allocatedCapacity = allocatedCapacityDecoded
        let executionTimeDecoded = try containerValues.decode(Int.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
        let securityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityConfiguration)
        securityConfiguration = securityConfigurationDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let notificationPropertyDecoded = try containerValues.decodeIfPresent(NotificationProperty.self, forKey: .notificationProperty)
        notificationProperty = notificationPropertyDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
    }
}

extension JobRun: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobRun(allocatedCapacity: \(String(describing: allocatedCapacity)), arguments: \(String(describing: arguments)), attempt: \(String(describing: attempt)), completedOn: \(String(describing: completedOn)), errorMessage: \(String(describing: errorMessage)), executionTime: \(String(describing: executionTime)), glueVersion: \(String(describing: glueVersion)), id: \(String(describing: id)), jobName: \(String(describing: jobName)), jobRunState: \(String(describing: jobRunState)), lastModifiedOn: \(String(describing: lastModifiedOn)), logGroupName: \(String(describing: logGroupName)), maxCapacity: \(String(describing: maxCapacity)), notificationProperty: \(String(describing: notificationProperty)), numberOfWorkers: \(String(describing: numberOfWorkers)), predecessorRuns: \(String(describing: predecessorRuns)), previousRunId: \(String(describing: previousRunId)), securityConfiguration: \(String(describing: securityConfiguration)), startedOn: \(String(describing: startedOn)), timeout: \(String(describing: timeout)), triggerName: \(String(describing: triggerName)), workerType: \(String(describing: workerType)))"}
}

/// <p>Contains information about a job run.</p>
public struct JobRun: Equatable {
    /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
    ///
    ///          <p>The number of AWS Glue data processing units (DPUs) allocated to this JobRun.
    ///       From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure
    ///       of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
    ///       For more information, see the <a href="https://aws.amazon.com/glue/pricing/">AWS Glue
    ///         pricing page</a>.</p>
    @available(*, deprecated, message: "This property is deprecated, use MaxCapacity instead.")
    public let allocatedCapacity: Int
    /// <p>The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself.</p>
    ///          <p>You can specify arguments here that your own job-execution script
    ///       consumes, as well as arguments that AWS Glue itself consumes.</p>
    ///          <p>For information about how to specify and consume your own job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling AWS Glue APIs in Python</a> topic in the developer guide.</p>
    ///          <p>For information about the key-value pairs that AWS Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by AWS Glue</a> topic in the developer guide.</p>
    public let arguments: [String:String]?
    /// <p>The number of the attempt to run this job.</p>
    public let attempt: Int
    /// <p>The date and time that this job run completed.</p>
    public let completedOn: Date?
    /// <p>An error message associated with this job run.</p>
    public let errorMessage: String?
    /// <p>The amount of time (in seconds) that the job run consumed resources.</p>
    public let executionTime: Int
    /// <p>Glue version determines the versions of Apache Spark and Python that AWS Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
    ///
    ///          <p>For more information about the available AWS Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    /// 	
    /// 	        <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
    public let glueVersion: String?
    /// <p>The ID of this job run.</p>
    public let id: String?
    /// <p>The name of the job definition being used in this run.</p>
    public let jobName: String?
    /// <p>The current state of the job run. For more information about the statuses of jobs that have terminated abnormally, see <a href="https://docs.aws.amazon.com/glue/latest/dg/job-run-statuses.html">AWS Glue Job Run Statuses</a>.</p>
    public let jobRunState: JobRunState?
    /// <p>The last time that this job run was modified.</p>
    public let lastModifiedOn: Date?
    /// <p>The name of the log group for secure logging that can be server-side encrypted in Amazon
    ///       CloudWatch using AWS KMS. This name can be <code>/aws-glue/jobs/</code>, in which case the
    ///       default encryption is <code>NONE</code>. If you add a role name and
    ///       <code>SecurityConfiguration</code> name (in other words,
    ///       <code>/aws-glue/jobs-yourRoleName-yourSecurityConfigurationName/</code>), then that security
    ///       configuration is used to encrypt the log group.</p>
    public let logGroupName: String?
    /// <p>The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure
    ///       of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
    ///       For more information, see the <a href="https://docs.aws.amazon.com/https:/aws.amazon.com/glue/pricing/">AWS Glue
    ///         pricing page</a>.</p>
    ///
    ///          <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
    ///
    ///          <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are
    ///       running a Python shell job or an Apache Spark ETL job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can
    ///         allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p>
    ///             </li>
    ///             <li>
    ///                <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p>
    ///             </li>
    ///          </ul>
    public let maxCapacity: Double?
    /// <p>Specifies configuration properties of a job run notification.</p>
    public let notificationProperty: NotificationProperty?
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
    ///
    ///          <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
    public let numberOfWorkers: Int?
    /// <p>A list of predecessors to this job run.</p>
    public let predecessorRuns: [Predecessor]?
    /// <p>The ID of the previous run of this job. For example, the <code>JobRunId</code> specified
    ///       in the <code>StartJobRun</code> action.</p>
    public let previousRunId: String?
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job
    ///       run.</p>
    public let securityConfiguration: String?
    /// <p>The date and time at which this job run was started.</p>
    public let startedOn: Date?
    /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can
    ///       consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default
    ///       is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.</p>
    public let timeout: Int?
    /// <p>The name of the trigger that started this job run.</p>
    public let triggerName: String?
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    ///          <ul>
    ///             <li>
    ///                <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///          </ul>
    public let workerType: WorkerType?

    public init (
        allocatedCapacity: Int = 0,
        arguments: [String:String]? = nil,
        attempt: Int = 0,
        completedOn: Date? = nil,
        errorMessage: String? = nil,
        executionTime: Int = 0,
        glueVersion: String? = nil,
        id: String? = nil,
        jobName: String? = nil,
        jobRunState: JobRunState? = nil,
        lastModifiedOn: Date? = nil,
        logGroupName: String? = nil,
        maxCapacity: Double? = nil,
        notificationProperty: NotificationProperty? = nil,
        numberOfWorkers: Int? = nil,
        predecessorRuns: [Predecessor]? = nil,
        previousRunId: String? = nil,
        securityConfiguration: String? = nil,
        startedOn: Date? = nil,
        timeout: Int? = nil,
        triggerName: String? = nil,
        workerType: WorkerType? = nil
    )
    {
        self.allocatedCapacity = allocatedCapacity
        self.arguments = arguments
        self.attempt = attempt
        self.completedOn = completedOn
        self.errorMessage = errorMessage
        self.executionTime = executionTime
        self.glueVersion = glueVersion
        self.id = id
        self.jobName = jobName
        self.jobRunState = jobRunState
        self.lastModifiedOn = lastModifiedOn
        self.logGroupName = logGroupName
        self.maxCapacity = maxCapacity
        self.notificationProperty = notificationProperty
        self.numberOfWorkers = numberOfWorkers
        self.predecessorRuns = predecessorRuns
        self.previousRunId = previousRunId
        self.securityConfiguration = securityConfiguration
        self.startedOn = startedOn
        self.timeout = timeout
        self.triggerName = triggerName
        self.workerType = workerType
    }
}

public enum JobRunState {
    case failed
    case running
    case starting
    case stopped
    case stopping
    case succeeded
    case timeout
    case sdkUnknown(String)
}

extension JobRunState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobRunState] {
        return [
            .failed,
            .running,
            .starting,
            .stopped,
            .stopping,
            .succeeded,
            .timeout,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case .starting: return "STARTING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case .succeeded: return "SUCCEEDED"
        case .timeout: return "TIMEOUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobRunState(rawValue: rawValue) ?? JobRunState.sdkUnknown(rawValue)
    }
}

extension JobUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedCapacity = "AllocatedCapacity"
        case command = "Command"
        case connections = "Connections"
        case defaultArguments = "DefaultArguments"
        case description = "Description"
        case executionProperty = "ExecutionProperty"
        case glueVersion = "GlueVersion"
        case logUri = "LogUri"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case nonOverridableArguments = "NonOverridableArguments"
        case notificationProperty = "NotificationProperty"
        case numberOfWorkers = "NumberOfWorkers"
        case role = "Role"
        case securityConfiguration = "SecurityConfiguration"
        case timeout = "Timeout"
        case workerType = "WorkerType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedCapacity != 0 {
            try encodeContainer.encode(allocatedCapacity, forKey: .allocatedCapacity)
        }
        if let command = command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let connections = connections {
            try encodeContainer.encode(connections, forKey: .connections)
        }
        if let defaultArguments = defaultArguments {
            var defaultArgumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .defaultArguments)
            for (dictKey0, genericmap0) in defaultArguments {
                try defaultArgumentsContainer.encode(genericmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionProperty = executionProperty {
            try encodeContainer.encode(executionProperty, forKey: .executionProperty)
        }
        if let glueVersion = glueVersion {
            try encodeContainer.encode(glueVersion, forKey: .glueVersion)
        }
        if let logUri = logUri {
            try encodeContainer.encode(logUri, forKey: .logUri)
        }
        if let maxCapacity = maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if maxRetries != 0 {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let nonOverridableArguments = nonOverridableArguments {
            var nonOverridableArgumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .nonOverridableArguments)
            for (dictKey0, genericmap0) in nonOverridableArguments {
                try nonOverridableArgumentsContainer.encode(genericmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let notificationProperty = notificationProperty {
            try encodeContainer.encode(notificationProperty, forKey: .notificationProperty)
        }
        if let numberOfWorkers = numberOfWorkers {
            try encodeContainer.encode(numberOfWorkers, forKey: .numberOfWorkers)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let securityConfiguration = securityConfiguration {
            try encodeContainer.encode(securityConfiguration, forKey: .securityConfiguration)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let workerType = workerType {
            try encodeContainer.encode(workerType.rawValue, forKey: .workerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let logUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logUri)
        logUri = logUriDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let executionPropertyDecoded = try containerValues.decodeIfPresent(ExecutionProperty.self, forKey: .executionProperty)
        executionProperty = executionPropertyDecoded
        let commandDecoded = try containerValues.decodeIfPresent(JobCommand.self, forKey: .command)
        command = commandDecoded
        let defaultArgumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .defaultArguments)
        var defaultArgumentsDecoded0: [String:String]? = nil
        if let defaultArgumentsContainer = defaultArgumentsContainer {
            defaultArgumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in defaultArgumentsContainer {
                if let genericstring0 = genericstring0 {
                    defaultArgumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        defaultArguments = defaultArgumentsDecoded0
        let nonOverridableArgumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .nonOverridableArguments)
        var nonOverridableArgumentsDecoded0: [String:String]? = nil
        if let nonOverridableArgumentsContainer = nonOverridableArgumentsContainer {
            nonOverridableArgumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in nonOverridableArgumentsContainer {
                if let genericstring0 = genericstring0 {
                    nonOverridableArgumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        nonOverridableArguments = nonOverridableArgumentsDecoded0
        let connectionsDecoded = try containerValues.decodeIfPresent(ConnectionsList.self, forKey: .connections)
        connections = connectionsDecoded
        let maxRetriesDecoded = try containerValues.decode(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let allocatedCapacityDecoded = try containerValues.decode(Int.self, forKey: .allocatedCapacity)
        allocatedCapacity = allocatedCapacityDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
        let securityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityConfiguration)
        securityConfiguration = securityConfigurationDecoded
        let notificationPropertyDecoded = try containerValues.decodeIfPresent(NotificationProperty.self, forKey: .notificationProperty)
        notificationProperty = notificationPropertyDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
    }
}

extension JobUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobUpdate(allocatedCapacity: \(String(describing: allocatedCapacity)), command: \(String(describing: command)), connections: \(String(describing: connections)), defaultArguments: \(String(describing: defaultArguments)), description: \(String(describing: description)), executionProperty: \(String(describing: executionProperty)), glueVersion: \(String(describing: glueVersion)), logUri: \(String(describing: logUri)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), nonOverridableArguments: \(String(describing: nonOverridableArguments)), notificationProperty: \(String(describing: notificationProperty)), numberOfWorkers: \(String(describing: numberOfWorkers)), role: \(String(describing: role)), securityConfiguration: \(String(describing: securityConfiguration)), timeout: \(String(describing: timeout)), workerType: \(String(describing: workerType)))"}
}

/// <p>Specifies information used to update an existing job definition. The previous job
///       definition is completely overwritten by this information.</p>
public struct JobUpdate: Equatable {
    /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
    ///
    ///          <p>The number of AWS Glue data processing units (DPUs) to allocate to this job. You can
    ///       allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing
    ///       power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information,
    ///       see the <a href="https://aws.amazon.com/glue/pricing/">AWS Glue pricing
    ///       page</a>.</p>
    @available(*, deprecated, message: "This property is deprecated, use MaxCapacity instead.")
    public let allocatedCapacity: Int
    /// <p>The <code>JobCommand</code> that executes this job (required).</p>
    public let command: JobCommand?
    /// <p>The connections used for this job.</p>
    public let connections: ConnectionsList?
    /// <p>The default arguments for this job.</p>
    ///          <p>You can specify arguments here that your own job-execution script
    ///       consumes, as well as arguments that AWS Glue itself consumes.</p>
    ///          <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling AWS Glue APIs in Python</a> topic in the developer guide.</p>
    ///          <p>For information about the key-value pairs that AWS Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by AWS Glue</a> topic in the developer guide.</p>
    public let defaultArguments: [String:String]?
    /// <p>Description of the job being defined.</p>
    public let description: String?
    /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed
    ///       for this job.</p>
    public let executionProperty: ExecutionProperty?
    /// <p>Glue version determines the versions of Apache Spark and Python that AWS Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
    ///
    ///          <p>For more information about the available AWS Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    public let glueVersion: String?
    /// <p>This field is reserved for future use.</p>
    public let logUri: String?
    /// <p>The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure
    ///      of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">AWS Glue pricing page</a>.</p>
    ///
    /// 	        <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>	
    /// 	
    ///          <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are
    ///       running a Python shell job or an Apache Spark ETL job:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can
    ///           allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p>
    ///             </li>
    ///             <li>
    ///                <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache
    ///            Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate from 2 to 100 DPUs.
    ///            The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p>
    ///             </li>
    ///          </ul>
    public let maxCapacity: Double?
    /// <p>The maximum number of times to retry this job if it fails.</p>
    public let maxRetries: Int
    /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
    public let nonOverridableArguments: [String:String]?
    /// <p>Specifies the configuration properties of a job notification.</p>
    public let notificationProperty: NotificationProperty?
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
    /// 	
    ///          <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
    public let numberOfWorkers: Int?
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job
    ///       (required).</p>
    public let role: String?
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this
    ///       job.</p>
    public let securityConfiguration: String?
    /// <p>The job timeout in minutes.  This is the maximum time that a job run
    ///       can consume resources before it is terminated and enters <code>TIMEOUT</code>
    ///       status. The default is 2,880 minutes (48 hours).</p>
    public let timeout: Int?
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
    ///             </li>
    ///          </ul>
    public let workerType: WorkerType?

    public init (
        allocatedCapacity: Int = 0,
        command: JobCommand? = nil,
        connections: ConnectionsList? = nil,
        defaultArguments: [String:String]? = nil,
        description: String? = nil,
        executionProperty: ExecutionProperty? = nil,
        glueVersion: String? = nil,
        logUri: String? = nil,
        maxCapacity: Double? = nil,
        maxRetries: Int = 0,
        nonOverridableArguments: [String:String]? = nil,
        notificationProperty: NotificationProperty? = nil,
        numberOfWorkers: Int? = nil,
        role: String? = nil,
        securityConfiguration: String? = nil,
        timeout: Int? = nil,
        workerType: WorkerType? = nil
    )
    {
        self.allocatedCapacity = allocatedCapacity
        self.command = command
        self.connections = connections
        self.defaultArguments = defaultArguments
        self.description = description
        self.executionProperty = executionProperty
        self.glueVersion = glueVersion
        self.logUri = logUri
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.nonOverridableArguments = nonOverridableArguments
        self.notificationProperty = notificationProperty
        self.numberOfWorkers = numberOfWorkers
        self.role = role
        self.securityConfiguration = securityConfiguration
        self.timeout = timeout
        self.workerType = workerType
    }
}

extension JsonClassifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case jsonPath = "JsonPath"
        case lastUpdated = "LastUpdated"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let jsonPath = jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let jsonPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
    }
}

extension JsonClassifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JsonClassifier(creationTime: \(String(describing: creationTime)), jsonPath: \(String(describing: jsonPath)), lastUpdated: \(String(describing: lastUpdated)), name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>A classifier for <code>JSON</code> content.</p>
public struct JsonClassifier: Equatable {
    /// <p>The time that this classifier was registered.</p>
    public let creationTime: Date?
    /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify.
    ///       AWS Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
    public let jsonPath: String?
    /// <p>The time that this classifier was last updated.</p>
    public let lastUpdated: Date?
    /// <p>The name of the classifier.</p>
    public let name: String?
    /// <p>The version of this classifier.</p>
    public let version: Int

    public init (
        creationTime: Date? = nil,
        jsonPath: String? = nil,
        lastUpdated: Date? = nil,
        name: String? = nil,
        version: Int = 0
    )
    {
        self.creationTime = creationTime
        self.jsonPath = jsonPath
        self.lastUpdated = lastUpdated
        self.name = name
        self.version = version
    }
}

extension KeySchemaElement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension KeySchemaElement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeySchemaElement(name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>A partition key pair consisting of a name and a type.</p>
public struct KeySchemaElement: Equatable {
    /// <p>The name of a partition key.</p>
    public let name: String?
    /// <p>The type of a partition key.</p>
    public let type: String?

    public init (
        name: String? = nil,
        type: String? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

extension LabelingSetGenerationTaskRunProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputS3Path = "OutputS3Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3Path = outputS3Path {
            try encodeContainer.encode(outputS3Path, forKey: .outputS3Path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Path)
        outputS3Path = outputS3PathDecoded
    }
}

extension LabelingSetGenerationTaskRunProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LabelingSetGenerationTaskRunProperties(outputS3Path: \(String(describing: outputS3Path)))"}
}

/// <p>Specifies configuration properties for a labeling set generation task run.</p>
public struct LabelingSetGenerationTaskRunProperties: Equatable {
    /// <p>The Amazon Simple Storage Service (Amazon S3) path where you will generate the labeling
    ///       set.</p>
    public let outputS3Path: String?

    public init (
        outputS3Path: String? = nil
    )
    {
        self.outputS3Path = outputS3Path
    }
}

public enum Language {
    case python
    case scala
    case sdkUnknown(String)
}

extension Language : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Language] {
        return [
            .python,
            .scala,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .python: return "PYTHON"
        case .scala: return "SCALA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Language(rawValue: rawValue) ?? Language.sdkUnknown(rawValue)
    }
}

extension LastCrawlInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorMessage = "ErrorMessage"
        case logGroup = "LogGroup"
        case logStream = "LogStream"
        case messagePrefix = "MessagePrefix"
        case startTime = "StartTime"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let logGroup = logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
        if let logStream = logStream {
            try encodeContainer.encode(logStream, forKey: .logStream)
        }
        if let messagePrefix = messagePrefix {
            try encodeContainer.encode(messagePrefix, forKey: .messagePrefix)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LastCrawlStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let logGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
        let logStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logStream)
        logStream = logStreamDecoded
        let messagePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messagePrefix)
        messagePrefix = messagePrefixDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension LastCrawlInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LastCrawlInfo(errorMessage: \(String(describing: errorMessage)), logGroup: \(String(describing: logGroup)), logStream: \(String(describing: logStream)), messagePrefix: \(String(describing: messagePrefix)), startTime: \(String(describing: startTime)), status: \(String(describing: status)))"}
}

/// <p>Status and error information about the most recent crawl.</p>
public struct LastCrawlInfo: Equatable {
    /// <p>If an error occurred, the error information about the last crawl.</p>
    public let errorMessage: String?
    /// <p>The log group for the last crawl.</p>
    public let logGroup: String?
    /// <p>The log stream for the last crawl.</p>
    public let logStream: String?
    /// <p>The prefix for a message about this crawl.</p>
    public let messagePrefix: String?
    /// <p>The time at which the crawl started.</p>
    public let startTime: Date?
    /// <p>Status of the last crawl.</p>
    public let status: LastCrawlStatus?

    public init (
        errorMessage: String? = nil,
        logGroup: String? = nil,
        logStream: String? = nil,
        messagePrefix: String? = nil,
        startTime: Date? = nil,
        status: LastCrawlStatus? = nil
    )
    {
        self.errorMessage = errorMessage
        self.logGroup = logGroup
        self.logStream = logStream
        self.messagePrefix = messagePrefix
        self.startTime = startTime
        self.status = status
    }
}

public enum LastCrawlStatus {
    case cancelled
    case failed
    case succeeded
    case sdkUnknown(String)
}

extension LastCrawlStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LastCrawlStatus] {
        return [
            .cancelled,
            .failed,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .failed: return "FAILED"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LastCrawlStatus(rawValue: rawValue) ?? LastCrawlStatus.sdkUnknown(rawValue)
    }
}

extension LineageConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlerLineageSettings = "CrawlerLineageSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawlerLineageSettings = crawlerLineageSettings {
            try encodeContainer.encode(crawlerLineageSettings.rawValue, forKey: .crawlerLineageSettings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerLineageSettingsDecoded = try containerValues.decodeIfPresent(CrawlerLineageSettings.self, forKey: .crawlerLineageSettings)
        crawlerLineageSettings = crawlerLineageSettingsDecoded
    }
}

extension LineageConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LineageConfiguration(crawlerLineageSettings: \(String(describing: crawlerLineageSettings)))"}
}

/// <p>Specifies data lineage configuration settings for the crawler.</p>
public struct LineageConfiguration: Equatable {
    /// <p>Specifies whether data lineage is enabled for the crawler. Valid values are:</p>
    /// 	
    /// 	        <ul>
    ///             <li>
    ///                <p>ENABLE: enables data lineage for the crawler</p>
    ///             </li>
    ///             <li>
    ///                <p>DISABLE: disables data lineage for the crawler</p>
    ///             </li>
    ///          </ul>
    public let crawlerLineageSettings: CrawlerLineageSettings?

    public init (
        crawlerLineageSettings: CrawlerLineageSettings? = nil
    )
    {
        self.crawlerLineageSettings = crawlerLineageSettings
    }
}

public struct ListCrawlersInputBodyMiddleware: Middleware {
    public let id: String = "ListCrawlersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCrawlersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCrawlersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCrawlersInput>
    public typealias MOutput = OperationOutput<ListCrawlersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCrawlersOutputError>
}

extension ListCrawlersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCrawlersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListCrawlersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ListCrawlersInputHeadersMiddleware: Middleware {
    public let id: String = "ListCrawlersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCrawlersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCrawlersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCrawlersInput>
    public typealias MOutput = OperationOutput<ListCrawlersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCrawlersOutputError>
}

public struct ListCrawlersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCrawlersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCrawlersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCrawlersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCrawlersInput>
    public typealias MOutput = OperationOutput<ListCrawlersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCrawlersOutputError>
}

public struct ListCrawlersInput: Equatable {
    /// <p>The maximum size of a list to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation request.</p>
    public let nextToken: String?
    /// <p>Specifies to return only these tagged resources.</p>
    public let tags: [String:String]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListCrawlersInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let tags: [String:String]?
}

extension ListCrawlersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListCrawlersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCrawlersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCrawlersOutputError: Equatable {
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCrawlersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCrawlersOutputResponse(crawlerNames: \(String(describing: crawlerNames)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCrawlersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCrawlersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.crawlerNames = output.crawlerNames
            self.nextToken = output.nextToken
        } else {
            self.crawlerNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListCrawlersOutputResponse: Equatable {
    /// <p>The names of all crawlers in the account, or the crawlers with the specified tags.</p>
    public let crawlerNames: [String]?
    /// <p>A continuation token, if the returned list does not contain the
    ///       last metric available.</p>
    public let nextToken: String?

    public init (
        crawlerNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.crawlerNames = crawlerNames
        self.nextToken = nextToken
    }
}

struct ListCrawlersOutputResponseBody: Equatable {
    public let crawlerNames: [String]?
    public let nextToken: String?
}

extension ListCrawlersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case crawlerNames = "CrawlerNames"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .crawlerNames)
        var crawlerNamesDecoded0:[String]? = nil
        if let crawlerNamesContainer = crawlerNamesContainer {
            crawlerNamesDecoded0 = [String]()
            for string0 in crawlerNamesContainer {
                if let string0 = string0 {
                    crawlerNamesDecoded0?.append(string0)
                }
            }
        }
        crawlerNames = crawlerNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDevEndpointsInputBodyMiddleware: Middleware {
    public let id: String = "ListDevEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevEndpointsInput>
    public typealias MOutput = OperationOutput<ListDevEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevEndpointsOutputError>
}

extension ListDevEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevEndpointsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListDevEndpointsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ListDevEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDevEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevEndpointsInput>
    public typealias MOutput = OperationOutput<ListDevEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevEndpointsOutputError>
}

public struct ListDevEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDevEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevEndpointsInput>
    public typealias MOutput = OperationOutput<ListDevEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevEndpointsOutputError>
}

public struct ListDevEndpointsInput: Equatable {
    /// <p>The maximum size of a list to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation request.</p>
    public let nextToken: String?
    /// <p>Specifies to return only these tagged resources.</p>
    public let tags: [String:String]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListDevEndpointsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let tags: [String:String]?
}

extension ListDevEndpointsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListDevEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevEndpointsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevEndpointsOutputResponse(devEndpointNames: \(String(describing: devEndpointNames)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDevEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDevEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devEndpointNames = output.devEndpointNames
            self.nextToken = output.nextToken
        } else {
            self.devEndpointNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevEndpointsOutputResponse: Equatable {
    /// <p>The names of all the <code>DevEndpoint</code>s in the account, or the
    ///         <code>DevEndpoint</code>s with the specified tags.</p>
    public let devEndpointNames: [String]?
    /// <p>A continuation token, if the returned list does not contain the
    ///       last metric available.</p>
    public let nextToken: String?

    public init (
        devEndpointNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.devEndpointNames = devEndpointNames
        self.nextToken = nextToken
    }
}

struct ListDevEndpointsOutputResponseBody: Equatable {
    public let devEndpointNames: [String]?
    public let nextToken: String?
}

extension ListDevEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devEndpointNames = "DevEndpointNames"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEndpointNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .devEndpointNames)
        var devEndpointNamesDecoded0:[String]? = nil
        if let devEndpointNamesContainer = devEndpointNamesContainer {
            devEndpointNamesDecoded0 = [String]()
            for string0 in devEndpointNamesContainer {
                if let string0 = string0 {
                    devEndpointNamesDecoded0?.append(string0)
                }
            }
        }
        devEndpointNames = devEndpointNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

extension ListJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ListJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInput: Equatable {
    /// <p>The maximum size of a list to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation request.</p>
    public let nextToken: String?
    /// <p>Specifies to return only these tagged resources.</p>
    public let tags: [String:String]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListJobsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let tags: [String:String]?
}

extension ListJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsOutputResponse(jobNames: \(String(describing: jobNames)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobNames = output.jobNames
            self.nextToken = output.nextToken
        } else {
            self.jobNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutputResponse: Equatable {
    /// <p>The names of all jobs in the account, or the jobs with the specified tags.</p>
    public let jobNames: [String]?
    /// <p>A continuation token, if the returned list does not contain the
    ///       last metric available.</p>
    public let nextToken: String?

    public init (
        jobNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobNames = jobNames
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Equatable {
    public let jobNames: [String]?
    public let nextToken: String?
}

extension ListJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobNames = "JobNames"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobNames)
        var jobNamesDecoded0:[String]? = nil
        if let jobNamesContainer = jobNamesContainer {
            jobNamesDecoded0 = [String]()
            for string0 in jobNamesContainer {
                if let string0 = string0 {
                    jobNamesDecoded0?.append(string0)
                }
            }
        }
        jobNames = jobNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMLTransformsInputBodyMiddleware: Middleware {
    public let id: String = "ListMLTransformsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMLTransformsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMLTransformsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMLTransformsInput>
    public typealias MOutput = OperationOutput<ListMLTransformsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMLTransformsOutputError>
}

extension ListMLTransformsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMLTransformsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sort: \(String(describing: sort)), tags: \(String(describing: tags)))"}
}

extension ListMLTransformsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ListMLTransformsInputHeadersMiddleware: Middleware {
    public let id: String = "ListMLTransformsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMLTransformsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMLTransformsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMLTransformsInput>
    public typealias MOutput = OperationOutput<ListMLTransformsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMLTransformsOutputError>
}

public struct ListMLTransformsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMLTransformsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMLTransformsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMLTransformsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMLTransformsInput>
    public typealias MOutput = OperationOutput<ListMLTransformsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMLTransformsOutputError>
}

public struct ListMLTransformsInput: Equatable {
    /// <p>A <code>TransformFilterCriteria</code> used to filter the machine learning transforms.</p>
    public let filter: TransformFilterCriteria?
    /// <p>The maximum size of a list to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation request.</p>
    public let nextToken: String?
    /// <p>A <code>TransformSortCriteria</code> used to sort the machine learning transforms.</p>
    public let sort: TransformSortCriteria?
    /// <p>Specifies to return only these tagged resources.</p>
    public let tags: [String:String]?

    public init (
        filter: TransformFilterCriteria? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sort: TransformSortCriteria? = nil,
        tags: [String:String]? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
        self.tags = tags
    }
}

struct ListMLTransformsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filter: TransformFilterCriteria?
    public let sort: TransformSortCriteria?
    public let tags: [String:String]?
}

extension ListMLTransformsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(TransformFilterCriteria.self, forKey: .filter)
        filter = filterDecoded
        let sortDecoded = try containerValues.decodeIfPresent(TransformSortCriteria.self, forKey: .sort)
        sort = sortDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListMLTransformsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMLTransformsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMLTransformsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMLTransformsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMLTransformsOutputResponse(nextToken: \(String(describing: nextToken)), transformIds: \(String(describing: transformIds)))"}
}

extension ListMLTransformsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMLTransformsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.transformIds = output.transformIds
        } else {
            self.nextToken = nil
            self.transformIds = nil
        }
    }
}

public struct ListMLTransformsOutputResponse: Equatable {
    /// <p>A continuation token, if the returned list does not contain the
    ///       last metric available.</p>
    public let nextToken: String?
    /// <p>The identifiers of all the machine learning transforms in the account, or the
    ///         machine learning transforms with the specified tags.</p>
    public let transformIds: [String]?

    public init (
        nextToken: String? = nil,
        transformIds: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.transformIds = transformIds
    }
}

struct ListMLTransformsOutputResponseBody: Equatable {
    public let transformIds: [String]?
    public let nextToken: String?
}

extension ListMLTransformsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case transformIds = "TransformIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .transformIds)
        var transformIdsDecoded0:[String]? = nil
        if let transformIdsContainer = transformIdsContainer {
            transformIdsDecoded0 = [String]()
            for string0 in transformIdsContainer {
                if let string0 = string0 {
                    transformIdsDecoded0?.append(string0)
                }
            }
        }
        transformIds = transformIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRegistriesInputBodyMiddleware: Middleware {
    public let id: String = "ListRegistriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegistriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegistriesInput>
    public typealias MOutput = OperationOutput<ListRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegistriesOutputError>
}

extension ListRegistriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegistriesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRegistriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRegistriesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRegistriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegistriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegistriesInput>
    public typealias MOutput = OperationOutput<ListRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegistriesOutputError>
}

public struct ListRegistriesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRegistriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegistriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegistriesInput>
    public typealias MOutput = OperationOutput<ListRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegistriesOutputError>
}

public struct ListRegistriesInput: Equatable {
    /// <p>Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRegistriesInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListRegistriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRegistriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRegistriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRegistriesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRegistriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegistriesOutputResponse(nextToken: \(String(describing: nextToken)), registries: \(String(describing: registries)))"}
}

extension ListRegistriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRegistriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.registries = output.registries
        } else {
            self.nextToken = nil
            self.registries = nil
        }
    }
}

public struct ListRegistriesOutputResponse: Equatable {
    /// <p>A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.</p>
    public let nextToken: String?
    /// <p>An array of <code>RegistryDetailedListItem</code> objects containing minimal details of each registry.</p>
    public let registries: [RegistryListItem]?

    public init (
        nextToken: String? = nil,
        registries: [RegistryListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.registries = registries
    }
}

struct ListRegistriesOutputResponseBody: Equatable {
    public let registries: [RegistryListItem]?
    public let nextToken: String?
}

extension ListRegistriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case registries = "Registries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registriesContainer = try containerValues.decodeIfPresent([RegistryListItem?].self, forKey: .registries)
        var registriesDecoded0:[RegistryListItem]? = nil
        if let registriesContainer = registriesContainer {
            registriesDecoded0 = [RegistryListItem]()
            for structure0 in registriesContainer {
                if let structure0 = structure0 {
                    registriesDecoded0?.append(structure0)
                }
            }
        }
        registries = registriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSchemaVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListSchemaVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemaVersionsInput>
    public typealias MOutput = OperationOutput<ListSchemaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemaVersionsOutputError>
}

extension ListSchemaVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemaVersionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), schemaId: \(String(describing: schemaId)))"}
}

extension ListSchemaVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaId = "SchemaId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
    }
}

public struct ListSchemaVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSchemaVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemaVersionsInput>
    public typealias MOutput = OperationOutput<ListSchemaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemaVersionsOutputError>
}

public struct ListSchemaVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSchemaVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemaVersionsInput>
    public typealias MOutput = OperationOutput<ListSchemaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemaVersionsOutputError>
}

public struct ListSchemaVersionsInput: Equatable {
    /// <p>Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?
    /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>SchemaId$SchemaName: The name of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
    ///             </li>
    ///          </ul>
    public let schemaId: SchemaId?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        schemaId: SchemaId? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaId = schemaId
    }
}

struct ListSchemaVersionsInputBody: Equatable {
    public let schemaId: SchemaId?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListSchemaVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaId = "SchemaId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSchemaVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemaVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSchemaVersionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemaVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemaVersionsOutputResponse(nextToken: \(String(describing: nextToken)), schemas: \(String(describing: schemas)))"}
}

extension ListSchemaVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSchemaVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemaVersionsOutputResponse: Equatable {
    /// <p>A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.</p>
    public let nextToken: String?
    /// <p>An array of <code>SchemaVersionList</code> objects containing details of each schema version.</p>
    public let schemas: [SchemaVersionListItem]?

    public init (
        nextToken: String? = nil,
        schemas: [SchemaVersionListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemaVersionsOutputResponseBody: Equatable {
    public let schemas: [SchemaVersionListItem]?
    public let nextToken: String?
}

extension ListSchemaVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([SchemaVersionListItem?].self, forKey: .schemas)
        var schemasDecoded0:[SchemaVersionListItem]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SchemaVersionListItem]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSchemasInputBodyMiddleware: Middleware {
    public let id: String = "ListSchemasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemasInput>
    public typealias MOutput = OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemasOutputError>
}

extension ListSchemasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemasInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), registryId: \(String(describing: registryId)))"}
}

extension ListSchemasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registryId = "RegistryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
    }
}

public struct ListSchemasInputHeadersMiddleware: Middleware {
    public let id: String = "ListSchemasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemasInput>
    public typealias MOutput = OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemasOutputError>
}

public struct ListSchemasInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSchemasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemasInput>
    public typealias MOutput = OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemasOutputError>
}

public struct ListSchemasInput: Equatable {
    /// <p>Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?
    /// <p>A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).</p>
    public let registryId: RegistryId?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        registryId: RegistryId? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
    }
}

struct ListSchemasInputBody: Equatable {
    public let registryId: RegistryId?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListSchemasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registryId = "RegistryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(RegistryId.self, forKey: .registryId)
        registryId = registryIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSchemasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSchemasOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemasOutputResponse(nextToken: \(String(describing: nextToken)), schemas: \(String(describing: schemas)))"}
}

extension ListSchemasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSchemasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemasOutputResponse: Equatable {
    /// <p>A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.</p>
    public let nextToken: String?
    /// <p>An array of <code>SchemaListItem</code> objects containing details of each schema.</p>
    public let schemas: [SchemaListItem]?

    public init (
        nextToken: String? = nil,
        schemas: [SchemaListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemasOutputResponseBody: Equatable {
    public let schemas: [SchemaListItem]?
    public let nextToken: String?
}

extension ListSchemasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([SchemaListItem?].self, forKey: .schemas)
        var schemasDecoded0:[SchemaListItem]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SchemaListItem]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTriggersInputBodyMiddleware: Middleware {
    public let id: String = "ListTriggersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTriggersInput>
    public typealias MOutput = OperationOutput<ListTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTriggersOutputError>
}

extension ListTriggersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTriggersInput(dependentJobName: \(String(describing: dependentJobName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTriggersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dependentJobName = "DependentJobName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependentJobName = dependentJobName {
            try encodeContainer.encode(dependentJobName, forKey: .dependentJobName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ListTriggersInputHeadersMiddleware: Middleware {
    public let id: String = "ListTriggersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTriggersInput>
    public typealias MOutput = OperationOutput<ListTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTriggersOutputError>
}

public struct ListTriggersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTriggersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTriggersInput>
    public typealias MOutput = OperationOutput<ListTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTriggersOutputError>
}

public struct ListTriggersInput: Equatable {
    /// <p> The name of the job for which to retrieve triggers. The trigger that can start this job
    ///       is returned. If there is no such trigger, all triggers are returned.</p>
    public let dependentJobName: String?
    /// <p>The maximum size of a list to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation request.</p>
    public let nextToken: String?
    /// <p>Specifies to return only these tagged resources.</p>
    public let tags: [String:String]?

    public init (
        dependentJobName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.dependentJobName = dependentJobName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTriggersInputBody: Equatable {
    public let nextToken: String?
    public let dependentJobName: String?
    public let maxResults: Int?
    public let tags: [String:String]?
}

extension ListTriggersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dependentJobName = "DependentJobName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dependentJobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dependentJobName)
        dependentJobName = dependentJobNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTriggersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTriggersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTriggersOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTriggersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTriggersOutputResponse(nextToken: \(String(describing: nextToken)), triggerNames: \(String(describing: triggerNames)))"}
}

extension ListTriggersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTriggersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.triggerNames = output.triggerNames
        } else {
            self.nextToken = nil
            self.triggerNames = nil
        }
    }
}

public struct ListTriggersOutputResponse: Equatable {
    /// <p>A continuation token, if the returned list does not contain the
    ///       last metric available.</p>
    public let nextToken: String?
    /// <p>The names of all triggers in the account, or the triggers with the specified tags.</p>
    public let triggerNames: [String]?

    public init (
        nextToken: String? = nil,
        triggerNames: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.triggerNames = triggerNames
    }
}

struct ListTriggersOutputResponseBody: Equatable {
    public let triggerNames: [String]?
    public let nextToken: String?
}

extension ListTriggersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case triggerNames = "TriggerNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .triggerNames)
        var triggerNamesDecoded0:[String]? = nil
        if let triggerNamesContainer = triggerNamesContainer {
            triggerNamesDecoded0 = [String]()
            for string0 in triggerNamesContainer {
                if let string0 = string0 {
                    triggerNamesDecoded0?.append(string0)
                }
            }
        }
        triggerNames = triggerNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWorkflowsInputBodyMiddleware: Middleware {
    public let id: String = "ListWorkflowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkflowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkflowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkflowsInput>
    public typealias MOutput = OperationOutput<ListWorkflowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkflowsOutputError>
}

extension ListWorkflowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkflowsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWorkflowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorkflowsInputHeadersMiddleware: Middleware {
    public let id: String = "ListWorkflowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkflowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkflowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkflowsInput>
    public typealias MOutput = OperationOutput<ListWorkflowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkflowsOutputError>
}

public struct ListWorkflowsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWorkflowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkflowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkflowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkflowsInput>
    public typealias MOutput = OperationOutput<ListWorkflowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkflowsOutputError>
}

public struct ListWorkflowsInput: Equatable {
    /// <p>The maximum size of a list to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is a continuation request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkflowsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListWorkflowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkflowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkflowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkflowsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkflowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkflowsOutputResponse(nextToken: \(String(describing: nextToken)), workflows: \(String(describing: workflows)))"}
}

extension ListWorkflowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWorkflowsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.workflows = output.workflows
        } else {
            self.nextToken = nil
            self.workflows = nil
        }
    }
}

public struct ListWorkflowsOutputResponse: Equatable {
    /// <p>A continuation token, if not all workflow names have been returned.</p>
    public let nextToken: String?
    /// <p>List of names of workflows in the account.</p>
    public let workflows: [String]?

    public init (
        nextToken: String? = nil,
        workflows: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflows = workflows
    }
}

struct ListWorkflowsOutputResponseBody: Equatable {
    public let workflows: [String]?
    public let nextToken: String?
}

extension ListWorkflowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case workflows = "Workflows"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .workflows)
        var workflowsDecoded0:[String]? = nil
        if let workflowsContainer = workflowsContainer {
            workflowsDecoded0 = [String]()
            for string0 in workflowsContainer {
                if let string0 = string0 {
                    workflowsDecoded0?.append(string0)
                }
            }
        }
        workflows = workflowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dynamoDB = "DynamoDB"
        case jdbc = "Jdbc"
        case s3 = "S3"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dynamoDB = dynamoDB {
            var dynamoDBContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dynamoDB)
            for codegennodeargs0 in dynamoDB {
                try dynamoDBContainer.encode(codegennodeargs0)
            }
        }
        if let jdbc = jdbc {
            var jdbcContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jdbc)
            for codegennodeargs0 in jdbc {
                try jdbcContainer.encode(codegennodeargs0)
            }
        }
        if let s3 = s3 {
            var s3Container = encodeContainer.nestedUnkeyedContainer(forKey: .s3)
            for codegennodeargs0 in s3 {
                try s3Container.encode(codegennodeargs0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jdbcContainer = try containerValues.decodeIfPresent([CodeGenNodeArg?].self, forKey: .jdbc)
        var jdbcDecoded0:[CodeGenNodeArg]? = nil
        if let jdbcContainer = jdbcContainer {
            jdbcDecoded0 = [CodeGenNodeArg]()
            for structure0 in jdbcContainer {
                if let structure0 = structure0 {
                    jdbcDecoded0?.append(structure0)
                }
            }
        }
        jdbc = jdbcDecoded0
        let s3Container = try containerValues.decodeIfPresent([CodeGenNodeArg?].self, forKey: .s3)
        var s3Decoded0:[CodeGenNodeArg]? = nil
        if let s3Container = s3Container {
            s3Decoded0 = [CodeGenNodeArg]()
            for structure0 in s3Container {
                if let structure0 = structure0 {
                    s3Decoded0?.append(structure0)
                }
            }
        }
        s3 = s3Decoded0
        let dynamoDBContainer = try containerValues.decodeIfPresent([CodeGenNodeArg?].self, forKey: .dynamoDB)
        var dynamoDBDecoded0:[CodeGenNodeArg]? = nil
        if let dynamoDBContainer = dynamoDBContainer {
            dynamoDBDecoded0 = [CodeGenNodeArg]()
            for structure0 in dynamoDBContainer {
                if let structure0 = structure0 {
                    dynamoDBDecoded0?.append(structure0)
                }
            }
        }
        dynamoDB = dynamoDBDecoded0
    }
}

extension Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Location(dynamoDB: \(String(describing: dynamoDB)), jdbc: \(String(describing: jdbc)), s3: \(String(describing: s3)))"}
}

/// <p>The location of resources.</p>
public struct Location: Equatable {
    /// <p>An Amazon DynamoDB table location.</p>
    public let dynamoDB: [CodeGenNodeArg]?
    /// <p>A JDBC location.</p>
    public let jdbc: [CodeGenNodeArg]?
    /// <p>An Amazon Simple Storage Service (Amazon S3) location.</p>
    public let s3: [CodeGenNodeArg]?

    public init (
        dynamoDB: [CodeGenNodeArg]? = nil,
        jdbc: [CodeGenNodeArg]? = nil,
        s3: [CodeGenNodeArg]? = nil
    )
    {
        self.dynamoDB = dynamoDB
        self.jdbc = jdbc
        self.s3 = s3
    }
}

public enum Logical {
    case and
    case any
    case sdkUnknown(String)
}

extension Logical : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Logical] {
        return [
            .and,
            .any,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .and: return "AND"
        case .any: return "ANY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Logical(rawValue: rawValue) ?? Logical.sdkUnknown(rawValue)
    }
}

public enum LogicalOperator {
    case equals
    case sdkUnknown(String)
}

extension LogicalOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogicalOperator] {
        return [
            .equals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equals: return "EQUALS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogicalOperator(rawValue: rawValue) ?? LogicalOperator.sdkUnknown(rawValue)
    }
}

extension LongColumnStatisticsData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maximumValue = "MaximumValue"
        case minimumValue = "MinimumValue"
        case numberOfDistinctValues = "NumberOfDistinctValues"
        case numberOfNulls = "NumberOfNulls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maximumValue != 0 {
            try encodeContainer.encode(maximumValue, forKey: .maximumValue)
        }
        if minimumValue != 0 {
            try encodeContainer.encode(minimumValue, forKey: .minimumValue)
        }
        if numberOfDistinctValues != 0 {
            try encodeContainer.encode(numberOfDistinctValues, forKey: .numberOfDistinctValues)
        }
        if numberOfNulls != 0 {
            try encodeContainer.encode(numberOfNulls, forKey: .numberOfNulls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumValueDecoded = try containerValues.decode(Int.self, forKey: .minimumValue)
        minimumValue = minimumValueDecoded
        let maximumValueDecoded = try containerValues.decode(Int.self, forKey: .maximumValue)
        maximumValue = maximumValueDecoded
        let numberOfNullsDecoded = try containerValues.decode(Int.self, forKey: .numberOfNulls)
        numberOfNulls = numberOfNullsDecoded
        let numberOfDistinctValuesDecoded = try containerValues.decode(Int.self, forKey: .numberOfDistinctValues)
        numberOfDistinctValues = numberOfDistinctValuesDecoded
    }
}

extension LongColumnStatisticsData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LongColumnStatisticsData(maximumValue: \(String(describing: maximumValue)), minimumValue: \(String(describing: minimumValue)), numberOfDistinctValues: \(String(describing: numberOfDistinctValues)), numberOfNulls: \(String(describing: numberOfNulls)))"}
}

/// <p>Defines column statistics supported for integer data columns.</p>
public struct LongColumnStatisticsData: Equatable {
    /// <p>The highest value in the column.</p>
    public let maximumValue: Int
    /// <p>The lowest value in the column.</p>
    public let minimumValue: Int
    /// <p>The number of distinct values in a column.</p>
    public let numberOfDistinctValues: Int
    /// <p>The number of null values in the column.</p>
    public let numberOfNulls: Int

    public init (
        maximumValue: Int = 0,
        minimumValue: Int = 0,
        numberOfDistinctValues: Int = 0,
        numberOfNulls: Int = 0
    )
    {
        self.maximumValue = maximumValue
        self.minimumValue = minimumValue
        self.numberOfDistinctValues = numberOfDistinctValues
        self.numberOfNulls = numberOfNulls
    }
}

extension MLTransform: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdOn = "CreatedOn"
        case description = "Description"
        case evaluationMetrics = "EvaluationMetrics"
        case glueVersion = "GlueVersion"
        case inputRecordTables = "InputRecordTables"
        case labelCount = "LabelCount"
        case lastModifiedOn = "LastModifiedOn"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case numberOfWorkers = "NumberOfWorkers"
        case parameters = "Parameters"
        case role = "Role"
        case schema = "Schema"
        case status = "Status"
        case timeout = "Timeout"
        case transformEncryption = "TransformEncryption"
        case transformId = "TransformId"
        case workerType = "WorkerType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdOn = createdOn {
            try encodeContainer.encode(createdOn.timeIntervalSince1970, forKey: .createdOn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let evaluationMetrics = evaluationMetrics {
            try encodeContainer.encode(evaluationMetrics, forKey: .evaluationMetrics)
        }
        if let glueVersion = glueVersion {
            try encodeContainer.encode(glueVersion, forKey: .glueVersion)
        }
        if let inputRecordTables = inputRecordTables {
            var inputRecordTablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputRecordTables)
            for gluetables0 in inputRecordTables {
                try inputRecordTablesContainer.encode(gluetables0)
            }
        }
        if labelCount != 0 {
            try encodeContainer.encode(labelCount, forKey: .labelCount)
        }
        if let lastModifiedOn = lastModifiedOn {
            try encodeContainer.encode(lastModifiedOn.timeIntervalSince1970, forKey: .lastModifiedOn)
        }
        if let maxCapacity = maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let maxRetries = maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberOfWorkers = numberOfWorkers {
            try encodeContainer.encode(numberOfWorkers, forKey: .numberOfWorkers)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let schema = schema {
            var schemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schema)
            for transformschema0 in schema {
                try schemaContainer.encode(transformschema0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let transformEncryption = transformEncryption {
            try encodeContainer.encode(transformEncryption, forKey: .transformEncryption)
        }
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
        if let workerType = workerType {
            try encodeContainer.encode(workerType.rawValue, forKey: .workerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransformStatusType.self, forKey: .status)
        status = statusDecoded
        let createdOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdOn)
        createdOn = createdOnDecoded
        let lastModifiedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedOn)
        lastModifiedOn = lastModifiedOnDecoded
        let inputRecordTablesContainer = try containerValues.decodeIfPresent([GlueTable?].self, forKey: .inputRecordTables)
        var inputRecordTablesDecoded0:[GlueTable]? = nil
        if let inputRecordTablesContainer = inputRecordTablesContainer {
            inputRecordTablesDecoded0 = [GlueTable]()
            for structure0 in inputRecordTablesContainer {
                if let structure0 = structure0 {
                    inputRecordTablesDecoded0?.append(structure0)
                }
            }
        }
        inputRecordTables = inputRecordTablesDecoded0
        let parametersDecoded = try containerValues.decodeIfPresent(TransformParameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let evaluationMetricsDecoded = try containerValues.decodeIfPresent(EvaluationMetrics.self, forKey: .evaluationMetrics)
        evaluationMetrics = evaluationMetricsDecoded
        let labelCountDecoded = try containerValues.decode(Int.self, forKey: .labelCount)
        labelCount = labelCountDecoded
        let schemaContainer = try containerValues.decodeIfPresent([SchemaColumn?].self, forKey: .schema)
        var schemaDecoded0:[SchemaColumn]? = nil
        if let schemaContainer = schemaContainer {
            schemaDecoded0 = [SchemaColumn]()
            for structure0 in schemaContainer {
                if let structure0 = structure0 {
                    schemaDecoded0?.append(structure0)
                }
            }
        }
        schema = schemaDecoded0
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let transformEncryptionDecoded = try containerValues.decodeIfPresent(TransformEncryption.self, forKey: .transformEncryption)
        transformEncryption = transformEncryptionDecoded
    }
}

extension MLTransform: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MLTransform(createdOn: \(String(describing: createdOn)), description: \(String(describing: description)), evaluationMetrics: \(String(describing: evaluationMetrics)), glueVersion: \(String(describing: glueVersion)), inputRecordTables: \(String(describing: inputRecordTables)), labelCount: \(String(describing: labelCount)), lastModifiedOn: \(String(describing: lastModifiedOn)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), numberOfWorkers: \(String(describing: numberOfWorkers)), parameters: \(String(describing: parameters)), role: \(String(describing: role)), schema: \(String(describing: schema)), status: \(String(describing: status)), timeout: \(String(describing: timeout)), transformEncryption: \(String(describing: transformEncryption)), transformId: \(String(describing: transformId)), workerType: \(String(describing: workerType)))"}
}

/// <p>A structure for a machine learning transform.</p>
public struct MLTransform: Equatable {
    /// <p>A timestamp. The time and date that this machine learning transform was created.</p>
    public let createdOn: Date?
    /// <p>A user-defined, long-form description text for the machine learning transform.
    ///       Descriptions are not guaranteed to be unique and can be changed at any time.</p>
    public let description: String?
    /// <p>An <code>EvaluationMetrics</code> object. Evaluation metrics provide an estimate of the quality of your machine learning transform.</p>
    public let evaluationMetrics: EvaluationMetrics?
    /// <p>This value determines which version of AWS Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">AWS Glue Versions</a> in the developer guide.</p>
    public let glueVersion: String?
    /// <p>A list of AWS Glue table definitions used by the transform.</p>
    public let inputRecordTables: [GlueTable]?
    /// <p>A count identifier for the labeling files generated by AWS Glue for this transform. As you create a better transform, you can iteratively download, label, and upload the labeling file.</p>
    public let labelCount: Int
    /// <p>A timestamp. The last point in time when this machine learning transform was modified.</p>
    public let lastModifiedOn: Date?
    /// <p>The number of AWS Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of
    ///       processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
    ///       information, see the <a href="http://aws.amazon.com/glue/pricing/">AWS Glue pricing
    ///         page</a>. </p>
    /// 		
    /// 		       <p>
    ///             <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
    ///         <ul>
    ///             <li>
    ///                <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p>
    ///             </li>
    ///          </ul>
    /// 		
    /// 	        <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
    public let maxCapacity: Double?
    /// <p>The maximum number of times to retry after an <code>MLTaskRun</code> of the machine
    ///       learning transform fails.</p>
    public let maxRetries: Int?
    /// <p>A user-defined name for the machine learning transform. Names are not guaranteed unique
    ///       and can be changed at any time.</p>
    public let name: String?
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a task of the transform runs.</p>
    /// 	
    /// 	        <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
    public let numberOfWorkers: Int?
    /// <p>A <code>TransformParameters</code> object. You can use parameters to tune (customize) the
    ///       behavior of the machine learning transform by specifying what data it learns from and your
    ///       preference on various tradeoffs (such as precious vs. recall, or accuracy vs. cost).</p>
    public let parameters: TransformParameters?
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both AWS Glue service role permissions to AWS Glue resources, and Amazon S3 permissions required by the transform. </p>
    ///
    /// 		       <ul>
    ///             <li>
    ///                <p>This role needs AWS Glue service role permissions to allow access to resources in AWS Glue. See <a href="https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html">Attach a Policy to IAM Users That Access AWS Glue</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.</p>
    ///             </li>
    ///          </ul>
    public let role: String?
    /// <p>A map of key-value pairs representing the columns and data types that this transform can
    ///       run against. Has an upper bound of 100 columns.</p>
    public let schema: [SchemaColumn]?
    /// <p>The current status of the machine learning transform.</p>
    public let status: TransformStatusType?
    /// <p>The timeout in minutes of the machine learning transform.</p>
    public let timeout: Int?
    /// <p>The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.</p>
    public let transformEncryption: TransformEncryption?
    /// <p>The unique transform ID that is generated for the machine learning transform. The ID is
    ///       guaranteed to be unique and does not change.</p>
    public let transformId: String?
    /// <p>The type of predefined worker that is allocated when a task of this transform runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///          </ul>
    /// 	
    /// 	        <p>
    ///             <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
    ///         <ul>
    ///             <li>
    ///                <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p>
    ///             </li>
    ///          </ul>
    public let workerType: WorkerType?

    public init (
        createdOn: Date? = nil,
        description: String? = nil,
        evaluationMetrics: EvaluationMetrics? = nil,
        glueVersion: String? = nil,
        inputRecordTables: [GlueTable]? = nil,
        labelCount: Int = 0,
        lastModifiedOn: Date? = nil,
        maxCapacity: Double? = nil,
        maxRetries: Int? = nil,
        name: String? = nil,
        numberOfWorkers: Int? = nil,
        parameters: TransformParameters? = nil,
        role: String? = nil,
        schema: [SchemaColumn]? = nil,
        status: TransformStatusType? = nil,
        timeout: Int? = nil,
        transformEncryption: TransformEncryption? = nil,
        transformId: String? = nil,
        workerType: WorkerType? = nil
    )
    {
        self.createdOn = createdOn
        self.description = description
        self.evaluationMetrics = evaluationMetrics
        self.glueVersion = glueVersion
        self.inputRecordTables = inputRecordTables
        self.labelCount = labelCount
        self.lastModifiedOn = lastModifiedOn
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.numberOfWorkers = numberOfWorkers
        self.parameters = parameters
        self.role = role
        self.schema = schema
        self.status = status
        self.timeout = timeout
        self.transformEncryption = transformEncryption
        self.transformId = transformId
        self.workerType = workerType
    }
}

extension MLTransformNotReadyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MLTransformNotReadyException(message: \(String(describing: message)))"}
}

extension MLTransformNotReadyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MLTransformNotReadyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The machine learning transform is not ready to run.</p>
public struct MLTransformNotReadyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MLTransformNotReadyExceptionBody: Equatable {
    public let message: String?
}

extension MLTransformNotReadyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MLUserDataEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyId = "KmsKeyId"
        case mlUserDataEncryptionMode = "MlUserDataEncryptionMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let mlUserDataEncryptionMode = mlUserDataEncryptionMode {
            try encodeContainer.encode(mlUserDataEncryptionMode.rawValue, forKey: .mlUserDataEncryptionMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mlUserDataEncryptionModeDecoded = try containerValues.decodeIfPresent(MLUserDataEncryptionModeString.self, forKey: .mlUserDataEncryptionMode)
        mlUserDataEncryptionMode = mlUserDataEncryptionModeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension MLUserDataEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MLUserDataEncryption(kmsKeyId: \(String(describing: kmsKeyId)), mlUserDataEncryptionMode: \(String(describing: mlUserDataEncryptionMode)))"}
}

/// <p>The encryption-at-rest settings of the transform that apply to accessing user data.</p>
public struct MLUserDataEncryption: Equatable {
    /// <p>The ID for the customer-provided KMS key.</p>
    public let kmsKeyId: String?
    /// <p>The encryption mode applied to user data. Valid values are:</p>
    /// 	
    /// 	        <ul>
    ///             <li>
    ///                <p>DISABLED: encryption is disabled</p>
    ///             </li>
    ///             <li>
    ///                <p>SSEKMS: use of server-side encryption with AWS Key Management Service (SSE-KMS) for user data stored in Amazon S3.</p>
    ///             </li>
    ///          </ul>
    public let mlUserDataEncryptionMode: MLUserDataEncryptionModeString?

    public init (
        kmsKeyId: String? = nil,
        mlUserDataEncryptionMode: MLUserDataEncryptionModeString? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.mlUserDataEncryptionMode = mlUserDataEncryptionMode
    }
}

public enum MLUserDataEncryptionModeString {
    case disabled
    case ssekms
    case sdkUnknown(String)
}

extension MLUserDataEncryptionModeString : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MLUserDataEncryptionModeString] {
        return [
            .disabled,
            .ssekms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .ssekms: return "SSE-KMS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MLUserDataEncryptionModeString(rawValue: rawValue) ?? MLUserDataEncryptionModeString.sdkUnknown(rawValue)
    }
}

extension MappingEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourcePath = "SourcePath"
        case sourceTable = "SourceTable"
        case sourceType = "SourceType"
        case targetPath = "TargetPath"
        case targetTable = "TargetTable"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourcePath = sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
        if let sourceTable = sourceTable {
            try encodeContainer.encode(sourceTable, forKey: .sourceTable)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let targetPath = targetPath {
            try encodeContainer.encode(targetPath, forKey: .targetPath)
        }
        if let targetTable = targetTable {
            try encodeContainer.encode(targetTable, forKey: .targetTable)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTableDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceTable)
        sourceTable = sourceTableDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let targetTableDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetTable)
        targetTable = targetTableDecoded
        let targetPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetPath)
        targetPath = targetPathDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

extension MappingEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MappingEntry(sourcePath: \(String(describing: sourcePath)), sourceTable: \(String(describing: sourceTable)), sourceType: \(String(describing: sourceType)), targetPath: \(String(describing: targetPath)), targetTable: \(String(describing: targetTable)), targetType: \(String(describing: targetType)))"}
}

/// <p>Defines a mapping.</p>
public struct MappingEntry: Equatable {
    /// <p>The source path.</p>
    public let sourcePath: String?
    /// <p>The name of the source table.</p>
    public let sourceTable: String?
    /// <p>The source type.</p>
    public let sourceType: String?
    /// <p>The target path.</p>
    public let targetPath: String?
    /// <p>The target table.</p>
    public let targetTable: String?
    /// <p>The target type.</p>
    public let targetType: String?

    public init (
        sourcePath: String? = nil,
        sourceTable: String? = nil,
        sourceType: String? = nil,
        targetPath: String? = nil,
        targetTable: String? = nil,
        targetType: String? = nil
    )
    {
        self.sourcePath = sourcePath
        self.sourceTable = sourceTable
        self.sourceType = sourceType
        self.targetPath = targetPath
        self.targetTable = targetTable
        self.targetType = targetType
    }
}

extension MetadataInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case metadataValue = "MetadataValue"
        case otherMetadataValueList = "OtherMetadataValueList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let metadataValue = metadataValue {
            try encodeContainer.encode(metadataValue, forKey: .metadataValue)
        }
        if let otherMetadataValueList = otherMetadataValueList {
            var otherMetadataValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .otherMetadataValueList)
            for othermetadatavaluelist0 in otherMetadataValueList {
                try otherMetadataValueListContainer.encode(othermetadatavaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadataValue)
        metadataValue = metadataValueDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let otherMetadataValueListContainer = try containerValues.decodeIfPresent([OtherMetadataValueListItem?].self, forKey: .otherMetadataValueList)
        var otherMetadataValueListDecoded0:[OtherMetadataValueListItem]? = nil
        if let otherMetadataValueListContainer = otherMetadataValueListContainer {
            otherMetadataValueListDecoded0 = [OtherMetadataValueListItem]()
            for structure0 in otherMetadataValueListContainer {
                if let structure0 = structure0 {
                    otherMetadataValueListDecoded0?.append(structure0)
                }
            }
        }
        otherMetadataValueList = otherMetadataValueListDecoded0
    }
}

extension MetadataInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetadataInfo(createdTime: \(String(describing: createdTime)), metadataValue: \(String(describing: metadataValue)), otherMetadataValueList: \(String(describing: otherMetadataValueList)))"}
}

/// <p>A structure containing metadata information for a schema version.</p>
public struct MetadataInfo: Equatable {
    /// <p>The time at which the entry was created.</p>
    public let createdTime: String?
    /// <p>The metadata key’s corresponding value.</p>
    public let metadataValue: String?
    /// <p>Other metadata belonging to the same metadata key.</p>
    public let otherMetadataValueList: [OtherMetadataValueListItem]?

    public init (
        createdTime: String? = nil,
        metadataValue: String? = nil,
        otherMetadataValueList: [OtherMetadataValueListItem]? = nil
    )
    {
        self.createdTime = createdTime
        self.metadataValue = metadataValue
        self.otherMetadataValueList = otherMetadataValueList
    }
}

extension MetadataKeyValuePair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metadataKey = "MetadataKey"
        case metadataValue = "MetadataValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataKey = metadataKey {
            try encodeContainer.encode(metadataKey, forKey: .metadataKey)
        }
        if let metadataValue = metadataValue {
            try encodeContainer.encode(metadataValue, forKey: .metadataValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadataKey)
        metadataKey = metadataKeyDecoded
        let metadataValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadataValue)
        metadataValue = metadataValueDecoded
    }
}

extension MetadataKeyValuePair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetadataKeyValuePair(metadataKey: \(String(describing: metadataKey)), metadataValue: \(String(describing: metadataValue)))"}
}

/// <p>A structure containing a key value pair for metadata.</p>
public struct MetadataKeyValuePair: Equatable {
    /// <p>A metadata key.</p>
    public let metadataKey: String?
    /// <p>A metadata key’s corresponding value.</p>
    public let metadataValue: String?

    public init (
        metadataKey: String? = nil,
        metadataValue: String? = nil
    )
    {
        self.metadataKey = metadataKey
        self.metadataValue = metadataValue
    }
}

extension MongoDBTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionName = "ConnectionName"
        case path = "Path"
        case scanAll = "ScanAll"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let scanAll = scanAll {
            try encodeContainer.encode(scanAll, forKey: .scanAll)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let scanAllDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .scanAll)
        scanAll = scanAllDecoded
    }
}

extension MongoDBTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MongoDBTarget(connectionName: \(String(describing: connectionName)), path: \(String(describing: path)), scanAll: \(String(describing: scanAll)))"}
}

/// <p>Specifies an Amazon DocumentDB or MongoDB data store to crawl.</p>
public struct MongoDBTarget: Equatable {
    /// <p>The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.</p>
    public let connectionName: String?
    /// <p>The path of the Amazon DocumentDB or MongoDB target (database/collection).</p>
    public let path: String?
    /// <p>Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.</p>
    /// 	
    /// 	        <p>A value of <code>true</code> means to scan all records, while a value of <code>false</code> means to sample the records. If no value is specified, the value defaults to <code>true</code>.</p>
    public let scanAll: Bool?

    public init (
        connectionName: String? = nil,
        path: String? = nil,
        scanAll: Bool? = nil
    )
    {
        self.connectionName = connectionName
        self.path = path
        self.scanAll = scanAll
    }
}

extension NoScheduleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoScheduleException(message: \(String(describing: message)))"}
}

extension NoScheduleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoScheduleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no applicable schedule.</p>
public struct NoScheduleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoScheduleExceptionBody: Equatable {
    public let message: String?
}

extension NoScheduleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Node: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlerDetails = "CrawlerDetails"
        case jobDetails = "JobDetails"
        case name = "Name"
        case triggerDetails = "TriggerDetails"
        case type = "Type"
        case uniqueId = "UniqueId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawlerDetails = crawlerDetails {
            try encodeContainer.encode(crawlerDetails, forKey: .crawlerDetails)
        }
        if let jobDetails = jobDetails {
            try encodeContainer.encode(jobDetails, forKey: .jobDetails)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let triggerDetails = triggerDetails {
            try encodeContainer.encode(triggerDetails, forKey: .triggerDetails)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uniqueId = uniqueId {
            try encodeContainer.encode(uniqueId, forKey: .uniqueId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(NodeType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let uniqueIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uniqueId)
        uniqueId = uniqueIdDecoded
        let triggerDetailsDecoded = try containerValues.decodeIfPresent(TriggerNodeDetails.self, forKey: .triggerDetails)
        triggerDetails = triggerDetailsDecoded
        let jobDetailsDecoded = try containerValues.decodeIfPresent(JobNodeDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
        let crawlerDetailsDecoded = try containerValues.decodeIfPresent(CrawlerNodeDetails.self, forKey: .crawlerDetails)
        crawlerDetails = crawlerDetailsDecoded
    }
}

extension Node: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Node(crawlerDetails: \(String(describing: crawlerDetails)), jobDetails: \(String(describing: jobDetails)), name: \(String(describing: name)), triggerDetails: \(String(describing: triggerDetails)), type: \(String(describing: type)), uniqueId: \(String(describing: uniqueId)))"}
}

/// <p>A node represents an AWS Glue component such as a trigger, or job, etc., that is part of a workflow.</p>
public struct Node: Equatable {
    /// <p>Details of the crawler when the node represents a crawler.</p>
    public let crawlerDetails: CrawlerNodeDetails?
    /// <p>Details of the Job when the node represents a Job.</p>
    public let jobDetails: JobNodeDetails?
    /// <p>The name of the AWS Glue component represented by the node.</p>
    public let name: String?
    /// <p>Details of the Trigger when the node represents a Trigger.</p>
    public let triggerDetails: TriggerNodeDetails?
    /// <p>The type of AWS Glue component represented by the node.</p>
    public let type: NodeType?
    /// <p>The unique Id assigned to the node within the workflow.</p>
    public let uniqueId: String?

    public init (
        crawlerDetails: CrawlerNodeDetails? = nil,
        jobDetails: JobNodeDetails? = nil,
        name: String? = nil,
        triggerDetails: TriggerNodeDetails? = nil,
        type: NodeType? = nil,
        uniqueId: String? = nil
    )
    {
        self.crawlerDetails = crawlerDetails
        self.jobDetails = jobDetails
        self.name = name
        self.triggerDetails = triggerDetails
        self.type = type
        self.uniqueId = uniqueId
    }
}

public enum NodeType {
    case crawler
    case job
    case trigger
    case sdkUnknown(String)
}

extension NodeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NodeType] {
        return [
            .crawler,
            .job,
            .trigger,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .crawler: return "CRAWLER"
        case .job: return "JOB"
        case .trigger: return "TRIGGER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NodeType(rawValue: rawValue) ?? NodeType.sdkUnknown(rawValue)
    }
}

extension NotificationProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notifyDelayAfter = "NotifyDelayAfter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notifyDelayAfter = notifyDelayAfter {
            try encodeContainer.encode(notifyDelayAfter, forKey: .notifyDelayAfter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notifyDelayAfterDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .notifyDelayAfter)
        notifyDelayAfter = notifyDelayAfterDecoded
    }
}

extension NotificationProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationProperty(notifyDelayAfter: \(String(describing: notifyDelayAfter)))"}
}

/// <p>Specifies configuration properties of a notification.</p>
public struct NotificationProperty: Equatable {
    /// <p>After a job run starts, the number of minutes to wait before
    ///       sending a job run delay notification.</p>
    public let notifyDelayAfter: Int?

    public init (
        notifyDelayAfter: Int? = nil
    )
    {
        self.notifyDelayAfter = notifyDelayAfter
    }
}

extension OperationTimeoutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationTimeoutException(message: \(String(describing: message)))"}
}

extension OperationTimeoutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationTimeoutExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation timed out.</p>
public struct OperationTimeoutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationTimeoutExceptionBody: Equatable {
    public let message: String?
}

extension OperationTimeoutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Order: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case column = "Column"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if sortOrder != 0 {
            try encodeContainer.encode(sortOrder, forKey: .sortOrder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .column)
        column = columnDecoded
        let sortOrderDecoded = try containerValues.decode(Int.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension Order: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Order(column: \(String(describing: column)), sortOrder: \(String(describing: sortOrder)))"}
}

/// <p>Specifies the sort order of a sorted column.</p>
public struct Order: Equatable {
    /// <p>The name of the column.</p>
    public let column: String?
    /// <p>Indicates that the column is sorted in ascending order
    ///       (<code>== 1</code>), or in descending order (<code>==0</code>).</p>
    public let sortOrder: Int

    public init (
        column: String? = nil,
        sortOrder: Int = 0
    )
    {
        self.column = column
        self.sortOrder = sortOrder
    }
}

extension OtherMetadataValueListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case metadataValue = "MetadataValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let metadataValue = metadataValue {
            try encodeContainer.encode(metadataValue, forKey: .metadataValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadataValue)
        metadataValue = metadataValueDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension OtherMetadataValueListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OtherMetadataValueListItem(createdTime: \(String(describing: createdTime)), metadataValue: \(String(describing: metadataValue)))"}
}

/// <p>A structure containing other metadata for a schema version belonging to the same metadata key.</p>
public struct OtherMetadataValueListItem: Equatable {
    /// <p>The time at which the entry was created.</p>
    public let createdTime: String?
    /// <p>The metadata key’s corresponding value for the other metadata belonging to the same metadata key.</p>
    public let metadataValue: String?

    public init (
        createdTime: String? = nil,
        metadataValue: String? = nil
    )
    {
        self.createdTime = createdTime
        self.metadataValue = metadataValue
    }
}

extension Partition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case creationTime = "CreationTime"
        case databaseName = "DatabaseName"
        case lastAccessTime = "LastAccessTime"
        case lastAnalyzedTime = "LastAnalyzedTime"
        case parameters = "Parameters"
        case storageDescriptor = "StorageDescriptor"
        case tableName = "TableName"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let lastAccessTime = lastAccessTime {
            try encodeContainer.encode(lastAccessTime.timeIntervalSince1970, forKey: .lastAccessTime)
        }
        if let lastAnalyzedTime = lastAnalyzedTime {
            try encodeContainer.encode(lastAnalyzedTime.timeIntervalSince1970, forKey: .lastAnalyzedTime)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let storageDescriptor = storageDescriptor {
            try encodeContainer.encode(storageDescriptor, forKey: .storageDescriptor)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for valuestringlist0 in values {
                try valuesContainer.encode(valuestringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastAccessTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAccessTime)
        lastAccessTime = lastAccessTimeDecoded
        let storageDescriptorDecoded = try containerValues.decodeIfPresent(StorageDescriptor.self, forKey: .storageDescriptor)
        storageDescriptor = storageDescriptorDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let lastAnalyzedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAnalyzedTime)
        lastAnalyzedTime = lastAnalyzedTimeDecoded
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension Partition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Partition(catalogId: \(String(describing: catalogId)), creationTime: \(String(describing: creationTime)), databaseName: \(String(describing: databaseName)), lastAccessTime: \(String(describing: lastAccessTime)), lastAnalyzedTime: \(String(describing: lastAnalyzedTime)), parameters: \(String(describing: parameters)), storageDescriptor: \(String(describing: storageDescriptor)), tableName: \(String(describing: tableName)), values: \(String(describing: values)))"}
}

/// <p>Represents a slice of table data.</p>
public struct Partition: Equatable {
    /// <p>The ID of the Data Catalog in which the partition resides.</p>
    public let catalogId: String?
    /// <p>The time at which the partition was created.</p>
    public let creationTime: Date?
    /// <p>The name of the catalog database in which to create the partition.</p>
    public let databaseName: String?
    /// <p>The last time at which the partition was accessed.</p>
    public let lastAccessTime: Date?
    /// <p>The last time at which column statistics were computed for this
    ///       partition.</p>
    public let lastAnalyzedTime: Date?
    /// <p>These key-value pairs define partition parameters.</p>
    public let parameters: [String:String]?
    /// <p>Provides information about the physical
    ///       location where the partition is stored.</p>
    public let storageDescriptor: StorageDescriptor?
    /// <p>The name of the database table in which to create the partition.</p>
    public let tableName: String?
    /// <p>The values of the partition.</p>
    public let values: [String]?

    public init (
        catalogId: String? = nil,
        creationTime: Date? = nil,
        databaseName: String? = nil,
        lastAccessTime: Date? = nil,
        lastAnalyzedTime: Date? = nil,
        parameters: [String:String]? = nil,
        storageDescriptor: StorageDescriptor? = nil,
        tableName: String? = nil,
        values: [String]? = nil
    )
    {
        self.catalogId = catalogId
        self.creationTime = creationTime
        self.databaseName = databaseName
        self.lastAccessTime = lastAccessTime
        self.lastAnalyzedTime = lastAnalyzedTime
        self.parameters = parameters
        self.storageDescriptor = storageDescriptor
        self.tableName = tableName
        self.values = values
    }
}

extension PartitionError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorDetail = "ErrorDetail"
        case partitionValues = "PartitionValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorDetail = errorDetail {
            try encodeContainer.encode(errorDetail, forKey: .errorDetail)
        }
        if let partitionValues = partitionValues {
            var partitionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValues)
            for valuestringlist0 in partitionValues {
                try partitionValuesContainer.encode(valuestringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionValues)
        var partitionValuesDecoded0:[String]? = nil
        if let partitionValuesContainer = partitionValuesContainer {
            partitionValuesDecoded0 = [String]()
            for string0 in partitionValuesContainer {
                if let string0 = string0 {
                    partitionValuesDecoded0?.append(string0)
                }
            }
        }
        partitionValues = partitionValuesDecoded0
        let errorDetailDecoded = try containerValues.decodeIfPresent(ErrorDetail.self, forKey: .errorDetail)
        errorDetail = errorDetailDecoded
    }
}

extension PartitionError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartitionError(errorDetail: \(String(describing: errorDetail)), partitionValues: \(String(describing: partitionValues)))"}
}

/// <p>Contains information about a partition error.</p>
public struct PartitionError: Equatable {
    /// <p>The details about the partition error.</p>
    public let errorDetail: ErrorDetail?
    /// <p>The values that define the partition.</p>
    public let partitionValues: [String]?

    public init (
        errorDetail: ErrorDetail? = nil,
        partitionValues: [String]? = nil
    )
    {
        self.errorDetail = errorDetail
        self.partitionValues = partitionValues
    }
}

extension PartitionIndex: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexName = "IndexName"
        case keys = "Keys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let keys = keys {
            var keysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keys)
            for keylist0 in keys {
                try keysContainer.encode(keylist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .keys)
        var keysDecoded0:[String]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [String]()
            for string0 in keysContainer {
                if let string0 = string0 {
                    keysDecoded0?.append(string0)
                }
            }
        }
        keys = keysDecoded0
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
    }
}

extension PartitionIndex: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartitionIndex(indexName: \(String(describing: indexName)), keys: \(String(describing: keys)))"}
}

/// <p>A structure for a partition index.</p>
public struct PartitionIndex: Equatable {
    /// <p>The name of the partition index.</p>
    public let indexName: String?
    /// <p>The keys for the partition index.</p>
    public let keys: [String]?

    public init (
        indexName: String? = nil,
        keys: [String]? = nil
    )
    {
        self.indexName = indexName
        self.keys = keys
    }
}

extension PartitionIndexDescriptor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backfillErrors = "BackfillErrors"
        case indexName = "IndexName"
        case indexStatus = "IndexStatus"
        case keys = "Keys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backfillErrors = backfillErrors {
            var backfillErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backfillErrors)
            for backfillerrors0 in backfillErrors {
                try backfillErrorsContainer.encode(backfillerrors0)
            }
        }
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let indexStatus = indexStatus {
            try encodeContainer.encode(indexStatus.rawValue, forKey: .indexStatus)
        }
        if let keys = keys {
            var keysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keys)
            for keyschemaelementlist0 in keys {
                try keysContainer.encode(keyschemaelementlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let keysContainer = try containerValues.decodeIfPresent([KeySchemaElement?].self, forKey: .keys)
        var keysDecoded0:[KeySchemaElement]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [KeySchemaElement]()
            for structure0 in keysContainer {
                if let structure0 = structure0 {
                    keysDecoded0?.append(structure0)
                }
            }
        }
        keys = keysDecoded0
        let indexStatusDecoded = try containerValues.decodeIfPresent(PartitionIndexStatus.self, forKey: .indexStatus)
        indexStatus = indexStatusDecoded
        let backfillErrorsContainer = try containerValues.decodeIfPresent([BackfillError?].self, forKey: .backfillErrors)
        var backfillErrorsDecoded0:[BackfillError]? = nil
        if let backfillErrorsContainer = backfillErrorsContainer {
            backfillErrorsDecoded0 = [BackfillError]()
            for structure0 in backfillErrorsContainer {
                if let structure0 = structure0 {
                    backfillErrorsDecoded0?.append(structure0)
                }
            }
        }
        backfillErrors = backfillErrorsDecoded0
    }
}

extension PartitionIndexDescriptor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartitionIndexDescriptor(backfillErrors: \(String(describing: backfillErrors)), indexName: \(String(describing: indexName)), indexStatus: \(String(describing: indexStatus)), keys: \(String(describing: keys)))"}
}

/// <p>A descriptor for a partition index in a table.</p>
public struct PartitionIndexDescriptor: Equatable {
    /// <p>A list of errors that can occur when registering partition indexes for an existing table.</p>
    public let backfillErrors: [BackfillError]?
    /// <p>The name of the partition index.</p>
    public let indexName: String?
    /// <p>The status of the partition index. </p>
    /// 	
    /// 	        <p>The possible statuses are:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>CREATING: The index is being created. When an index is in a CREATING state, the index or its table cannot be deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>ACTIVE: The index creation succeeds.</p>
    ///             </li>
    ///             <li>
    ///                <p>FAILED: The index creation fails. </p>
    ///             </li>
    ///             <li>
    ///                <p>DELETING: The index is deleted from the list of indexes.</p>
    ///             </li>
    ///          </ul>
    public let indexStatus: PartitionIndexStatus?
    /// <p>A list of one or more keys, as <code>KeySchemaElement</code> structures, for the partition index.</p>
    public let keys: [KeySchemaElement]?

    public init (
        backfillErrors: [BackfillError]? = nil,
        indexName: String? = nil,
        indexStatus: PartitionIndexStatus? = nil,
        keys: [KeySchemaElement]? = nil
    )
    {
        self.backfillErrors = backfillErrors
        self.indexName = indexName
        self.indexStatus = indexStatus
        self.keys = keys
    }
}

public enum PartitionIndexStatus {
    case active
    case creating
    case deleting
    case failed
    case sdkUnknown(String)
}

extension PartitionIndexStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PartitionIndexStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PartitionIndexStatus(rawValue: rawValue) ?? PartitionIndexStatus.sdkUnknown(rawValue)
    }
}

extension PartitionInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastAccessTime = "LastAccessTime"
        case lastAnalyzedTime = "LastAnalyzedTime"
        case parameters = "Parameters"
        case storageDescriptor = "StorageDescriptor"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastAccessTime = lastAccessTime {
            try encodeContainer.encode(lastAccessTime.timeIntervalSince1970, forKey: .lastAccessTime)
        }
        if let lastAnalyzedTime = lastAnalyzedTime {
            try encodeContainer.encode(lastAnalyzedTime.timeIntervalSince1970, forKey: .lastAnalyzedTime)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let storageDescriptor = storageDescriptor {
            try encodeContainer.encode(storageDescriptor, forKey: .storageDescriptor)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for valuestringlist0 in values {
                try valuesContainer.encode(valuestringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let lastAccessTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAccessTime)
        lastAccessTime = lastAccessTimeDecoded
        let storageDescriptorDecoded = try containerValues.decodeIfPresent(StorageDescriptor.self, forKey: .storageDescriptor)
        storageDescriptor = storageDescriptorDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let lastAnalyzedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAnalyzedTime)
        lastAnalyzedTime = lastAnalyzedTimeDecoded
    }
}

extension PartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartitionInput(lastAccessTime: \(String(describing: lastAccessTime)), lastAnalyzedTime: \(String(describing: lastAnalyzedTime)), parameters: \(String(describing: parameters)), storageDescriptor: \(String(describing: storageDescriptor)), values: \(String(describing: values)))"}
}

/// <p>The structure used to create and update a partition.</p>
public struct PartitionInput: Equatable {
    /// <p>The last time at which the partition was accessed.</p>
    public let lastAccessTime: Date?
    /// <p>The last time at which column statistics were computed for this partition.</p>
    public let lastAnalyzedTime: Date?
    /// <p>These key-value pairs define partition parameters.</p>
    public let parameters: [String:String]?
    /// <p>Provides information about the physical
    ///       location where the partition is stored.</p>
    public let storageDescriptor: StorageDescriptor?
    /// <p>The values of the partition. Although this parameter is not required by the SDK, you must specify this parameter for a valid input.</p>
    /// 	
    /// 	        <p>The values for the keys for the new partition must be passed as an array of String objects that must be ordered in the same order as the partition keys appearing in the Amazon S3 prefix. Otherwise AWS Glue will add the values to the wrong keys.</p>
    public let values: [String]?

    public init (
        lastAccessTime: Date? = nil,
        lastAnalyzedTime: Date? = nil,
        parameters: [String:String]? = nil,
        storageDescriptor: StorageDescriptor? = nil,
        values: [String]? = nil
    )
    {
        self.lastAccessTime = lastAccessTime
        self.lastAnalyzedTime = lastAnalyzedTime
        self.parameters = parameters
        self.storageDescriptor = storageDescriptor
        self.values = values
    }
}

extension PartitionValueList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for valuestringlist0 in values {
                try valuesContainer.encode(valuestringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PartitionValueList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartitionValueList(values: \(String(describing: values)))"}
}

/// <p>Contains a list of values defining partitions.</p>
public struct PartitionValueList: Equatable {
    /// <p>The list of values.</p>
    public let values: [String]?

    public init (
        values: [String]? = nil
    )
    {
        self.values = values
    }
}

public enum Permission {
    case all
    case alter
    case createDatabase
    case createTable
    case dataLocationAccess
    case delete
    case drop
    case insert
    case select
    case sdkUnknown(String)
}

extension Permission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Permission] {
        return [
            .all,
            .alter,
            .createDatabase,
            .createTable,
            .dataLocationAccess,
            .delete,
            .drop,
            .insert,
            .select,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .alter: return "ALTER"
        case .createDatabase: return "CREATE_DATABASE"
        case .createTable: return "CREATE_TABLE"
        case .dataLocationAccess: return "DATA_LOCATION_ACCESS"
        case .delete: return "DELETE"
        case .drop: return "DROP"
        case .insert: return "INSERT"
        case .select: return "SELECT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
    }
}

extension PhysicalConnectionRequirements: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case securityGroupIdList = "SecurityGroupIdList"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let securityGroupIdList = securityGroupIdList {
            var securityGroupIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIdList)
            for securitygroupidlist0 in securityGroupIdList {
                try securityGroupIdListContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let securityGroupIdListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIdList)
        var securityGroupIdListDecoded0:[String]? = nil
        if let securityGroupIdListContainer = securityGroupIdListContainer {
            securityGroupIdListDecoded0 = [String]()
            for string0 in securityGroupIdListContainer {
                if let string0 = string0 {
                    securityGroupIdListDecoded0?.append(string0)
                }
            }
        }
        securityGroupIdList = securityGroupIdListDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
    }
}

extension PhysicalConnectionRequirements: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PhysicalConnectionRequirements(availabilityZone: \(String(describing: availabilityZone)), securityGroupIdList: \(String(describing: securityGroupIdList)), subnetId: \(String(describing: subnetId)))"}
}

/// <p>Specifies the physical requirements for a connection.</p>
public struct PhysicalConnectionRequirements: Equatable {
    /// <p>The connection's Availability Zone. This field is redundant because the specified subnet
    ///       implies the Availability Zone to be used. Currently the field must be populated, but it will
    ///       be deprecated in the future.</p>
    public let availabilityZone: String?
    /// <p>The security group ID list used by the connection.</p>
    public let securityGroupIdList: [String]?
    /// <p>The subnet ID used by the connection.</p>
    public let subnetId: String?

    public init (
        availabilityZone: String? = nil,
        securityGroupIdList: [String]? = nil,
        subnetId: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.securityGroupIdList = securityGroupIdList
        self.subnetId = subnetId
    }
}

extension Predecessor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case runId = "RunId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let runId = runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
    }
}

extension Predecessor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Predecessor(jobName: \(String(describing: jobName)), runId: \(String(describing: runId)))"}
}

/// <p>A job run that was used in the predicate of a conditional trigger
///       that triggered this job run.</p>
public struct Predecessor: Equatable {
    /// <p>The name of the job definition used by the predecessor job run.</p>
    public let jobName: String?
    /// <p>The job-run ID of the predecessor job run.</p>
    public let runId: String?

    public init (
        jobName: String? = nil,
        runId: String? = nil
    )
    {
        self.jobName = jobName
        self.runId = runId
    }
}

extension Predicate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conditions = "Conditions"
        case logical = "Logical"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditions = conditions {
            var conditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditions)
            for conditionlist0 in conditions {
                try conditionsContainer.encode(conditionlist0)
            }
        }
        if let logical = logical {
            try encodeContainer.encode(logical.rawValue, forKey: .logical)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logicalDecoded = try containerValues.decodeIfPresent(Logical.self, forKey: .logical)
        logical = logicalDecoded
        let conditionsContainer = try containerValues.decodeIfPresent([Condition?].self, forKey: .conditions)
        var conditionsDecoded0:[Condition]? = nil
        if let conditionsContainer = conditionsContainer {
            conditionsDecoded0 = [Condition]()
            for structure0 in conditionsContainer {
                if let structure0 = structure0 {
                    conditionsDecoded0?.append(structure0)
                }
            }
        }
        conditions = conditionsDecoded0
    }
}

extension Predicate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Predicate(conditions: \(String(describing: conditions)), logical: \(String(describing: logical)))"}
}

/// <p>Defines the predicate of the trigger, which determines when it fires.</p>
public struct Predicate: Equatable {
    /// <p>A list of the conditions that determine when the trigger will fire.</p>
    public let conditions: [Condition]?
    /// <p>An optional field if only one condition is listed. If multiple conditions are listed, then
    ///       this field is required.</p>
    public let logical: Logical?

    public init (
        conditions: [Condition]? = nil,
        logical: Logical? = nil
    )
    {
        self.conditions = conditions
        self.logical = logical
    }
}

extension PrincipalPermissions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permissions = "Permissions"
        case principal = "Principal"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissionlist0 in permissions {
                try permissionsContainer.encode(permissionlist0.rawValue)
            }
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permission]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension PrincipalPermissions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PrincipalPermissions(permissions: \(String(describing: permissions)), principal: \(String(describing: principal)))"}
}

/// <p>Permissions granted to a principal.</p>
public struct PrincipalPermissions: Equatable {
    /// <p>The permissions that are granted to the principal.</p>
    public let permissions: [Permission]?
    /// <p>The principal who is granted permissions.</p>
    public let principal: DataLakePrincipal?

    public init (
        permissions: [Permission]? = nil,
        principal: DataLakePrincipal? = nil
    )
    {
        self.permissions = permissions
        self.principal = principal
    }
}

public enum PrincipalType {
    case group
    case role
    case user
    case sdkUnknown(String)
}

extension PrincipalType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PrincipalType] {
        return [
            .group,
            .role,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .group: return "GROUP"
        case .role: return "ROLE"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
    }
}

extension PropertyPredicate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparator = "Comparator"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let comparatorDecoded = try containerValues.decodeIfPresent(Comparator.self, forKey: .comparator)
        comparator = comparatorDecoded
    }
}

extension PropertyPredicate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PropertyPredicate(comparator: \(String(describing: comparator)), key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Defines a property predicate.</p>
public struct PropertyPredicate: Equatable {
    /// <p>The comparator used to compare this property to others.</p>
    public let comparator: Comparator?
    /// <p>The key of the property.</p>
    public let key: String?
    /// <p>The value of the property.</p>
    public let value: String?

    public init (
        comparator: Comparator? = nil,
        key: String? = nil,
        value: String? = nil
    )
    {
        self.comparator = comparator
        self.key = key
        self.value = value
    }
}

public struct PutDataCatalogEncryptionSettingsInputBodyMiddleware: Middleware {
    public let id: String = "PutDataCatalogEncryptionSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDataCatalogEncryptionSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDataCatalogEncryptionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDataCatalogEncryptionSettingsInput>
    public typealias MOutput = OperationOutput<PutDataCatalogEncryptionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDataCatalogEncryptionSettingsOutputError>
}

extension PutDataCatalogEncryptionSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDataCatalogEncryptionSettingsInput(catalogId: \(String(describing: catalogId)), dataCatalogEncryptionSettings: \(String(describing: dataCatalogEncryptionSettings)))"}
}

extension PutDataCatalogEncryptionSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case dataCatalogEncryptionSettings = "DataCatalogEncryptionSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let dataCatalogEncryptionSettings = dataCatalogEncryptionSettings {
            try encodeContainer.encode(dataCatalogEncryptionSettings, forKey: .dataCatalogEncryptionSettings)
        }
    }
}

public struct PutDataCatalogEncryptionSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "PutDataCatalogEncryptionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDataCatalogEncryptionSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDataCatalogEncryptionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDataCatalogEncryptionSettingsInput>
    public typealias MOutput = OperationOutput<PutDataCatalogEncryptionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDataCatalogEncryptionSettingsOutputError>
}

public struct PutDataCatalogEncryptionSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDataCatalogEncryptionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDataCatalogEncryptionSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDataCatalogEncryptionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDataCatalogEncryptionSettingsInput>
    public typealias MOutput = OperationOutput<PutDataCatalogEncryptionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDataCatalogEncryptionSettingsOutputError>
}

public struct PutDataCatalogEncryptionSettingsInput: Equatable {
    /// <p>The ID of the Data Catalog to set the security configuration for. If none is provided, the
    ///       AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The security configuration to set.</p>
    public let dataCatalogEncryptionSettings: DataCatalogEncryptionSettings?

    public init (
        catalogId: String? = nil,
        dataCatalogEncryptionSettings: DataCatalogEncryptionSettings? = nil
    )
    {
        self.catalogId = catalogId
        self.dataCatalogEncryptionSettings = dataCatalogEncryptionSettings
    }
}

struct PutDataCatalogEncryptionSettingsInputBody: Equatable {
    public let catalogId: String?
    public let dataCatalogEncryptionSettings: DataCatalogEncryptionSettings?
}

extension PutDataCatalogEncryptionSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case dataCatalogEncryptionSettings = "DataCatalogEncryptionSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let dataCatalogEncryptionSettingsDecoded = try containerValues.decodeIfPresent(DataCatalogEncryptionSettings.self, forKey: .dataCatalogEncryptionSettings)
        dataCatalogEncryptionSettings = dataCatalogEncryptionSettingsDecoded
    }
}

extension PutDataCatalogEncryptionSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDataCatalogEncryptionSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDataCatalogEncryptionSettingsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDataCatalogEncryptionSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDataCatalogEncryptionSettingsOutputResponse()"}
}

extension PutDataCatalogEncryptionSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutDataCatalogEncryptionSettingsOutputResponse: Equatable {

    public init() {}
}

struct PutDataCatalogEncryptionSettingsOutputResponseBody: Equatable {
}

extension PutDataCatalogEncryptionSettingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

extension PutResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyInput(enableHybrid: \(String(describing: enableHybrid)), policyExistsCondition: \(String(describing: policyExistsCondition)), policyHashCondition: \(String(describing: policyHashCondition)), policyInJson: \(String(describing: policyInJson)), resourceArn: \(String(describing: resourceArn)))"}
}

extension PutResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enableHybrid = "EnableHybrid"
        case policyExistsCondition = "PolicyExistsCondition"
        case policyHashCondition = "PolicyHashCondition"
        case policyInJson = "PolicyInJson"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableHybrid = enableHybrid {
            try encodeContainer.encode(enableHybrid.rawValue, forKey: .enableHybrid)
        }
        if let policyExistsCondition = policyExistsCondition {
            try encodeContainer.encode(policyExistsCondition.rawValue, forKey: .policyExistsCondition)
        }
        if let policyHashCondition = policyHashCondition {
            try encodeContainer.encode(policyHashCondition, forKey: .policyHashCondition)
        }
        if let policyInJson = policyInJson {
            try encodeContainer.encode(policyInJson, forKey: .policyInJson)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct PutResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInput: Equatable {
    /// <p>If <code>'TRUE'</code>, indicates that you are using both methods to grant cross-account
    ///       access to Data Catalog resources:</p>
    ///          <ul>
    ///             <li>
    ///                <p>By directly updating the resource policy with <code>PutResourePolicy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>By using the <b>Grant permissions</b> command on the AWS
    ///           Management Console.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Must be set to <code>'TRUE'</code> if you have already used the Management Console to
    ///       grant cross-account access, otherwise the call fails. Default is 'FALSE'.</p>
    public let enableHybrid: EnableHybridValues?
    /// <p>A value of <code>MUST_EXIST</code> is used to update a policy. A value of
    ///         <code>NOT_EXIST</code> is used to create a new policy. If a value of <code>NONE</code> or a
    ///       null value is used, the call does not depend on the existence of a policy.</p>
    public let policyExistsCondition: ExistCondition?
    /// <p>The hash value returned when the previous policy was set using
    ///         <code>PutResourcePolicy</code>. Its purpose is to prevent concurrent modifications of a
    ///       policy. Do not use this parameter if no previous policy has been set.</p>
    public let policyHashCondition: String?
    /// <p>Contains the policy document to set, in JSON format.</p>
    public let policyInJson: String?
    /// <p>Do not use. For internal use only.</p>
    public let resourceArn: String?

    public init (
        enableHybrid: EnableHybridValues? = nil,
        policyExistsCondition: ExistCondition? = nil,
        policyHashCondition: String? = nil,
        policyInJson: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.enableHybrid = enableHybrid
        self.policyExistsCondition = policyExistsCondition
        self.policyHashCondition = policyHashCondition
        self.policyInJson = policyInJson
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Equatable {
    public let policyInJson: String?
    public let resourceArn: String?
    public let policyHashCondition: String?
    public let policyExistsCondition: ExistCondition?
    public let enableHybrid: EnableHybridValues?
}

extension PutResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enableHybrid = "EnableHybrid"
        case policyExistsCondition = "PolicyExistsCondition"
        case policyHashCondition = "PolicyHashCondition"
        case policyInJson = "PolicyInJson"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyInJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyInJson)
        policyInJson = policyInJsonDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyHashConditionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyHashCondition)
        policyHashCondition = policyHashConditionDecoded
        let policyExistsConditionDecoded = try containerValues.decodeIfPresent(ExistCondition.self, forKey: .policyExistsCondition)
        policyExistsCondition = policyExistsConditionDecoded
        let enableHybridDecoded = try containerValues.decodeIfPresent(EnableHybridValues.self, forKey: .enableHybrid)
        enableHybrid = enableHybridDecoded
    }
}

extension PutResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConditionCheckFailureException" : self = .conditionCheckFailureException(try ConditionCheckFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourcePolicyOutputError: Equatable {
    case conditionCheckFailureException(ConditionCheckFailureException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyOutputResponse(policyHash: \(String(describing: policyHash)))"}
}

extension PutResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyHash = output.policyHash
        } else {
            self.policyHash = nil
        }
    }
}

public struct PutResourcePolicyOutputResponse: Equatable {
    /// <p>A hash of the policy that has just been set. This must
    ///       be included in a subsequent call that overwrites or updates
    ///       this policy.</p>
    public let policyHash: String?

    public init (
        policyHash: String? = nil
    )
    {
        self.policyHash = policyHash
    }
}

struct PutResourcePolicyOutputResponseBody: Equatable {
    public let policyHash: String?
}

extension PutResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyHash = "PolicyHash"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyHash)
        policyHash = policyHashDecoded
    }
}

public struct PutSchemaVersionMetadataInputBodyMiddleware: Middleware {
    public let id: String = "PutSchemaVersionMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSchemaVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSchemaVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSchemaVersionMetadataInput>
    public typealias MOutput = OperationOutput<PutSchemaVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSchemaVersionMetadataOutputError>
}

extension PutSchemaVersionMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSchemaVersionMetadataInput(metadataKeyValue: \(String(describing: metadataKeyValue)), schemaId: \(String(describing: schemaId)), schemaVersionId: \(String(describing: schemaVersionId)), schemaVersionNumber: \(String(describing: schemaVersionNumber)))"}
}

extension PutSchemaVersionMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metadataKeyValue = "MetadataKeyValue"
        case schemaId = "SchemaId"
        case schemaVersionId = "SchemaVersionId"
        case schemaVersionNumber = "SchemaVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataKeyValue = metadataKeyValue {
            try encodeContainer.encode(metadataKeyValue, forKey: .metadataKeyValue)
        }
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let schemaVersionId = schemaVersionId {
            try encodeContainer.encode(schemaVersionId, forKey: .schemaVersionId)
        }
        if let schemaVersionNumber = schemaVersionNumber {
            try encodeContainer.encode(schemaVersionNumber, forKey: .schemaVersionNumber)
        }
    }
}

public struct PutSchemaVersionMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "PutSchemaVersionMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSchemaVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSchemaVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSchemaVersionMetadataInput>
    public typealias MOutput = OperationOutput<PutSchemaVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSchemaVersionMetadataOutputError>
}

public struct PutSchemaVersionMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "PutSchemaVersionMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSchemaVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSchemaVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSchemaVersionMetadataInput>
    public typealias MOutput = OperationOutput<PutSchemaVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSchemaVersionMetadataOutputError>
}

public struct PutSchemaVersionMetadataInput: Equatable {
    /// <p>The metadata key's corresponding value.</p>
    public let metadataKeyValue: MetadataKeyValuePair?
    /// <p>The unique ID for the schema.</p>
    public let schemaId: SchemaId?
    /// <p>The unique version ID of the schema version.</p>
    public let schemaVersionId: String?
    /// <p>The version number of the schema.</p>
    public let schemaVersionNumber: SchemaVersionNumber?

    public init (
        metadataKeyValue: MetadataKeyValuePair? = nil,
        schemaId: SchemaId? = nil,
        schemaVersionId: String? = nil,
        schemaVersionNumber: SchemaVersionNumber? = nil
    )
    {
        self.metadataKeyValue = metadataKeyValue
        self.schemaId = schemaId
        self.schemaVersionId = schemaVersionId
        self.schemaVersionNumber = schemaVersionNumber
    }
}

struct PutSchemaVersionMetadataInputBody: Equatable {
    public let schemaId: SchemaId?
    public let schemaVersionNumber: SchemaVersionNumber?
    public let schemaVersionId: String?
    public let metadataKeyValue: MetadataKeyValuePair?
}

extension PutSchemaVersionMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadataKeyValue = "MetadataKeyValue"
        case schemaId = "SchemaId"
        case schemaVersionId = "SchemaVersionId"
        case schemaVersionNumber = "SchemaVersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaVersionNumberDecoded = try containerValues.decodeIfPresent(SchemaVersionNumber.self, forKey: .schemaVersionNumber)
        schemaVersionNumber = schemaVersionNumberDecoded
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let metadataKeyValueDecoded = try containerValues.decodeIfPresent(MetadataKeyValuePair.self, forKey: .metadataKeyValue)
        metadataKeyValue = metadataKeyValueDecoded
    }
}

extension PutSchemaVersionMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSchemaVersionMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSchemaVersionMetadataOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case alreadyExistsException(AlreadyExistsException)
    case entityNotFoundException(EntityNotFoundException)
    case invalidInputException(InvalidInputException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSchemaVersionMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSchemaVersionMetadataOutputResponse(latestVersion: \(String(describing: latestVersion)), metadataKey: \(String(describing: metadataKey)), metadataValue: \(String(describing: metadataValue)), registryName: \(String(describing: registryName)), schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)), schemaVersionId: \(String(describing: schemaVersionId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension PutSchemaVersionMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutSchemaVersionMetadataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.latestVersion = output.latestVersion
            self.metadataKey = output.metadataKey
            self.metadataValue = output.metadataValue
            self.registryName = output.registryName
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersionId = output.schemaVersionId
            self.versionNumber = output.versionNumber
        } else {
            self.latestVersion = false
            self.metadataKey = nil
            self.metadataValue = nil
            self.registryName = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersionId = nil
            self.versionNumber = 0
        }
    }
}

public struct PutSchemaVersionMetadataOutputResponse: Equatable {
    /// <p>The latest version of the schema.</p>
    public let latestVersion: Bool
    /// <p>The metadata key.</p>
    public let metadataKey: String?
    /// <p>The value of the metadata key.</p>
    public let metadataValue: String?
    /// <p>The name for the registry.</p>
    public let registryName: String?
    /// <p>The Amazon Resource Name (ARN) for the schema.</p>
    public let schemaArn: String?
    /// <p>The name for the schema.</p>
    public let schemaName: String?
    /// <p>The unique version ID of the schema version.</p>
    public let schemaVersionId: String?
    /// <p>The version number of the schema.</p>
    public let versionNumber: Int

    public init (
        latestVersion: Bool = false,
        metadataKey: String? = nil,
        metadataValue: String? = nil,
        registryName: String? = nil,
        schemaArn: String? = nil,
        schemaName: String? = nil,
        schemaVersionId: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.latestVersion = latestVersion
        self.metadataKey = metadataKey
        self.metadataValue = metadataValue
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersionId = schemaVersionId
        self.versionNumber = versionNumber
    }
}

struct PutSchemaVersionMetadataOutputResponseBody: Equatable {
    public let schemaArn: String?
    public let schemaName: String?
    public let registryName: String?
    public let latestVersion: Bool
    public let versionNumber: Int
    public let schemaVersionId: String?
    public let metadataKey: String?
    public let metadataValue: String?
}

extension PutSchemaVersionMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case latestVersion = "LatestVersion"
        case metadataKey = "MetadataKey"
        case metadataValue = "MetadataValue"
        case registryName = "RegistryName"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersionId = "SchemaVersionId"
        case versionNumber = "VersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let latestVersionDecoded = try containerValues.decode(Bool.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let metadataKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadataKey)
        metadataKey = metadataKeyDecoded
        let metadataValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadataValue)
        metadataValue = metadataValueDecoded
    }
}

public struct PutWorkflowRunPropertiesInputBodyMiddleware: Middleware {
    public let id: String = "PutWorkflowRunPropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutWorkflowRunPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutWorkflowRunPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutWorkflowRunPropertiesInput>
    public typealias MOutput = OperationOutput<PutWorkflowRunPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutWorkflowRunPropertiesOutputError>
}

extension PutWorkflowRunPropertiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutWorkflowRunPropertiesInput(name: \(String(describing: name)), runId: \(String(describing: runId)), runProperties: \(String(describing: runProperties)))"}
}

extension PutWorkflowRunPropertiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case runId = "RunId"
        case runProperties = "RunProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runId = runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
        if let runProperties = runProperties {
            var runPropertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .runProperties)
            for (dictKey0, workflowrunproperties0) in runProperties {
                try runPropertiesContainer.encode(workflowrunproperties0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct PutWorkflowRunPropertiesInputHeadersMiddleware: Middleware {
    public let id: String = "PutWorkflowRunPropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutWorkflowRunPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutWorkflowRunPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutWorkflowRunPropertiesInput>
    public typealias MOutput = OperationOutput<PutWorkflowRunPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutWorkflowRunPropertiesOutputError>
}

public struct PutWorkflowRunPropertiesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutWorkflowRunPropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutWorkflowRunPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutWorkflowRunPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutWorkflowRunPropertiesInput>
    public typealias MOutput = OperationOutput<PutWorkflowRunPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutWorkflowRunPropertiesOutputError>
}

public struct PutWorkflowRunPropertiesInput: Equatable {
    /// <p>Name of the workflow which was run.</p>
    public let name: String?
    /// <p>The ID of the workflow run for which the run properties should be updated.</p>
    public let runId: String?
    /// <p>The properties to put for the specified run.</p>
    public let runProperties: [String:String]?

    public init (
        name: String? = nil,
        runId: String? = nil,
        runProperties: [String:String]? = nil
    )
    {
        self.name = name
        self.runId = runId
        self.runProperties = runProperties
    }
}

struct PutWorkflowRunPropertiesInputBody: Equatable {
    public let name: String?
    public let runId: String?
    public let runProperties: [String:String]?
}

extension PutWorkflowRunPropertiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case runId = "RunId"
        case runProperties = "RunProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
        let runPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .runProperties)
        var runPropertiesDecoded0: [String:String]? = nil
        if let runPropertiesContainer = runPropertiesContainer {
            runPropertiesDecoded0 = [String:String]()
            for (key0, genericstring0) in runPropertiesContainer {
                if let genericstring0 = genericstring0 {
                    runPropertiesDecoded0?[key0] = genericstring0
                }
            }
        }
        runProperties = runPropertiesDecoded0
    }
}

extension PutWorkflowRunPropertiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutWorkflowRunPropertiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutWorkflowRunPropertiesOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutWorkflowRunPropertiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutWorkflowRunPropertiesOutputResponse()"}
}

extension PutWorkflowRunPropertiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutWorkflowRunPropertiesOutputResponse: Equatable {

    public init() {}
}

struct PutWorkflowRunPropertiesOutputResponseBody: Equatable {
}

extension PutWorkflowRunPropertiesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct QuerySchemaVersionMetadataInputBodyMiddleware: Middleware {
    public let id: String = "QuerySchemaVersionMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QuerySchemaVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<QuerySchemaVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QuerySchemaVersionMetadataInput>
    public typealias MOutput = OperationOutput<QuerySchemaVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QuerySchemaVersionMetadataOutputError>
}

extension QuerySchemaVersionMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuerySchemaVersionMetadataInput(maxResults: \(String(describing: maxResults)), metadataList: \(String(describing: metadataList)), nextToken: \(String(describing: nextToken)), schemaId: \(String(describing: schemaId)), schemaVersionId: \(String(describing: schemaVersionId)), schemaVersionNumber: \(String(describing: schemaVersionNumber)))"}
}

extension QuerySchemaVersionMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case metadataList = "MetadataList"
        case nextToken = "NextToken"
        case schemaId = "SchemaId"
        case schemaVersionId = "SchemaVersionId"
        case schemaVersionNumber = "SchemaVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metadataList = metadataList {
            var metadataListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadataList)
            for metadatalist0 in metadataList {
                try metadataListContainer.encode(metadatalist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let schemaVersionId = schemaVersionId {
            try encodeContainer.encode(schemaVersionId, forKey: .schemaVersionId)
        }
        if let schemaVersionNumber = schemaVersionNumber {
            try encodeContainer.encode(schemaVersionNumber, forKey: .schemaVersionNumber)
        }
    }
}

public struct QuerySchemaVersionMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "QuerySchemaVersionMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QuerySchemaVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<QuerySchemaVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QuerySchemaVersionMetadataInput>
    public typealias MOutput = OperationOutput<QuerySchemaVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QuerySchemaVersionMetadataOutputError>
}

public struct QuerySchemaVersionMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "QuerySchemaVersionMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QuerySchemaVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<QuerySchemaVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QuerySchemaVersionMetadataInput>
    public typealias MOutput = OperationOutput<QuerySchemaVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QuerySchemaVersionMetadataOutputError>
}

public struct QuerySchemaVersionMetadataInput: Equatable {
    /// <p>Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.</p>
    public let maxResults: Int
    /// <p>Search key-value pairs for metadata, if they are not provided all the metadata information will be fetched.</p>
    public let metadataList: [MetadataKeyValuePair]?
    /// <p>A continuation token, if this is a continuation call.</p>
    public let nextToken: String?
    /// <p>A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).</p>
    public let schemaId: SchemaId?
    /// <p>The unique version ID of the schema version.</p>
    public let schemaVersionId: String?
    /// <p>The version number of the schema.</p>
    public let schemaVersionNumber: SchemaVersionNumber?

    public init (
        maxResults: Int = 0,
        metadataList: [MetadataKeyValuePair]? = nil,
        nextToken: String? = nil,
        schemaId: SchemaId? = nil,
        schemaVersionId: String? = nil,
        schemaVersionNumber: SchemaVersionNumber? = nil
    )
    {
        self.maxResults = maxResults
        self.metadataList = metadataList
        self.nextToken = nextToken
        self.schemaId = schemaId
        self.schemaVersionId = schemaVersionId
        self.schemaVersionNumber = schemaVersionNumber
    }
}

struct QuerySchemaVersionMetadataInputBody: Equatable {
    public let schemaId: SchemaId?
    public let schemaVersionNumber: SchemaVersionNumber?
    public let schemaVersionId: String?
    public let metadataList: [MetadataKeyValuePair]?
    public let maxResults: Int
    public let nextToken: String?
}

extension QuerySchemaVersionMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case metadataList = "MetadataList"
        case nextToken = "NextToken"
        case schemaId = "SchemaId"
        case schemaVersionId = "SchemaVersionId"
        case schemaVersionNumber = "SchemaVersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaVersionNumberDecoded = try containerValues.decodeIfPresent(SchemaVersionNumber.self, forKey: .schemaVersionNumber)
        schemaVersionNumber = schemaVersionNumberDecoded
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let metadataListContainer = try containerValues.decodeIfPresent([MetadataKeyValuePair?].self, forKey: .metadataList)
        var metadataListDecoded0:[MetadataKeyValuePair]? = nil
        if let metadataListContainer = metadataListContainer {
            metadataListDecoded0 = [MetadataKeyValuePair]()
            for structure0 in metadataListContainer {
                if let structure0 = structure0 {
                    metadataListDecoded0?.append(structure0)
                }
            }
        }
        metadataList = metadataListDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension QuerySchemaVersionMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension QuerySchemaVersionMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum QuerySchemaVersionMetadataOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension QuerySchemaVersionMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuerySchemaVersionMetadataOutputResponse(metadataInfoMap: \(String(describing: metadataInfoMap)), nextToken: \(String(describing: nextToken)), schemaVersionId: \(String(describing: schemaVersionId)))"}
}

extension QuerySchemaVersionMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: QuerySchemaVersionMetadataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metadataInfoMap = output.metadataInfoMap
            self.nextToken = output.nextToken
            self.schemaVersionId = output.schemaVersionId
        } else {
            self.metadataInfoMap = nil
            self.nextToken = nil
            self.schemaVersionId = nil
        }
    }
}

public struct QuerySchemaVersionMetadataOutputResponse: Equatable {
    /// <p>A map of a metadata key and associated values.</p>
    public let metadataInfoMap: [String:MetadataInfo]?
    /// <p>A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.</p>
    public let nextToken: String?
    /// <p>The unique version ID of the schema version.</p>
    public let schemaVersionId: String?

    public init (
        metadataInfoMap: [String:MetadataInfo]? = nil,
        nextToken: String? = nil,
        schemaVersionId: String? = nil
    )
    {
        self.metadataInfoMap = metadataInfoMap
        self.nextToken = nextToken
        self.schemaVersionId = schemaVersionId
    }
}

struct QuerySchemaVersionMetadataOutputResponseBody: Equatable {
    public let metadataInfoMap: [String:MetadataInfo]?
    public let schemaVersionId: String?
    public let nextToken: String?
}

extension QuerySchemaVersionMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadataInfoMap = "MetadataInfoMap"
        case nextToken = "NextToken"
        case schemaVersionId = "SchemaVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataInfoMapContainer = try containerValues.decodeIfPresent([String: MetadataInfo?].self, forKey: .metadataInfoMap)
        var metadataInfoMapDecoded0: [String:MetadataInfo]? = nil
        if let metadataInfoMapContainer = metadataInfoMapContainer {
            metadataInfoMapDecoded0 = [String:MetadataInfo]()
            for (key0, metadatainfo0) in metadataInfoMapContainer {
                if let metadatainfo0 = metadatainfo0 {
                    metadataInfoMapDecoded0?[key0] = metadatainfo0
                }
            }
        }
        metadataInfoMap = metadataInfoMapDecoded0
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum RecrawlBehavior {
    case crawlEverything
    case crawlNewFoldersOnly
    case sdkUnknown(String)
}

extension RecrawlBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecrawlBehavior] {
        return [
            .crawlEverything,
            .crawlNewFoldersOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .crawlEverything: return "CRAWL_EVERYTHING"
        case .crawlNewFoldersOnly: return "CRAWL_NEW_FOLDERS_ONLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecrawlBehavior(rawValue: rawValue) ?? RecrawlBehavior.sdkUnknown(rawValue)
    }
}

extension RecrawlPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recrawlBehavior = "RecrawlBehavior"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recrawlBehavior = recrawlBehavior {
            try encodeContainer.encode(recrawlBehavior.rawValue, forKey: .recrawlBehavior)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recrawlBehaviorDecoded = try containerValues.decodeIfPresent(RecrawlBehavior.self, forKey: .recrawlBehavior)
        recrawlBehavior = recrawlBehaviorDecoded
    }
}

extension RecrawlPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecrawlPolicy(recrawlBehavior: \(String(describing: recrawlBehavior)))"}
}

/// <p>When crawling an Amazon S3 data source after the first crawl is complete, specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/incremental-crawls.html">Incremental Crawls in AWS Glue</a> in the developer guide.</p>
public struct RecrawlPolicy: Equatable {
    /// <p>Specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run.</p>
    /// 	
    /// 	        <p>A value of <code>CRAWL_EVERYTHING</code> specifies crawling the entire dataset again.</p>
    ///
    ///          <p>A value of <code>CRAWL_NEW_FOLDERS_ONLY</code> specifies crawling only folders that were added since the last crawler run.</p>
    public let recrawlBehavior: RecrawlBehavior?

    public init (
        recrawlBehavior: RecrawlBehavior? = nil
    )
    {
        self.recrawlBehavior = recrawlBehavior
    }
}

public struct RegisterSchemaVersionInputBodyMiddleware: Middleware {
    public let id: String = "RegisterSchemaVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterSchemaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterSchemaVersionInput>
    public typealias MOutput = OperationOutput<RegisterSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterSchemaVersionOutputError>
}

extension RegisterSchemaVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterSchemaVersionInput(schemaDefinition: \(String(describing: schemaDefinition)), schemaId: \(String(describing: schemaId)))"}
}

extension RegisterSchemaVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaDefinition = "SchemaDefinition"
        case schemaId = "SchemaId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaDefinition = schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
    }
}

public struct RegisterSchemaVersionInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterSchemaVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterSchemaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterSchemaVersionInput>
    public typealias MOutput = OperationOutput<RegisterSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterSchemaVersionOutputError>
}

public struct RegisterSchemaVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterSchemaVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterSchemaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterSchemaVersionInput>
    public typealias MOutput = OperationOutput<RegisterSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterSchemaVersionOutputError>
}

public struct RegisterSchemaVersionInput: Equatable {
    /// <p>The schema definition using the <code>DataFormat</code> setting for the <code>SchemaName</code>.</p>
    public let schemaDefinition: String?
    /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>SchemaId$SchemaName: The name of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
    ///             </li>
    ///          </ul>
    public let schemaId: SchemaId?

    public init (
        schemaDefinition: String? = nil,
        schemaId: SchemaId? = nil
    )
    {
        self.schemaDefinition = schemaDefinition
        self.schemaId = schemaId
    }
}

struct RegisterSchemaVersionInputBody: Equatable {
    public let schemaId: SchemaId?
    public let schemaDefinition: String?
}

extension RegisterSchemaVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaDefinition = "SchemaDefinition"
        case schemaId = "SchemaId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension RegisterSchemaVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterSchemaVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterSchemaVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterSchemaVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterSchemaVersionOutputResponse(schemaVersionId: \(String(describing: schemaVersionId)), status: \(String(describing: status)), versionNumber: \(String(describing: versionNumber)))"}
}

extension RegisterSchemaVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterSchemaVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.schemaVersionId = output.schemaVersionId
            self.status = output.status
            self.versionNumber = output.versionNumber
        } else {
            self.schemaVersionId = nil
            self.status = nil
            self.versionNumber = 0
        }
    }
}

public struct RegisterSchemaVersionOutputResponse: Equatable {
    /// <p>The unique ID that represents the version of this schema.</p>
    public let schemaVersionId: String?
    /// <p>The status of the schema version.</p>
    public let status: SchemaVersionStatus?
    /// <p>The version of this schema (for sync flow only, in case this is the first version).</p>
    public let versionNumber: Int

    public init (
        schemaVersionId: String? = nil,
        status: SchemaVersionStatus? = nil,
        versionNumber: Int = 0
    )
    {
        self.schemaVersionId = schemaVersionId
        self.status = status
        self.versionNumber = versionNumber
    }
}

struct RegisterSchemaVersionOutputResponseBody: Equatable {
    public let schemaVersionId: String?
    public let versionNumber: Int
    public let status: SchemaVersionStatus?
}

extension RegisterSchemaVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaVersionId = "SchemaVersionId"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SchemaVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension RegistryId: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryArn = registryArn {
            try encodeContainer.encode(registryArn, forKey: .registryArn)
        }
        if let registryName = registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
    }
}

extension RegistryId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegistryId(registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)))"}
}

/// <p>A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).</p>
public struct RegistryId: Equatable {
    /// <p>Arn of the registry to be updated. One of <code>RegistryArn</code> or <code>RegistryName</code> has to be provided.</p>
    public let registryArn: String?
    /// <p>Name of the registry. Used only for lookup. One of <code>RegistryArn</code> or <code>RegistryName</code> has to be provided. </p>
    public let registryName: String?

    public init (
        registryArn: String? = nil,
        registryName: String? = nil
    )
    {
        self.registryArn = registryArn
        self.registryName = registryName
    }
}

extension RegistryListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case status = "Status"
        case updatedTime = "UpdatedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let registryArn = registryArn {
            try encodeContainer.encode(registryArn, forKey: .registryArn)
        }
        if let registryName = registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTime = updatedTime {
            try encodeContainer.encode(updatedTime, forKey: .updatedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RegistryStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
    }
}

extension RegistryListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegistryListItem(createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)), status: \(String(describing: status)), updatedTime: \(String(describing: updatedTime)))"}
}

/// <p>A structure containing the details for a registry.</p>
public struct RegistryListItem: Equatable {
    /// <p>The data the registry was created.</p>
    public let createdTime: String?
    /// <p>A description of the registry.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the registry.</p>
    public let registryArn: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The status of the registry.</p>
    public let status: RegistryStatus?
    /// <p>The date the registry was updated.</p>
    public let updatedTime: String?

    public init (
        createdTime: String? = nil,
        description: String? = nil,
        registryArn: String? = nil,
        registryName: String? = nil,
        status: RegistryStatus? = nil,
        updatedTime: String? = nil
    )
    {
        self.createdTime = createdTime
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.status = status
        self.updatedTime = updatedTime
    }
}

public enum RegistryStatus {
    case available
    case deleting
    case sdkUnknown(String)
}

extension RegistryStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RegistryStatus] {
        return [
            .available,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RegistryStatus(rawValue: rawValue) ?? RegistryStatus.sdkUnknown(rawValue)
    }
}

public struct RemoveSchemaVersionMetadataInputBodyMiddleware: Middleware {
    public let id: String = "RemoveSchemaVersionMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveSchemaVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveSchemaVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveSchemaVersionMetadataInput>
    public typealias MOutput = OperationOutput<RemoveSchemaVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveSchemaVersionMetadataOutputError>
}

extension RemoveSchemaVersionMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveSchemaVersionMetadataInput(metadataKeyValue: \(String(describing: metadataKeyValue)), schemaId: \(String(describing: schemaId)), schemaVersionId: \(String(describing: schemaVersionId)), schemaVersionNumber: \(String(describing: schemaVersionNumber)))"}
}

extension RemoveSchemaVersionMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metadataKeyValue = "MetadataKeyValue"
        case schemaId = "SchemaId"
        case schemaVersionId = "SchemaVersionId"
        case schemaVersionNumber = "SchemaVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataKeyValue = metadataKeyValue {
            try encodeContainer.encode(metadataKeyValue, forKey: .metadataKeyValue)
        }
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let schemaVersionId = schemaVersionId {
            try encodeContainer.encode(schemaVersionId, forKey: .schemaVersionId)
        }
        if let schemaVersionNumber = schemaVersionNumber {
            try encodeContainer.encode(schemaVersionNumber, forKey: .schemaVersionNumber)
        }
    }
}

public struct RemoveSchemaVersionMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveSchemaVersionMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveSchemaVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveSchemaVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveSchemaVersionMetadataInput>
    public typealias MOutput = OperationOutput<RemoveSchemaVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveSchemaVersionMetadataOutputError>
}

public struct RemoveSchemaVersionMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveSchemaVersionMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveSchemaVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveSchemaVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveSchemaVersionMetadataInput>
    public typealias MOutput = OperationOutput<RemoveSchemaVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveSchemaVersionMetadataOutputError>
}

public struct RemoveSchemaVersionMetadataInput: Equatable {
    /// <p>The value of the metadata key.</p>
    public let metadataKeyValue: MetadataKeyValuePair?
    /// <p>A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).</p>
    public let schemaId: SchemaId?
    /// <p>The unique version ID of the schema version.</p>
    public let schemaVersionId: String?
    /// <p>The version number of the schema.</p>
    public let schemaVersionNumber: SchemaVersionNumber?

    public init (
        metadataKeyValue: MetadataKeyValuePair? = nil,
        schemaId: SchemaId? = nil,
        schemaVersionId: String? = nil,
        schemaVersionNumber: SchemaVersionNumber? = nil
    )
    {
        self.metadataKeyValue = metadataKeyValue
        self.schemaId = schemaId
        self.schemaVersionId = schemaVersionId
        self.schemaVersionNumber = schemaVersionNumber
    }
}

struct RemoveSchemaVersionMetadataInputBody: Equatable {
    public let schemaId: SchemaId?
    public let schemaVersionNumber: SchemaVersionNumber?
    public let schemaVersionId: String?
    public let metadataKeyValue: MetadataKeyValuePair?
}

extension RemoveSchemaVersionMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadataKeyValue = "MetadataKeyValue"
        case schemaId = "SchemaId"
        case schemaVersionId = "SchemaVersionId"
        case schemaVersionNumber = "SchemaVersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaVersionNumberDecoded = try containerValues.decodeIfPresent(SchemaVersionNumber.self, forKey: .schemaVersionNumber)
        schemaVersionNumber = schemaVersionNumberDecoded
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let metadataKeyValueDecoded = try containerValues.decodeIfPresent(MetadataKeyValuePair.self, forKey: .metadataKeyValue)
        metadataKeyValue = metadataKeyValueDecoded
    }
}

extension RemoveSchemaVersionMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveSchemaVersionMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveSchemaVersionMetadataOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveSchemaVersionMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveSchemaVersionMetadataOutputResponse(latestVersion: \(String(describing: latestVersion)), metadataKey: \(String(describing: metadataKey)), metadataValue: \(String(describing: metadataValue)), registryName: \(String(describing: registryName)), schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)), schemaVersionId: \(String(describing: schemaVersionId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension RemoveSchemaVersionMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveSchemaVersionMetadataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.latestVersion = output.latestVersion
            self.metadataKey = output.metadataKey
            self.metadataValue = output.metadataValue
            self.registryName = output.registryName
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersionId = output.schemaVersionId
            self.versionNumber = output.versionNumber
        } else {
            self.latestVersion = false
            self.metadataKey = nil
            self.metadataValue = nil
            self.registryName = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersionId = nil
            self.versionNumber = 0
        }
    }
}

public struct RemoveSchemaVersionMetadataOutputResponse: Equatable {
    /// <p>The latest version of the schema.</p>
    public let latestVersion: Bool
    /// <p>The metadata key.</p>
    public let metadataKey: String?
    /// <p>The value of the metadata key.</p>
    public let metadataValue: String?
    /// <p>The name of the registry.</p>
    public let registryName: String?
    /// <p>The Amazon Resource Name (ARN) of the schema.</p>
    public let schemaArn: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>The version ID for the schema version.</p>
    public let schemaVersionId: String?
    /// <p>The version number of the schema.</p>
    public let versionNumber: Int

    public init (
        latestVersion: Bool = false,
        metadataKey: String? = nil,
        metadataValue: String? = nil,
        registryName: String? = nil,
        schemaArn: String? = nil,
        schemaName: String? = nil,
        schemaVersionId: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.latestVersion = latestVersion
        self.metadataKey = metadataKey
        self.metadataValue = metadataValue
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersionId = schemaVersionId
        self.versionNumber = versionNumber
    }
}

struct RemoveSchemaVersionMetadataOutputResponseBody: Equatable {
    public let schemaArn: String?
    public let schemaName: String?
    public let registryName: String?
    public let latestVersion: Bool
    public let versionNumber: Int
    public let schemaVersionId: String?
    public let metadataKey: String?
    public let metadataValue: String?
}

extension RemoveSchemaVersionMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case latestVersion = "LatestVersion"
        case metadataKey = "MetadataKey"
        case metadataValue = "MetadataValue"
        case registryName = "RegistryName"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersionId = "SchemaVersionId"
        case versionNumber = "VersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let latestVersionDecoded = try containerValues.decode(Bool.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let metadataKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadataKey)
        metadataKey = metadataKeyDecoded
        let metadataValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadataValue)
        metadataValue = metadataValueDecoded
    }
}

public struct ResetJobBookmarkInputBodyMiddleware: Middleware {
    public let id: String = "ResetJobBookmarkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetJobBookmarkInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetJobBookmarkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetJobBookmarkInput>
    public typealias MOutput = OperationOutput<ResetJobBookmarkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetJobBookmarkOutputError>
}

extension ResetJobBookmarkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetJobBookmarkInput(jobName: \(String(describing: jobName)), runId: \(String(describing: runId)))"}
}

extension ResetJobBookmarkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case runId = "RunId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let runId = runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
    }
}

public struct ResetJobBookmarkInputHeadersMiddleware: Middleware {
    public let id: String = "ResetJobBookmarkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetJobBookmarkInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetJobBookmarkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetJobBookmarkInput>
    public typealias MOutput = OperationOutput<ResetJobBookmarkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetJobBookmarkOutputError>
}

public struct ResetJobBookmarkInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetJobBookmarkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetJobBookmarkInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetJobBookmarkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetJobBookmarkInput>
    public typealias MOutput = OperationOutput<ResetJobBookmarkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetJobBookmarkOutputError>
}

public struct ResetJobBookmarkInput: Equatable {
    /// <p>The name of the job in question.</p>
    public let jobName: String?
    /// <p>The unique run identifier associated with this job run.</p>
    public let runId: String?

    public init (
        jobName: String? = nil,
        runId: String? = nil
    )
    {
        self.jobName = jobName
        self.runId = runId
    }
}

struct ResetJobBookmarkInputBody: Equatable {
    public let jobName: String?
    public let runId: String?
}

extension ResetJobBookmarkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case runId = "RunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
    }
}

extension ResetJobBookmarkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetJobBookmarkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetJobBookmarkOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetJobBookmarkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetJobBookmarkOutputResponse(jobBookmarkEntry: \(String(describing: jobBookmarkEntry)))"}
}

extension ResetJobBookmarkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResetJobBookmarkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobBookmarkEntry = output.jobBookmarkEntry
        } else {
            self.jobBookmarkEntry = nil
        }
    }
}

public struct ResetJobBookmarkOutputResponse: Equatable {
    /// <p>The reset bookmark entry.</p>
    public let jobBookmarkEntry: JobBookmarkEntry?

    public init (
        jobBookmarkEntry: JobBookmarkEntry? = nil
    )
    {
        self.jobBookmarkEntry = jobBookmarkEntry
    }
}

struct ResetJobBookmarkOutputResponseBody: Equatable {
    public let jobBookmarkEntry: JobBookmarkEntry?
}

extension ResetJobBookmarkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobBookmarkEntry = "JobBookmarkEntry"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobBookmarkEntryDecoded = try containerValues.decodeIfPresent(JobBookmarkEntry.self, forKey: .jobBookmarkEntry)
        jobBookmarkEntry = jobBookmarkEntryDecoded
    }
}

extension ResourceNumberLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNumberLimitExceededException(message: \(String(describing: message)))"}
}

extension ResourceNumberLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNumberLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource numerical limit was exceeded.</p>
public struct ResourceNumberLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNumberLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNumberLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceShareType {
    case all
    case foreign
    case sdkUnknown(String)
}

extension ResourceShareType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceShareType] {
        return [
            .all,
            .foreign,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .foreign: return "FOREIGN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceShareType(rawValue: rawValue) ?? ResourceShareType.sdkUnknown(rawValue)
    }
}

public enum ResourceType {
    case archive
    case file
    case jar
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .archive,
            .file,
            .jar,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .archive: return "ARCHIVE"
        case .file: return "FILE"
        case .jar: return "JAR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension ResourceUri: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceType = "ResourceType"
        case uri = "Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension ResourceUri: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceUri(resourceType: \(String(describing: resourceType)), uri: \(String(describing: uri)))"}
}

/// <p>The URIs for function resources.</p>
public struct ResourceUri: Equatable {
    /// <p>The type of the resource.</p>
    public let resourceType: ResourceType?
    /// <p>The URI for accessing the resource.</p>
    public let uri: String?

    public init (
        resourceType: ResourceType? = nil,
        uri: String? = nil
    )
    {
        self.resourceType = resourceType
        self.uri = uri
    }
}

public struct ResumeWorkflowRunInputBodyMiddleware: Middleware {
    public let id: String = "ResumeWorkflowRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeWorkflowRunInput>
    public typealias MOutput = OperationOutput<ResumeWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeWorkflowRunOutputError>
}

extension ResumeWorkflowRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResumeWorkflowRunInput(name: \(String(describing: name)), nodeIds: \(String(describing: nodeIds)), runId: \(String(describing: runId)))"}
}

extension ResumeWorkflowRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case nodeIds = "NodeIds"
        case runId = "RunId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nodeIds = nodeIds {
            var nodeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIds)
            for nodeidlist0 in nodeIds {
                try nodeIdsContainer.encode(nodeidlist0)
            }
        }
        if let runId = runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
    }
}

public struct ResumeWorkflowRunInputHeadersMiddleware: Middleware {
    public let id: String = "ResumeWorkflowRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeWorkflowRunInput>
    public typealias MOutput = OperationOutput<ResumeWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeWorkflowRunOutputError>
}

public struct ResumeWorkflowRunInputQueryItemMiddleware: Middleware {
    public let id: String = "ResumeWorkflowRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeWorkflowRunInput>
    public typealias MOutput = OperationOutput<ResumeWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeWorkflowRunOutputError>
}

public struct ResumeWorkflowRunInput: Equatable {
    /// <p>The name of the workflow to resume.</p>
    public let name: String?
    /// <p>A list of the node IDs for the nodes you want to restart. The nodes that are to be restarted must have a run attempt in the original run.</p>
    public let nodeIds: [String]?
    /// <p>The ID of the workflow run to resume.</p>
    public let runId: String?

    public init (
        name: String? = nil,
        nodeIds: [String]? = nil,
        runId: String? = nil
    )
    {
        self.name = name
        self.nodeIds = nodeIds
        self.runId = runId
    }
}

struct ResumeWorkflowRunInputBody: Equatable {
    public let name: String?
    public let runId: String?
    public let nodeIds: [String]?
}

extension ResumeWorkflowRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case nodeIds = "NodeIds"
        case runId = "RunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
        let nodeIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .nodeIds)
        var nodeIdsDecoded0:[String]? = nil
        if let nodeIdsContainer = nodeIdsContainer {
            nodeIdsDecoded0 = [String]()
            for string0 in nodeIdsContainer {
                if let string0 = string0 {
                    nodeIdsDecoded0?.append(string0)
                }
            }
        }
        nodeIds = nodeIdsDecoded0
    }
}

extension ResumeWorkflowRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeWorkflowRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentRunsExceededException" : self = .concurrentRunsExceededException(try ConcurrentRunsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalWorkflowStateException" : self = .illegalWorkflowStateException(try IllegalWorkflowStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResumeWorkflowRunOutputError: Equatable {
    case concurrentRunsExceededException(ConcurrentRunsExceededException)
    case entityNotFoundException(EntityNotFoundException)
    case illegalWorkflowStateException(IllegalWorkflowStateException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeWorkflowRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResumeWorkflowRunOutputResponse(nodeIds: \(String(describing: nodeIds)), runId: \(String(describing: runId)))"}
}

extension ResumeWorkflowRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResumeWorkflowRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nodeIds = output.nodeIds
            self.runId = output.runId
        } else {
            self.nodeIds = nil
            self.runId = nil
        }
    }
}

public struct ResumeWorkflowRunOutputResponse: Equatable {
    /// <p>A list of the node IDs for the nodes that were actually restarted.</p>
    public let nodeIds: [String]?
    /// <p>The new ID assigned to the resumed workflow run. Each resume of a workflow run will have a new run ID.</p>
    public let runId: String?

    public init (
        nodeIds: [String]? = nil,
        runId: String? = nil
    )
    {
        self.nodeIds = nodeIds
        self.runId = runId
    }
}

struct ResumeWorkflowRunOutputResponseBody: Equatable {
    public let runId: String?
    public let nodeIds: [String]?
}

extension ResumeWorkflowRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nodeIds = "NodeIds"
        case runId = "RunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
        let nodeIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .nodeIds)
        var nodeIdsDecoded0:[String]? = nil
        if let nodeIdsContainer = nodeIdsContainer {
            nodeIdsDecoded0 = [String]()
            for string0 in nodeIdsContainer {
                if let string0 = string0 {
                    nodeIdsDecoded0?.append(string0)
                }
            }
        }
        nodeIds = nodeIdsDecoded0
    }
}

extension S3Encryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyArn = "KmsKeyArn"
        case s3EncryptionMode = "S3EncryptionMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let s3EncryptionMode = s3EncryptionMode {
            try encodeContainer.encode(s3EncryptionMode.rawValue, forKey: .s3EncryptionMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3EncryptionModeDecoded = try containerValues.decodeIfPresent(S3EncryptionMode.self, forKey: .s3EncryptionMode)
        s3EncryptionMode = s3EncryptionModeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension S3Encryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Encryption(kmsKeyArn: \(String(describing: kmsKeyArn)), s3EncryptionMode: \(String(describing: s3EncryptionMode)))"}
}

/// <p>Specifies how Amazon Simple Storage Service (Amazon S3) data should be encrypted.</p>
public struct S3Encryption: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
    public let kmsKeyArn: String?
    /// <p>The encryption mode to use for Amazon S3 data.</p>
    public let s3EncryptionMode: S3EncryptionMode?

    public init (
        kmsKeyArn: String? = nil,
        s3EncryptionMode: S3EncryptionMode? = nil
    )
    {
        self.kmsKeyArn = kmsKeyArn
        self.s3EncryptionMode = s3EncryptionMode
    }
}

public enum S3EncryptionMode {
    case disabled
    case ssekms
    case sses3
    case sdkUnknown(String)
}

extension S3EncryptionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3EncryptionMode] {
        return [
            .disabled,
            .ssekms,
            .sses3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .ssekms: return "SSE-KMS"
        case .sses3: return "SSE-S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3EncryptionMode(rawValue: rawValue) ?? S3EncryptionMode.sdkUnknown(rawValue)
    }
}

extension S3Target: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionName = "ConnectionName"
        case exclusions = "Exclusions"
        case path = "Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let exclusions = exclusions {
            var exclusionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusions)
            for pathlist0 in exclusions {
                try exclusionsContainer.encode(pathlist0)
            }
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let exclusionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exclusions)
        var exclusionsDecoded0:[String]? = nil
        if let exclusionsContainer = exclusionsContainer {
            exclusionsDecoded0 = [String]()
            for string0 in exclusionsContainer {
                if let string0 = string0 {
                    exclusionsDecoded0?.append(string0)
                }
            }
        }
        exclusions = exclusionsDecoded0
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
    }
}

extension S3Target: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Target(connectionName: \(String(describing: connectionName)), exclusions: \(String(describing: exclusions)), path: \(String(describing: path)))"}
}

/// <p>Specifies a data store in Amazon Simple Storage Service (Amazon S3).</p>
public struct S3Target: Equatable {
    /// <p>The name of a connection which allows a job or crawler to access data in Amazon S3 within an Amazon Virtual Private Cloud environment (Amazon VPC).</p>
    public let connectionName: String?
    /// <p>A list of glob patterns used to exclude from the crawl.
    ///       For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html">Catalog Tables with a Crawler</a>.</p>
    public let exclusions: [String]?
    /// <p>The path to the Amazon S3 target.</p>
    public let path: String?

    public init (
        connectionName: String? = nil,
        exclusions: [String]? = nil,
        path: String? = nil
    )
    {
        self.connectionName = connectionName
        self.exclusions = exclusions
        self.path = path
    }
}

extension Schedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ScheduleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension Schedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Schedule(scheduleExpression: \(String(describing: scheduleExpression)), state: \(String(describing: state)))"}
}

/// <p>A scheduling object using a <code>cron</code> statement to schedule an event.</p>
public struct Schedule: Equatable {
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run
    ///       something every day at 12:15 UTC, you would specify:
    ///       <code>cron(15 12 * * ? *)</code>.</p>
    public let scheduleExpression: String?
    /// <p>The state of the schedule.</p>
    public let state: ScheduleState?

    public init (
        scheduleExpression: String? = nil,
        state: ScheduleState? = nil
    )
    {
        self.scheduleExpression = scheduleExpression
        self.state = state
    }
}

public enum ScheduleState {
    case notScheduled
    case scheduled
    case transitioning
    case sdkUnknown(String)
}

extension ScheduleState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScheduleState] {
        return [
            .notScheduled,
            .scheduled,
            .transitioning,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notScheduled: return "NOT_SCHEDULED"
        case .scheduled: return "SCHEDULED"
        case .transitioning: return "TRANSITIONING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScheduleState(rawValue: rawValue) ?? ScheduleState.sdkUnknown(rawValue)
    }
}

extension SchedulerNotRunningException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchedulerNotRunningException(message: \(String(describing: message)))"}
}

extension SchedulerNotRunningException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SchedulerNotRunningExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified scheduler is not running.</p>
public struct SchedulerNotRunningException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SchedulerNotRunningExceptionBody: Equatable {
    public let message: String?
}

extension SchedulerNotRunningExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchedulerRunningException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchedulerRunningException(message: \(String(describing: message)))"}
}

extension SchedulerRunningException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SchedulerRunningExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified scheduler is already running.</p>
public struct SchedulerRunningException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SchedulerRunningExceptionBody: Equatable {
    public let message: String?
}

extension SchedulerRunningExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchedulerTransitioningException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchedulerTransitioningException(message: \(String(describing: message)))"}
}

extension SchedulerTransitioningException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SchedulerTransitioningExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified scheduler is transitioning.</p>
public struct SchedulerTransitioningException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SchedulerTransitioningExceptionBody: Equatable {
    public let message: String?
}

extension SchedulerTransitioningExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchemaChangePolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteBehavior = "DeleteBehavior"
        case updateBehavior = "UpdateBehavior"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteBehavior = deleteBehavior {
            try encodeContainer.encode(deleteBehavior.rawValue, forKey: .deleteBehavior)
        }
        if let updateBehavior = updateBehavior {
            try encodeContainer.encode(updateBehavior.rawValue, forKey: .updateBehavior)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateBehaviorDecoded = try containerValues.decodeIfPresent(UpdateBehavior.self, forKey: .updateBehavior)
        updateBehavior = updateBehaviorDecoded
        let deleteBehaviorDecoded = try containerValues.decodeIfPresent(DeleteBehavior.self, forKey: .deleteBehavior)
        deleteBehavior = deleteBehaviorDecoded
    }
}

extension SchemaChangePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaChangePolicy(deleteBehavior: \(String(describing: deleteBehavior)), updateBehavior: \(String(describing: updateBehavior)))"}
}

/// <p>A policy that specifies update and deletion behaviors for the crawler.</p>
public struct SchemaChangePolicy: Equatable {
    /// <p>The deletion behavior when the crawler finds a deleted object.</p>
    public let deleteBehavior: DeleteBehavior?
    /// <p>The update behavior when the crawler finds a changed schema.</p>
    public let updateBehavior: UpdateBehavior?

    public init (
        deleteBehavior: DeleteBehavior? = nil,
        updateBehavior: UpdateBehavior? = nil
    )
    {
        self.deleteBehavior = deleteBehavior
        self.updateBehavior = updateBehavior
    }
}

extension SchemaColumn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataType = "DataType"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension SchemaColumn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaColumn(dataType: \(String(describing: dataType)), name: \(String(describing: name)))"}
}

/// <p>A key-value pair representing a column and data type that this transform can
///       run against. The <code>Schema</code> parameter of the <code>MLTransform</code> may contain up to 100 of these structures.</p>
public struct SchemaColumn: Equatable {
    /// <p>The type of data in the column.</p>
    public let dataType: String?
    /// <p>The name of the column.</p>
    public let name: String?

    public init (
        dataType: String? = nil,
        name: String? = nil
    )
    {
        self.dataType = dataType
        self.name = name
    }
}

public enum SchemaDiffType {
    case syntaxDiff
    case sdkUnknown(String)
}

extension SchemaDiffType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SchemaDiffType] {
        return [
            .syntaxDiff,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .syntaxDiff: return "SYNTAX_DIFF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SchemaDiffType(rawValue: rawValue) ?? SchemaDiffType.sdkUnknown(rawValue)
    }
}

extension SchemaId: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryName = "RegistryName"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryName = registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
    }
}

extension SchemaId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaId(registryName: \(String(describing: registryName)), schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)))"}
}

/// <p>The unique ID of the schema in the AWS Glue schema registry.</p>
public struct SchemaId: Equatable {
    /// <p>The name of the schema registry that contains the schema.</p>
    public let registryName: String?
    /// <p>The Amazon Resource Name (ARN) of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    public let schemaArn: String?
    /// <p>The name of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    public let schemaName: String?

    public init (
        registryName: String? = nil,
        schemaArn: String? = nil,
        schemaName: String? = nil
    )
    {
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaName = schemaName
    }
}

extension SchemaListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case description = "Description"
        case registryName = "RegistryName"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaStatus = "SchemaStatus"
        case updatedTime = "UpdatedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let registryName = registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let schemaStatus = schemaStatus {
            try encodeContainer.encode(schemaStatus.rawValue, forKey: .schemaStatus)
        }
        if let updatedTime = updatedTime {
            try encodeContainer.encode(updatedTime, forKey: .updatedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let schemaStatusDecoded = try containerValues.decodeIfPresent(SchemaStatus.self, forKey: .schemaStatus)
        schemaStatus = schemaStatusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
    }
}

extension SchemaListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaListItem(createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), registryName: \(String(describing: registryName)), schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)), schemaStatus: \(String(describing: schemaStatus)), updatedTime: \(String(describing: updatedTime)))"}
}

/// <p>An object that contains minimal details for a schema.</p>
public struct SchemaListItem: Equatable {
    /// <p>The date and time that a schema was created.</p>
    public let createdTime: String?
    /// <p>A description for the schema.</p>
    public let description: String?
    /// <p>the name of the registry where the schema resides.</p>
    public let registryName: String?
    /// <p>The Amazon Resource Name (ARN) for the schema.</p>
    public let schemaArn: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?
    /// <p>The status of the schema.</p>
    public let schemaStatus: SchemaStatus?
    /// <p>The date and time that a schema was updated.</p>
    public let updatedTime: String?

    public init (
        createdTime: String? = nil,
        description: String? = nil,
        registryName: String? = nil,
        schemaArn: String? = nil,
        schemaName: String? = nil,
        schemaStatus: SchemaStatus? = nil,
        updatedTime: String? = nil
    )
    {
        self.createdTime = createdTime
        self.description = description
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaStatus = schemaStatus
        self.updatedTime = updatedTime
    }
}

extension SchemaReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaId = "SchemaId"
        case schemaVersionId = "SchemaVersionId"
        case schemaVersionNumber = "SchemaVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let schemaVersionId = schemaVersionId {
            try encodeContainer.encode(schemaVersionId, forKey: .schemaVersionId)
        }
        if schemaVersionNumber != 0 {
            try encodeContainer.encode(schemaVersionNumber, forKey: .schemaVersionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let schemaVersionNumberDecoded = try containerValues.decode(Int.self, forKey: .schemaVersionNumber)
        schemaVersionNumber = schemaVersionNumberDecoded
    }
}

extension SchemaReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaReference(schemaId: \(String(describing: schemaId)), schemaVersionId: \(String(describing: schemaVersionId)), schemaVersionNumber: \(String(describing: schemaVersionNumber)))"}
}

/// <p>An object that references a schema stored in the AWS Glue Schema Registry.</p>
public struct SchemaReference: Equatable {
    /// <p>A structure that contains schema identity fields. Either this or the <code>SchemaVersionId</code> has to be provided.</p>
    public let schemaId: SchemaId?
    /// <p>The unique ID assigned to a version of the schema. Either this or the <code>SchemaId</code> has to be provided.</p>
    public let schemaVersionId: String?
    /// <p>The version number of the schema.</p>
    public let schemaVersionNumber: Int

    public init (
        schemaId: SchemaId? = nil,
        schemaVersionId: String? = nil,
        schemaVersionNumber: Int = 0
    )
    {
        self.schemaId = schemaId
        self.schemaVersionId = schemaVersionId
        self.schemaVersionNumber = schemaVersionNumber
    }
}

public enum SchemaStatus {
    case available
    case deleting
    case pending
    case sdkUnknown(String)
}

extension SchemaStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SchemaStatus] {
        return [
            .available,
            .deleting,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleting: return "DELETING"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SchemaStatus(rawValue: rawValue) ?? SchemaStatus.sdkUnknown(rawValue)
    }
}

extension SchemaVersionErrorItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorDetails = "ErrorDetails"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorDetails = errorDetails {
            try encodeContainer.encode(errorDetails, forKey: .errorDetails)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

extension SchemaVersionErrorItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaVersionErrorItem(errorDetails: \(String(describing: errorDetails)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>An object that contains the error details for an operation on a schema version.</p>
public struct SchemaVersionErrorItem: Equatable {
    /// <p>The details of the error for the schema version.</p>
    public let errorDetails: ErrorDetails?
    /// <p>The version number of the schema.</p>
    public let versionNumber: Int

    public init (
        errorDetails: ErrorDetails? = nil,
        versionNumber: Int = 0
    )
    {
        self.errorDetails = errorDetails
        self.versionNumber = versionNumber
    }
}

extension SchemaVersionListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case schemaArn = "SchemaArn"
        case schemaVersionId = "SchemaVersionId"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaVersionId = schemaVersionId {
            try encodeContainer.encode(schemaVersionId, forKey: .schemaVersionId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SchemaVersionStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension SchemaVersionListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaVersionListItem(createdTime: \(String(describing: createdTime)), schemaArn: \(String(describing: schemaArn)), schemaVersionId: \(String(describing: schemaVersionId)), status: \(String(describing: status)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>An object containing the details about a schema version.</p>
public struct SchemaVersionListItem: Equatable {
    /// <p>The date and time the schema version was created.</p>
    public let createdTime: String?
    /// <p>The Amazon Resource Name (ARN) of the schema.</p>
    public let schemaArn: String?
    /// <p>The unique identifier of the schema version.</p>
    public let schemaVersionId: String?
    /// <p>The status of the schema version.</p>
    public let status: SchemaVersionStatus?
    /// <p>The version number of the schema.</p>
    public let versionNumber: Int

    public init (
        createdTime: String? = nil,
        schemaArn: String? = nil,
        schemaVersionId: String? = nil,
        status: SchemaVersionStatus? = nil,
        versionNumber: Int = 0
    )
    {
        self.createdTime = createdTime
        self.schemaArn = schemaArn
        self.schemaVersionId = schemaVersionId
        self.status = status
        self.versionNumber = versionNumber
    }
}

extension SchemaVersionNumber: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case latestVersion = "LatestVersion"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if latestVersion != false {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestVersionDecoded = try containerValues.decode(Bool.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
    }
}

extension SchemaVersionNumber: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaVersionNumber(latestVersion: \(String(describing: latestVersion)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>A structure containing the schema version information.</p>
public struct SchemaVersionNumber: Equatable {
    /// <p>The latest version available for the schema.</p>
    public let latestVersion: Bool
    /// <p>The version number of the schema.</p>
    public let versionNumber: Int

    public init (
        latestVersion: Bool = false,
        versionNumber: Int = 0
    )
    {
        self.latestVersion = latestVersion
        self.versionNumber = versionNumber
    }
}

public enum SchemaVersionStatus {
    case available
    case deleting
    case failure
    case pending
    case sdkUnknown(String)
}

extension SchemaVersionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SchemaVersionStatus] {
        return [
            .available,
            .deleting,
            .failure,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleting: return "DELETING"
        case .failure: return "FAILURE"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SchemaVersionStatus(rawValue: rawValue) ?? SchemaVersionStatus.sdkUnknown(rawValue)
    }
}

public struct SearchTablesInputBodyMiddleware: Middleware {
    public let id: String = "SearchTablesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchTablesInput>
    public typealias MOutput = OperationOutput<SearchTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchTablesOutputError>
}

extension SearchTablesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchTablesInput(catalogId: \(String(describing: catalogId)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceShareType: \(String(describing: resourceShareType)), searchText: \(String(describing: searchText)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension SearchTablesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceShareType = "ResourceShareType"
        case searchText = "SearchText"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for searchpropertypredicates0 in filters {
                try filtersContainer.encode(searchpropertypredicates0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareType = resourceShareType {
            try encodeContainer.encode(resourceShareType.rawValue, forKey: .resourceShareType)
        }
        if let searchText = searchText {
            try encodeContainer.encode(searchText, forKey: .searchText)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortcriteria0 in sortCriteria {
                try sortCriteriaContainer.encode(sortcriteria0)
            }
        }
    }
}

public struct SearchTablesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchTablesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchTablesInput>
    public typealias MOutput = OperationOutput<SearchTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchTablesOutputError>
}

public struct SearchTablesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchTablesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchTablesInput>
    public typealias MOutput = OperationOutput<SearchTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchTablesOutputError>
}

public struct SearchTablesInput: Equatable {
    /// <p>A unique identifier, consisting of <code>
    ///                <i>account_id</i>
    ///             </code>.</p>
    public let catalogId: String?
    /// <p>A list of key-value pairs, and a comparator used to filter the search results. Returns all entities matching the predicate.</p>
    /// 	
    /// 	        <p>The <code>Comparator</code> member of the <code>PropertyPredicate</code> struct is used only for time fields, and can be omitted for other field types. Also, when comparing string values, such as when <code>Key=Name</code>, a fuzzy match algorithm is used. The <code>Key</code> field (for example, the value of the <code>Name</code> field) is split on certain punctuation characters, for example, -, :, #, etc. into tokens. Then each token is exact-match compared with the <code>Value</code> member of <code>PropertyPredicate</code>. For example, if <code>Key=Name</code> and <code>Value=link</code>, tables named <code>customer-link</code> and <code>xx-link-yy</code> are returned, but <code>xxlinkyy</code> is not returned.</p>
    public let filters: [PropertyPredicate]?
    /// <p>The maximum number of tables to return in a single response.</p>
    public let maxResults: Int?
    /// <p>A continuation token, included if this is a continuation call.</p>
    public let nextToken: String?
    /// <p>Allows you to specify that you want to search the tables shared with your account. The allowable values are <code>FOREIGN</code> or <code>ALL</code>. </p>
    /// 	
    /// 	        <ul>
    ///             <li>
    ///                <p>If set to <code>FOREIGN</code>, will search the tables shared with your account. </p>
    ///             </li>
    ///             <li>
    ///                <p>If set to <code>ALL</code>, will search the tables shared with your account, as well as the tables in yor local account. </p>
    ///             </li>
    ///          </ul>
    public let resourceShareType: ResourceShareType?
    /// <p>A string used for a text search.</p>
    /// 	        <p>Specifying a value in quotes filters based on an exact match to the value.</p>
    public let searchText: String?
    /// <p>A list of criteria for sorting the results by a field name, in an ascending or descending order.</p>
    public let sortCriteria: [SortCriterion]?

    public init (
        catalogId: String? = nil,
        filters: [PropertyPredicate]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceShareType: ResourceShareType? = nil,
        searchText: String? = nil,
        sortCriteria: [SortCriterion]? = nil
    )
    {
        self.catalogId = catalogId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareType = resourceShareType
        self.searchText = searchText
        self.sortCriteria = sortCriteria
    }
}

struct SearchTablesInputBody: Equatable {
    public let catalogId: String?
    public let nextToken: String?
    public let filters: [PropertyPredicate]?
    public let searchText: String?
    public let sortCriteria: [SortCriterion]?
    public let maxResults: Int?
    public let resourceShareType: ResourceShareType?
}

extension SearchTablesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceShareType = "ResourceShareType"
        case searchText = "SearchText"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([PropertyPredicate?].self, forKey: .filters)
        var filtersDecoded0:[PropertyPredicate]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PropertyPredicate]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let searchTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .searchText)
        searchText = searchTextDecoded
        let sortCriteriaContainer = try containerValues.decodeIfPresent([SortCriterion?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[SortCriterion]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [SortCriterion]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceShareTypeDecoded = try containerValues.decodeIfPresent(ResourceShareType.self, forKey: .resourceShareType)
        resourceShareType = resourceShareTypeDecoded
    }
}

extension SearchTablesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchTablesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchTablesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchTablesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchTablesOutputResponse(nextToken: \(String(describing: nextToken)), tableList: \(String(describing: tableList)))"}
}

extension SearchTablesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchTablesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tableList = output.tableList
        } else {
            self.nextToken = nil
            self.tableList = nil
        }
    }
}

public struct SearchTablesOutputResponse: Equatable {
    /// <p>A continuation token, present if the current list segment is not the last.</p>
    public let nextToken: String?
    /// <p>A list of the requested <code>Table</code> objects. The <code>SearchTables</code> response returns only the tables that you have access to.</p>
    public let tableList: [Table]?

    public init (
        nextToken: String? = nil,
        tableList: [Table]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableList = tableList
    }
}

struct SearchTablesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let tableList: [Table]?
}

extension SearchTablesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tableList = "TableList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tableListContainer = try containerValues.decodeIfPresent([Table?].self, forKey: .tableList)
        var tableListDecoded0:[Table]? = nil
        if let tableListContainer = tableListContainer {
            tableListDecoded0 = [Table]()
            for structure0 in tableListContainer {
                if let structure0 = structure0 {
                    tableListDecoded0?.append(structure0)
                }
            }
        }
        tableList = tableListDecoded0
    }
}

extension SecurityConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTimeStamp = "CreatedTimeStamp"
        case encryptionConfiguration = "EncryptionConfiguration"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimeStamp = createdTimeStamp {
            try encodeContainer.encode(createdTimeStamp.timeIntervalSince1970, forKey: .createdTimeStamp)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdTimeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension SecurityConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityConfiguration(createdTimeStamp: \(String(describing: createdTimeStamp)), encryptionConfiguration: \(String(describing: encryptionConfiguration)), name: \(String(describing: name)))"}
}

/// <p>Specifies a security configuration.</p>
public struct SecurityConfiguration: Equatable {
    /// <p>The time at which this security configuration was created.</p>
    public let createdTimeStamp: Date?
    /// <p>The encryption configuration associated with this security configuration.</p>
    public let encryptionConfiguration: EncryptionConfiguration?
    /// <p>The name of the security configuration.</p>
    public let name: String?

    public init (
        createdTimeStamp: Date? = nil,
        encryptionConfiguration: EncryptionConfiguration? = nil,
        name: String? = nil
    )
    {
        self.createdTimeStamp = createdTimeStamp
        self.encryptionConfiguration = encryptionConfiguration
        self.name = name
    }
}

extension Segment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case segmentNumber = "SegmentNumber"
        case totalSegments = "TotalSegments"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if segmentNumber != 0 {
            try encodeContainer.encode(segmentNumber, forKey: .segmentNumber)
        }
        if totalSegments != 0 {
            try encodeContainer.encode(totalSegments, forKey: .totalSegments)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentNumberDecoded = try containerValues.decode(Int.self, forKey: .segmentNumber)
        segmentNumber = segmentNumberDecoded
        let totalSegmentsDecoded = try containerValues.decode(Int.self, forKey: .totalSegments)
        totalSegments = totalSegmentsDecoded
    }
}

extension Segment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Segment(segmentNumber: \(String(describing: segmentNumber)), totalSegments: \(String(describing: totalSegments)))"}
}

/// <p>Defines a non-overlapping region of a table's partitions, allowing
///       multiple requests to be executed in parallel.</p>
public struct Segment: Equatable {
    /// <p>The zero-based index number of the segment. For example, if the total number of segments
    ///       is 4, <code>SegmentNumber</code> values range from 0 through 3.</p>
    public let segmentNumber: Int
    /// <p>The total number of segments.</p>
    public let totalSegments: Int

    public init (
        segmentNumber: Int = 0,
        totalSegments: Int = 0
    )
    {
        self.segmentNumber = segmentNumber
        self.totalSegments = totalSegments
    }
}

extension SerDeInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parameters = "Parameters"
        case serializationLibrary = "SerializationLibrary"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let serializationLibrary = serializationLibrary {
            try encodeContainer.encode(serializationLibrary, forKey: .serializationLibrary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let serializationLibraryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serializationLibrary)
        serializationLibrary = serializationLibraryDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension SerDeInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SerDeInfo(name: \(String(describing: name)), parameters: \(String(describing: parameters)), serializationLibrary: \(String(describing: serializationLibrary)))"}
}

/// <p>Information about a serialization/deserialization program (SerDe) that serves as an
///       extractor and loader.</p>
public struct SerDeInfo: Equatable {
    /// <p>Name of the SerDe.</p>
    public let name: String?
    /// <p>These key-value pairs define initialization parameters for the SerDe.</p>
    public let parameters: [String:String]?
    /// <p>Usually the class that implements the SerDe. An example is
    ///         <code>org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe</code>.</p>
    public let serializationLibrary: String?

    public init (
        name: String? = nil,
        parameters: [String:String]? = nil,
        serializationLibrary: String? = nil
    )
    {
        self.name = name
        self.parameters = parameters
        self.serializationLibrary = serializationLibrary
    }
}

extension SkewedInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case skewedColumnNames = "SkewedColumnNames"
        case skewedColumnValueLocationMaps = "SkewedColumnValueLocationMaps"
        case skewedColumnValues = "SkewedColumnValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skewedColumnNames = skewedColumnNames {
            var skewedColumnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .skewedColumnNames)
            for namestringlist0 in skewedColumnNames {
                try skewedColumnNamesContainer.encode(namestringlist0)
            }
        }
        if let skewedColumnValueLocationMaps = skewedColumnValueLocationMaps {
            var skewedColumnValueLocationMapsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .skewedColumnValueLocationMaps)
            for (dictKey0, locationmap0) in skewedColumnValueLocationMaps {
                try skewedColumnValueLocationMapsContainer.encode(locationmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let skewedColumnValues = skewedColumnValues {
            var skewedColumnValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .skewedColumnValues)
            for columnvaluestringlist0 in skewedColumnValues {
                try skewedColumnValuesContainer.encode(columnvaluestringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skewedColumnNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .skewedColumnNames)
        var skewedColumnNamesDecoded0:[String]? = nil
        if let skewedColumnNamesContainer = skewedColumnNamesContainer {
            skewedColumnNamesDecoded0 = [String]()
            for string0 in skewedColumnNamesContainer {
                if let string0 = string0 {
                    skewedColumnNamesDecoded0?.append(string0)
                }
            }
        }
        skewedColumnNames = skewedColumnNamesDecoded0
        let skewedColumnValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .skewedColumnValues)
        var skewedColumnValuesDecoded0:[String]? = nil
        if let skewedColumnValuesContainer = skewedColumnValuesContainer {
            skewedColumnValuesDecoded0 = [String]()
            for string0 in skewedColumnValuesContainer {
                if let string0 = string0 {
                    skewedColumnValuesDecoded0?.append(string0)
                }
            }
        }
        skewedColumnValues = skewedColumnValuesDecoded0
        let skewedColumnValueLocationMapsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .skewedColumnValueLocationMaps)
        var skewedColumnValueLocationMapsDecoded0: [String:String]? = nil
        if let skewedColumnValueLocationMapsContainer = skewedColumnValueLocationMapsContainer {
            skewedColumnValueLocationMapsDecoded0 = [String:String]()
            for (key0, columnvaluesstring0) in skewedColumnValueLocationMapsContainer {
                if let columnvaluesstring0 = columnvaluesstring0 {
                    skewedColumnValueLocationMapsDecoded0?[key0] = columnvaluesstring0
                }
            }
        }
        skewedColumnValueLocationMaps = skewedColumnValueLocationMapsDecoded0
    }
}

extension SkewedInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SkewedInfo(skewedColumnNames: \(String(describing: skewedColumnNames)), skewedColumnValueLocationMaps: \(String(describing: skewedColumnValueLocationMaps)), skewedColumnValues: \(String(describing: skewedColumnValues)))"}
}

/// <p>Specifies skewed values in a table. Skewed values are those that occur with very high
///       frequency.</p>
public struct SkewedInfo: Equatable {
    /// <p>A list of names of columns that contain skewed values.</p>
    public let skewedColumnNames: [String]?
    /// <p>A mapping of skewed values to the columns that contain them.</p>
    public let skewedColumnValueLocationMaps: [String:String]?
    /// <p>A list of values that appear so frequently as to be considered
    ///       skewed.</p>
    public let skewedColumnValues: [String]?

    public init (
        skewedColumnNames: [String]? = nil,
        skewedColumnValueLocationMaps: [String:String]? = nil,
        skewedColumnValues: [String]? = nil
    )
    {
        self.skewedColumnNames = skewedColumnNames
        self.skewedColumnValueLocationMaps = skewedColumnValueLocationMaps
        self.skewedColumnValues = skewedColumnValues
    }
}

public enum Sort {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension Sort : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Sort] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASC"
        case .descending: return "DESC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Sort(rawValue: rawValue) ?? Sort.sdkUnknown(rawValue)
    }
}

extension SortCriterion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldName = "FieldName"
        case sort = "Sort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldName = fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let sort = sort {
            try encodeContainer.encode(sort.rawValue, forKey: .sort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let sortDecoded = try containerValues.decodeIfPresent(Sort.self, forKey: .sort)
        sort = sortDecoded
    }
}

extension SortCriterion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SortCriterion(fieldName: \(String(describing: fieldName)), sort: \(String(describing: sort)))"}
}

/// <p>Specifies a field to sort by and a sort order.</p>
public struct SortCriterion: Equatable {
    /// <p>The name of the field on which to sort.</p>
    public let fieldName: String?
    /// <p>An ascending or descending sort.</p>
    public let sort: Sort?

    public init (
        fieldName: String? = nil,
        sort: Sort? = nil
    )
    {
        self.fieldName = fieldName
        self.sort = sort
    }
}

public enum SortDirectionType {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortDirectionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortDirectionType] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortDirectionType(rawValue: rawValue) ?? SortDirectionType.sdkUnknown(rawValue)
    }
}

public struct StartCrawlerInputBodyMiddleware: Middleware {
    public let id: String = "StartCrawlerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCrawlerInput>
    public typealias MOutput = OperationOutput<StartCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCrawlerOutputError>
}

extension StartCrawlerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCrawlerInput(name: \(String(describing: name)))"}
}

extension StartCrawlerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StartCrawlerInputHeadersMiddleware: Middleware {
    public let id: String = "StartCrawlerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCrawlerInput>
    public typealias MOutput = OperationOutput<StartCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCrawlerOutputError>
}

public struct StartCrawlerInputQueryItemMiddleware: Middleware {
    public let id: String = "StartCrawlerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCrawlerInput>
    public typealias MOutput = OperationOutput<StartCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCrawlerOutputError>
}

public struct StartCrawlerInput: Equatable {
    /// <p>Name of the crawler to start.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StartCrawlerInputBody: Equatable {
    public let name: String?
}

extension StartCrawlerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartCrawlerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCrawlerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CrawlerRunningException" : self = .crawlerRunningException(try CrawlerRunningException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartCrawlerOutputError: Equatable {
    case crawlerRunningException(CrawlerRunningException)
    case entityNotFoundException(EntityNotFoundException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCrawlerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCrawlerOutputResponse()"}
}

extension StartCrawlerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartCrawlerOutputResponse: Equatable {

    public init() {}
}

struct StartCrawlerOutputResponseBody: Equatable {
}

extension StartCrawlerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartCrawlerScheduleInputBodyMiddleware: Middleware {
    public let id: String = "StartCrawlerScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCrawlerScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCrawlerScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCrawlerScheduleInput>
    public typealias MOutput = OperationOutput<StartCrawlerScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCrawlerScheduleOutputError>
}

extension StartCrawlerScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCrawlerScheduleInput(crawlerName: \(String(describing: crawlerName)))"}
}

extension StartCrawlerScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlerName = "CrawlerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawlerName = crawlerName {
            try encodeContainer.encode(crawlerName, forKey: .crawlerName)
        }
    }
}

public struct StartCrawlerScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "StartCrawlerScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCrawlerScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCrawlerScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCrawlerScheduleInput>
    public typealias MOutput = OperationOutput<StartCrawlerScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCrawlerScheduleOutputError>
}

public struct StartCrawlerScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "StartCrawlerScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCrawlerScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCrawlerScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCrawlerScheduleInput>
    public typealias MOutput = OperationOutput<StartCrawlerScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCrawlerScheduleOutputError>
}

public struct StartCrawlerScheduleInput: Equatable {
    /// <p>Name of the crawler to schedule.</p>
    public let crawlerName: String?

    public init (
        crawlerName: String? = nil
    )
    {
        self.crawlerName = crawlerName
    }
}

struct StartCrawlerScheduleInputBody: Equatable {
    public let crawlerName: String?
}

extension StartCrawlerScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case crawlerName = "CrawlerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .crawlerName)
        crawlerName = crawlerNameDecoded
    }
}

extension StartCrawlerScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCrawlerScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoScheduleException" : self = .noScheduleException(try NoScheduleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchedulerRunningException" : self = .schedulerRunningException(try SchedulerRunningException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchedulerTransitioningException" : self = .schedulerTransitioningException(try SchedulerTransitioningException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartCrawlerScheduleOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case noScheduleException(NoScheduleException)
    case operationTimeoutException(OperationTimeoutException)
    case schedulerRunningException(SchedulerRunningException)
    case schedulerTransitioningException(SchedulerTransitioningException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCrawlerScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCrawlerScheduleOutputResponse()"}
}

extension StartCrawlerScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartCrawlerScheduleOutputResponse: Equatable {

    public init() {}
}

struct StartCrawlerScheduleOutputResponseBody: Equatable {
}

extension StartCrawlerScheduleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartExportLabelsTaskRunInputBodyMiddleware: Middleware {
    public let id: String = "StartExportLabelsTaskRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExportLabelsTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExportLabelsTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExportLabelsTaskRunInput>
    public typealias MOutput = OperationOutput<StartExportLabelsTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExportLabelsTaskRunOutputError>
}

extension StartExportLabelsTaskRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartExportLabelsTaskRunInput(outputS3Path: \(String(describing: outputS3Path)), transformId: \(String(describing: transformId)))"}
}

extension StartExportLabelsTaskRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputS3Path = "OutputS3Path"
        case transformId = "TransformId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3Path = outputS3Path {
            try encodeContainer.encode(outputS3Path, forKey: .outputS3Path)
        }
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
    }
}

public struct StartExportLabelsTaskRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartExportLabelsTaskRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExportLabelsTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExportLabelsTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExportLabelsTaskRunInput>
    public typealias MOutput = OperationOutput<StartExportLabelsTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExportLabelsTaskRunOutputError>
}

public struct StartExportLabelsTaskRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartExportLabelsTaskRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExportLabelsTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExportLabelsTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExportLabelsTaskRunInput>
    public typealias MOutput = OperationOutput<StartExportLabelsTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExportLabelsTaskRunOutputError>
}

public struct StartExportLabelsTaskRunInput: Equatable {
    /// <p>The Amazon S3 path where you export the labels.</p>
    public let outputS3Path: String?
    /// <p>The unique identifier of the machine learning transform.</p>
    public let transformId: String?

    public init (
        outputS3Path: String? = nil,
        transformId: String? = nil
    )
    {
        self.outputS3Path = outputS3Path
        self.transformId = transformId
    }
}

struct StartExportLabelsTaskRunInputBody: Equatable {
    public let transformId: String?
    public let outputS3Path: String?
}

extension StartExportLabelsTaskRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case outputS3Path = "OutputS3Path"
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let outputS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Path)
        outputS3Path = outputS3PathDecoded
    }
}

extension StartExportLabelsTaskRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartExportLabelsTaskRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartExportLabelsTaskRunOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExportLabelsTaskRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartExportLabelsTaskRunOutputResponse(taskRunId: \(String(describing: taskRunId)))"}
}

extension StartExportLabelsTaskRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartExportLabelsTaskRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.taskRunId = output.taskRunId
        } else {
            self.taskRunId = nil
        }
    }
}

public struct StartExportLabelsTaskRunOutputResponse: Equatable {
    /// <p>The unique identifier for the task run.</p>
    public let taskRunId: String?

    public init (
        taskRunId: String? = nil
    )
    {
        self.taskRunId = taskRunId
    }
}

struct StartExportLabelsTaskRunOutputResponseBody: Equatable {
    public let taskRunId: String?
}

extension StartExportLabelsTaskRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskRunId = "TaskRunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRunId)
        taskRunId = taskRunIdDecoded
    }
}

public struct StartImportLabelsTaskRunInputBodyMiddleware: Middleware {
    public let id: String = "StartImportLabelsTaskRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImportLabelsTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImportLabelsTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImportLabelsTaskRunInput>
    public typealias MOutput = OperationOutput<StartImportLabelsTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImportLabelsTaskRunOutputError>
}

extension StartImportLabelsTaskRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImportLabelsTaskRunInput(inputS3Path: \(String(describing: inputS3Path)), replaceAllLabels: \(String(describing: replaceAllLabels)), transformId: \(String(describing: transformId)))"}
}

extension StartImportLabelsTaskRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputS3Path = "InputS3Path"
        case replaceAllLabels = "ReplaceAllLabels"
        case transformId = "TransformId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputS3Path = inputS3Path {
            try encodeContainer.encode(inputS3Path, forKey: .inputS3Path)
        }
        if replaceAllLabels != false {
            try encodeContainer.encode(replaceAllLabels, forKey: .replaceAllLabels)
        }
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
    }
}

public struct StartImportLabelsTaskRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartImportLabelsTaskRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImportLabelsTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImportLabelsTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImportLabelsTaskRunInput>
    public typealias MOutput = OperationOutput<StartImportLabelsTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImportLabelsTaskRunOutputError>
}

public struct StartImportLabelsTaskRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartImportLabelsTaskRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImportLabelsTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImportLabelsTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImportLabelsTaskRunInput>
    public typealias MOutput = OperationOutput<StartImportLabelsTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImportLabelsTaskRunOutputError>
}

public struct StartImportLabelsTaskRunInput: Equatable {
    /// <p>The Amazon Simple Storage Service (Amazon S3) path from where you import the
    ///       labels.</p>
    public let inputS3Path: String?
    /// <p>Indicates whether to overwrite your existing labels.</p>
    public let replaceAllLabels: Bool
    /// <p>The unique identifier of the machine learning transform.</p>
    public let transformId: String?

    public init (
        inputS3Path: String? = nil,
        replaceAllLabels: Bool = false,
        transformId: String? = nil
    )
    {
        self.inputS3Path = inputS3Path
        self.replaceAllLabels = replaceAllLabels
        self.transformId = transformId
    }
}

struct StartImportLabelsTaskRunInputBody: Equatable {
    public let transformId: String?
    public let inputS3Path: String?
    public let replaceAllLabels: Bool
}

extension StartImportLabelsTaskRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputS3Path = "InputS3Path"
        case replaceAllLabels = "ReplaceAllLabels"
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let inputS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputS3Path)
        inputS3Path = inputS3PathDecoded
        let replaceAllLabelsDecoded = try containerValues.decode(Bool.self, forKey: .replaceAllLabels)
        replaceAllLabels = replaceAllLabelsDecoded
    }
}

extension StartImportLabelsTaskRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImportLabelsTaskRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartImportLabelsTaskRunOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImportLabelsTaskRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImportLabelsTaskRunOutputResponse(taskRunId: \(String(describing: taskRunId)))"}
}

extension StartImportLabelsTaskRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartImportLabelsTaskRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.taskRunId = output.taskRunId
        } else {
            self.taskRunId = nil
        }
    }
}

public struct StartImportLabelsTaskRunOutputResponse: Equatable {
    /// <p>The unique identifier for the task run.</p>
    public let taskRunId: String?

    public init (
        taskRunId: String? = nil
    )
    {
        self.taskRunId = taskRunId
    }
}

struct StartImportLabelsTaskRunOutputResponseBody: Equatable {
    public let taskRunId: String?
}

extension StartImportLabelsTaskRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskRunId = "TaskRunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRunId)
        taskRunId = taskRunIdDecoded
    }
}

public struct StartJobRunInputBodyMiddleware: Middleware {
    public let id: String = "StartJobRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobRunInput>
    public typealias MOutput = OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobRunOutputError>
}

extension StartJobRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartJobRunInput(allocatedCapacity: \(String(describing: allocatedCapacity)), arguments: \(String(describing: arguments)), jobName: \(String(describing: jobName)), jobRunId: \(String(describing: jobRunId)), maxCapacity: \(String(describing: maxCapacity)), notificationProperty: \(String(describing: notificationProperty)), numberOfWorkers: \(String(describing: numberOfWorkers)), securityConfiguration: \(String(describing: securityConfiguration)), timeout: \(String(describing: timeout)), workerType: \(String(describing: workerType)))"}
}

extension StartJobRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedCapacity = "AllocatedCapacity"
        case arguments = "Arguments"
        case jobName = "JobName"
        case jobRunId = "JobRunId"
        case maxCapacity = "MaxCapacity"
        case notificationProperty = "NotificationProperty"
        case numberOfWorkers = "NumberOfWorkers"
        case securityConfiguration = "SecurityConfiguration"
        case timeout = "Timeout"
        case workerType = "WorkerType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedCapacity != 0 {
            try encodeContainer.encode(allocatedCapacity, forKey: .allocatedCapacity)
        }
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .arguments)
            for (dictKey0, genericmap0) in arguments {
                try argumentsContainer.encode(genericmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobRunId = jobRunId {
            try encodeContainer.encode(jobRunId, forKey: .jobRunId)
        }
        if let maxCapacity = maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let notificationProperty = notificationProperty {
            try encodeContainer.encode(notificationProperty, forKey: .notificationProperty)
        }
        if let numberOfWorkers = numberOfWorkers {
            try encodeContainer.encode(numberOfWorkers, forKey: .numberOfWorkers)
        }
        if let securityConfiguration = securityConfiguration {
            try encodeContainer.encode(securityConfiguration, forKey: .securityConfiguration)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let workerType = workerType {
            try encodeContainer.encode(workerType.rawValue, forKey: .workerType)
        }
    }
}

public struct StartJobRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobRunInput>
    public typealias MOutput = OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobRunOutputError>
}

public struct StartJobRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobRunInput>
    public typealias MOutput = OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobRunOutputError>
}

public struct StartJobRunInput: Equatable {
    /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
    ///
    ///          <p>The number of AWS Glue data processing units (DPUs) to allocate to this JobRun.
    ///       From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure
    ///       of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
    ///       For more information, see the <a href="https://docs.aws.amazon.com/https:/aws.amazon.com/glue/pricing/">AWS Glue
    ///         pricing page</a>.</p>
    @available(*, deprecated, message: "This property is deprecated, use MaxCapacity instead.")
    public let allocatedCapacity: Int
    /// <p>The job arguments specifically for this run. For this job run, they replace the default arguments set in the job definition itself.</p>
    ///          <p>You can specify arguments here that your own job-execution script
    ///       consumes, as well as arguments that AWS Glue itself consumes.</p>
    ///          <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling AWS Glue APIs in Python</a> topic in the developer guide.</p>
    ///          <p>For information about the key-value pairs that AWS Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by AWS Glue</a> topic in the developer guide.</p>
    public let arguments: [String:String]?
    /// <p>The name of the job definition to use.</p>
    public let jobName: String?
    /// <p>The ID of a previous <code>JobRun</code> to retry.</p>
    public let jobRunId: String?
    /// <p>The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure
    ///       of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
    ///       For more information, see the <a href="https://docs.aws.amazon.com/https:/aws.amazon.com/glue/pricing/">AWS Glue
    ///         pricing page</a>.</p>
    ///
    ///          <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
    ///
    ///          <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are
    ///       running a Python shell job, or an Apache Spark ETL job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can
    ///         allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p>
    ///             </li>
    ///             <li>
    ///                <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p>
    ///             </li>
    ///          </ul>
    public let maxCapacity: Double?
    /// <p>Specifies configuration properties of a job run notification.</p>
    public let notificationProperty: NotificationProperty?
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
    ///
    ///          <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
    public let numberOfWorkers: Int?
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job
    ///       run.</p>
    public let securityConfiguration: String?
    /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can
    ///       consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default
    ///       is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.</p>
    public let timeout: Int?
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    ///          <ul>
    ///             <li>
    ///                <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///          </ul>
    public let workerType: WorkerType?

    public init (
        allocatedCapacity: Int = 0,
        arguments: [String:String]? = nil,
        jobName: String? = nil,
        jobRunId: String? = nil,
        maxCapacity: Double? = nil,
        notificationProperty: NotificationProperty? = nil,
        numberOfWorkers: Int? = nil,
        securityConfiguration: String? = nil,
        timeout: Int? = nil,
        workerType: WorkerType? = nil
    )
    {
        self.allocatedCapacity = allocatedCapacity
        self.arguments = arguments
        self.jobName = jobName
        self.jobRunId = jobRunId
        self.maxCapacity = maxCapacity
        self.notificationProperty = notificationProperty
        self.numberOfWorkers = numberOfWorkers
        self.securityConfiguration = securityConfiguration
        self.timeout = timeout
        self.workerType = workerType
    }
}

struct StartJobRunInputBody: Equatable {
    public let jobName: String?
    public let jobRunId: String?
    public let arguments: [String:String]?
    public let allocatedCapacity: Int
    public let timeout: Int?
    public let maxCapacity: Double?
    public let securityConfiguration: String?
    public let notificationProperty: NotificationProperty?
    public let workerType: WorkerType?
    public let numberOfWorkers: Int?
}

extension StartJobRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allocatedCapacity = "AllocatedCapacity"
        case arguments = "Arguments"
        case jobName = "JobName"
        case jobRunId = "JobRunId"
        case maxCapacity = "MaxCapacity"
        case notificationProperty = "NotificationProperty"
        case numberOfWorkers = "NumberOfWorkers"
        case securityConfiguration = "SecurityConfiguration"
        case timeout = "Timeout"
        case workerType = "WorkerType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobRunId)
        jobRunId = jobRunIdDecoded
        let argumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .arguments)
        var argumentsDecoded0: [String:String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in argumentsContainer {
                if let genericstring0 = genericstring0 {
                    argumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        arguments = argumentsDecoded0
        let allocatedCapacityDecoded = try containerValues.decode(Int.self, forKey: .allocatedCapacity)
        allocatedCapacity = allocatedCapacityDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let securityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityConfiguration)
        securityConfiguration = securityConfigurationDecoded
        let notificationPropertyDecoded = try containerValues.decodeIfPresent(NotificationProperty.self, forKey: .notificationProperty)
        notificationProperty = notificationPropertyDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
    }
}

extension StartJobRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartJobRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentRunsExceededException" : self = .concurrentRunsExceededException(try ConcurrentRunsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartJobRunOutputError: Equatable {
    case concurrentRunsExceededException(ConcurrentRunsExceededException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartJobRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartJobRunOutputResponse(jobRunId: \(String(describing: jobRunId)))"}
}

extension StartJobRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartJobRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobRunId = output.jobRunId
        } else {
            self.jobRunId = nil
        }
    }
}

public struct StartJobRunOutputResponse: Equatable {
    /// <p>The ID assigned to this job run.</p>
    public let jobRunId: String?

    public init (
        jobRunId: String? = nil
    )
    {
        self.jobRunId = jobRunId
    }
}

struct StartJobRunOutputResponseBody: Equatable {
    public let jobRunId: String?
}

extension StartJobRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobRunId = "JobRunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobRunId)
        jobRunId = jobRunIdDecoded
    }
}

public struct StartMLEvaluationTaskRunInputBodyMiddleware: Middleware {
    public let id: String = "StartMLEvaluationTaskRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMLEvaluationTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMLEvaluationTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMLEvaluationTaskRunInput>
    public typealias MOutput = OperationOutput<StartMLEvaluationTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMLEvaluationTaskRunOutputError>
}

extension StartMLEvaluationTaskRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMLEvaluationTaskRunInput(transformId: \(String(describing: transformId)))"}
}

extension StartMLEvaluationTaskRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case transformId = "TransformId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
    }
}

public struct StartMLEvaluationTaskRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartMLEvaluationTaskRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMLEvaluationTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMLEvaluationTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMLEvaluationTaskRunInput>
    public typealias MOutput = OperationOutput<StartMLEvaluationTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMLEvaluationTaskRunOutputError>
}

public struct StartMLEvaluationTaskRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartMLEvaluationTaskRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMLEvaluationTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMLEvaluationTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMLEvaluationTaskRunInput>
    public typealias MOutput = OperationOutput<StartMLEvaluationTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMLEvaluationTaskRunOutputError>
}

public struct StartMLEvaluationTaskRunInput: Equatable {
    /// <p>The unique identifier of the machine learning transform.</p>
    public let transformId: String?

    public init (
        transformId: String? = nil
    )
    {
        self.transformId = transformId
    }
}

struct StartMLEvaluationTaskRunInputBody: Equatable {
    public let transformId: String?
}

extension StartMLEvaluationTaskRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
    }
}

extension StartMLEvaluationTaskRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMLEvaluationTaskRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentRunsExceededException" : self = .concurrentRunsExceededException(try ConcurrentRunsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MLTransformNotReadyException" : self = .mLTransformNotReadyException(try MLTransformNotReadyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMLEvaluationTaskRunOutputError: Equatable {
    case concurrentRunsExceededException(ConcurrentRunsExceededException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case mLTransformNotReadyException(MLTransformNotReadyException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMLEvaluationTaskRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMLEvaluationTaskRunOutputResponse(taskRunId: \(String(describing: taskRunId)))"}
}

extension StartMLEvaluationTaskRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartMLEvaluationTaskRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.taskRunId = output.taskRunId
        } else {
            self.taskRunId = nil
        }
    }
}

public struct StartMLEvaluationTaskRunOutputResponse: Equatable {
    /// <p>The unique identifier associated with this run.</p>
    public let taskRunId: String?

    public init (
        taskRunId: String? = nil
    )
    {
        self.taskRunId = taskRunId
    }
}

struct StartMLEvaluationTaskRunOutputResponseBody: Equatable {
    public let taskRunId: String?
}

extension StartMLEvaluationTaskRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskRunId = "TaskRunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRunId)
        taskRunId = taskRunIdDecoded
    }
}

public struct StartMLLabelingSetGenerationTaskRunInputBodyMiddleware: Middleware {
    public let id: String = "StartMLLabelingSetGenerationTaskRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMLLabelingSetGenerationTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMLLabelingSetGenerationTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMLLabelingSetGenerationTaskRunInput>
    public typealias MOutput = OperationOutput<StartMLLabelingSetGenerationTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMLLabelingSetGenerationTaskRunOutputError>
}

extension StartMLLabelingSetGenerationTaskRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMLLabelingSetGenerationTaskRunInput(outputS3Path: \(String(describing: outputS3Path)), transformId: \(String(describing: transformId)))"}
}

extension StartMLLabelingSetGenerationTaskRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputS3Path = "OutputS3Path"
        case transformId = "TransformId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3Path = outputS3Path {
            try encodeContainer.encode(outputS3Path, forKey: .outputS3Path)
        }
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
    }
}

public struct StartMLLabelingSetGenerationTaskRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartMLLabelingSetGenerationTaskRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMLLabelingSetGenerationTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMLLabelingSetGenerationTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMLLabelingSetGenerationTaskRunInput>
    public typealias MOutput = OperationOutput<StartMLLabelingSetGenerationTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMLLabelingSetGenerationTaskRunOutputError>
}

public struct StartMLLabelingSetGenerationTaskRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartMLLabelingSetGenerationTaskRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMLLabelingSetGenerationTaskRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMLLabelingSetGenerationTaskRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMLLabelingSetGenerationTaskRunInput>
    public typealias MOutput = OperationOutput<StartMLLabelingSetGenerationTaskRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMLLabelingSetGenerationTaskRunOutputError>
}

public struct StartMLLabelingSetGenerationTaskRunInput: Equatable {
    /// <p>The Amazon Simple Storage Service (Amazon S3) path where you generate the labeling
    ///       set.</p>
    public let outputS3Path: String?
    /// <p>The unique identifier of the machine learning transform.</p>
    public let transformId: String?

    public init (
        outputS3Path: String? = nil,
        transformId: String? = nil
    )
    {
        self.outputS3Path = outputS3Path
        self.transformId = transformId
    }
}

struct StartMLLabelingSetGenerationTaskRunInputBody: Equatable {
    public let transformId: String?
    public let outputS3Path: String?
}

extension StartMLLabelingSetGenerationTaskRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case outputS3Path = "OutputS3Path"
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let outputS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Path)
        outputS3Path = outputS3PathDecoded
    }
}

extension StartMLLabelingSetGenerationTaskRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMLLabelingSetGenerationTaskRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentRunsExceededException" : self = .concurrentRunsExceededException(try ConcurrentRunsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMLLabelingSetGenerationTaskRunOutputError: Equatable {
    case concurrentRunsExceededException(ConcurrentRunsExceededException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMLLabelingSetGenerationTaskRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMLLabelingSetGenerationTaskRunOutputResponse(taskRunId: \(String(describing: taskRunId)))"}
}

extension StartMLLabelingSetGenerationTaskRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartMLLabelingSetGenerationTaskRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.taskRunId = output.taskRunId
        } else {
            self.taskRunId = nil
        }
    }
}

public struct StartMLLabelingSetGenerationTaskRunOutputResponse: Equatable {
    /// <p>The unique run identifier that is associated with this task run.</p>
    public let taskRunId: String?

    public init (
        taskRunId: String? = nil
    )
    {
        self.taskRunId = taskRunId
    }
}

struct StartMLLabelingSetGenerationTaskRunOutputResponseBody: Equatable {
    public let taskRunId: String?
}

extension StartMLLabelingSetGenerationTaskRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskRunId = "TaskRunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRunId)
        taskRunId = taskRunIdDecoded
    }
}

public struct StartTriggerInputBodyMiddleware: Middleware {
    public let id: String = "StartTriggerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTriggerInput>
    public typealias MOutput = OperationOutput<StartTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTriggerOutputError>
}

extension StartTriggerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTriggerInput(name: \(String(describing: name)))"}
}

extension StartTriggerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StartTriggerInputHeadersMiddleware: Middleware {
    public let id: String = "StartTriggerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTriggerInput>
    public typealias MOutput = OperationOutput<StartTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTriggerOutputError>
}

public struct StartTriggerInputQueryItemMiddleware: Middleware {
    public let id: String = "StartTriggerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTriggerInput>
    public typealias MOutput = OperationOutput<StartTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTriggerOutputError>
}

public struct StartTriggerInput: Equatable {
    /// <p>The name of the trigger to start.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StartTriggerInputBody: Equatable {
    public let name: String?
}

extension StartTriggerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartTriggerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartTriggerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentRunsExceededException" : self = .concurrentRunsExceededException(try ConcurrentRunsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartTriggerOutputError: Equatable {
    case concurrentRunsExceededException(ConcurrentRunsExceededException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartTriggerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTriggerOutputResponse(name: \(String(describing: name)))"}
}

extension StartTriggerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartTriggerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct StartTriggerOutputResponse: Equatable {
    /// <p>The name of the trigger that was started.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StartTriggerOutputResponseBody: Equatable {
    public let name: String?
}

extension StartTriggerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct StartWorkflowRunInputBodyMiddleware: Middleware {
    public let id: String = "StartWorkflowRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartWorkflowRunInput>
    public typealias MOutput = OperationOutput<StartWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartWorkflowRunOutputError>
}

extension StartWorkflowRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartWorkflowRunInput(name: \(String(describing: name)))"}
}

extension StartWorkflowRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StartWorkflowRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartWorkflowRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartWorkflowRunInput>
    public typealias MOutput = OperationOutput<StartWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartWorkflowRunOutputError>
}

public struct StartWorkflowRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartWorkflowRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartWorkflowRunInput>
    public typealias MOutput = OperationOutput<StartWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartWorkflowRunOutputError>
}

public struct StartWorkflowRunInput: Equatable {
    /// <p>The name of the workflow to start.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StartWorkflowRunInputBody: Equatable {
    public let name: String?
}

extension StartWorkflowRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartWorkflowRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartWorkflowRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentRunsExceededException" : self = .concurrentRunsExceededException(try ConcurrentRunsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartWorkflowRunOutputError: Equatable {
    case concurrentRunsExceededException(ConcurrentRunsExceededException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartWorkflowRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartWorkflowRunOutputResponse(runId: \(String(describing: runId)))"}
}

extension StartWorkflowRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartWorkflowRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.runId = output.runId
        } else {
            self.runId = nil
        }
    }
}

public struct StartWorkflowRunOutputResponse: Equatable {
    /// <p>An Id for the new run.</p>
    public let runId: String?

    public init (
        runId: String? = nil
    )
    {
        self.runId = runId
    }
}

struct StartWorkflowRunOutputResponseBody: Equatable {
    public let runId: String?
}

extension StartWorkflowRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case runId = "RunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
    }
}

public struct StopCrawlerInputBodyMiddleware: Middleware {
    public let id: String = "StopCrawlerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopCrawlerInput>
    public typealias MOutput = OperationOutput<StopCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopCrawlerOutputError>
}

extension StopCrawlerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopCrawlerInput(name: \(String(describing: name)))"}
}

extension StopCrawlerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StopCrawlerInputHeadersMiddleware: Middleware {
    public let id: String = "StopCrawlerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopCrawlerInput>
    public typealias MOutput = OperationOutput<StopCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopCrawlerOutputError>
}

public struct StopCrawlerInputQueryItemMiddleware: Middleware {
    public let id: String = "StopCrawlerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopCrawlerInput>
    public typealias MOutput = OperationOutput<StopCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopCrawlerOutputError>
}

public struct StopCrawlerInput: Equatable {
    /// <p>Name of the crawler to stop.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StopCrawlerInputBody: Equatable {
    public let name: String?
}

extension StopCrawlerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopCrawlerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopCrawlerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CrawlerNotRunningException" : self = .crawlerNotRunningException(try CrawlerNotRunningException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CrawlerStoppingException" : self = .crawlerStoppingException(try CrawlerStoppingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopCrawlerOutputError: Equatable {
    case crawlerNotRunningException(CrawlerNotRunningException)
    case crawlerStoppingException(CrawlerStoppingException)
    case entityNotFoundException(EntityNotFoundException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopCrawlerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopCrawlerOutputResponse()"}
}

extension StopCrawlerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopCrawlerOutputResponse: Equatable {

    public init() {}
}

struct StopCrawlerOutputResponseBody: Equatable {
}

extension StopCrawlerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StopCrawlerScheduleInputBodyMiddleware: Middleware {
    public let id: String = "StopCrawlerScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopCrawlerScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<StopCrawlerScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopCrawlerScheduleInput>
    public typealias MOutput = OperationOutput<StopCrawlerScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopCrawlerScheduleOutputError>
}

extension StopCrawlerScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopCrawlerScheduleInput(crawlerName: \(String(describing: crawlerName)))"}
}

extension StopCrawlerScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlerName = "CrawlerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawlerName = crawlerName {
            try encodeContainer.encode(crawlerName, forKey: .crawlerName)
        }
    }
}

public struct StopCrawlerScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "StopCrawlerScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopCrawlerScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<StopCrawlerScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopCrawlerScheduleInput>
    public typealias MOutput = OperationOutput<StopCrawlerScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopCrawlerScheduleOutputError>
}

public struct StopCrawlerScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "StopCrawlerScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopCrawlerScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<StopCrawlerScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopCrawlerScheduleInput>
    public typealias MOutput = OperationOutput<StopCrawlerScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopCrawlerScheduleOutputError>
}

public struct StopCrawlerScheduleInput: Equatable {
    /// <p>Name of the crawler whose schedule state to set.</p>
    public let crawlerName: String?

    public init (
        crawlerName: String? = nil
    )
    {
        self.crawlerName = crawlerName
    }
}

struct StopCrawlerScheduleInputBody: Equatable {
    public let crawlerName: String?
}

extension StopCrawlerScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case crawlerName = "CrawlerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .crawlerName)
        crawlerName = crawlerNameDecoded
    }
}

extension StopCrawlerScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopCrawlerScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchedulerNotRunningException" : self = .schedulerNotRunningException(try SchedulerNotRunningException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchedulerTransitioningException" : self = .schedulerTransitioningException(try SchedulerTransitioningException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopCrawlerScheduleOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case operationTimeoutException(OperationTimeoutException)
    case schedulerNotRunningException(SchedulerNotRunningException)
    case schedulerTransitioningException(SchedulerTransitioningException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopCrawlerScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopCrawlerScheduleOutputResponse()"}
}

extension StopCrawlerScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopCrawlerScheduleOutputResponse: Equatable {

    public init() {}
}

struct StopCrawlerScheduleOutputResponseBody: Equatable {
}

extension StopCrawlerScheduleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StopTriggerInputBodyMiddleware: Middleware {
    public let id: String = "StopTriggerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTriggerInput>
    public typealias MOutput = OperationOutput<StopTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTriggerOutputError>
}

extension StopTriggerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopTriggerInput(name: \(String(describing: name)))"}
}

extension StopTriggerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StopTriggerInputHeadersMiddleware: Middleware {
    public let id: String = "StopTriggerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTriggerInput>
    public typealias MOutput = OperationOutput<StopTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTriggerOutputError>
}

public struct StopTriggerInputQueryItemMiddleware: Middleware {
    public let id: String = "StopTriggerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopTriggerInput>
    public typealias MOutput = OperationOutput<StopTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopTriggerOutputError>
}

public struct StopTriggerInput: Equatable {
    /// <p>The name of the trigger to stop.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StopTriggerInputBody: Equatable {
    public let name: String?
}

extension StopTriggerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopTriggerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopTriggerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopTriggerOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopTriggerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopTriggerOutputResponse(name: \(String(describing: name)))"}
}

extension StopTriggerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopTriggerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct StopTriggerOutputResponse: Equatable {
    /// <p>The name of the trigger that was stopped.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StopTriggerOutputResponseBody: Equatable {
    public let name: String?
}

extension StopTriggerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct StopWorkflowRunInputBodyMiddleware: Middleware {
    public let id: String = "StopWorkflowRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopWorkflowRunInput>
    public typealias MOutput = OperationOutput<StopWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopWorkflowRunOutputError>
}

extension StopWorkflowRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopWorkflowRunInput(name: \(String(describing: name)), runId: \(String(describing: runId)))"}
}

extension StopWorkflowRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case runId = "RunId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runId = runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
    }
}

public struct StopWorkflowRunInputHeadersMiddleware: Middleware {
    public let id: String = "StopWorkflowRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopWorkflowRunInput>
    public typealias MOutput = OperationOutput<StopWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopWorkflowRunOutputError>
}

public struct StopWorkflowRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StopWorkflowRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopWorkflowRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopWorkflowRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopWorkflowRunInput>
    public typealias MOutput = OperationOutput<StopWorkflowRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopWorkflowRunOutputError>
}

public struct StopWorkflowRunInput: Equatable {
    /// <p>The name of the workflow to stop.</p>
    public let name: String?
    /// <p>The ID of the workflow run to stop.</p>
    public let runId: String?

    public init (
        name: String? = nil,
        runId: String? = nil
    )
    {
        self.name = name
        self.runId = runId
    }
}

struct StopWorkflowRunInputBody: Equatable {
    public let name: String?
    public let runId: String?
}

extension StopWorkflowRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case runId = "RunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
    }
}

extension StopWorkflowRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopWorkflowRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalWorkflowStateException" : self = .illegalWorkflowStateException(try IllegalWorkflowStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopWorkflowRunOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case illegalWorkflowStateException(IllegalWorkflowStateException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopWorkflowRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopWorkflowRunOutputResponse()"}
}

extension StopWorkflowRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopWorkflowRunOutputResponse: Equatable {

    public init() {}
}

struct StopWorkflowRunOutputResponseBody: Equatable {
}

extension StopWorkflowRunOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StorageDescriptor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketColumns = "BucketColumns"
        case columns = "Columns"
        case compressed = "Compressed"
        case inputFormat = "InputFormat"
        case location = "Location"
        case numberOfBuckets = "NumberOfBuckets"
        case outputFormat = "OutputFormat"
        case parameters = "Parameters"
        case schemaReference = "SchemaReference"
        case serdeInfo = "SerdeInfo"
        case skewedInfo = "SkewedInfo"
        case sortColumns = "SortColumns"
        case storedAsSubDirectories = "StoredAsSubDirectories"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketColumns = bucketColumns {
            var bucketColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bucketColumns)
            for namestringlist0 in bucketColumns {
                try bucketColumnsContainer.encode(namestringlist0)
            }
        }
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columnlist0 in columns {
                try columnsContainer.encode(columnlist0)
            }
        }
        if compressed != false {
            try encodeContainer.encode(compressed, forKey: .compressed)
        }
        if let inputFormat = inputFormat {
            try encodeContainer.encode(inputFormat, forKey: .inputFormat)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if numberOfBuckets != 0 {
            try encodeContainer.encode(numberOfBuckets, forKey: .numberOfBuckets)
        }
        if let outputFormat = outputFormat {
            try encodeContainer.encode(outputFormat, forKey: .outputFormat)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let schemaReference = schemaReference {
            try encodeContainer.encode(schemaReference, forKey: .schemaReference)
        }
        if let serdeInfo = serdeInfo {
            try encodeContainer.encode(serdeInfo, forKey: .serdeInfo)
        }
        if let skewedInfo = skewedInfo {
            try encodeContainer.encode(skewedInfo, forKey: .skewedInfo)
        }
        if let sortColumns = sortColumns {
            var sortColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortColumns)
            for orderlist0 in sortColumns {
                try sortColumnsContainer.encode(orderlist0)
            }
        }
        if storedAsSubDirectories != false {
            try encodeContainer.encode(storedAsSubDirectories, forKey: .storedAsSubDirectories)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnsContainer = try containerValues.decodeIfPresent([Column?].self, forKey: .columns)
        var columnsDecoded0:[Column]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [Column]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let inputFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputFormat)
        inputFormat = inputFormatDecoded
        let outputFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let compressedDecoded = try containerValues.decode(Bool.self, forKey: .compressed)
        compressed = compressedDecoded
        let numberOfBucketsDecoded = try containerValues.decode(Int.self, forKey: .numberOfBuckets)
        numberOfBuckets = numberOfBucketsDecoded
        let serdeInfoDecoded = try containerValues.decodeIfPresent(SerDeInfo.self, forKey: .serdeInfo)
        serdeInfo = serdeInfoDecoded
        let bucketColumnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .bucketColumns)
        var bucketColumnsDecoded0:[String]? = nil
        if let bucketColumnsContainer = bucketColumnsContainer {
            bucketColumnsDecoded0 = [String]()
            for string0 in bucketColumnsContainer {
                if let string0 = string0 {
                    bucketColumnsDecoded0?.append(string0)
                }
            }
        }
        bucketColumns = bucketColumnsDecoded0
        let sortColumnsContainer = try containerValues.decodeIfPresent([Order?].self, forKey: .sortColumns)
        var sortColumnsDecoded0:[Order]? = nil
        if let sortColumnsContainer = sortColumnsContainer {
            sortColumnsDecoded0 = [Order]()
            for structure0 in sortColumnsContainer {
                if let structure0 = structure0 {
                    sortColumnsDecoded0?.append(structure0)
                }
            }
        }
        sortColumns = sortColumnsDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let skewedInfoDecoded = try containerValues.decodeIfPresent(SkewedInfo.self, forKey: .skewedInfo)
        skewedInfo = skewedInfoDecoded
        let storedAsSubDirectoriesDecoded = try containerValues.decode(Bool.self, forKey: .storedAsSubDirectories)
        storedAsSubDirectories = storedAsSubDirectoriesDecoded
        let schemaReferenceDecoded = try containerValues.decodeIfPresent(SchemaReference.self, forKey: .schemaReference)
        schemaReference = schemaReferenceDecoded
    }
}

extension StorageDescriptor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageDescriptor(bucketColumns: \(String(describing: bucketColumns)), columns: \(String(describing: columns)), compressed: \(String(describing: compressed)), inputFormat: \(String(describing: inputFormat)), location: \(String(describing: location)), numberOfBuckets: \(String(describing: numberOfBuckets)), outputFormat: \(String(describing: outputFormat)), parameters: \(String(describing: parameters)), schemaReference: \(String(describing: schemaReference)), serdeInfo: \(String(describing: serdeInfo)), skewedInfo: \(String(describing: skewedInfo)), sortColumns: \(String(describing: sortColumns)), storedAsSubDirectories: \(String(describing: storedAsSubDirectories)))"}
}

/// <p>Describes the physical storage of table data.</p>
public struct StorageDescriptor: Equatable {
    /// <p>A list of reducer grouping columns, clustering columns, and
    ///       bucketing columns in the table.</p>
    public let bucketColumns: [String]?
    /// <p>A list of the <code>Columns</code> in the table.</p>
    public let columns: [Column]?
    /// <p>
    ///             <code>True</code> if the data in the table is compressed, or <code>False</code> if
    ///       not.</p>
    public let compressed: Bool
    /// <p>The input format: <code>SequenceFileInputFormat</code> (binary),
    ///       or <code>TextInputFormat</code>, or a custom format.</p>
    public let inputFormat: String?
    /// <p>The physical location of the table. By default, this takes the form of the warehouse
    ///       location, followed by the database location in the warehouse, followed by the table
    ///       name.</p>
    public let location: String?
    /// <p>Must be specified if the table contains any dimension columns.</p>
    public let numberOfBuckets: Int
    /// <p>The output format: <code>SequenceFileOutputFormat</code> (binary),
    ///       or <code>IgnoreKeyTextOutputFormat</code>, or a custom format.</p>
    public let outputFormat: String?
    /// <p>The user-supplied properties in key-value form.</p>
    public let parameters: [String:String]?
    /// <p>An object that references a schema stored in the AWS Glue Schema Registry.</p>
    /// 	
    /// 	        <p>When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference.</p>
    public let schemaReference: SchemaReference?
    /// <p>The serialization/deserialization (SerDe) information.</p>
    public let serdeInfo: SerDeInfo?
    /// <p>The information about values that appear frequently in a column (skewed values).</p>
    public let skewedInfo: SkewedInfo?
    /// <p>A list specifying the sort order of each bucket in the table.</p>
    public let sortColumns: [Order]?
    /// <p>
    ///             <code>True</code> if the table data is stored in subdirectories, or <code>False</code> if
    ///       not.</p>
    public let storedAsSubDirectories: Bool

    public init (
        bucketColumns: [String]? = nil,
        columns: [Column]? = nil,
        compressed: Bool = false,
        inputFormat: String? = nil,
        location: String? = nil,
        numberOfBuckets: Int = 0,
        outputFormat: String? = nil,
        parameters: [String:String]? = nil,
        schemaReference: SchemaReference? = nil,
        serdeInfo: SerDeInfo? = nil,
        skewedInfo: SkewedInfo? = nil,
        sortColumns: [Order]? = nil,
        storedAsSubDirectories: Bool = false
    )
    {
        self.bucketColumns = bucketColumns
        self.columns = columns
        self.compressed = compressed
        self.inputFormat = inputFormat
        self.location = location
        self.numberOfBuckets = numberOfBuckets
        self.outputFormat = outputFormat
        self.parameters = parameters
        self.schemaReference = schemaReference
        self.serdeInfo = serdeInfo
        self.skewedInfo = skewedInfo
        self.sortColumns = sortColumns
        self.storedAsSubDirectories = storedAsSubDirectories
    }
}

extension StringColumnStatisticsData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case averageLength = "AverageLength"
        case maximumLength = "MaximumLength"
        case numberOfDistinctValues = "NumberOfDistinctValues"
        case numberOfNulls = "NumberOfNulls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if averageLength != 0.0 {
            try encodeContainer.encode(averageLength, forKey: .averageLength)
        }
        if maximumLength != 0 {
            try encodeContainer.encode(maximumLength, forKey: .maximumLength)
        }
        if numberOfDistinctValues != 0 {
            try encodeContainer.encode(numberOfDistinctValues, forKey: .numberOfDistinctValues)
        }
        if numberOfNulls != 0 {
            try encodeContainer.encode(numberOfNulls, forKey: .numberOfNulls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumLengthDecoded = try containerValues.decode(Int.self, forKey: .maximumLength)
        maximumLength = maximumLengthDecoded
        let averageLengthDecoded = try containerValues.decode(Double.self, forKey: .averageLength)
        averageLength = averageLengthDecoded
        let numberOfNullsDecoded = try containerValues.decode(Int.self, forKey: .numberOfNulls)
        numberOfNulls = numberOfNullsDecoded
        let numberOfDistinctValuesDecoded = try containerValues.decode(Int.self, forKey: .numberOfDistinctValues)
        numberOfDistinctValues = numberOfDistinctValuesDecoded
    }
}

extension StringColumnStatisticsData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StringColumnStatisticsData(averageLength: \(String(describing: averageLength)), maximumLength: \(String(describing: maximumLength)), numberOfDistinctValues: \(String(describing: numberOfDistinctValues)), numberOfNulls: \(String(describing: numberOfNulls)))"}
}

/// <p>Defines column statistics supported for character sequence data values.</p>
public struct StringColumnStatisticsData: Equatable {
    /// <p>The average string length in the column.</p>
    public let averageLength: Double
    /// <p>The size of the longest string in the column.</p>
    public let maximumLength: Int
    /// <p>The number of distinct values in a column.</p>
    public let numberOfDistinctValues: Int
    /// <p>The number of null values in the column.</p>
    public let numberOfNulls: Int

    public init (
        averageLength: Double = 0.0,
        maximumLength: Int = 0,
        numberOfDistinctValues: Int = 0,
        numberOfNulls: Int = 0
    )
    {
        self.averageLength = averageLength
        self.maximumLength = maximumLength
        self.numberOfDistinctValues = numberOfDistinctValues
        self.numberOfNulls = numberOfNulls
    }
}

extension Table: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case createTime = "CreateTime"
        case createdBy = "CreatedBy"
        case databaseName = "DatabaseName"
        case description = "Description"
        case isRegisteredWithLakeFormation = "IsRegisteredWithLakeFormation"
        case lastAccessTime = "LastAccessTime"
        case lastAnalyzedTime = "LastAnalyzedTime"
        case name = "Name"
        case owner = "Owner"
        case parameters = "Parameters"
        case partitionKeys = "PartitionKeys"
        case retention = "Retention"
        case storageDescriptor = "StorageDescriptor"
        case tableType = "TableType"
        case targetTable = "TargetTable"
        case updateTime = "UpdateTime"
        case viewExpandedText = "ViewExpandedText"
        case viewOriginalText = "ViewOriginalText"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isRegisteredWithLakeFormation != false {
            try encodeContainer.encode(isRegisteredWithLakeFormation, forKey: .isRegisteredWithLakeFormation)
        }
        if let lastAccessTime = lastAccessTime {
            try encodeContainer.encode(lastAccessTime.timeIntervalSince1970, forKey: .lastAccessTime)
        }
        if let lastAnalyzedTime = lastAnalyzedTime {
            try encodeContainer.encode(lastAnalyzedTime.timeIntervalSince1970, forKey: .lastAnalyzedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let partitionKeys = partitionKeys {
            var partitionKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionKeys)
            for columnlist0 in partitionKeys {
                try partitionKeysContainer.encode(columnlist0)
            }
        }
        if retention != 0 {
            try encodeContainer.encode(retention, forKey: .retention)
        }
        if let storageDescriptor = storageDescriptor {
            try encodeContainer.encode(storageDescriptor, forKey: .storageDescriptor)
        }
        if let tableType = tableType {
            try encodeContainer.encode(tableType, forKey: .tableType)
        }
        if let targetTable = targetTable {
            try encodeContainer.encode(targetTable, forKey: .targetTable)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
        if let viewExpandedText = viewExpandedText {
            try encodeContainer.encode(viewExpandedText, forKey: .viewExpandedText)
        }
        if let viewOriginalText = viewOriginalText {
            try encodeContainer.encode(viewOriginalText, forKey: .viewOriginalText)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let lastAccessTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAccessTime)
        lastAccessTime = lastAccessTimeDecoded
        let lastAnalyzedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAnalyzedTime)
        lastAnalyzedTime = lastAnalyzedTimeDecoded
        let retentionDecoded = try containerValues.decode(Int.self, forKey: .retention)
        retention = retentionDecoded
        let storageDescriptorDecoded = try containerValues.decodeIfPresent(StorageDescriptor.self, forKey: .storageDescriptor)
        storageDescriptor = storageDescriptorDecoded
        let partitionKeysContainer = try containerValues.decodeIfPresent([Column?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[Column]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [Column]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let viewOriginalTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .viewOriginalText)
        viewOriginalText = viewOriginalTextDecoded
        let viewExpandedTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .viewExpandedText)
        viewExpandedText = viewExpandedTextDecoded
        let tableTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableType)
        tableType = tableTypeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let isRegisteredWithLakeFormationDecoded = try containerValues.decode(Bool.self, forKey: .isRegisteredWithLakeFormation)
        isRegisteredWithLakeFormation = isRegisteredWithLakeFormationDecoded
        let targetTableDecoded = try containerValues.decodeIfPresent(TableIdentifier.self, forKey: .targetTable)
        targetTable = targetTableDecoded
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension Table: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Table(catalogId: \(String(describing: catalogId)), createTime: \(String(describing: createTime)), createdBy: \(String(describing: createdBy)), databaseName: \(String(describing: databaseName)), description: \(String(describing: description)), isRegisteredWithLakeFormation: \(String(describing: isRegisteredWithLakeFormation)), lastAccessTime: \(String(describing: lastAccessTime)), lastAnalyzedTime: \(String(describing: lastAnalyzedTime)), name: \(String(describing: name)), owner: \(String(describing: owner)), parameters: \(String(describing: parameters)), partitionKeys: \(String(describing: partitionKeys)), retention: \(String(describing: retention)), storageDescriptor: \(String(describing: storageDescriptor)), tableType: \(String(describing: tableType)), targetTable: \(String(describing: targetTable)), updateTime: \(String(describing: updateTime)), viewExpandedText: \(String(describing: viewExpandedText)), viewOriginalText: \(String(describing: viewOriginalText)))"}
}

/// <p>Represents a collection of related data organized in columns and rows.</p>
public struct Table: Equatable {
    /// <p>The ID of the Data Catalog in which the table resides.</p>
    public let catalogId: String?
    /// <p>The time when the table definition was created in the Data Catalog.</p>
    public let createTime: Date?
    /// <p>The person or entity who created the table.</p>
    public let createdBy: String?
    /// <p>The name of the database where the table metadata resides.
    ///       For Hive compatibility, this must be all lowercase.</p>
    public let databaseName: String?
    /// <p>A description of the table.</p>
    public let description: String?
    /// <p>Indicates whether the table has been registered with AWS Lake Formation.</p>
    public let isRegisteredWithLakeFormation: Bool
    /// <p>The last time that the table was accessed. This is usually taken from HDFS, and might not
    ///       be reliable.</p>
    public let lastAccessTime: Date?
    /// <p>The last time that column statistics were computed for this table.</p>
    public let lastAnalyzedTime: Date?
    /// <p>The table name. For Hive compatibility, this must be entirely
    ///       lowercase.</p>
    public let name: String?
    /// <p>The owner of the table.</p>
    public let owner: String?
    /// <p>These key-value pairs define properties associated with the table.</p>
    public let parameters: [String:String]?
    /// <p>A list of columns by which the table is partitioned. Only primitive
    ///       types are supported as partition keys.</p>
    /// 	        <p>When you create a table used by Amazon Athena, and you do not specify any
    ///         <code>partitionKeys</code>, you must at least set the value of <code>partitionKeys</code> to
    ///       an empty list. For example:</p>
    ///          <p>
    ///             <code>"PartitionKeys": []</code>
    ///          </p>
    public let partitionKeys: [Column]?
    /// <p>The retention time for this table.</p>
    public let retention: Int
    /// <p>A storage descriptor containing information about the physical storage
    ///       of this table.</p>
    public let storageDescriptor: StorageDescriptor?
    /// <p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>
    public let tableType: String?
    /// <p>A <code>TableIdentifier</code> structure that describes a target table for resource linking.</p>
    public let targetTable: TableIdentifier?
    /// <p>The last time that the table was updated.</p>
    public let updateTime: Date?
    /// <p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>
    public let viewExpandedText: String?
    /// <p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>
    public let viewOriginalText: String?

    public init (
        catalogId: String? = nil,
        createTime: Date? = nil,
        createdBy: String? = nil,
        databaseName: String? = nil,
        description: String? = nil,
        isRegisteredWithLakeFormation: Bool = false,
        lastAccessTime: Date? = nil,
        lastAnalyzedTime: Date? = nil,
        name: String? = nil,
        owner: String? = nil,
        parameters: [String:String]? = nil,
        partitionKeys: [Column]? = nil,
        retention: Int = 0,
        storageDescriptor: StorageDescriptor? = nil,
        tableType: String? = nil,
        targetTable: TableIdentifier? = nil,
        updateTime: Date? = nil,
        viewExpandedText: String? = nil,
        viewOriginalText: String? = nil
    )
    {
        self.catalogId = catalogId
        self.createTime = createTime
        self.createdBy = createdBy
        self.databaseName = databaseName
        self.description = description
        self.isRegisteredWithLakeFormation = isRegisteredWithLakeFormation
        self.lastAccessTime = lastAccessTime
        self.lastAnalyzedTime = lastAnalyzedTime
        self.name = name
        self.owner = owner
        self.parameters = parameters
        self.partitionKeys = partitionKeys
        self.retention = retention
        self.storageDescriptor = storageDescriptor
        self.tableType = tableType
        self.targetTable = targetTable
        self.updateTime = updateTime
        self.viewExpandedText = viewExpandedText
        self.viewOriginalText = viewOriginalText
    }
}

extension TableError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorDetail = "ErrorDetail"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorDetail = errorDetail {
            try encodeContainer.encode(errorDetail, forKey: .errorDetail)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let errorDetailDecoded = try containerValues.decodeIfPresent(ErrorDetail.self, forKey: .errorDetail)
        errorDetail = errorDetailDecoded
    }
}

extension TableError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableError(errorDetail: \(String(describing: errorDetail)), tableName: \(String(describing: tableName)))"}
}

/// <p>An error record for table operations.</p>
public struct TableError: Equatable {
    /// <p>The details about the error.</p>
    public let errorDetail: ErrorDetail?
    /// <p>The name of the table. For Hive compatibility, this must be entirely lowercase.</p>
    public let tableName: String?

    public init (
        errorDetail: ErrorDetail? = nil,
        tableName: String? = nil
    )
    {
        self.errorDetail = errorDetail
        self.tableName = tableName
    }
}

extension TableIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension TableIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableIdentifier(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), name: \(String(describing: name)))"}
}

/// <p>A structure that describes a target table for resource linking.</p>
public struct TableIdentifier: Equatable {
    /// <p>The ID of the Data Catalog in which the table resides.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database that contains the target table.</p>
    public let databaseName: String?
    /// <p>The name of the target table.</p>
    public let name: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        name: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.name = name
    }
}

extension TableInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case lastAccessTime = "LastAccessTime"
        case lastAnalyzedTime = "LastAnalyzedTime"
        case name = "Name"
        case owner = "Owner"
        case parameters = "Parameters"
        case partitionKeys = "PartitionKeys"
        case retention = "Retention"
        case storageDescriptor = "StorageDescriptor"
        case tableType = "TableType"
        case targetTable = "TargetTable"
        case viewExpandedText = "ViewExpandedText"
        case viewOriginalText = "ViewOriginalText"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastAccessTime = lastAccessTime {
            try encodeContainer.encode(lastAccessTime.timeIntervalSince1970, forKey: .lastAccessTime)
        }
        if let lastAnalyzedTime = lastAnalyzedTime {
            try encodeContainer.encode(lastAnalyzedTime.timeIntervalSince1970, forKey: .lastAnalyzedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let partitionKeys = partitionKeys {
            var partitionKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionKeys)
            for columnlist0 in partitionKeys {
                try partitionKeysContainer.encode(columnlist0)
            }
        }
        if retention != 0 {
            try encodeContainer.encode(retention, forKey: .retention)
        }
        if let storageDescriptor = storageDescriptor {
            try encodeContainer.encode(storageDescriptor, forKey: .storageDescriptor)
        }
        if let tableType = tableType {
            try encodeContainer.encode(tableType, forKey: .tableType)
        }
        if let targetTable = targetTable {
            try encodeContainer.encode(targetTable, forKey: .targetTable)
        }
        if let viewExpandedText = viewExpandedText {
            try encodeContainer.encode(viewExpandedText, forKey: .viewExpandedText)
        }
        if let viewOriginalText = viewOriginalText {
            try encodeContainer.encode(viewOriginalText, forKey: .viewOriginalText)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let lastAccessTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAccessTime)
        lastAccessTime = lastAccessTimeDecoded
        let lastAnalyzedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAnalyzedTime)
        lastAnalyzedTime = lastAnalyzedTimeDecoded
        let retentionDecoded = try containerValues.decode(Int.self, forKey: .retention)
        retention = retentionDecoded
        let storageDescriptorDecoded = try containerValues.decodeIfPresent(StorageDescriptor.self, forKey: .storageDescriptor)
        storageDescriptor = storageDescriptorDecoded
        let partitionKeysContainer = try containerValues.decodeIfPresent([Column?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[Column]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [Column]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let viewOriginalTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .viewOriginalText)
        viewOriginalText = viewOriginalTextDecoded
        let viewExpandedTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .viewExpandedText)
        viewExpandedText = viewExpandedTextDecoded
        let tableTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableType)
        tableType = tableTypeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let targetTableDecoded = try containerValues.decodeIfPresent(TableIdentifier.self, forKey: .targetTable)
        targetTable = targetTableDecoded
    }
}

extension TableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableInput(description: \(String(describing: description)), lastAccessTime: \(String(describing: lastAccessTime)), lastAnalyzedTime: \(String(describing: lastAnalyzedTime)), name: \(String(describing: name)), owner: \(String(describing: owner)), parameters: \(String(describing: parameters)), partitionKeys: \(String(describing: partitionKeys)), retention: \(String(describing: retention)), storageDescriptor: \(String(describing: storageDescriptor)), tableType: \(String(describing: tableType)), targetTable: \(String(describing: targetTable)), viewExpandedText: \(String(describing: viewExpandedText)), viewOriginalText: \(String(describing: viewOriginalText)))"}
}

/// <p>A structure used to define a table.</p>
public struct TableInput: Equatable {
    /// <p>A description of the table.</p>
    public let description: String?
    /// <p>The last time that the table was accessed.</p>
    public let lastAccessTime: Date?
    /// <p>The last time that column statistics were computed for this table.</p>
    public let lastAnalyzedTime: Date?
    /// <p>The table name. For Hive compatibility, this is folded to
    ///       lowercase when it is stored.</p>
    public let name: String?
    /// <p>The table owner.</p>
    public let owner: String?
    /// <p>These key-value pairs define properties associated with the table.</p>
    public let parameters: [String:String]?
    /// <p>A list of columns by which the table is partitioned. Only primitive
    ///       types are supported as partition keys.</p>
    /// 	        <p>When you create a table used by Amazon Athena, and you do not specify any
    ///         <code>partitionKeys</code>, you must at least set the value of <code>partitionKeys</code> to
    ///       an empty list. For example:</p>
    ///          <p>
    ///             <code>"PartitionKeys": []</code>
    ///          </p>
    public let partitionKeys: [Column]?
    /// <p>The retention time for this table.</p>
    public let retention: Int
    /// <p>A storage descriptor containing information about the physical storage
    ///       of this table.</p>
    public let storageDescriptor: StorageDescriptor?
    /// <p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>
    public let tableType: String?
    /// <p>A <code>TableIdentifier</code> structure that describes a target table for resource linking.</p>
    public let targetTable: TableIdentifier?
    /// <p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>
    public let viewExpandedText: String?
    /// <p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>
    public let viewOriginalText: String?

    public init (
        description: String? = nil,
        lastAccessTime: Date? = nil,
        lastAnalyzedTime: Date? = nil,
        name: String? = nil,
        owner: String? = nil,
        parameters: [String:String]? = nil,
        partitionKeys: [Column]? = nil,
        retention: Int = 0,
        storageDescriptor: StorageDescriptor? = nil,
        tableType: String? = nil,
        targetTable: TableIdentifier? = nil,
        viewExpandedText: String? = nil,
        viewOriginalText: String? = nil
    )
    {
        self.description = description
        self.lastAccessTime = lastAccessTime
        self.lastAnalyzedTime = lastAnalyzedTime
        self.name = name
        self.owner = owner
        self.parameters = parameters
        self.partitionKeys = partitionKeys
        self.retention = retention
        self.storageDescriptor = storageDescriptor
        self.tableType = tableType
        self.targetTable = targetTable
        self.viewExpandedText = viewExpandedText
        self.viewOriginalText = viewOriginalText
    }
}

extension TableVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case table = "Table"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let table = table {
            try encodeContainer.encode(table, forKey: .table)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(Table.self, forKey: .table)
        table = tableDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension TableVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableVersion(table: \(String(describing: table)), versionId: \(String(describing: versionId)))"}
}

/// <p>Specifies a version of a table.</p>
public struct TableVersion: Equatable {
    /// <p>The table in question.</p>
    public let table: Table?
    /// <p>The ID value that identifies this table version. A <code>VersionId</code> is a string representation of an integer. Each version is incremented by 1.</p>
    public let versionId: String?

    public init (
        table: Table? = nil,
        versionId: String? = nil
    )
    {
        self.table = table
        self.versionId = versionId
    }
}

extension TableVersionError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorDetail = "ErrorDetail"
        case tableName = "TableName"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorDetail = errorDetail {
            try encodeContainer.encode(errorDetail, forKey: .errorDetail)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let errorDetailDecoded = try containerValues.decodeIfPresent(ErrorDetail.self, forKey: .errorDetail)
        errorDetail = errorDetailDecoded
    }
}

extension TableVersionError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableVersionError(errorDetail: \(String(describing: errorDetail)), tableName: \(String(describing: tableName)), versionId: \(String(describing: versionId)))"}
}

/// <p>An error record for table-version operations.</p>
public struct TableVersionError: Equatable {
    /// <p>The details about the error.</p>
    public let errorDetail: ErrorDetail?
    /// <p>The name of the table in question.</p>
    public let tableName: String?
    /// <p>The ID value of the version in question. A <code>VersionID</code> is a string representation of an integer. Each version is incremented by 1.</p>
    public let versionId: String?

    public init (
        errorDetail: ErrorDetail? = nil,
        tableName: String? = nil,
        versionId: String? = nil
    )
    {
        self.errorDetail = errorDetail
        self.tableName = tableName
        self.versionId = versionId
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tagsToAdd: \(String(describing: tagsToAdd)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagsToAdd = "TagsToAdd"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagsToAdd = tagsToAdd {
            var tagsToAddContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tagsToAdd)
            for (dictKey0, tagsmap0) in tagsToAdd {
                try tagsToAddContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the AWS Glue resource to which to add the tags. For more
    ///       information about AWS Glue resource ARNs, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-common.html#aws-glue-api-regex-aws-glue-arn-id">AWS Glue ARN string pattern</a>.</p>
    public let resourceArn: String?
    /// <p>Tags to add to this resource.</p>
    public let tagsToAdd: [String:String]?

    public init (
        resourceArn: String? = nil,
        tagsToAdd: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagsToAdd = tagsToAdd
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagsToAdd: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagsToAdd = "TagsToAdd"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsToAddContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tagsToAdd)
        var tagsToAddDecoded0: [String:String]? = nil
        if let tagsToAddContainer = tagsToAddContainer {
            tagsToAddDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsToAddContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsToAddDecoded0?[key0] = tagvalue0
                }
            }
        }
        tagsToAdd = tagsToAddDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TaskRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completedOn = "CompletedOn"
        case errorString = "ErrorString"
        case executionTime = "ExecutionTime"
        case lastModifiedOn = "LastModifiedOn"
        case logGroupName = "LogGroupName"
        case properties = "Properties"
        case startedOn = "StartedOn"
        case status = "Status"
        case taskRunId = "TaskRunId"
        case transformId = "TransformId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedOn = completedOn {
            try encodeContainer.encode(completedOn.timeIntervalSince1970, forKey: .completedOn)
        }
        if let errorString = errorString {
            try encodeContainer.encode(errorString, forKey: .errorString)
        }
        if executionTime != 0 {
            try encodeContainer.encode(executionTime, forKey: .executionTime)
        }
        if let lastModifiedOn = lastModifiedOn {
            try encodeContainer.encode(lastModifiedOn.timeIntervalSince1970, forKey: .lastModifiedOn)
        }
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let startedOn = startedOn {
            try encodeContainer.encode(startedOn.timeIntervalSince1970, forKey: .startedOn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let taskRunId = taskRunId {
            try encodeContainer.encode(taskRunId, forKey: .taskRunId)
        }
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let taskRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRunId)
        taskRunId = taskRunIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TaskStatusType.self, forKey: .status)
        status = statusDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(TaskRunProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let errorStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorString)
        errorString = errorStringDecoded
        let startedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedOn)
        startedOn = startedOnDecoded
        let lastModifiedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedOn)
        lastModifiedOn = lastModifiedOnDecoded
        let completedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedOn)
        completedOn = completedOnDecoded
        let executionTimeDecoded = try containerValues.decode(Int.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
    }
}

extension TaskRun: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskRun(completedOn: \(String(describing: completedOn)), errorString: \(String(describing: errorString)), executionTime: \(String(describing: executionTime)), lastModifiedOn: \(String(describing: lastModifiedOn)), logGroupName: \(String(describing: logGroupName)), properties: \(String(describing: properties)), startedOn: \(String(describing: startedOn)), status: \(String(describing: status)), taskRunId: \(String(describing: taskRunId)), transformId: \(String(describing: transformId)))"}
}

/// <p>The sampling parameters that are associated with the machine learning transform.</p>
public struct TaskRun: Equatable {
    /// <p>The last point in time that the requested task run was completed.</p>
    public let completedOn: Date?
    /// <p>The list of error strings associated with this task run.</p>
    public let errorString: String?
    /// <p>The amount of time (in seconds) that the task run consumed resources.</p>
    public let executionTime: Int
    /// <p>The last point in time that the requested task run was updated.</p>
    public let lastModifiedOn: Date?
    /// <p>The names of the log group for secure logging, associated with this task run.</p>
    public let logGroupName: String?
    /// <p>Specifies configuration properties associated with this task run.</p>
    public let properties: TaskRunProperties?
    /// <p>The date and time that this task run started.</p>
    public let startedOn: Date?
    /// <p>The current status of the requested task run.</p>
    public let status: TaskStatusType?
    /// <p>The unique identifier for this task run.</p>
    public let taskRunId: String?
    /// <p>The unique identifier for the transform.</p>
    public let transformId: String?

    public init (
        completedOn: Date? = nil,
        errorString: String? = nil,
        executionTime: Int = 0,
        lastModifiedOn: Date? = nil,
        logGroupName: String? = nil,
        properties: TaskRunProperties? = nil,
        startedOn: Date? = nil,
        status: TaskStatusType? = nil,
        taskRunId: String? = nil,
        transformId: String? = nil
    )
    {
        self.completedOn = completedOn
        self.errorString = errorString
        self.executionTime = executionTime
        self.lastModifiedOn = lastModifiedOn
        self.logGroupName = logGroupName
        self.properties = properties
        self.startedOn = startedOn
        self.status = status
        self.taskRunId = taskRunId
        self.transformId = transformId
    }
}

extension TaskRunFilterCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case startedAfter = "StartedAfter"
        case startedBefore = "StartedBefore"
        case status = "Status"
        case taskRunType = "TaskRunType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startedAfter = startedAfter {
            try encodeContainer.encode(startedAfter.timeIntervalSince1970, forKey: .startedAfter)
        }
        if let startedBefore = startedBefore {
            try encodeContainer.encode(startedBefore.timeIntervalSince1970, forKey: .startedBefore)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let taskRunType = taskRunType {
            try encodeContainer.encode(taskRunType.rawValue, forKey: .taskRunType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskRunTypeDecoded = try containerValues.decodeIfPresent(TaskType.self, forKey: .taskRunType)
        taskRunType = taskRunTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TaskStatusType.self, forKey: .status)
        status = statusDecoded
        let startedBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedBefore)
        startedBefore = startedBeforeDecoded
        let startedAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAfter)
        startedAfter = startedAfterDecoded
    }
}

extension TaskRunFilterCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskRunFilterCriteria(startedAfter: \(String(describing: startedAfter)), startedBefore: \(String(describing: startedBefore)), status: \(String(describing: status)), taskRunType: \(String(describing: taskRunType)))"}
}

/// <p>The criteria that are used to filter the task runs for the machine learning
///       transform.</p>
public struct TaskRunFilterCriteria: Equatable {
    /// <p>Filter on task runs started after this date.</p>
    public let startedAfter: Date?
    /// <p>Filter on task runs started before this date.</p>
    public let startedBefore: Date?
    /// <p>The current status of the task run.</p>
    public let status: TaskStatusType?
    /// <p>The type of task run.</p>
    public let taskRunType: TaskType?

    public init (
        startedAfter: Date? = nil,
        startedBefore: Date? = nil,
        status: TaskStatusType? = nil,
        taskRunType: TaskType? = nil
    )
    {
        self.startedAfter = startedAfter
        self.startedBefore = startedBefore
        self.status = status
        self.taskRunType = taskRunType
    }
}

extension TaskRunProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportLabelsTaskRunProperties = "ExportLabelsTaskRunProperties"
        case findMatchesTaskRunProperties = "FindMatchesTaskRunProperties"
        case importLabelsTaskRunProperties = "ImportLabelsTaskRunProperties"
        case labelingSetGenerationTaskRunProperties = "LabelingSetGenerationTaskRunProperties"
        case taskType = "TaskType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportLabelsTaskRunProperties = exportLabelsTaskRunProperties {
            try encodeContainer.encode(exportLabelsTaskRunProperties, forKey: .exportLabelsTaskRunProperties)
        }
        if let findMatchesTaskRunProperties = findMatchesTaskRunProperties {
            try encodeContainer.encode(findMatchesTaskRunProperties, forKey: .findMatchesTaskRunProperties)
        }
        if let importLabelsTaskRunProperties = importLabelsTaskRunProperties {
            try encodeContainer.encode(importLabelsTaskRunProperties, forKey: .importLabelsTaskRunProperties)
        }
        if let labelingSetGenerationTaskRunProperties = labelingSetGenerationTaskRunProperties {
            try encodeContainer.encode(labelingSetGenerationTaskRunProperties, forKey: .labelingSetGenerationTaskRunProperties)
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskTypeDecoded = try containerValues.decodeIfPresent(TaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let importLabelsTaskRunPropertiesDecoded = try containerValues.decodeIfPresent(ImportLabelsTaskRunProperties.self, forKey: .importLabelsTaskRunProperties)
        importLabelsTaskRunProperties = importLabelsTaskRunPropertiesDecoded
        let exportLabelsTaskRunPropertiesDecoded = try containerValues.decodeIfPresent(ExportLabelsTaskRunProperties.self, forKey: .exportLabelsTaskRunProperties)
        exportLabelsTaskRunProperties = exportLabelsTaskRunPropertiesDecoded
        let labelingSetGenerationTaskRunPropertiesDecoded = try containerValues.decodeIfPresent(LabelingSetGenerationTaskRunProperties.self, forKey: .labelingSetGenerationTaskRunProperties)
        labelingSetGenerationTaskRunProperties = labelingSetGenerationTaskRunPropertiesDecoded
        let findMatchesTaskRunPropertiesDecoded = try containerValues.decodeIfPresent(FindMatchesTaskRunProperties.self, forKey: .findMatchesTaskRunProperties)
        findMatchesTaskRunProperties = findMatchesTaskRunPropertiesDecoded
    }
}

extension TaskRunProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskRunProperties(exportLabelsTaskRunProperties: \(String(describing: exportLabelsTaskRunProperties)), findMatchesTaskRunProperties: \(String(describing: findMatchesTaskRunProperties)), importLabelsTaskRunProperties: \(String(describing: importLabelsTaskRunProperties)), labelingSetGenerationTaskRunProperties: \(String(describing: labelingSetGenerationTaskRunProperties)), taskType: \(String(describing: taskType)))"}
}

/// <p>The configuration properties for the task run.</p>
public struct TaskRunProperties: Equatable {
    /// <p>The configuration properties for an exporting labels task run.</p>
    public let exportLabelsTaskRunProperties: ExportLabelsTaskRunProperties?
    /// <p>The configuration properties for a find matches task run.</p>
    public let findMatchesTaskRunProperties: FindMatchesTaskRunProperties?
    /// <p>The configuration properties for an importing labels task run.</p>
    public let importLabelsTaskRunProperties: ImportLabelsTaskRunProperties?
    /// <p>The configuration properties for a labeling set generation task run.</p>
    public let labelingSetGenerationTaskRunProperties: LabelingSetGenerationTaskRunProperties?
    /// <p>The type of task run.</p>
    public let taskType: TaskType?

    public init (
        exportLabelsTaskRunProperties: ExportLabelsTaskRunProperties? = nil,
        findMatchesTaskRunProperties: FindMatchesTaskRunProperties? = nil,
        importLabelsTaskRunProperties: ImportLabelsTaskRunProperties? = nil,
        labelingSetGenerationTaskRunProperties: LabelingSetGenerationTaskRunProperties? = nil,
        taskType: TaskType? = nil
    )
    {
        self.exportLabelsTaskRunProperties = exportLabelsTaskRunProperties
        self.findMatchesTaskRunProperties = findMatchesTaskRunProperties
        self.importLabelsTaskRunProperties = importLabelsTaskRunProperties
        self.labelingSetGenerationTaskRunProperties = labelingSetGenerationTaskRunProperties
        self.taskType = taskType
    }
}

public enum TaskRunSortColumnType {
    case started
    case status
    case taskRunType
    case sdkUnknown(String)
}

extension TaskRunSortColumnType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaskRunSortColumnType] {
        return [
            .started,
            .status,
            .taskRunType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .started: return "STARTED"
        case .status: return "STATUS"
        case .taskRunType: return "TASK_RUN_TYPE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaskRunSortColumnType(rawValue: rawValue) ?? TaskRunSortColumnType.sdkUnknown(rawValue)
    }
}

extension TaskRunSortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case column = "Column"
        case sortDirection = "SortDirection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = column {
            try encodeContainer.encode(column.rawValue, forKey: .column)
        }
        if let sortDirection = sortDirection {
            try encodeContainer.encode(sortDirection.rawValue, forKey: .sortDirection)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decodeIfPresent(TaskRunSortColumnType.self, forKey: .column)
        column = columnDecoded
        let sortDirectionDecoded = try containerValues.decodeIfPresent(SortDirectionType.self, forKey: .sortDirection)
        sortDirection = sortDirectionDecoded
    }
}

extension TaskRunSortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskRunSortCriteria(column: \(String(describing: column)), sortDirection: \(String(describing: sortDirection)))"}
}

/// <p>The sorting criteria that are used to sort the list of task runs for the machine learning
///       transform.</p>
public struct TaskRunSortCriteria: Equatable {
    /// <p>The column to be used to sort the list of task runs for the machine learning
    ///       transform.</p>
    public let column: TaskRunSortColumnType?
    /// <p>The sort direction to be used to sort the list of task runs for the machine learning
    ///       transform.</p>
    public let sortDirection: SortDirectionType?

    public init (
        column: TaskRunSortColumnType? = nil,
        sortDirection: SortDirectionType? = nil
    )
    {
        self.column = column
        self.sortDirection = sortDirection
    }
}

public enum TaskStatusType {
    case failed
    case running
    case starting
    case stopped
    case stopping
    case succeeded
    case timeout
    case sdkUnknown(String)
}

extension TaskStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaskStatusType] {
        return [
            .failed,
            .running,
            .starting,
            .stopped,
            .stopping,
            .succeeded,
            .timeout,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case .starting: return "STARTING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case .succeeded: return "SUCCEEDED"
        case .timeout: return "TIMEOUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaskStatusType(rawValue: rawValue) ?? TaskStatusType.sdkUnknown(rawValue)
    }
}

public enum TaskType {
    case evaluation
    case exportLabels
    case findMatches
    case importLabels
    case labelingSetGeneration
    case sdkUnknown(String)
}

extension TaskType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaskType] {
        return [
            .evaluation,
            .exportLabels,
            .findMatches,
            .importLabels,
            .labelingSetGeneration,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .evaluation: return "EVALUATION"
        case .exportLabels: return "EXPORT_LABELS"
        case .findMatches: return "FIND_MATCHES"
        case .importLabels: return "IMPORT_LABELS"
        case .labelingSetGeneration: return "LABELING_SET_GENERATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaskType(rawValue: rawValue) ?? TaskType.sdkUnknown(rawValue)
    }
}

extension TransformEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mlUserDataEncryption = "MlUserDataEncryption"
        case taskRunSecurityConfigurationName = "TaskRunSecurityConfigurationName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mlUserDataEncryption = mlUserDataEncryption {
            try encodeContainer.encode(mlUserDataEncryption, forKey: .mlUserDataEncryption)
        }
        if let taskRunSecurityConfigurationName = taskRunSecurityConfigurationName {
            try encodeContainer.encode(taskRunSecurityConfigurationName, forKey: .taskRunSecurityConfigurationName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mlUserDataEncryptionDecoded = try containerValues.decodeIfPresent(MLUserDataEncryption.self, forKey: .mlUserDataEncryption)
        mlUserDataEncryption = mlUserDataEncryptionDecoded
        let taskRunSecurityConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRunSecurityConfigurationName)
        taskRunSecurityConfigurationName = taskRunSecurityConfigurationNameDecoded
    }
}

extension TransformEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransformEncryption(mlUserDataEncryption: \(String(describing: mlUserDataEncryption)), taskRunSecurityConfigurationName: \(String(describing: taskRunSecurityConfigurationName)))"}
}

/// <p>The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.</p>
///
/// 	        <p>Additionally, imported labels and trained transforms can now be encrypted using a customer provided KMS key.</p>
public struct TransformEncryption: Equatable {
    /// <p>An <code>MLUserDataEncryption</code> object containing the encryption mode and customer-provided KMS key ID.</p>
    public let mlUserDataEncryption: MLUserDataEncryption?
    /// <p>The name of the security configuration.</p>
    public let taskRunSecurityConfigurationName: String?

    public init (
        mlUserDataEncryption: MLUserDataEncryption? = nil,
        taskRunSecurityConfigurationName: String? = nil
    )
    {
        self.mlUserDataEncryption = mlUserDataEncryption
        self.taskRunSecurityConfigurationName = taskRunSecurityConfigurationName
    }
}

extension TransformFilterCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAfter = "CreatedAfter"
        case createdBefore = "CreatedBefore"
        case glueVersion = "GlueVersion"
        case lastModifiedAfter = "LastModifiedAfter"
        case lastModifiedBefore = "LastModifiedBefore"
        case name = "Name"
        case schema = "Schema"
        case status = "Status"
        case transformType = "TransformType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = createdAfter {
            try encodeContainer.encode(createdAfter.timeIntervalSince1970, forKey: .createdAfter)
        }
        if let createdBefore = createdBefore {
            try encodeContainer.encode(createdBefore.timeIntervalSince1970, forKey: .createdBefore)
        }
        if let glueVersion = glueVersion {
            try encodeContainer.encode(glueVersion, forKey: .glueVersion)
        }
        if let lastModifiedAfter = lastModifiedAfter {
            try encodeContainer.encode(lastModifiedAfter.timeIntervalSince1970, forKey: .lastModifiedAfter)
        }
        if let lastModifiedBefore = lastModifiedBefore {
            try encodeContainer.encode(lastModifiedBefore.timeIntervalSince1970, forKey: .lastModifiedBefore)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            var schemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schema)
            for transformschema0 in schema {
                try schemaContainer.encode(transformschema0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let transformType = transformType {
            try encodeContainer.encode(transformType.rawValue, forKey: .transformType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let transformTypeDecoded = try containerValues.decodeIfPresent(TransformType.self, forKey: .transformType)
        transformType = transformTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransformStatusType.self, forKey: .status)
        status = statusDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
        let createdBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
        let createdAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let lastModifiedBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedBefore)
        lastModifiedBefore = lastModifiedBeforeDecoded
        let lastModifiedAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedAfter)
        lastModifiedAfter = lastModifiedAfterDecoded
        let schemaContainer = try containerValues.decodeIfPresent([SchemaColumn?].self, forKey: .schema)
        var schemaDecoded0:[SchemaColumn]? = nil
        if let schemaContainer = schemaContainer {
            schemaDecoded0 = [SchemaColumn]()
            for structure0 in schemaContainer {
                if let structure0 = structure0 {
                    schemaDecoded0?.append(structure0)
                }
            }
        }
        schema = schemaDecoded0
    }
}

extension TransformFilterCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransformFilterCriteria(createdAfter: \(String(describing: createdAfter)), createdBefore: \(String(describing: createdBefore)), glueVersion: \(String(describing: glueVersion)), lastModifiedAfter: \(String(describing: lastModifiedAfter)), lastModifiedBefore: \(String(describing: lastModifiedBefore)), name: \(String(describing: name)), schema: \(String(describing: schema)), status: \(String(describing: status)), transformType: \(String(describing: transformType)))"}
}

/// <p>The criteria used to filter the machine learning transforms.</p>
public struct TransformFilterCriteria: Equatable {
    /// <p>The time and date after which the transforms were created.</p>
    public let createdAfter: Date?
    /// <p>The time and date before which the transforms were created.</p>
    public let createdBefore: Date?
    /// <p>This value determines which version of AWS Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">AWS Glue Versions</a> in the developer guide.</p>
    public let glueVersion: String?
    /// <p>Filter on transforms last modified after this date.</p>
    public let lastModifiedAfter: Date?
    /// <p>Filter on transforms last modified before this date.</p>
    public let lastModifiedBefore: Date?
    /// <p>A unique transform name that is used to filter the machine learning transforms.</p>
    public let name: String?
    /// <p>Filters on datasets with a specific schema. The <code>Map<Column, Type></code>
    ///       object is an array of key-value pairs representing the schema this transform accepts, where
    ///         <code>Column</code> is the name of a column, and <code>Type</code> is the type of the data
    ///       such as an integer or string. Has an upper bound of 100 columns.</p>
    public let schema: [SchemaColumn]?
    /// <p>Filters the list of machine learning transforms by the last known status of the transforms (to indicate whether a transform can be used or not). One of "NOT_READY", "READY", or "DELETING".</p>
    public let status: TransformStatusType?
    /// <p>The type of machine learning transform that is used to filter the machine learning
    ///       transforms.</p>
    public let transformType: TransformType?

    public init (
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        glueVersion: String? = nil,
        lastModifiedAfter: Date? = nil,
        lastModifiedBefore: Date? = nil,
        name: String? = nil,
        schema: [SchemaColumn]? = nil,
        status: TransformStatusType? = nil,
        transformType: TransformType? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.glueVersion = glueVersion
        self.lastModifiedAfter = lastModifiedAfter
        self.lastModifiedBefore = lastModifiedBefore
        self.name = name
        self.schema = schema
        self.status = status
        self.transformType = transformType
    }
}

extension TransformParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findMatchesParameters = "FindMatchesParameters"
        case transformType = "TransformType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findMatchesParameters = findMatchesParameters {
            try encodeContainer.encode(findMatchesParameters, forKey: .findMatchesParameters)
        }
        if let transformType = transformType {
            try encodeContainer.encode(transformType.rawValue, forKey: .transformType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformTypeDecoded = try containerValues.decodeIfPresent(TransformType.self, forKey: .transformType)
        transformType = transformTypeDecoded
        let findMatchesParametersDecoded = try containerValues.decodeIfPresent(FindMatchesParameters.self, forKey: .findMatchesParameters)
        findMatchesParameters = findMatchesParametersDecoded
    }
}

extension TransformParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransformParameters(findMatchesParameters: \(String(describing: findMatchesParameters)), transformType: \(String(describing: transformType)))"}
}

/// <p>The algorithm-specific parameters that are associated with the machine learning
///       transform.</p>
public struct TransformParameters: Equatable {
    /// <p>The parameters for the find matches algorithm.</p>
    public let findMatchesParameters: FindMatchesParameters?
    /// <p>The type of machine learning transform.</p>
    /// 	        <p>For information about the types of machine learning transforms, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job-machine-learning-transform.html">Creating Machine Learning Transforms</a>.</p>
    public let transformType: TransformType?

    public init (
        findMatchesParameters: FindMatchesParameters? = nil,
        transformType: TransformType? = nil
    )
    {
        self.findMatchesParameters = findMatchesParameters
        self.transformType = transformType
    }
}

public enum TransformSortColumnType {
    case created
    case lastModified
    case name
    case status
    case transformType
    case sdkUnknown(String)
}

extension TransformSortColumnType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TransformSortColumnType] {
        return [
            .created,
            .lastModified,
            .name,
            .status,
            .transformType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .created: return "CREATED"
        case .lastModified: return "LAST_MODIFIED"
        case .name: return "NAME"
        case .status: return "STATUS"
        case .transformType: return "TRANSFORM_TYPE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TransformSortColumnType(rawValue: rawValue) ?? TransformSortColumnType.sdkUnknown(rawValue)
    }
}

extension TransformSortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case column = "Column"
        case sortDirection = "SortDirection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = column {
            try encodeContainer.encode(column.rawValue, forKey: .column)
        }
        if let sortDirection = sortDirection {
            try encodeContainer.encode(sortDirection.rawValue, forKey: .sortDirection)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decodeIfPresent(TransformSortColumnType.self, forKey: .column)
        column = columnDecoded
        let sortDirectionDecoded = try containerValues.decodeIfPresent(SortDirectionType.self, forKey: .sortDirection)
        sortDirection = sortDirectionDecoded
    }
}

extension TransformSortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransformSortCriteria(column: \(String(describing: column)), sortDirection: \(String(describing: sortDirection)))"}
}

/// <p>The sorting criteria that are associated with the machine learning transform.</p>
public struct TransformSortCriteria: Equatable {
    /// <p>The column to be used in the sorting criteria that are associated with the machine
    ///       learning transform.</p>
    public let column: TransformSortColumnType?
    /// <p>The sort direction to be used in the sorting criteria that are associated with the machine
    ///       learning transform.</p>
    public let sortDirection: SortDirectionType?

    public init (
        column: TransformSortColumnType? = nil,
        sortDirection: SortDirectionType? = nil
    )
    {
        self.column = column
        self.sortDirection = sortDirection
    }
}

public enum TransformStatusType {
    case deleting
    case notReady
    case ready
    case sdkUnknown(String)
}

extension TransformStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TransformStatusType] {
        return [
            .deleting,
            .notReady,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleting: return "DELETING"
        case .notReady: return "NOT_READY"
        case .ready: return "READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TransformStatusType(rawValue: rawValue) ?? TransformStatusType.sdkUnknown(rawValue)
    }
}

public enum TransformType {
    case findMatches
    case sdkUnknown(String)
}

extension TransformType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TransformType] {
        return [
            .findMatches,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .findMatches: return "FIND_MATCHES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TransformType(rawValue: rawValue) ?? TransformType.sdkUnknown(rawValue)
    }
}

extension Trigger: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case predicate = "Predicate"
        case schedule = "Schedule"
        case state = "State"
        case type = "Type"
        case workflowName = "WorkflowName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predicate = predicate {
            try encodeContainer.encode(predicate, forKey: .predicate)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let workflowName = workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let workflowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TriggerType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TriggerState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let predicateDecoded = try containerValues.decodeIfPresent(Predicate.self, forKey: .predicate)
        predicate = predicateDecoded
    }
}

extension Trigger: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Trigger(actions: \(String(describing: actions)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), predicate: \(String(describing: predicate)), schedule: \(String(describing: schedule)), state: \(String(describing: state)), type: \(String(describing: type)), workflowName: \(String(describing: workflowName)))"}
}

/// <p>Information about a specific trigger.</p>
public struct Trigger: Equatable {
    /// <p>The actions initiated by this trigger.</p>
    public let actions: [Action]?
    /// <p>A description of this trigger.</p>
    public let description: String?
    /// <p>Reserved for future use.</p>
    public let id: String?
    /// <p>The name of the trigger.</p>
    public let name: String?
    /// <p>The predicate of this trigger, which defines when it will fire.</p>
    public let predicate: Predicate?
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based
    ///       Schedules for Jobs and Crawlers</a>. For example, to run
    ///       something every day at 12:15 UTC, you would specify:
    ///       <code>cron(15 12 * * ? *)</code>.</p>
    public let schedule: String?
    /// <p>The current state of the trigger.</p>
    public let state: TriggerState?
    /// <p>The type of trigger that this is.</p>
    public let type: TriggerType?
    /// <p>The name of the workflow associated with the trigger.</p>
    public let workflowName: String?

    public init (
        actions: [Action]? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        predicate: Predicate? = nil,
        schedule: String? = nil,
        state: TriggerState? = nil,
        type: TriggerType? = nil,
        workflowName: String? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.id = id
        self.name = name
        self.predicate = predicate
        self.schedule = schedule
        self.state = state
        self.type = type
        self.workflowName = workflowName
    }
}

extension TriggerNodeDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case trigger = "Trigger"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trigger = trigger {
            try encodeContainer.encode(trigger, forKey: .trigger)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerDecoded = try containerValues.decodeIfPresent(Trigger.self, forKey: .trigger)
        trigger = triggerDecoded
    }
}

extension TriggerNodeDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TriggerNodeDetails(trigger: \(String(describing: trigger)))"}
}

/// <p>The details of a Trigger node present in the workflow.</p>
public struct TriggerNodeDetails: Equatable {
    /// <p>The information of the trigger represented by the trigger node.</p>
    public let trigger: Trigger?

    public init (
        trigger: Trigger? = nil
    )
    {
        self.trigger = trigger
    }
}

public enum TriggerState {
    case activated
    case activating
    case created
    case creating
    case deactivated
    case deactivating
    case deleting
    case updating
    case sdkUnknown(String)
}

extension TriggerState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TriggerState] {
        return [
            .activated,
            .activating,
            .created,
            .creating,
            .deactivated,
            .deactivating,
            .deleting,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activated: return "ACTIVATED"
        case .activating: return "ACTIVATING"
        case .created: return "CREATED"
        case .creating: return "CREATING"
        case .deactivated: return "DEACTIVATED"
        case .deactivating: return "DEACTIVATING"
        case .deleting: return "DELETING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TriggerState(rawValue: rawValue) ?? TriggerState.sdkUnknown(rawValue)
    }
}

public enum TriggerType {
    case conditional
    case onDemand
    case scheduled
    case sdkUnknown(String)
}

extension TriggerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TriggerType] {
        return [
            .conditional,
            .onDemand,
            .scheduled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .conditional: return "CONDITIONAL"
        case .onDemand: return "ON_DEMAND"
        case .scheduled: return "SCHEDULED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
    }
}

extension TriggerUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case description = "Description"
        case name = "Name"
        case predicate = "Predicate"
        case schedule = "Schedule"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predicate = predicate {
            try encodeContainer.encode(predicate, forKey: .predicate)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let predicateDecoded = try containerValues.decodeIfPresent(Predicate.self, forKey: .predicate)
        predicate = predicateDecoded
    }
}

extension TriggerUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TriggerUpdate(actions: \(String(describing: actions)), description: \(String(describing: description)), name: \(String(describing: name)), predicate: \(String(describing: predicate)), schedule: \(String(describing: schedule)))"}
}

/// <p>A structure used to provide information used to update a trigger. This object updates the
///       previous trigger definition by overwriting it completely.</p>
public struct TriggerUpdate: Equatable {
    /// <p>The actions initiated by this trigger.</p>
    public let actions: [Action]?
    /// <p>A description of this trigger.</p>
    public let description: String?
    /// <p>Reserved for future use.</p>
    public let name: String?
    /// <p>The predicate of this trigger, which defines when it will fire.</p>
    public let predicate: Predicate?
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based
    ///       Schedules for Jobs and Crawlers</a>. For example, to run
    ///       something every day at 12:15 UTC, you would specify:
    ///       <code>cron(15 12 * * ? *)</code>.</p>
    public let schedule: String?

    public init (
        actions: [Action]? = nil,
        description: String? = nil,
        name: String? = nil,
        predicate: Predicate? = nil,
        schedule: String? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.name = name
        self.predicate = predicate
        self.schedule = schedule
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagsToRemove: \(String(describing: tagsToRemove)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagsToRemove = "TagsToRemove"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagsToRemove = tagsToRemove {
            var tagsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsToRemove)
            for tagkeyslist0 in tagsToRemove {
                try tagsToRemoveContainer.encode(tagkeyslist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource from which to remove the tags.</p>
    public let resourceArn: String?
    /// <p>Tags to remove from this resource.</p>
    public let tagsToRemove: [String]?

    public init (
        resourceArn: String? = nil,
        tagsToRemove: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagsToRemove = tagsToRemove
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagsToRemove: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagsToRemove = "TagsToRemove"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsToRemoveContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagsToRemove)
        var tagsToRemoveDecoded0:[String]? = nil
        if let tagsToRemoveContainer = tagsToRemoveContainer {
            tagsToRemoveDecoded0 = [String]()
            for string0 in tagsToRemoveContainer {
                if let string0 = string0 {
                    tagsToRemoveDecoded0?.append(string0)
                }
            }
        }
        tagsToRemove = tagsToRemoveDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum UpdateBehavior {
    case log
    case updateInDatabase
    case sdkUnknown(String)
}

extension UpdateBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UpdateBehavior] {
        return [
            .log,
            .updateInDatabase,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .log: return "LOG"
        case .updateInDatabase: return "UPDATE_IN_DATABASE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UpdateBehavior(rawValue: rawValue) ?? UpdateBehavior.sdkUnknown(rawValue)
    }
}

public struct UpdateClassifierInputBodyMiddleware: Middleware {
    public let id: String = "UpdateClassifierInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClassifierInput>
    public typealias MOutput = OperationOutput<UpdateClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClassifierOutputError>
}

extension UpdateClassifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClassifierInput(csvClassifier: \(String(describing: csvClassifier)), grokClassifier: \(String(describing: grokClassifier)), jsonClassifier: \(String(describing: jsonClassifier)), xMLClassifier: \(String(describing: xMLClassifier)))"}
}

extension UpdateClassifierInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case csvClassifier = "CsvClassifier"
        case grokClassifier = "GrokClassifier"
        case jsonClassifier = "JsonClassifier"
        case xMLClassifier = "XMLClassifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvClassifier = csvClassifier {
            try encodeContainer.encode(csvClassifier, forKey: .csvClassifier)
        }
        if let grokClassifier = grokClassifier {
            try encodeContainer.encode(grokClassifier, forKey: .grokClassifier)
        }
        if let jsonClassifier = jsonClassifier {
            try encodeContainer.encode(jsonClassifier, forKey: .jsonClassifier)
        }
        if let xMLClassifier = xMLClassifier {
            try encodeContainer.encode(xMLClassifier, forKey: .xMLClassifier)
        }
    }
}

public struct UpdateClassifierInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateClassifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClassifierInput>
    public typealias MOutput = OperationOutput<UpdateClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClassifierOutputError>
}

public struct UpdateClassifierInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateClassifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClassifierInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClassifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClassifierInput>
    public typealias MOutput = OperationOutput<UpdateClassifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClassifierOutputError>
}

public struct UpdateClassifierInput: Equatable {
    /// <p>A <code>CsvClassifier</code> object with updated fields.</p>
    public let csvClassifier: UpdateCsvClassifierRequest?
    /// <p>A <code>GrokClassifier</code> object with updated fields.</p>
    public let grokClassifier: UpdateGrokClassifierRequest?
    /// <p>A <code>JsonClassifier</code> object with updated fields.</p>
    public let jsonClassifier: UpdateJsonClassifierRequest?
    /// <p>An <code>XMLClassifier</code> object with updated fields.</p>
    public let xMLClassifier: UpdateXMLClassifierRequest?

    public init (
        csvClassifier: UpdateCsvClassifierRequest? = nil,
        grokClassifier: UpdateGrokClassifierRequest? = nil,
        jsonClassifier: UpdateJsonClassifierRequest? = nil,
        xMLClassifier: UpdateXMLClassifierRequest? = nil
    )
    {
        self.csvClassifier = csvClassifier
        self.grokClassifier = grokClassifier
        self.jsonClassifier = jsonClassifier
        self.xMLClassifier = xMLClassifier
    }
}

struct UpdateClassifierInputBody: Equatable {
    public let grokClassifier: UpdateGrokClassifierRequest?
    public let xMLClassifier: UpdateXMLClassifierRequest?
    public let jsonClassifier: UpdateJsonClassifierRequest?
    public let csvClassifier: UpdateCsvClassifierRequest?
}

extension UpdateClassifierInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case csvClassifier = "CsvClassifier"
        case grokClassifier = "GrokClassifier"
        case jsonClassifier = "JsonClassifier"
        case xMLClassifier = "XMLClassifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grokClassifierDecoded = try containerValues.decodeIfPresent(UpdateGrokClassifierRequest.self, forKey: .grokClassifier)
        grokClassifier = grokClassifierDecoded
        let xMLClassifierDecoded = try containerValues.decodeIfPresent(UpdateXMLClassifierRequest.self, forKey: .xMLClassifier)
        xMLClassifier = xMLClassifierDecoded
        let jsonClassifierDecoded = try containerValues.decodeIfPresent(UpdateJsonClassifierRequest.self, forKey: .jsonClassifier)
        jsonClassifier = jsonClassifierDecoded
        let csvClassifierDecoded = try containerValues.decodeIfPresent(UpdateCsvClassifierRequest.self, forKey: .csvClassifier)
        csvClassifier = csvClassifierDecoded
    }
}

extension UpdateClassifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClassifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClassifierOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClassifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClassifierOutputResponse()"}
}

extension UpdateClassifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateClassifierOutputResponse: Equatable {

    public init() {}
}

struct UpdateClassifierOutputResponseBody: Equatable {
}

extension UpdateClassifierOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateColumnStatisticsForPartitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateColumnStatisticsForPartitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateColumnStatisticsForPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateColumnStatisticsForPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateColumnStatisticsForPartitionInput>
    public typealias MOutput = OperationOutput<UpdateColumnStatisticsForPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateColumnStatisticsForPartitionOutputError>
}

extension UpdateColumnStatisticsForPartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateColumnStatisticsForPartitionInput(catalogId: \(String(describing: catalogId)), columnStatisticsList: \(String(describing: columnStatisticsList)), databaseName: \(String(describing: databaseName)), partitionValues: \(String(describing: partitionValues)), tableName: \(String(describing: tableName)))"}
}

extension UpdateColumnStatisticsForPartitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnStatisticsList = "ColumnStatisticsList"
        case databaseName = "DatabaseName"
        case partitionValues = "PartitionValues"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let columnStatisticsList = columnStatisticsList {
            var columnStatisticsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnStatisticsList)
            for updatecolumnstatisticslist0 in columnStatisticsList {
                try columnStatisticsListContainer.encode(updatecolumnstatisticslist0)
            }
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionValues = partitionValues {
            var partitionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValues)
            for valuestringlist0 in partitionValues {
                try partitionValuesContainer.encode(valuestringlist0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct UpdateColumnStatisticsForPartitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateColumnStatisticsForPartitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateColumnStatisticsForPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateColumnStatisticsForPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateColumnStatisticsForPartitionInput>
    public typealias MOutput = OperationOutput<UpdateColumnStatisticsForPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateColumnStatisticsForPartitionOutputError>
}

public struct UpdateColumnStatisticsForPartitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateColumnStatisticsForPartitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateColumnStatisticsForPartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateColumnStatisticsForPartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateColumnStatisticsForPartitionInput>
    public typealias MOutput = OperationOutput<UpdateColumnStatisticsForPartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateColumnStatisticsForPartitionOutputError>
}

public struct UpdateColumnStatisticsForPartitionInput: Equatable {
    /// <p>The ID of the Data Catalog where the partitions in question reside.
    ///       If none is supplied, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>A list of the column statistics.</p>
    public let columnStatisticsList: [ColumnStatistics]?
    /// <p>The name of the catalog database where the partitions reside.</p>
    public let databaseName: String?
    /// <p>A list of partition values identifying the partition.</p>
    public let partitionValues: [String]?
    /// <p>The name of the partitions' table.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        columnStatisticsList: [ColumnStatistics]? = nil,
        databaseName: String? = nil,
        partitionValues: [String]? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnStatisticsList = columnStatisticsList
        self.databaseName = databaseName
        self.partitionValues = partitionValues
        self.tableName = tableName
    }
}

struct UpdateColumnStatisticsForPartitionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let partitionValues: [String]?
    public let columnStatisticsList: [ColumnStatistics]?
}

extension UpdateColumnStatisticsForPartitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnStatisticsList = "ColumnStatisticsList"
        case databaseName = "DatabaseName"
        case partitionValues = "PartitionValues"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let partitionValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionValues)
        var partitionValuesDecoded0:[String]? = nil
        if let partitionValuesContainer = partitionValuesContainer {
            partitionValuesDecoded0 = [String]()
            for string0 in partitionValuesContainer {
                if let string0 = string0 {
                    partitionValuesDecoded0?.append(string0)
                }
            }
        }
        partitionValues = partitionValuesDecoded0
        let columnStatisticsListContainer = try containerValues.decodeIfPresent([ColumnStatistics?].self, forKey: .columnStatisticsList)
        var columnStatisticsListDecoded0:[ColumnStatistics]? = nil
        if let columnStatisticsListContainer = columnStatisticsListContainer {
            columnStatisticsListDecoded0 = [ColumnStatistics]()
            for structure0 in columnStatisticsListContainer {
                if let structure0 = structure0 {
                    columnStatisticsListDecoded0?.append(structure0)
                }
            }
        }
        columnStatisticsList = columnStatisticsListDecoded0
    }
}

extension UpdateColumnStatisticsForPartitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateColumnStatisticsForPartitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateColumnStatisticsForPartitionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateColumnStatisticsForPartitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateColumnStatisticsForPartitionOutputResponse(errors: \(String(describing: errors)))"}
}

extension UpdateColumnStatisticsForPartitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateColumnStatisticsForPartitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct UpdateColumnStatisticsForPartitionOutputResponse: Equatable {
    /// <p>Error occurred during updating column statistics data.</p>
    public let errors: [ColumnStatisticsError]?

    public init (
        errors: [ColumnStatisticsError]? = nil
    )
    {
        self.errors = errors
    }
}

struct UpdateColumnStatisticsForPartitionOutputResponseBody: Equatable {
    public let errors: [ColumnStatisticsError]?
}

extension UpdateColumnStatisticsForPartitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([ColumnStatisticsError?].self, forKey: .errors)
        var errorsDecoded0:[ColumnStatisticsError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ColumnStatisticsError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct UpdateColumnStatisticsForTableInputBodyMiddleware: Middleware {
    public let id: String = "UpdateColumnStatisticsForTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateColumnStatisticsForTableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateColumnStatisticsForTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateColumnStatisticsForTableInput>
    public typealias MOutput = OperationOutput<UpdateColumnStatisticsForTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateColumnStatisticsForTableOutputError>
}

extension UpdateColumnStatisticsForTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateColumnStatisticsForTableInput(catalogId: \(String(describing: catalogId)), columnStatisticsList: \(String(describing: columnStatisticsList)), databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)))"}
}

extension UpdateColumnStatisticsForTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnStatisticsList = "ColumnStatisticsList"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let columnStatisticsList = columnStatisticsList {
            var columnStatisticsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnStatisticsList)
            for updatecolumnstatisticslist0 in columnStatisticsList {
                try columnStatisticsListContainer.encode(updatecolumnstatisticslist0)
            }
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct UpdateColumnStatisticsForTableInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateColumnStatisticsForTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateColumnStatisticsForTableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateColumnStatisticsForTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateColumnStatisticsForTableInput>
    public typealias MOutput = OperationOutput<UpdateColumnStatisticsForTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateColumnStatisticsForTableOutputError>
}

public struct UpdateColumnStatisticsForTableInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateColumnStatisticsForTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateColumnStatisticsForTableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateColumnStatisticsForTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateColumnStatisticsForTableInput>
    public typealias MOutput = OperationOutput<UpdateColumnStatisticsForTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateColumnStatisticsForTableOutputError>
}

public struct UpdateColumnStatisticsForTableInput: Equatable {
    /// <p>The ID of the Data Catalog where the partitions in question reside.
    ///       If none is supplied, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>A list of the column statistics.</p>
    public let columnStatisticsList: [ColumnStatistics]?
    /// <p>The name of the catalog database where the partitions reside.</p>
    public let databaseName: String?
    /// <p>The name of the partitions' table.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        columnStatisticsList: [ColumnStatistics]? = nil,
        databaseName: String? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnStatisticsList = columnStatisticsList
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct UpdateColumnStatisticsForTableInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let columnStatisticsList: [ColumnStatistics]?
}

extension UpdateColumnStatisticsForTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnStatisticsList = "ColumnStatisticsList"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let columnStatisticsListContainer = try containerValues.decodeIfPresent([ColumnStatistics?].self, forKey: .columnStatisticsList)
        var columnStatisticsListDecoded0:[ColumnStatistics]? = nil
        if let columnStatisticsListContainer = columnStatisticsListContainer {
            columnStatisticsListDecoded0 = [ColumnStatistics]()
            for structure0 in columnStatisticsListContainer {
                if let structure0 = structure0 {
                    columnStatisticsListDecoded0?.append(structure0)
                }
            }
        }
        columnStatisticsList = columnStatisticsListDecoded0
    }
}

extension UpdateColumnStatisticsForTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateColumnStatisticsForTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateColumnStatisticsForTableOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateColumnStatisticsForTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateColumnStatisticsForTableOutputResponse(errors: \(String(describing: errors)))"}
}

extension UpdateColumnStatisticsForTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateColumnStatisticsForTableOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct UpdateColumnStatisticsForTableOutputResponse: Equatable {
    /// <p>List of ColumnStatisticsErrors.</p>
    public let errors: [ColumnStatisticsError]?

    public init (
        errors: [ColumnStatisticsError]? = nil
    )
    {
        self.errors = errors
    }
}

struct UpdateColumnStatisticsForTableOutputResponseBody: Equatable {
    public let errors: [ColumnStatisticsError]?
}

extension UpdateColumnStatisticsForTableOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([ColumnStatisticsError?].self, forKey: .errors)
        var errorsDecoded0:[ColumnStatisticsError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ColumnStatisticsError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct UpdateConnectionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

extension UpdateConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionInput(catalogId: \(String(describing: catalogId)), connectionInput: \(String(describing: connectionInput)), name: \(String(describing: name)))"}
}

extension UpdateConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case connectionInput = "ConnectionInput"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let connectionInput = connectionInput {
            try encodeContainer.encode(connectionInput, forKey: .connectionInput)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInput: Equatable {
    /// <p>The ID of the Data Catalog in which the connection resides. If none is provided, the AWS
    ///       account ID is used by default.</p>
    public let catalogId: String?
    /// <p>A <code>ConnectionInput</code> object that redefines the connection
    ///       in question.</p>
    public let connectionInput: ConnectionInput?
    /// <p>The name of the connection definition to update.</p>
    public let name: String?

    public init (
        catalogId: String? = nil,
        connectionInput: ConnectionInput? = nil,
        name: String? = nil
    )
    {
        self.catalogId = catalogId
        self.connectionInput = connectionInput
        self.name = name
    }
}

struct UpdateConnectionInputBody: Equatable {
    public let catalogId: String?
    public let name: String?
    public let connectionInput: ConnectionInput?
}

extension UpdateConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case connectionInput = "ConnectionInput"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let connectionInputDecoded = try containerValues.decodeIfPresent(ConnectionInput.self, forKey: .connectionInput)
        connectionInput = connectionInputDecoded
    }
}

extension UpdateConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionOutputResponse()"}
}

extension UpdateConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateConnectionOutputResponse: Equatable {

    public init() {}
}

struct UpdateConnectionOutputResponseBody: Equatable {
}

extension UpdateConnectionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateCrawlerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCrawlerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCrawlerInput>
    public typealias MOutput = OperationOutput<UpdateCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCrawlerOutputError>
}

extension UpdateCrawlerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCrawlerInput(classifiers: \(String(describing: classifiers)), configuration: \(String(describing: configuration)), crawlerSecurityConfiguration: \(String(describing: crawlerSecurityConfiguration)), databaseName: \(String(describing: databaseName)), description: \(String(describing: description)), lineageConfiguration: \(String(describing: lineageConfiguration)), name: \(String(describing: name)), recrawlPolicy: \(String(describing: recrawlPolicy)), role: \(String(describing: role)), schedule: \(String(describing: schedule)), schemaChangePolicy: \(String(describing: schemaChangePolicy)), tablePrefix: \(String(describing: tablePrefix)), targets: \(String(describing: targets)))"}
}

extension UpdateCrawlerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classifiers = "Classifiers"
        case configuration = "Configuration"
        case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
        case databaseName = "DatabaseName"
        case description = "Description"
        case lineageConfiguration = "LineageConfiguration"
        case name = "Name"
        case recrawlPolicy = "RecrawlPolicy"
        case role = "Role"
        case schedule = "Schedule"
        case schemaChangePolicy = "SchemaChangePolicy"
        case tablePrefix = "TablePrefix"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classifiers = classifiers {
            var classifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .classifiers)
            for classifiernamelist0 in classifiers {
                try classifiersContainer.encode(classifiernamelist0)
            }
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let crawlerSecurityConfiguration = crawlerSecurityConfiguration {
            try encodeContainer.encode(crawlerSecurityConfiguration, forKey: .crawlerSecurityConfiguration)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lineageConfiguration = lineageConfiguration {
            try encodeContainer.encode(lineageConfiguration, forKey: .lineageConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recrawlPolicy = recrawlPolicy {
            try encodeContainer.encode(recrawlPolicy, forKey: .recrawlPolicy)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let schemaChangePolicy = schemaChangePolicy {
            try encodeContainer.encode(schemaChangePolicy, forKey: .schemaChangePolicy)
        }
        if let tablePrefix = tablePrefix {
            try encodeContainer.encode(tablePrefix, forKey: .tablePrefix)
        }
        if let targets = targets {
            try encodeContainer.encode(targets, forKey: .targets)
        }
    }
}

public struct UpdateCrawlerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCrawlerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCrawlerInput>
    public typealias MOutput = OperationOutput<UpdateCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCrawlerOutputError>
}

public struct UpdateCrawlerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCrawlerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCrawlerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCrawlerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCrawlerInput>
    public typealias MOutput = OperationOutput<UpdateCrawlerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCrawlerOutputError>
}

public struct UpdateCrawlerInput: Equatable {
    /// <p>A list of custom classifiers that the user
    ///       has registered. By default, all built-in classifiers are included in a crawl,
    ///       but these custom classifiers always override the default classifiers
    ///       for a given classification.</p>
    public let classifiers: [String]?
    /// <p>Crawler configuration information. This versioned JSON string allows users
    ///         to specify aspects of a crawler's behavior.
    ///         For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html">Configuring a Crawler</a>.</p>
    public let configuration: String?
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used by this
    ///       crawler.</p>
    public let crawlerSecurityConfiguration: String?
    /// <p>The AWS Glue database where results are stored, such as:
    ///         <code>arn:aws:daylight:us-east-1::database/sometable/*</code>.</p>
    public let databaseName: String?
    /// <p>A description of the new crawler.</p>
    public let description: String?
    /// <p>Specifies data lineage configuration settings for the crawler.</p>
    public let lineageConfiguration: LineageConfiguration?
    /// <p>Name of the new crawler.</p>
    public let name: String?
    /// <p>A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.</p>
    public let recrawlPolicy: RecrawlPolicy?
    /// <p>The IAM role or Amazon Resource Name (ARN) of an IAM role that is used by the new crawler
    ///       to access customer resources.</p>
    public let role: String?
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run
    ///       something every day at 12:15 UTC, you would specify:
    ///       <code>cron(15 12 * * ? *)</code>.</p>
    public let schedule: String?
    /// <p>The policy for the crawler's update and deletion behavior.</p>
    public let schemaChangePolicy: SchemaChangePolicy?
    /// <p>The table prefix used for catalog tables that are created.</p>
    public let tablePrefix: String?
    /// <p>A list of targets to crawl.</p>
    public let targets: CrawlerTargets?

    public init (
        classifiers: [String]? = nil,
        configuration: String? = nil,
        crawlerSecurityConfiguration: String? = nil,
        databaseName: String? = nil,
        description: String? = nil,
        lineageConfiguration: LineageConfiguration? = nil,
        name: String? = nil,
        recrawlPolicy: RecrawlPolicy? = nil,
        role: String? = nil,
        schedule: String? = nil,
        schemaChangePolicy: SchemaChangePolicy? = nil,
        tablePrefix: String? = nil,
        targets: CrawlerTargets? = nil
    )
    {
        self.classifiers = classifiers
        self.configuration = configuration
        self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
        self.databaseName = databaseName
        self.description = description
        self.lineageConfiguration = lineageConfiguration
        self.name = name
        self.recrawlPolicy = recrawlPolicy
        self.role = role
        self.schedule = schedule
        self.schemaChangePolicy = schemaChangePolicy
        self.tablePrefix = tablePrefix
        self.targets = targets
    }
}

struct UpdateCrawlerInputBody: Equatable {
    public let name: String?
    public let role: String?
    public let databaseName: String?
    public let description: String?
    public let targets: CrawlerTargets?
    public let schedule: String?
    public let classifiers: [String]?
    public let tablePrefix: String?
    public let schemaChangePolicy: SchemaChangePolicy?
    public let recrawlPolicy: RecrawlPolicy?
    public let lineageConfiguration: LineageConfiguration?
    public let configuration: String?
    public let crawlerSecurityConfiguration: String?
}

extension UpdateCrawlerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case classifiers = "Classifiers"
        case configuration = "Configuration"
        case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
        case databaseName = "DatabaseName"
        case description = "Description"
        case lineageConfiguration = "LineageConfiguration"
        case name = "Name"
        case recrawlPolicy = "RecrawlPolicy"
        case role = "Role"
        case schedule = "Schedule"
        case schemaChangePolicy = "SchemaChangePolicy"
        case tablePrefix = "TablePrefix"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetsDecoded = try containerValues.decodeIfPresent(CrawlerTargets.self, forKey: .targets)
        targets = targetsDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let classifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .classifiers)
        var classifiersDecoded0:[String]? = nil
        if let classifiersContainer = classifiersContainer {
            classifiersDecoded0 = [String]()
            for string0 in classifiersContainer {
                if let string0 = string0 {
                    classifiersDecoded0?.append(string0)
                }
            }
        }
        classifiers = classifiersDecoded0
        let tablePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tablePrefix)
        tablePrefix = tablePrefixDecoded
        let schemaChangePolicyDecoded = try containerValues.decodeIfPresent(SchemaChangePolicy.self, forKey: .schemaChangePolicy)
        schemaChangePolicy = schemaChangePolicyDecoded
        let recrawlPolicyDecoded = try containerValues.decodeIfPresent(RecrawlPolicy.self, forKey: .recrawlPolicy)
        recrawlPolicy = recrawlPolicyDecoded
        let lineageConfigurationDecoded = try containerValues.decodeIfPresent(LineageConfiguration.self, forKey: .lineageConfiguration)
        lineageConfiguration = lineageConfigurationDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configuration)
        configuration = configurationDecoded
        let crawlerSecurityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .crawlerSecurityConfiguration)
        crawlerSecurityConfiguration = crawlerSecurityConfigurationDecoded
    }
}

extension UpdateCrawlerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCrawlerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CrawlerRunningException" : self = .crawlerRunningException(try CrawlerRunningException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCrawlerOutputError: Equatable {
    case crawlerRunningException(CrawlerRunningException)
    case entityNotFoundException(EntityNotFoundException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCrawlerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCrawlerOutputResponse()"}
}

extension UpdateCrawlerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCrawlerOutputResponse: Equatable {

    public init() {}
}

struct UpdateCrawlerOutputResponseBody: Equatable {
}

extension UpdateCrawlerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateCrawlerScheduleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCrawlerScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCrawlerScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCrawlerScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCrawlerScheduleInput>
    public typealias MOutput = OperationOutput<UpdateCrawlerScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCrawlerScheduleOutputError>
}

extension UpdateCrawlerScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCrawlerScheduleInput(crawlerName: \(String(describing: crawlerName)), schedule: \(String(describing: schedule)))"}
}

extension UpdateCrawlerScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crawlerName = "CrawlerName"
        case schedule = "Schedule"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawlerName = crawlerName {
            try encodeContainer.encode(crawlerName, forKey: .crawlerName)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
    }
}

public struct UpdateCrawlerScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCrawlerScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCrawlerScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCrawlerScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCrawlerScheduleInput>
    public typealias MOutput = OperationOutput<UpdateCrawlerScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCrawlerScheduleOutputError>
}

public struct UpdateCrawlerScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCrawlerScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCrawlerScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCrawlerScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCrawlerScheduleInput>
    public typealias MOutput = OperationOutput<UpdateCrawlerScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCrawlerScheduleOutputError>
}

public struct UpdateCrawlerScheduleInput: Equatable {
    /// <p>The name of the crawler whose schedule to update.</p>
    public let crawlerName: String?
    /// <p>The updated <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run
    ///       something every day at 12:15 UTC, you would specify:
    ///       <code>cron(15 12 * * ? *)</code>.</p>
    public let schedule: String?

    public init (
        crawlerName: String? = nil,
        schedule: String? = nil
    )
    {
        self.crawlerName = crawlerName
        self.schedule = schedule
    }
}

struct UpdateCrawlerScheduleInputBody: Equatable {
    public let crawlerName: String?
    public let schedule: String?
}

extension UpdateCrawlerScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case crawlerName = "CrawlerName"
        case schedule = "Schedule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .crawlerName)
        crawlerName = crawlerNameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
    }
}

extension UpdateCrawlerScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCrawlerScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchedulerTransitioningException" : self = .schedulerTransitioningException(try SchedulerTransitioningException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCrawlerScheduleOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case schedulerTransitioningException(SchedulerTransitioningException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCrawlerScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCrawlerScheduleOutputResponse()"}
}

extension UpdateCrawlerScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCrawlerScheduleOutputResponse: Equatable {

    public init() {}
}

struct UpdateCrawlerScheduleOutputResponseBody: Equatable {
}

extension UpdateCrawlerScheduleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateCsvClassifierRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowSingleColumn = "AllowSingleColumn"
        case containsHeader = "ContainsHeader"
        case delimiter = "Delimiter"
        case disableValueTrimming = "DisableValueTrimming"
        case header = "Header"
        case name = "Name"
        case quoteSymbol = "QuoteSymbol"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSingleColumn = allowSingleColumn {
            try encodeContainer.encode(allowSingleColumn, forKey: .allowSingleColumn)
        }
        if let containsHeader = containsHeader {
            try encodeContainer.encode(containsHeader.rawValue, forKey: .containsHeader)
        }
        if let delimiter = delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let disableValueTrimming = disableValueTrimming {
            try encodeContainer.encode(disableValueTrimming, forKey: .disableValueTrimming)
        }
        if let header = header {
            var headerContainer = encodeContainer.nestedUnkeyedContainer(forKey: .header)
            for csvheader0 in header {
                try headerContainer.encode(csvheader0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quoteSymbol = quoteSymbol {
            try encodeContainer.encode(quoteSymbol, forKey: .quoteSymbol)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let quoteSymbolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteSymbol)
        quoteSymbol = quoteSymbolDecoded
        let containsHeaderDecoded = try containerValues.decodeIfPresent(CsvHeaderOption.self, forKey: .containsHeader)
        containsHeader = containsHeaderDecoded
        let headerContainer = try containerValues.decodeIfPresent([String?].self, forKey: .header)
        var headerDecoded0:[String]? = nil
        if let headerContainer = headerContainer {
            headerDecoded0 = [String]()
            for string0 in headerContainer {
                if let string0 = string0 {
                    headerDecoded0?.append(string0)
                }
            }
        }
        header = headerDecoded0
        let disableValueTrimmingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableValueTrimming)
        disableValueTrimming = disableValueTrimmingDecoded
        let allowSingleColumnDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSingleColumn)
        allowSingleColumn = allowSingleColumnDecoded
    }
}

extension UpdateCsvClassifierRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCsvClassifierRequest(allowSingleColumn: \(String(describing: allowSingleColumn)), containsHeader: \(String(describing: containsHeader)), delimiter: \(String(describing: delimiter)), disableValueTrimming: \(String(describing: disableValueTrimming)), header: \(String(describing: header)), name: \(String(describing: name)), quoteSymbol: \(String(describing: quoteSymbol)))"}
}

/// <p>Specifies a custom CSV classifier to be updated.</p>
public struct UpdateCsvClassifierRequest: Equatable {
    /// <p>Enables the processing of files that contain only one column.</p>
    public let allowSingleColumn: Bool?
    /// <p>Indicates whether the CSV file contains a header.</p>
    public let containsHeader: CsvHeaderOption?
    /// <p>A custom symbol to denote what separates each column entry in the row.</p>
    public let delimiter: String?
    /// <p>Specifies not to trim values before identifying the type of column values. The default value is true.</p>
    public let disableValueTrimming: Bool?
    /// <p>A list of strings representing column names.</p>
    public let header: [String]?
    /// <p>The name of the classifier.</p>
    public let name: String?
    /// <p>A custom symbol to denote what combines content into a single column value. It must be
    ///       different from the column delimiter.</p>
    public let quoteSymbol: String?

    public init (
        allowSingleColumn: Bool? = nil,
        containsHeader: CsvHeaderOption? = nil,
        delimiter: String? = nil,
        disableValueTrimming: Bool? = nil,
        header: [String]? = nil,
        name: String? = nil,
        quoteSymbol: String? = nil
    )
    {
        self.allowSingleColumn = allowSingleColumn
        self.containsHeader = containsHeader
        self.delimiter = delimiter
        self.disableValueTrimming = disableValueTrimming
        self.header = header
        self.name = name
        self.quoteSymbol = quoteSymbol
    }
}

public struct UpdateDatabaseInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatabaseInput>
    public typealias MOutput = OperationOutput<UpdateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatabaseOutputError>
}

extension UpdateDatabaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatabaseInput(catalogId: \(String(describing: catalogId)), databaseInput: \(String(describing: databaseInput)), name: \(String(describing: name)))"}
}

extension UpdateDatabaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseInput = "DatabaseInput"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseInput = databaseInput {
            try encodeContainer.encode(databaseInput, forKey: .databaseInput)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateDatabaseInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatabaseInput>
    public typealias MOutput = OperationOutput<UpdateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatabaseOutputError>
}

public struct UpdateDatabaseInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatabaseInput>
    public typealias MOutput = OperationOutput<UpdateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatabaseOutputError>
}

public struct UpdateDatabaseInput: Equatable {
    /// <p>The ID of the Data Catalog in which the metadata database resides. If none is provided,
    ///       the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>A <code>DatabaseInput</code> object specifying the new definition
    ///       of the metadata database in the catalog.</p>
    public let databaseInput: DatabaseInput?
    /// <p>The name of the database to update in the catalog. For Hive
    ///       compatibility, this is folded to lowercase.</p>
    public let name: String?

    public init (
        catalogId: String? = nil,
        databaseInput: DatabaseInput? = nil,
        name: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseInput = databaseInput
        self.name = name
    }
}

struct UpdateDatabaseInputBody: Equatable {
    public let catalogId: String?
    public let name: String?
    public let databaseInput: DatabaseInput?
}

extension UpdateDatabaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseInput = "DatabaseInput"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let databaseInputDecoded = try containerValues.decodeIfPresent(DatabaseInput.self, forKey: .databaseInput)
        databaseInput = databaseInputDecoded
    }
}

extension UpdateDatabaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatabaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatabaseOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatabaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatabaseOutputResponse()"}
}

extension UpdateDatabaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatabaseOutputResponse: Equatable {

    public init() {}
}

struct UpdateDatabaseOutputResponseBody: Equatable {
}

extension UpdateDatabaseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDevEndpointInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDevEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDevEndpointInput>
    public typealias MOutput = OperationOutput<UpdateDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDevEndpointOutputError>
}

extension UpdateDevEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDevEndpointInput(addArguments: \(String(describing: addArguments)), addPublicKeys: \(String(describing: addPublicKeys)), customLibraries: \(String(describing: customLibraries)), deleteArguments: \(String(describing: deleteArguments)), deletePublicKeys: \(String(describing: deletePublicKeys)), endpointName: \(String(describing: endpointName)), publicKey: \(String(describing: publicKey)), updateEtlLibraries: \(String(describing: updateEtlLibraries)))"}
}

extension UpdateDevEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addArguments = "AddArguments"
        case addPublicKeys = "AddPublicKeys"
        case customLibraries = "CustomLibraries"
        case deleteArguments = "DeleteArguments"
        case deletePublicKeys = "DeletePublicKeys"
        case endpointName = "EndpointName"
        case publicKey = "PublicKey"
        case updateEtlLibraries = "UpdateEtlLibraries"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addArguments = addArguments {
            var addArgumentsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .addArguments)
            for (dictKey0, mapvalue0) in addArguments {
                try addArgumentsContainer.encode(mapvalue0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let addPublicKeys = addPublicKeys {
            var addPublicKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addPublicKeys)
            for publickeyslist0 in addPublicKeys {
                try addPublicKeysContainer.encode(publickeyslist0)
            }
        }
        if let customLibraries = customLibraries {
            try encodeContainer.encode(customLibraries, forKey: .customLibraries)
        }
        if let deleteArguments = deleteArguments {
            var deleteArgumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deleteArguments)
            for stringlist0 in deleteArguments {
                try deleteArgumentsContainer.encode(stringlist0)
            }
        }
        if let deletePublicKeys = deletePublicKeys {
            var deletePublicKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deletePublicKeys)
            for publickeyslist0 in deletePublicKeys {
                try deletePublicKeysContainer.encode(publickeyslist0)
            }
        }
        if let endpointName = endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
        if let publicKey = publicKey {
            try encodeContainer.encode(publicKey, forKey: .publicKey)
        }
        if updateEtlLibraries != false {
            try encodeContainer.encode(updateEtlLibraries, forKey: .updateEtlLibraries)
        }
    }
}

public struct UpdateDevEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDevEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDevEndpointInput>
    public typealias MOutput = OperationOutput<UpdateDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDevEndpointOutputError>
}

public struct UpdateDevEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDevEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDevEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDevEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDevEndpointInput>
    public typealias MOutput = OperationOutput<UpdateDevEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDevEndpointOutputError>
}

public struct UpdateDevEndpointInput: Equatable {
    /// <p>The map of arguments to add the map of arguments used to configure the
    ///         <code>DevEndpoint</code>.</p>
    /// 		
    /// 	        <p>Valid arguments are:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>
    ///                   <code>"--enable-glue-datacatalog": ""</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"GLUE_PYTHON_VERSION": "3"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"GLUE_PYTHON_VERSION": "2"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    /// 	
    ///          <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
    public let addArguments: [String:String]?
    /// <p>The list of public keys for the <code>DevEndpoint</code> to use.</p>
    public let addPublicKeys: [String]?
    /// <p>Custom Python or Java libraries to be loaded in the <code>DevEndpoint</code>.</p>
    public let customLibraries: DevEndpointCustomLibraries?
    /// <p>The list of argument keys to be deleted from the map of arguments used to configure the
    ///         <code>DevEndpoint</code>.</p>
    public let deleteArguments: [String]?
    /// <p>The list of public keys to be deleted from the <code>DevEndpoint</code>.</p>
    public let deletePublicKeys: [String]?
    /// <p>The name of the <code>DevEndpoint</code> to be updated.</p>
    public let endpointName: String?
    /// <p>The public key for the <code>DevEndpoint</code> to use.</p>
    public let publicKey: String?
    /// <p>
    ///             <code>True</code> if the list of custom libraries to be loaded in the development endpoint
    ///       needs to be updated, or <code>False</code> if otherwise.</p>
    public let updateEtlLibraries: Bool

    public init (
        addArguments: [String:String]? = nil,
        addPublicKeys: [String]? = nil,
        customLibraries: DevEndpointCustomLibraries? = nil,
        deleteArguments: [String]? = nil,
        deletePublicKeys: [String]? = nil,
        endpointName: String? = nil,
        publicKey: String? = nil,
        updateEtlLibraries: Bool = false
    )
    {
        self.addArguments = addArguments
        self.addPublicKeys = addPublicKeys
        self.customLibraries = customLibraries
        self.deleteArguments = deleteArguments
        self.deletePublicKeys = deletePublicKeys
        self.endpointName = endpointName
        self.publicKey = publicKey
        self.updateEtlLibraries = updateEtlLibraries
    }
}

struct UpdateDevEndpointInputBody: Equatable {
    public let endpointName: String?
    public let publicKey: String?
    public let addPublicKeys: [String]?
    public let deletePublicKeys: [String]?
    public let customLibraries: DevEndpointCustomLibraries?
    public let updateEtlLibraries: Bool
    public let deleteArguments: [String]?
    public let addArguments: [String:String]?
}

extension UpdateDevEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addArguments = "AddArguments"
        case addPublicKeys = "AddPublicKeys"
        case customLibraries = "CustomLibraries"
        case deleteArguments = "DeleteArguments"
        case deletePublicKeys = "DeletePublicKeys"
        case endpointName = "EndpointName"
        case publicKey = "PublicKey"
        case updateEtlLibraries = "UpdateEtlLibraries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let publicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
        let addPublicKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .addPublicKeys)
        var addPublicKeysDecoded0:[String]? = nil
        if let addPublicKeysContainer = addPublicKeysContainer {
            addPublicKeysDecoded0 = [String]()
            for string0 in addPublicKeysContainer {
                if let string0 = string0 {
                    addPublicKeysDecoded0?.append(string0)
                }
            }
        }
        addPublicKeys = addPublicKeysDecoded0
        let deletePublicKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deletePublicKeys)
        var deletePublicKeysDecoded0:[String]? = nil
        if let deletePublicKeysContainer = deletePublicKeysContainer {
            deletePublicKeysDecoded0 = [String]()
            for string0 in deletePublicKeysContainer {
                if let string0 = string0 {
                    deletePublicKeysDecoded0?.append(string0)
                }
            }
        }
        deletePublicKeys = deletePublicKeysDecoded0
        let customLibrariesDecoded = try containerValues.decodeIfPresent(DevEndpointCustomLibraries.self, forKey: .customLibraries)
        customLibraries = customLibrariesDecoded
        let updateEtlLibrariesDecoded = try containerValues.decode(Bool.self, forKey: .updateEtlLibraries)
        updateEtlLibraries = updateEtlLibrariesDecoded
        let deleteArgumentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deleteArguments)
        var deleteArgumentsDecoded0:[String]? = nil
        if let deleteArgumentsContainer = deleteArgumentsContainer {
            deleteArgumentsDecoded0 = [String]()
            for string0 in deleteArgumentsContainer {
                if let string0 = string0 {
                    deleteArgumentsDecoded0?.append(string0)
                }
            }
        }
        deleteArguments = deleteArgumentsDecoded0
        let addArgumentsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .addArguments)
        var addArgumentsDecoded0: [String:String]? = nil
        if let addArgumentsContainer = addArgumentsContainer {
            addArgumentsDecoded0 = [String:String]()
            for (key0, genericstring0) in addArgumentsContainer {
                if let genericstring0 = genericstring0 {
                    addArgumentsDecoded0?[key0] = genericstring0
                }
            }
        }
        addArguments = addArgumentsDecoded0
    }
}

extension UpdateDevEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDevEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDevEndpointOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDevEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDevEndpointOutputResponse()"}
}

extension UpdateDevEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDevEndpointOutputResponse: Equatable {

    public init() {}
}

struct UpdateDevEndpointOutputResponseBody: Equatable {
}

extension UpdateDevEndpointOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateGrokClassifierRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classification = "Classification"
        case customPatterns = "CustomPatterns"
        case grokPattern = "GrokPattern"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let customPatterns = customPatterns {
            try encodeContainer.encode(customPatterns, forKey: .customPatterns)
        }
        if let grokPattern = grokPattern {
            try encodeContainer.encode(grokPattern, forKey: .grokPattern)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let classificationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .classification)
        classification = classificationDecoded
        let grokPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grokPattern)
        grokPattern = grokPatternDecoded
        let customPatternsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customPatterns)
        customPatterns = customPatternsDecoded
    }
}

extension UpdateGrokClassifierRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGrokClassifierRequest(classification: \(String(describing: classification)), customPatterns: \(String(describing: customPatterns)), grokPattern: \(String(describing: grokPattern)), name: \(String(describing: name)))"}
}

/// <p>Specifies a grok classifier to update when passed to
///       <code>UpdateClassifier</code>.</p>
public struct UpdateGrokClassifierRequest: Equatable {
    /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs,
    ///       Amazon CloudWatch Logs, and so on.</p>
    public let classification: String?
    /// <p>Optional custom grok patterns used by this classifier.</p>
    public let customPatterns: String?
    /// <p>The grok pattern used by this classifier.</p>
    public let grokPattern: String?
    /// <p>The name of the <code>GrokClassifier</code>.</p>
    public let name: String?

    public init (
        classification: String? = nil,
        customPatterns: String? = nil,
        grokPattern: String? = nil,
        name: String? = nil
    )
    {
        self.classification = classification
        self.customPatterns = customPatterns
        self.grokPattern = grokPattern
        self.name = name
    }
}

public struct UpdateJobInputBodyMiddleware: Middleware {
    public let id: String = "UpdateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobInput>
    public typealias MOutput = OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobOutputError>
}

extension UpdateJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobInput(jobName: \(String(describing: jobName)), jobUpdate: \(String(describing: jobUpdate)))"}
}

extension UpdateJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobUpdate = "JobUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobUpdate = jobUpdate {
            try encodeContainer.encode(jobUpdate, forKey: .jobUpdate)
        }
    }
}

public struct UpdateJobInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobInput>
    public typealias MOutput = OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobOutputError>
}

public struct UpdateJobInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobInput>
    public typealias MOutput = OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobOutputError>
}

public struct UpdateJobInput: Equatable {
    /// <p>The name of the job definition to update.</p>
    public let jobName: String?
    /// <p>Specifies the values with which to update the job definition.</p>
    public let jobUpdate: JobUpdate?

    public init (
        jobName: String? = nil,
        jobUpdate: JobUpdate? = nil
    )
    {
        self.jobName = jobName
        self.jobUpdate = jobUpdate
    }
}

struct UpdateJobInputBody: Equatable {
    public let jobName: String?
    public let jobUpdate: JobUpdate?
}

extension UpdateJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
        case jobUpdate = "JobUpdate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobUpdateDecoded = try containerValues.decodeIfPresent(JobUpdate.self, forKey: .jobUpdate)
        jobUpdate = jobUpdateDecoded
    }
}

extension UpdateJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateJobOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobOutputResponse(jobName: \(String(describing: jobName)))"}
}

extension UpdateJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobName = output.jobName
        } else {
            self.jobName = nil
        }
    }
}

public struct UpdateJobOutputResponse: Equatable {
    /// <p>Returns the name of the updated job definition.</p>
    public let jobName: String?

    public init (
        jobName: String? = nil
    )
    {
        self.jobName = jobName
    }
}

struct UpdateJobOutputResponseBody: Equatable {
    public let jobName: String?
}

extension UpdateJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobName = "JobName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
    }
}

extension UpdateJsonClassifierRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jsonPath = "JsonPath"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonPath = jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let jsonPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
    }
}

extension UpdateJsonClassifierRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJsonClassifierRequest(jsonPath: \(String(describing: jsonPath)), name: \(String(describing: name)))"}
}

/// <p>Specifies a JSON classifier to be updated.</p>
public struct UpdateJsonClassifierRequest: Equatable {
    /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify.
    ///       AWS Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
    public let jsonPath: String?
    /// <p>The name of the classifier.</p>
    public let name: String?

    public init (
        jsonPath: String? = nil,
        name: String? = nil
    )
    {
        self.jsonPath = jsonPath
        self.name = name
    }
}

public struct UpdateMLTransformInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMLTransformInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMLTransformInput>
    public typealias MOutput = OperationOutput<UpdateMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMLTransformOutputError>
}

extension UpdateMLTransformInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMLTransformInput(description: \(String(describing: description)), glueVersion: \(String(describing: glueVersion)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), numberOfWorkers: \(String(describing: numberOfWorkers)), parameters: \(String(describing: parameters)), role: \(String(describing: role)), timeout: \(String(describing: timeout)), transformId: \(String(describing: transformId)), workerType: \(String(describing: workerType)))"}
}

extension UpdateMLTransformInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case glueVersion = "GlueVersion"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case numberOfWorkers = "NumberOfWorkers"
        case parameters = "Parameters"
        case role = "Role"
        case timeout = "Timeout"
        case transformId = "TransformId"
        case workerType = "WorkerType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let glueVersion = glueVersion {
            try encodeContainer.encode(glueVersion, forKey: .glueVersion)
        }
        if let maxCapacity = maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let maxRetries = maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberOfWorkers = numberOfWorkers {
            try encodeContainer.encode(numberOfWorkers, forKey: .numberOfWorkers)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let transformId = transformId {
            try encodeContainer.encode(transformId, forKey: .transformId)
        }
        if let workerType = workerType {
            try encodeContainer.encode(workerType.rawValue, forKey: .workerType)
        }
    }
}

public struct UpdateMLTransformInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMLTransformInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMLTransformInput>
    public typealias MOutput = OperationOutput<UpdateMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMLTransformOutputError>
}

public struct UpdateMLTransformInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMLTransformInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMLTransformInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMLTransformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMLTransformInput>
    public typealias MOutput = OperationOutput<UpdateMLTransformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMLTransformOutputError>
}

public struct UpdateMLTransformInput: Equatable {
    /// <p>A description of the transform. The default is an empty string.</p>
    public let description: String?
    /// <p>This value determines which version of AWS Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">AWS Glue Versions</a> in the developer guide.</p>
    public let glueVersion: String?
    /// <p>The number of AWS Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of
    ///       processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
    ///       information, see the <a href="https://aws.amazon.com/glue/pricing/">AWS Glue pricing
    ///         page</a>. </p>
    /// 		
    ///          <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
    public let maxCapacity: Double?
    /// <p>The maximum number of times to retry a task for this transform after a task run fails.</p>
    public let maxRetries: Int?
    /// <p>The unique name that you gave the transform when you created it.</p>
    public let name: String?
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when this task runs.</p>
    public let numberOfWorkers: Int?
    /// <p>The configuration parameters that are specific to the transform type (algorithm) used.
    ///       Conditionally dependent on the transform type.</p>
    public let parameters: TransformParameters?
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required
    ///       permissions.</p>
    public let role: String?
    /// <p>The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
    public let timeout: Int?
    /// <p>A unique identifier that was generated when the transform was created.</p>
    public let transformId: String?
    /// <p>The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///             <li>
    ///                <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p>
    ///             </li>
    ///          </ul>
    public let workerType: WorkerType?

    public init (
        description: String? = nil,
        glueVersion: String? = nil,
        maxCapacity: Double? = nil,
        maxRetries: Int? = nil,
        name: String? = nil,
        numberOfWorkers: Int? = nil,
        parameters: TransformParameters? = nil,
        role: String? = nil,
        timeout: Int? = nil,
        transformId: String? = nil,
        workerType: WorkerType? = nil
    )
    {
        self.description = description
        self.glueVersion = glueVersion
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.numberOfWorkers = numberOfWorkers
        self.parameters = parameters
        self.role = role
        self.timeout = timeout
        self.transformId = transformId
        self.workerType = workerType
    }
}

struct UpdateMLTransformInputBody: Equatable {
    public let transformId: String?
    public let name: String?
    public let description: String?
    public let parameters: TransformParameters?
    public let role: String?
    public let glueVersion: String?
    public let maxCapacity: Double?
    public let workerType: WorkerType?
    public let numberOfWorkers: Int?
    public let timeout: Int?
    public let maxRetries: Int?
}

extension UpdateMLTransformInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case glueVersion = "GlueVersion"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case numberOfWorkers = "NumberOfWorkers"
        case parameters = "Parameters"
        case role = "Role"
        case timeout = "Timeout"
        case transformId = "TransformId"
        case workerType = "WorkerType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(TransformParameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let glueVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueVersion)
        glueVersion = glueVersionDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let workerTypeDecoded = try containerValues.decodeIfPresent(WorkerType.self, forKey: .workerType)
        workerType = workerTypeDecoded
        let numberOfWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfWorkers)
        numberOfWorkers = numberOfWorkersDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
    }
}

extension UpdateMLTransformOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMLTransformOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMLTransformOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMLTransformOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMLTransformOutputResponse(transformId: \(String(describing: transformId)))"}
}

extension UpdateMLTransformOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateMLTransformOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transformId = output.transformId
        } else {
            self.transformId = nil
        }
    }
}

public struct UpdateMLTransformOutputResponse: Equatable {
    /// <p>The unique identifier for the transform that was updated.</p>
    public let transformId: String?

    public init (
        transformId: String? = nil
    )
    {
        self.transformId = transformId
    }
}

struct UpdateMLTransformOutputResponseBody: Equatable {
    public let transformId: String?
}

extension UpdateMLTransformOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transformId = "TransformId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformId)
        transformId = transformIdDecoded
    }
}

public struct UpdatePartitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePartitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePartitionInput>
    public typealias MOutput = OperationOutput<UpdatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePartitionOutputError>
}

extension UpdatePartitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePartitionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), partitionInput: \(String(describing: partitionInput)), partitionValueList: \(String(describing: partitionValueList)), tableName: \(String(describing: tableName)))"}
}

extension UpdatePartitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionInput = "PartitionInput"
        case partitionValueList = "PartitionValueList"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let partitionInput = partitionInput {
            try encodeContainer.encode(partitionInput, forKey: .partitionInput)
        }
        if let partitionValueList = partitionValueList {
            var partitionValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValueList)
            for boundedpartitionvaluelist0 in partitionValueList {
                try partitionValueListContainer.encode(boundedpartitionvaluelist0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct UpdatePartitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePartitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePartitionInput>
    public typealias MOutput = OperationOutput<UpdatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePartitionOutputError>
}

public struct UpdatePartitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePartitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePartitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePartitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePartitionInput>
    public typealias MOutput = OperationOutput<UpdatePartitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePartitionOutputError>
}

public struct UpdatePartitionInput: Equatable {
    /// <p>The ID of the Data Catalog where the partition to be updated resides. If none is provided,
    ///       the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database in which the table in question
    ///       resides.</p>
    public let databaseName: String?
    /// <p>The new partition object to update the partition to.</p>
    /// 	
    /// 	        <p>The <code>Values</code> property can't be changed. If you want to change the partition key values for a partition, delete and recreate the partition.</p>
    public let partitionInput: PartitionInput?
    /// <p>List of partition key values that define the partition to update.</p>
    public let partitionValueList: [String]?
    /// <p>The name of the table in which the partition to be updated is located.</p>
    public let tableName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        partitionInput: PartitionInput? = nil,
        partitionValueList: [String]? = nil,
        tableName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionInput = partitionInput
        self.partitionValueList = partitionValueList
        self.tableName = tableName
    }
}

struct UpdatePartitionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableName: String?
    public let partitionValueList: [String]?
    public let partitionInput: PartitionInput?
}

extension UpdatePartitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case partitionInput = "PartitionInput"
        case partitionValueList = "PartitionValueList"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let partitionValueListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionValueList)
        var partitionValueListDecoded0:[String]? = nil
        if let partitionValueListContainer = partitionValueListContainer {
            partitionValueListDecoded0 = [String]()
            for string0 in partitionValueListContainer {
                if let string0 = string0 {
                    partitionValueListDecoded0?.append(string0)
                }
            }
        }
        partitionValueList = partitionValueListDecoded0
        let partitionInputDecoded = try containerValues.decodeIfPresent(PartitionInput.self, forKey: .partitionInput)
        partitionInput = partitionInputDecoded
    }
}

extension UpdatePartitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePartitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePartitionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePartitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePartitionOutputResponse()"}
}

extension UpdatePartitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePartitionOutputResponse: Equatable {

    public init() {}
}

struct UpdatePartitionOutputResponseBody: Equatable {
}

extension UpdatePartitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRegistryInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRegistryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegistryInput>
    public typealias MOutput = OperationOutput<UpdateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegistryOutputError>
}

extension UpdateRegistryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegistryInput(description: \(String(describing: description)), registryId: \(String(describing: registryId)))"}
}

extension UpdateRegistryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case registryId = "RegistryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
    }
}

public struct UpdateRegistryInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRegistryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegistryInput>
    public typealias MOutput = OperationOutput<UpdateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegistryOutputError>
}

public struct UpdateRegistryInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRegistryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegistryInput>
    public typealias MOutput = OperationOutput<UpdateRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegistryOutputError>
}

public struct UpdateRegistryInput: Equatable {
    /// <p>A description of the registry. If description is not provided, this field will not be updated.</p>
    public let description: String?
    /// <p>This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).</p>
    public let registryId: RegistryId?

    public init (
        description: String? = nil,
        registryId: RegistryId? = nil
    )
    {
        self.description = description
        self.registryId = registryId
    }
}

struct UpdateRegistryInputBody: Equatable {
    public let registryId: RegistryId?
    public let description: String?
}

extension UpdateRegistryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case registryId = "RegistryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(RegistryId.self, forKey: .registryId)
        registryId = registryIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRegistryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRegistryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRegistryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRegistryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegistryOutputResponse(registryArn: \(String(describing: registryArn)), registryName: \(String(describing: registryName)))"}
}

extension UpdateRegistryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRegistryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.registryArn = output.registryArn
            self.registryName = output.registryName
        } else {
            self.registryArn = nil
            self.registryName = nil
        }
    }
}

public struct UpdateRegistryOutputResponse: Equatable {
    /// <p>The Amazon Resource name (ARN) of the updated registry.</p>
    public let registryArn: String?
    /// <p>The name of the updated registry.</p>
    public let registryName: String?

    public init (
        registryArn: String? = nil,
        registryName: String? = nil
    )
    {
        self.registryArn = registryArn
        self.registryName = registryName
    }
}

struct UpdateRegistryOutputResponseBody: Equatable {
    public let registryName: String?
    public let registryArn: String?
}

extension UpdateRegistryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
    }
}

public struct UpdateSchemaInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSchemaOutputError>
}

extension UpdateSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSchemaInput(compatibility: \(String(describing: compatibility)), description: \(String(describing: description)), schemaId: \(String(describing: schemaId)), schemaVersionNumber: \(String(describing: schemaVersionNumber)))"}
}

extension UpdateSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compatibility = "Compatibility"
        case description = "Description"
        case schemaId = "SchemaId"
        case schemaVersionNumber = "SchemaVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibility = compatibility {
            try encodeContainer.encode(compatibility.rawValue, forKey: .compatibility)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let schemaId = schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let schemaVersionNumber = schemaVersionNumber {
            try encodeContainer.encode(schemaVersionNumber, forKey: .schemaVersionNumber)
        }
    }
}

public struct UpdateSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSchemaOutputError>
}

public struct UpdateSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSchemaOutputError>
}

public struct UpdateSchemaInput: Equatable {
    /// <p>The new compatibility setting for the schema.</p>
    public let compatibility: Compatibility?
    /// <p>The new description for the schema.</p>
    public let description: String?
    /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>SchemaId$SchemaName: The name of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    ///             </li>
    ///          </ul>
    public let schemaId: SchemaId?
    /// <p>Version number required for check pointing. One of <code>VersionNumber</code> or <code>Compatibility</code> has to be provided.</p>
    public let schemaVersionNumber: SchemaVersionNumber?

    public init (
        compatibility: Compatibility? = nil,
        description: String? = nil,
        schemaId: SchemaId? = nil,
        schemaVersionNumber: SchemaVersionNumber? = nil
    )
    {
        self.compatibility = compatibility
        self.description = description
        self.schemaId = schemaId
        self.schemaVersionNumber = schemaVersionNumber
    }
}

struct UpdateSchemaInputBody: Equatable {
    public let schemaId: SchemaId?
    public let schemaVersionNumber: SchemaVersionNumber?
    public let compatibility: Compatibility?
    public let description: String?
}

extension UpdateSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibility = "Compatibility"
        case description = "Description"
        case schemaId = "SchemaId"
        case schemaVersionNumber = "SchemaVersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(SchemaId.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaVersionNumberDecoded = try containerValues.decodeIfPresent(SchemaVersionNumber.self, forKey: .schemaVersionNumber)
        schemaVersionNumber = schemaVersionNumberDecoded
        let compatibilityDecoded = try containerValues.decodeIfPresent(Compatibility.self, forKey: .compatibility)
        compatibility = compatibilityDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSchemaOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSchemaOutputResponse(registryName: \(String(describing: registryName)), schemaArn: \(String(describing: schemaArn)), schemaName: \(String(describing: schemaName)))"}
}

extension UpdateSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.registryName = output.registryName
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
        } else {
            self.registryName = nil
            self.schemaArn = nil
            self.schemaName = nil
        }
    }
}

public struct UpdateSchemaOutputResponse: Equatable {
    /// <p>The name of the registry that contains the schema.</p>
    public let registryName: String?
    /// <p>The Amazon Resource Name (ARN) of the schema.</p>
    public let schemaArn: String?
    /// <p>The name of the schema.</p>
    public let schemaName: String?

    public init (
        registryName: String? = nil,
        schemaArn: String? = nil,
        schemaName: String? = nil
    )
    {
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaName = schemaName
    }
}

struct UpdateSchemaOutputResponseBody: Equatable {
    public let schemaArn: String?
    public let schemaName: String?
    public let registryName: String?
}

extension UpdateSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryName = "RegistryName"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryName)
        registryName = registryNameDecoded
    }
}

public struct UpdateTableInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTableInput>
    public typealias MOutput = OperationOutput<UpdateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTableOutputError>
}

extension UpdateTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTableInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), skipArchive: \(String(describing: skipArchive)), tableInput: \(String(describing: tableInput)))"}
}

extension UpdateTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case skipArchive = "SkipArchive"
        case tableInput = "TableInput"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let skipArchive = skipArchive {
            try encodeContainer.encode(skipArchive, forKey: .skipArchive)
        }
        if let tableInput = tableInput {
            try encodeContainer.encode(tableInput, forKey: .tableInput)
        }
    }
}

public struct UpdateTableInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTableInput>
    public typealias MOutput = OperationOutput<UpdateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTableOutputError>
}

public struct UpdateTableInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTableInput>
    public typealias MOutput = OperationOutput<UpdateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTableOutputError>
}

public struct UpdateTableInput: Equatable {
    /// <p>The ID of the Data Catalog where the table resides. If none is provided, the AWS account
    ///       ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database in which the table resides. For Hive
    ///       compatibility, this name is entirely lowercase.</p>
    public let databaseName: String?
    /// <p>By default, <code>UpdateTable</code> always creates an archived version of the table
    ///       before updating it. However, if <code>skipArchive</code> is set to true,
    ///         <code>UpdateTable</code> does not create the archived version.</p>
    public let skipArchive: Bool?
    /// <p>An updated <code>TableInput</code> object to define the metadata table
    ///       in the catalog.</p>
    public let tableInput: TableInput?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        skipArchive: Bool? = nil,
        tableInput: TableInput? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.skipArchive = skipArchive
        self.tableInput = tableInput
    }
}

struct UpdateTableInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let tableInput: TableInput?
    public let skipArchive: Bool?
}

extension UpdateTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case skipArchive = "SkipArchive"
        case tableInput = "TableInput"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableInputDecoded = try containerValues.decodeIfPresent(TableInput.self, forKey: .tableInput)
        tableInput = tableInputDecoded
        let skipArchiveDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .skipArchive)
        skipArchive = skipArchiveDecoded
    }
}

extension UpdateTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTableOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTableOutputResponse()"}
}

extension UpdateTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTableOutputResponse: Equatable {

    public init() {}
}

struct UpdateTableOutputResponseBody: Equatable {
}

extension UpdateTableOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateTriggerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTriggerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTriggerInput>
    public typealias MOutput = OperationOutput<UpdateTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTriggerOutputError>
}

extension UpdateTriggerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTriggerInput(name: \(String(describing: name)), triggerUpdate: \(String(describing: triggerUpdate)))"}
}

extension UpdateTriggerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case triggerUpdate = "TriggerUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let triggerUpdate = triggerUpdate {
            try encodeContainer.encode(triggerUpdate, forKey: .triggerUpdate)
        }
    }
}

public struct UpdateTriggerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTriggerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTriggerInput>
    public typealias MOutput = OperationOutput<UpdateTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTriggerOutputError>
}

public struct UpdateTriggerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTriggerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTriggerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTriggerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTriggerInput>
    public typealias MOutput = OperationOutput<UpdateTriggerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTriggerOutputError>
}

public struct UpdateTriggerInput: Equatable {
    /// <p>The name of the trigger to update.</p>
    public let name: String?
    /// <p>The new values with which to update the trigger.</p>
    public let triggerUpdate: TriggerUpdate?

    public init (
        name: String? = nil,
        triggerUpdate: TriggerUpdate? = nil
    )
    {
        self.name = name
        self.triggerUpdate = triggerUpdate
    }
}

struct UpdateTriggerInputBody: Equatable {
    public let name: String?
    public let triggerUpdate: TriggerUpdate?
}

extension UpdateTriggerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case triggerUpdate = "TriggerUpdate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let triggerUpdateDecoded = try containerValues.decodeIfPresent(TriggerUpdate.self, forKey: .triggerUpdate)
        triggerUpdate = triggerUpdateDecoded
    }
}

extension UpdateTriggerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTriggerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTriggerOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTriggerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTriggerOutputResponse(trigger: \(String(describing: trigger)))"}
}

extension UpdateTriggerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTriggerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.trigger = output.trigger
        } else {
            self.trigger = nil
        }
    }
}

public struct UpdateTriggerOutputResponse: Equatable {
    /// <p>The resulting trigger definition.</p>
    public let trigger: Trigger?

    public init (
        trigger: Trigger? = nil
    )
    {
        self.trigger = trigger
    }
}

struct UpdateTriggerOutputResponseBody: Equatable {
    public let trigger: Trigger?
}

extension UpdateTriggerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case trigger = "Trigger"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerDecoded = try containerValues.decodeIfPresent(Trigger.self, forKey: .trigger)
        trigger = triggerDecoded
    }
}

public struct UpdateUserDefinedFunctionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserDefinedFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<UpdateUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserDefinedFunctionOutputError>
}

extension UpdateUserDefinedFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserDefinedFunctionInput(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), functionInput: \(String(describing: functionInput)), functionName: \(String(describing: functionName)))"}
}

extension UpdateUserDefinedFunctionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case functionInput = "FunctionInput"
        case functionName = "FunctionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let functionInput = functionInput {
            try encodeContainer.encode(functionInput, forKey: .functionInput)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
    }
}

public struct UpdateUserDefinedFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserDefinedFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<UpdateUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserDefinedFunctionOutputError>
}

public struct UpdateUserDefinedFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserDefinedFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserDefinedFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserDefinedFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserDefinedFunctionInput>
    public typealias MOutput = OperationOutput<UpdateUserDefinedFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserDefinedFunctionOutputError>
}

public struct UpdateUserDefinedFunctionInput: Equatable {
    /// <p>The ID of the Data Catalog where the function to be updated is located. If none is
    ///       provided, the AWS account ID is used by default.</p>
    public let catalogId: String?
    /// <p>The name of the catalog database where the function to be updated is
    ///       located.</p>
    public let databaseName: String?
    /// <p>A <code>FunctionInput</code> object that redefines the function in the Data
    ///       Catalog.</p>
    public let functionInput: UserDefinedFunctionInput?
    /// <p>The name of the function.</p>
    public let functionName: String?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        functionInput: UserDefinedFunctionInput? = nil,
        functionName: String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.functionInput = functionInput
        self.functionName = functionName
    }
}

struct UpdateUserDefinedFunctionInputBody: Equatable {
    public let catalogId: String?
    public let databaseName: String?
    public let functionName: String?
    public let functionInput: UserDefinedFunctionInput?
}

extension UpdateUserDefinedFunctionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case functionInput = "FunctionInput"
        case functionName = "FunctionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionInputDecoded = try containerValues.decodeIfPresent(UserDefinedFunctionInput.self, forKey: .functionInput)
        functionInput = functionInputDecoded
    }
}

extension UpdateUserDefinedFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserDefinedFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserDefinedFunctionOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserDefinedFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserDefinedFunctionOutputResponse()"}
}

extension UpdateUserDefinedFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserDefinedFunctionOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserDefinedFunctionOutputResponseBody: Equatable {
}

extension UpdateUserDefinedFunctionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateWorkflowInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWorkflowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkflowInput>
    public typealias MOutput = OperationOutput<UpdateWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkflowOutputError>
}

extension UpdateWorkflowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkflowInput(defaultRunProperties: \(String(describing: defaultRunProperties)), description: \(String(describing: description)), maxConcurrentRuns: \(String(describing: maxConcurrentRuns)), name: \(String(describing: name)))"}
}

extension UpdateWorkflowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultRunProperties = "DefaultRunProperties"
        case description = "Description"
        case maxConcurrentRuns = "MaxConcurrentRuns"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultRunProperties = defaultRunProperties {
            var defaultRunPropertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .defaultRunProperties)
            for (dictKey0, workflowrunproperties0) in defaultRunProperties {
                try defaultRunPropertiesContainer.encode(workflowrunproperties0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxConcurrentRuns = maxConcurrentRuns {
            try encodeContainer.encode(maxConcurrentRuns, forKey: .maxConcurrentRuns)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateWorkflowInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWorkflowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkflowInput>
    public typealias MOutput = OperationOutput<UpdateWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkflowOutputError>
}

public struct UpdateWorkflowInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWorkflowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkflowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkflowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkflowInput>
    public typealias MOutput = OperationOutput<UpdateWorkflowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkflowOutputError>
}

public struct UpdateWorkflowInput: Equatable {
    /// <p>A collection of properties to be used as part of each execution of the workflow.</p>
    public let defaultRunProperties: [String:String]?
    /// <p>The description of the workflow.</p>
    public let description: String?
    /// <p>You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.</p>
    public let maxConcurrentRuns: Int?
    /// <p>Name of the workflow to be updated.</p>
    public let name: String?

    public init (
        defaultRunProperties: [String:String]? = nil,
        description: String? = nil,
        maxConcurrentRuns: Int? = nil,
        name: String? = nil
    )
    {
        self.defaultRunProperties = defaultRunProperties
        self.description = description
        self.maxConcurrentRuns = maxConcurrentRuns
        self.name = name
    }
}

struct UpdateWorkflowInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let defaultRunProperties: [String:String]?
    public let maxConcurrentRuns: Int?
}

extension UpdateWorkflowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultRunProperties = "DefaultRunProperties"
        case description = "Description"
        case maxConcurrentRuns = "MaxConcurrentRuns"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let defaultRunPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .defaultRunProperties)
        var defaultRunPropertiesDecoded0: [String:String]? = nil
        if let defaultRunPropertiesContainer = defaultRunPropertiesContainer {
            defaultRunPropertiesDecoded0 = [String:String]()
            for (key0, genericstring0) in defaultRunPropertiesContainer {
                if let genericstring0 = genericstring0 {
                    defaultRunPropertiesDecoded0?[key0] = genericstring0
                }
            }
        }
        defaultRunProperties = defaultRunPropertiesDecoded0
        let maxConcurrentRunsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxConcurrentRuns)
        maxConcurrentRuns = maxConcurrentRunsDecoded
    }
}

extension UpdateWorkflowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkflowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkflowOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkflowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkflowOutputResponse(name: \(String(describing: name)))"}
}

extension UpdateWorkflowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateWorkflowOutputResponse: Equatable {
    /// <p>The name of the workflow which was specified in input.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateWorkflowOutputResponseBody: Equatable {
    public let name: String?
}

extension UpdateWorkflowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateXMLClassifierRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classification = "Classification"
        case name = "Name"
        case rowTag = "RowTag"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rowTag = rowTag {
            try encodeContainer.encode(rowTag, forKey: .rowTag)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let classificationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .classification)
        classification = classificationDecoded
        let rowTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rowTag)
        rowTag = rowTagDecoded
    }
}

extension UpdateXMLClassifierRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateXMLClassifierRequest(classification: \(String(describing: classification)), name: \(String(describing: name)), rowTag: \(String(describing: rowTag)))"}
}

/// <p>Specifies an XML classifier to be updated.</p>
public struct UpdateXMLClassifierRequest: Equatable {
    /// <p>An identifier of the data format that the classifier matches.</p>
    public let classification: String?
    /// <p>The name of the classifier.</p>
    public let name: String?
    /// <p>The XML tag designating the element that contains each record in an XML document being
    ///       parsed. This cannot identify a self-closing element (closed by <code>/></code>). An empty
    ///       row element that contains only attributes can be parsed as long as it ends with a closing tag
    ///       (for example, <code><row item_a="A" item_b="B"></row></code> is okay, but
    ///         <code><row item_a="A" item_b="B" /></code> is not).</p>
    public let rowTag: String?

    public init (
        classification: String? = nil,
        name: String? = nil,
        rowTag: String? = nil
    )
    {
        self.classification = classification
        self.name = name
        self.rowTag = rowTag
    }
}

extension UserDefinedFunction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case className = "ClassName"
        case createTime = "CreateTime"
        case databaseName = "DatabaseName"
        case functionName = "FunctionName"
        case ownerName = "OwnerName"
        case ownerType = "OwnerType"
        case resourceUris = "ResourceUris"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let className = className {
            try encodeContainer.encode(className, forKey: .className)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let ownerName = ownerName {
            try encodeContainer.encode(ownerName, forKey: .ownerName)
        }
        if let ownerType = ownerType {
            try encodeContainer.encode(ownerType.rawValue, forKey: .ownerType)
        }
        if let resourceUris = resourceUris {
            var resourceUrisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceUris)
            for resourceurilist0 in resourceUris {
                try resourceUrisContainer.encode(resourceurilist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .className)
        className = classNameDecoded
        let ownerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerName)
        ownerName = ownerNameDecoded
        let ownerTypeDecoded = try containerValues.decodeIfPresent(PrincipalType.self, forKey: .ownerType)
        ownerType = ownerTypeDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let resourceUrisContainer = try containerValues.decodeIfPresent([ResourceUri?].self, forKey: .resourceUris)
        var resourceUrisDecoded0:[ResourceUri]? = nil
        if let resourceUrisContainer = resourceUrisContainer {
            resourceUrisDecoded0 = [ResourceUri]()
            for structure0 in resourceUrisContainer {
                if let structure0 = structure0 {
                    resourceUrisDecoded0?.append(structure0)
                }
            }
        }
        resourceUris = resourceUrisDecoded0
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension UserDefinedFunction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserDefinedFunction(catalogId: \(String(describing: catalogId)), className: \(String(describing: className)), createTime: \(String(describing: createTime)), databaseName: \(String(describing: databaseName)), functionName: \(String(describing: functionName)), ownerName: \(String(describing: ownerName)), ownerType: \(String(describing: ownerType)), resourceUris: \(String(describing: resourceUris)))"}
}

/// <p>Represents the equivalent of a Hive user-defined function
///       (<code>UDF</code>) definition.</p>
public struct UserDefinedFunction: Equatable {
    /// <p>The ID of the Data Catalog in which the function resides.</p>
    public let catalogId: String?
    /// <p>The Java class that contains the function code.</p>
    public let className: String?
    /// <p>The time at which the function was created.</p>
    public let createTime: Date?
    /// <p>The name of the catalog database that contains the function.</p>
    public let databaseName: String?
    /// <p>The name of the function.</p>
    public let functionName: String?
    /// <p>The owner of the function.</p>
    public let ownerName: String?
    /// <p>The owner type.</p>
    public let ownerType: PrincipalType?
    /// <p>The resource URIs for the function.</p>
    public let resourceUris: [ResourceUri]?

    public init (
        catalogId: String? = nil,
        className: String? = nil,
        createTime: Date? = nil,
        databaseName: String? = nil,
        functionName: String? = nil,
        ownerName: String? = nil,
        ownerType: PrincipalType? = nil,
        resourceUris: [ResourceUri]? = nil
    )
    {
        self.catalogId = catalogId
        self.className = className
        self.createTime = createTime
        self.databaseName = databaseName
        self.functionName = functionName
        self.ownerName = ownerName
        self.ownerType = ownerType
        self.resourceUris = resourceUris
    }
}

extension UserDefinedFunctionInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case className = "ClassName"
        case functionName = "FunctionName"
        case ownerName = "OwnerName"
        case ownerType = "OwnerType"
        case resourceUris = "ResourceUris"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let className = className {
            try encodeContainer.encode(className, forKey: .className)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let ownerName = ownerName {
            try encodeContainer.encode(ownerName, forKey: .ownerName)
        }
        if let ownerType = ownerType {
            try encodeContainer.encode(ownerType.rawValue, forKey: .ownerType)
        }
        if let resourceUris = resourceUris {
            var resourceUrisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceUris)
            for resourceurilist0 in resourceUris {
                try resourceUrisContainer.encode(resourceurilist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .className)
        className = classNameDecoded
        let ownerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerName)
        ownerName = ownerNameDecoded
        let ownerTypeDecoded = try containerValues.decodeIfPresent(PrincipalType.self, forKey: .ownerType)
        ownerType = ownerTypeDecoded
        let resourceUrisContainer = try containerValues.decodeIfPresent([ResourceUri?].self, forKey: .resourceUris)
        var resourceUrisDecoded0:[ResourceUri]? = nil
        if let resourceUrisContainer = resourceUrisContainer {
            resourceUrisDecoded0 = [ResourceUri]()
            for structure0 in resourceUrisContainer {
                if let structure0 = structure0 {
                    resourceUrisDecoded0?.append(structure0)
                }
            }
        }
        resourceUris = resourceUrisDecoded0
    }
}

extension UserDefinedFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserDefinedFunctionInput(className: \(String(describing: className)), functionName: \(String(describing: functionName)), ownerName: \(String(describing: ownerName)), ownerType: \(String(describing: ownerType)), resourceUris: \(String(describing: resourceUris)))"}
}

/// <p>A structure used to create or update a user-defined function.</p>
public struct UserDefinedFunctionInput: Equatable {
    /// <p>The Java class that contains the function code.</p>
    public let className: String?
    /// <p>The name of the function.</p>
    public let functionName: String?
    /// <p>The owner of the function.</p>
    public let ownerName: String?
    /// <p>The owner type.</p>
    public let ownerType: PrincipalType?
    /// <p>The resource URIs for the function.</p>
    public let resourceUris: [ResourceUri]?

    public init (
        className: String? = nil,
        functionName: String? = nil,
        ownerName: String? = nil,
        ownerType: PrincipalType? = nil,
        resourceUris: [ResourceUri]? = nil
    )
    {
        self.className = className
        self.functionName = functionName
        self.ownerName = ownerName
        self.ownerType = ownerType
        self.resourceUris = resourceUris
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A value could not be validated.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VersionMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VersionMismatchException(message: \(String(describing: message)))"}
}

extension VersionMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: VersionMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was a version conflict.</p>
public struct VersionMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct VersionMismatchExceptionBody: Equatable {
    public let message: String?
}

extension VersionMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum WorkerType {
    case g1x
    case g2x
    case standard
    case sdkUnknown(String)
}

extension WorkerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkerType] {
        return [
            .g1x,
            .g2x,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .g1x: return "G.1X"
        case .g2x: return "G.2X"
        case .standard: return "Standard"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkerType(rawValue: rawValue) ?? WorkerType.sdkUnknown(rawValue)
    }
}

extension Workflow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdOn = "CreatedOn"
        case defaultRunProperties = "DefaultRunProperties"
        case description = "Description"
        case graph = "Graph"
        case lastModifiedOn = "LastModifiedOn"
        case lastRun = "LastRun"
        case maxConcurrentRuns = "MaxConcurrentRuns"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdOn = createdOn {
            try encodeContainer.encode(createdOn.timeIntervalSince1970, forKey: .createdOn)
        }
        if let defaultRunProperties = defaultRunProperties {
            var defaultRunPropertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .defaultRunProperties)
            for (dictKey0, workflowrunproperties0) in defaultRunProperties {
                try defaultRunPropertiesContainer.encode(workflowrunproperties0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let graph = graph {
            try encodeContainer.encode(graph, forKey: .graph)
        }
        if let lastModifiedOn = lastModifiedOn {
            try encodeContainer.encode(lastModifiedOn.timeIntervalSince1970, forKey: .lastModifiedOn)
        }
        if let lastRun = lastRun {
            try encodeContainer.encode(lastRun, forKey: .lastRun)
        }
        if let maxConcurrentRuns = maxConcurrentRuns {
            try encodeContainer.encode(maxConcurrentRuns, forKey: .maxConcurrentRuns)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let defaultRunPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .defaultRunProperties)
        var defaultRunPropertiesDecoded0: [String:String]? = nil
        if let defaultRunPropertiesContainer = defaultRunPropertiesContainer {
            defaultRunPropertiesDecoded0 = [String:String]()
            for (key0, genericstring0) in defaultRunPropertiesContainer {
                if let genericstring0 = genericstring0 {
                    defaultRunPropertiesDecoded0?[key0] = genericstring0
                }
            }
        }
        defaultRunProperties = defaultRunPropertiesDecoded0
        let createdOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdOn)
        createdOn = createdOnDecoded
        let lastModifiedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedOn)
        lastModifiedOn = lastModifiedOnDecoded
        let lastRunDecoded = try containerValues.decodeIfPresent(WorkflowRun.self, forKey: .lastRun)
        lastRun = lastRunDecoded
        let graphDecoded = try containerValues.decodeIfPresent(WorkflowGraph.self, forKey: .graph)
        graph = graphDecoded
        let maxConcurrentRunsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxConcurrentRuns)
        maxConcurrentRuns = maxConcurrentRunsDecoded
    }
}

extension Workflow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Workflow(createdOn: \(String(describing: createdOn)), defaultRunProperties: \(String(describing: defaultRunProperties)), description: \(String(describing: description)), graph: \(String(describing: graph)), lastModifiedOn: \(String(describing: lastModifiedOn)), lastRun: \(String(describing: lastRun)), maxConcurrentRuns: \(String(describing: maxConcurrentRuns)), name: \(String(describing: name)))"}
}

/// <p>A workflow represents a flow in which AWS Glue components should be executed to complete a logical
///       task.</p>
public struct Workflow: Equatable {
    /// <p>The date and time when the workflow was created.</p>
    public let createdOn: Date?
    /// <p>A collection of properties to be used as part of each execution of the workflow.</p>
    public let defaultRunProperties: [String:String]?
    /// <p>A description of the workflow.</p>
    public let description: String?
    /// <p>The graph representing all the AWS Glue components that belong to the workflow as nodes and directed
    ///       connections between them as edges.</p>
    public let graph: WorkflowGraph?
    /// <p>The date and time when the workflow was last modified.</p>
    public let lastModifiedOn: Date?
    /// <p>The information about the last execution of the workflow.</p>
    public let lastRun: WorkflowRun?
    /// <p>You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.</p>
    public let maxConcurrentRuns: Int?
    /// <p>The name of the workflow representing the flow.</p>
    public let name: String?

    public init (
        createdOn: Date? = nil,
        defaultRunProperties: [String:String]? = nil,
        description: String? = nil,
        graph: WorkflowGraph? = nil,
        lastModifiedOn: Date? = nil,
        lastRun: WorkflowRun? = nil,
        maxConcurrentRuns: Int? = nil,
        name: String? = nil
    )
    {
        self.createdOn = createdOn
        self.defaultRunProperties = defaultRunProperties
        self.description = description
        self.graph = graph
        self.lastModifiedOn = lastModifiedOn
        self.lastRun = lastRun
        self.maxConcurrentRuns = maxConcurrentRuns
        self.name = name
    }
}

extension WorkflowGraph: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case edges = "Edges"
        case nodes = "Nodes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let edges = edges {
            var edgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edges)
            for edgelist0 in edges {
                try edgesContainer.encode(edgelist0)
            }
        }
        if let nodes = nodes {
            var nodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodes)
            for nodelist0 in nodes {
                try nodesContainer.encode(nodelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodesContainer = try containerValues.decodeIfPresent([Node?].self, forKey: .nodes)
        var nodesDecoded0:[Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [Node]()
            for structure0 in nodesContainer {
                if let structure0 = structure0 {
                    nodesDecoded0?.append(structure0)
                }
            }
        }
        nodes = nodesDecoded0
        let edgesContainer = try containerValues.decodeIfPresent([Edge?].self, forKey: .edges)
        var edgesDecoded0:[Edge]? = nil
        if let edgesContainer = edgesContainer {
            edgesDecoded0 = [Edge]()
            for structure0 in edgesContainer {
                if let structure0 = structure0 {
                    edgesDecoded0?.append(structure0)
                }
            }
        }
        edges = edgesDecoded0
    }
}

extension WorkflowGraph: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkflowGraph(edges: \(String(describing: edges)), nodes: \(String(describing: nodes)))"}
}

/// <p>A workflow graph represents the complete workflow containing all the AWS Glue components present in the
///       workflow and all the directed connections between them.</p>
public struct WorkflowGraph: Equatable {
    /// <p>A list of all the directed connections between the nodes belonging to the workflow.</p>
    public let edges: [Edge]?
    /// <p>A list of the the AWS Glue components belong to the workflow represented as nodes.</p>
    public let nodes: [Node]?

    public init (
        edges: [Edge]? = nil,
        nodes: [Node]? = nil
    )
    {
        self.edges = edges
        self.nodes = nodes
    }
}

extension WorkflowRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completedOn = "CompletedOn"
        case errorMessage = "ErrorMessage"
        case graph = "Graph"
        case name = "Name"
        case previousRunId = "PreviousRunId"
        case startedOn = "StartedOn"
        case statistics = "Statistics"
        case status = "Status"
        case workflowRunId = "WorkflowRunId"
        case workflowRunProperties = "WorkflowRunProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedOn = completedOn {
            try encodeContainer.encode(completedOn.timeIntervalSince1970, forKey: .completedOn)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let graph = graph {
            try encodeContainer.encode(graph, forKey: .graph)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let previousRunId = previousRunId {
            try encodeContainer.encode(previousRunId, forKey: .previousRunId)
        }
        if let startedOn = startedOn {
            try encodeContainer.encode(startedOn.timeIntervalSince1970, forKey: .startedOn)
        }
        if let statistics = statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workflowRunId = workflowRunId {
            try encodeContainer.encode(workflowRunId, forKey: .workflowRunId)
        }
        if let workflowRunProperties = workflowRunProperties {
            var workflowRunPropertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .workflowRunProperties)
            for (dictKey0, workflowrunproperties0) in workflowRunProperties {
                try workflowRunPropertiesContainer.encode(workflowrunproperties0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let workflowRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workflowRunId)
        workflowRunId = workflowRunIdDecoded
        let previousRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .previousRunId)
        previousRunId = previousRunIdDecoded
        let workflowRunPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .workflowRunProperties)
        var workflowRunPropertiesDecoded0: [String:String]? = nil
        if let workflowRunPropertiesContainer = workflowRunPropertiesContainer {
            workflowRunPropertiesDecoded0 = [String:String]()
            for (key0, genericstring0) in workflowRunPropertiesContainer {
                if let genericstring0 = genericstring0 {
                    workflowRunPropertiesDecoded0?[key0] = genericstring0
                }
            }
        }
        workflowRunProperties = workflowRunPropertiesDecoded0
        let startedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedOn)
        startedOn = startedOnDecoded
        let completedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedOn)
        completedOn = completedOnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkflowRunStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(WorkflowRunStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let graphDecoded = try containerValues.decodeIfPresent(WorkflowGraph.self, forKey: .graph)
        graph = graphDecoded
    }
}

extension WorkflowRun: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkflowRun(completedOn: \(String(describing: completedOn)), errorMessage: \(String(describing: errorMessage)), graph: \(String(describing: graph)), name: \(String(describing: name)), previousRunId: \(String(describing: previousRunId)), startedOn: \(String(describing: startedOn)), statistics: \(String(describing: statistics)), status: \(String(describing: status)), workflowRunId: \(String(describing: workflowRunId)), workflowRunProperties: \(String(describing: workflowRunProperties)))"}
}

/// <p>A workflow run is an execution of a workflow providing all the runtime information.</p>
public struct WorkflowRun: Equatable {
    /// <p>The date and time when the workflow run completed.</p>
    public let completedOn: Date?
    /// <p>This error message describes any error that may have occurred in starting the workflow run. Currently the only error message is "Concurrent runs exceeded for workflow: <code>foo</code>."</p>
    public let errorMessage: String?
    /// <p>The graph representing all the AWS Glue components that belong to the workflow as nodes and directed
    ///       connections between them as edges.</p>
    public let graph: WorkflowGraph?
    /// <p>Name of the workflow that was executed.</p>
    public let name: String?
    /// <p>The ID of the previous workflow run.</p>
    public let previousRunId: String?
    /// <p>The date and time when the workflow run was started.</p>
    public let startedOn: Date?
    /// <p>The statistics of the run.</p>
    public let statistics: WorkflowRunStatistics?
    /// <p>The status of the workflow run.</p>
    public let status: WorkflowRunStatus?
    /// <p>The ID of this workflow run.</p>
    public let workflowRunId: String?
    /// <p>The workflow run properties which were set during the run.</p>
    public let workflowRunProperties: [String:String]?

    public init (
        completedOn: Date? = nil,
        errorMessage: String? = nil,
        graph: WorkflowGraph? = nil,
        name: String? = nil,
        previousRunId: String? = nil,
        startedOn: Date? = nil,
        statistics: WorkflowRunStatistics? = nil,
        status: WorkflowRunStatus? = nil,
        workflowRunId: String? = nil,
        workflowRunProperties: [String:String]? = nil
    )
    {
        self.completedOn = completedOn
        self.errorMessage = errorMessage
        self.graph = graph
        self.name = name
        self.previousRunId = previousRunId
        self.startedOn = startedOn
        self.statistics = statistics
        self.status = status
        self.workflowRunId = workflowRunId
        self.workflowRunProperties = workflowRunProperties
    }
}

extension WorkflowRunStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failedActions = "FailedActions"
        case runningActions = "RunningActions"
        case stoppedActions = "StoppedActions"
        case succeededActions = "SucceededActions"
        case timeoutActions = "TimeoutActions"
        case totalActions = "TotalActions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if failedActions != 0 {
            try encodeContainer.encode(failedActions, forKey: .failedActions)
        }
        if runningActions != 0 {
            try encodeContainer.encode(runningActions, forKey: .runningActions)
        }
        if stoppedActions != 0 {
            try encodeContainer.encode(stoppedActions, forKey: .stoppedActions)
        }
        if succeededActions != 0 {
            try encodeContainer.encode(succeededActions, forKey: .succeededActions)
        }
        if timeoutActions != 0 {
            try encodeContainer.encode(timeoutActions, forKey: .timeoutActions)
        }
        if totalActions != 0 {
            try encodeContainer.encode(totalActions, forKey: .totalActions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalActionsDecoded = try containerValues.decode(Int.self, forKey: .totalActions)
        totalActions = totalActionsDecoded
        let timeoutActionsDecoded = try containerValues.decode(Int.self, forKey: .timeoutActions)
        timeoutActions = timeoutActionsDecoded
        let failedActionsDecoded = try containerValues.decode(Int.self, forKey: .failedActions)
        failedActions = failedActionsDecoded
        let stoppedActionsDecoded = try containerValues.decode(Int.self, forKey: .stoppedActions)
        stoppedActions = stoppedActionsDecoded
        let succeededActionsDecoded = try containerValues.decode(Int.self, forKey: .succeededActions)
        succeededActions = succeededActionsDecoded
        let runningActionsDecoded = try containerValues.decode(Int.self, forKey: .runningActions)
        runningActions = runningActionsDecoded
    }
}

extension WorkflowRunStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkflowRunStatistics(failedActions: \(String(describing: failedActions)), runningActions: \(String(describing: runningActions)), stoppedActions: \(String(describing: stoppedActions)), succeededActions: \(String(describing: succeededActions)), timeoutActions: \(String(describing: timeoutActions)), totalActions: \(String(describing: totalActions)))"}
}

/// <p>Workflow run statistics provides statistics about the workflow run.</p>
public struct WorkflowRunStatistics: Equatable {
    /// <p>Total number of Actions that have failed.</p>
    public let failedActions: Int
    /// <p>Total number Actions in running state.</p>
    public let runningActions: Int
    /// <p>Total number of Actions that have stopped.</p>
    public let stoppedActions: Int
    /// <p>Total number of Actions that have succeeded.</p>
    public let succeededActions: Int
    /// <p>Total number of Actions that timed out.</p>
    public let timeoutActions: Int
    /// <p>Total number of Actions in the workflow run.</p>
    public let totalActions: Int

    public init (
        failedActions: Int = 0,
        runningActions: Int = 0,
        stoppedActions: Int = 0,
        succeededActions: Int = 0,
        timeoutActions: Int = 0,
        totalActions: Int = 0
    )
    {
        self.failedActions = failedActions
        self.runningActions = runningActions
        self.stoppedActions = stoppedActions
        self.succeededActions = succeededActions
        self.timeoutActions = timeoutActions
        self.totalActions = totalActions
    }
}

public enum WorkflowRunStatus {
    case completed
    case error
    case running
    case stopped
    case stopping
    case sdkUnknown(String)
}

extension WorkflowRunStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkflowRunStatus] {
        return [
            .completed,
            .error,
            .running,
            .stopped,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .error: return "ERROR"
        case .running: return "RUNNING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkflowRunStatus(rawValue: rawValue) ?? WorkflowRunStatus.sdkUnknown(rawValue)
    }
}

extension XMLClassifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classification = "Classification"
        case creationTime = "CreationTime"
        case lastUpdated = "LastUpdated"
        case name = "Name"
        case rowTag = "RowTag"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rowTag = rowTag {
            try encodeContainer.encode(rowTag, forKey: .rowTag)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let classificationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .classification)
        classification = classificationDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let rowTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rowTag)
        rowTag = rowTagDecoded
    }
}

extension XMLClassifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "XMLClassifier(classification: \(String(describing: classification)), creationTime: \(String(describing: creationTime)), lastUpdated: \(String(describing: lastUpdated)), name: \(String(describing: name)), rowTag: \(String(describing: rowTag)), version: \(String(describing: version)))"}
}

/// <p>A classifier for <code>XML</code> content.</p>
public struct XMLClassifier: Equatable {
    /// <p>An identifier of the data format that the classifier matches.</p>
    public let classification: String?
    /// <p>The time that this classifier was registered.</p>
    public let creationTime: Date?
    /// <p>The time that this classifier was last updated.</p>
    public let lastUpdated: Date?
    /// <p>The name of the classifier.</p>
    public let name: String?
    /// <p>The XML tag designating the element that contains each record in an XML document being
    ///       parsed. This can't identify a self-closing element (closed by <code>/></code>). An empty
    ///       row element that contains only attributes can be parsed as long as it ends with a closing tag
    ///       (for example, <code><row item_a="A" item_b="B"></row></code> is okay, but
    ///         <code><row item_a="A" item_b="B" /></code> is not).</p>
    public let rowTag: String?
    /// <p>The version of this classifier.</p>
    public let version: Int

    public init (
        classification: String? = nil,
        creationTime: Date? = nil,
        lastUpdated: Date? = nil,
        name: String? = nil,
        rowTag: String? = nil,
        version: Int = 0
    )
    {
        self.classification = classification
        self.creationTime = creationTime
        self.lastUpdated = lastUpdated
        self.name = name
        self.rowTag = rowTag
        self.version = version
    }
}
