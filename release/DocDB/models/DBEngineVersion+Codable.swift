// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DBEngineVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBEngineDescription = dBEngineDescription {
            try container.encode(dBEngineDescription, forKey: Key("DBEngineDescription"))
        }
        if let dBEngineVersionDescription = dBEngineVersionDescription {
            try container.encode(dBEngineVersionDescription, forKey: Key("DBEngineVersionDescription"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let exportableLogTypes = exportableLogTypes {
            var exportableLogTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExportableLogTypes"))
            for (index0, string0) in exportableLogTypes.enumerated() {
                try exportableLogTypesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if supportsLogExportsToCloudwatchLogs != false {
            try container.encode(supportsLogExportsToCloudwatchLogs, forKey: Key("SupportsLogExportsToCloudwatchLogs"))
        }
        if let validUpgradeTarget = validUpgradeTarget {
            var validUpgradeTargetContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValidUpgradeTarget"))
            for (index0, upgradetarget0) in validUpgradeTarget.enumerated() {
                try validUpgradeTargetContainer.encode(upgradetarget0, forKey: Key("UpgradeTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var exportableLogTypesBuffer:[String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
    }
}
