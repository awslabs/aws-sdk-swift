// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DBEngineVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case defaultCharacterSet = "DefaultCharacterSet"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case supportedCharacterSets = "SupportedCharacterSets"
        case supportedTimezones = "SupportedTimezones"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case supportsReadReplica = "SupportsReadReplica"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBEngineDescription = dBEngineDescription {
            try container.encode(dBEngineDescription, forKey: Key("DBEngineDescription"))
        }
        if let dBEngineVersionDescription = dBEngineVersionDescription {
            try container.encode(dBEngineVersionDescription, forKey: Key("DBEngineVersionDescription"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let defaultCharacterSet = defaultCharacterSet {
            try container.encode(defaultCharacterSet, forKey: Key("DefaultCharacterSet"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let exportableLogTypes = exportableLogTypes {
            var exportableLogTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExportableLogTypes"))
            for (index0, string0) in exportableLogTypes.enumerated() {
                try exportableLogTypesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedCharacterSets = supportedCharacterSets {
            var supportedCharacterSetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedCharacterSets"))
            for (index0, characterset0) in supportedCharacterSets.enumerated() {
                try supportedCharacterSetsContainer.encode(characterset0, forKey: Key("CharacterSet.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedTimezones = supportedTimezones {
            var supportedTimezonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedTimezones"))
            for (index0, timezone0) in supportedTimezones.enumerated() {
                try supportedTimezonesContainer.encode(timezone0, forKey: Key("Timezone.\(index0.advanced(by: 1))"))
            }
        }
        if supportsLogExportsToCloudwatchLogs != false {
            try container.encode(supportsLogExportsToCloudwatchLogs, forKey: Key("SupportsLogExportsToCloudwatchLogs"))
        }
        if supportsReadReplica != false {
            try container.encode(supportsReadReplica, forKey: Key("SupportsReadReplica"))
        }
        if let validUpgradeTarget = validUpgradeTarget {
            var validUpgradeTargetContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValidUpgradeTarget"))
            for (index0, upgradetarget0) in validUpgradeTarget.enumerated() {
                try validUpgradeTargetContainer.encode(upgradetarget0, forKey: Key("UpgradeTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        let defaultCharacterSetDecoded = try containerValues.decodeIfPresent(CharacterSet.self, forKey: .defaultCharacterSet)
        defaultCharacterSet = defaultCharacterSetDecoded
        if containerValues.contains(.supportedCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedCharacterSets)
            if let supportedCharacterSetsWrappedContainer = supportedCharacterSetsWrappedContainer {
                let supportedCharacterSetsContainer = try supportedCharacterSetsWrappedContainer.decodeIfPresent([CharacterSet].self, forKey: .member)
                var supportedCharacterSetsBuffer:[CharacterSet]? = nil
                if let supportedCharacterSetsContainer = supportedCharacterSetsContainer {
                    supportedCharacterSetsBuffer = [CharacterSet]()
                    for structureContainer0 in supportedCharacterSetsContainer {
                        supportedCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedCharacterSets = supportedCharacterSetsBuffer
            } else {
                supportedCharacterSets = []
            }
        } else {
            supportedCharacterSets = nil
        }
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.supportedTimezones) {
            struct KeyVal0{struct Timezone{}}
            let supportedTimezonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Timezone>.CodingKeys.self, forKey: .supportedTimezones)
            if let supportedTimezonesWrappedContainer = supportedTimezonesWrappedContainer {
                let supportedTimezonesContainer = try supportedTimezonesWrappedContainer.decodeIfPresent([Timezone].self, forKey: .member)
                var supportedTimezonesBuffer:[Timezone]? = nil
                if let supportedTimezonesContainer = supportedTimezonesContainer {
                    supportedTimezonesBuffer = [Timezone]()
                    for structureContainer0 in supportedTimezonesContainer {
                        supportedTimezonesBuffer?.append(structureContainer0)
                    }
                }
                supportedTimezones = supportedTimezonesBuffer
            } else {
                supportedTimezones = []
            }
        } else {
            supportedTimezones = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var exportableLogTypesBuffer:[String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
        let supportsReadReplicaDecoded = try containerValues.decode(Bool.self, forKey: .supportsReadReplica)
        supportsReadReplica = supportsReadReplicaDecoded
    }
}
