// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddRoleToDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "AddRoleToDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToDBClusterOutputError>
}

extension AddRoleToDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddRoleToDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), featureName: \(String(describing: featureName)), roleArn: \(String(describing: roleArn)))"}
}

extension AddRoleToDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        try container.encode("AddRoleToDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct AddRoleToDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "AddRoleToDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToDBClusterOutputError>
}

public struct AddRoleToDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "AddRoleToDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRoleToDBClusterOutputError>
}

public struct AddRoleToDBClusterInput: Equatable {
    /// <p>The name of the DB cluster to associate the IAM role with.</p>
    public let dBClusterIdentifier: String?
    /// <p>The name of the feature for the Neptune DB cluster that the IAM role is to be associated with.
    ///       For the list of supported feature names, see <a>DBEngineVersion</a>.</p>
    public let featureName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to associate with the Neptune DB cluster,
    ///       for example <code>arn:aws:iam::123456789012:role/NeptuneAccessRole</code>.</p>
    public let roleArn: String?

    public init (
        dBClusterIdentifier: String? = nil,
        featureName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension AddRoleToDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddRoleToDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleAlreadyExistsFault" : self = .dBClusterRoleAlreadyExistsFault(try DBClusterRoleAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleQuotaExceededFault" : self = .dBClusterRoleQuotaExceededFault(try DBClusterRoleQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddRoleToDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterRoleAlreadyExistsFault(DBClusterRoleAlreadyExistsFault)
    case dBClusterRoleQuotaExceededFault(DBClusterRoleQuotaExceededFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddRoleToDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddRoleToDBClusterOutputResponse()"}
}

extension AddRoleToDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddRoleToDBClusterOutputResponse: Equatable {

    public init() {}
}

struct AddRoleToDBClusterOutputResponseBody: Equatable {
}

extension AddRoleToDBClusterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddSourceIdentifierToSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "AddSourceIdentifierToSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

extension AddSourceIdentifierToSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddSourceIdentifierToSubscriptionInput(sourceIdentifier: \(String(describing: sourceIdentifier)), subscriptionName: \(String(describing: subscriptionName)))"}
}

extension AddSourceIdentifierToSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: Key("SourceIdentifier"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("AddSourceIdentifierToSubscription", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct AddSourceIdentifierToSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "AddSourceIdentifierToSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

public struct AddSourceIdentifierToSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "AddSourceIdentifierToSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

public struct AddSourceIdentifierToSubscriptionInput: Equatable {
    /// <p>The identifier of the event source to be added.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the source type is a DB instance, then a <code>DBInstanceIdentifier</code> must be
    ///           supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB security group, a <code>DBSecurityGroupName</code> must be
    ///           supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB parameter group, a <code>DBParameterGroupName</code> must
    ///           be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB snapshot, a <code>DBSnapshotIdentifier</code> must be
    ///           supplied.</p>
    ///             </li>
    ///          </ul>
    public let sourceIdentifier: String?
    /// <p>The name of the event notification subscription you want to add a source identifier
    ///       to.</p>
    public let subscriptionName: String?

    public init (
        sourceIdentifier: String? = nil,
        subscriptionName: String? = nil
    )
    {
        self.sourceIdentifier = sourceIdentifier
        self.subscriptionName = subscriptionName
    }
}

extension AddSourceIdentifierToSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddSourceIdentifierToSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddSourceIdentifierToSubscriptionOutputError: Equatable {
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddSourceIdentifierToSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddSourceIdentifierToSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension AddSourceIdentifierToSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddSourceIdentifierToSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct AddSourceIdentifierToSubscriptionOutputResponse: Equatable {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct AddSourceIdentifierToSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension AddSourceIdentifierToSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AddSourceIdentifierToSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct AddTagsToResourceInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceInput(resourceName: \(String(describing: resourceName)), tags: \(String(describing: tags)))"}
}

extension AddTagsToResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AddTagsToResource", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInput: Equatable {
    /// <p>The Amazon Neptune resource that the tags are added to. This value is an Amazon Resource
    ///       Name (ARN). For information about creating an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    public let resourceName: String?
    /// <p>The tags to be assigned to the Amazon Neptune resource.</p>
    public let tags: [Tag]?

    public init (
        resourceName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceName = resourceName
        self.tags = tags
    }
}

extension AddTagsToResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceOutputResponse()"}
}

extension AddTagsToResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToResourceOutputResponse: Equatable {

    public init() {}
}

struct AddTagsToResourceOutputResponseBody: Equatable {
}

extension AddTagsToResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ApplyMethod {
    case immediate
    case pendingReboot
    case sdkUnknown(String)
}

extension ApplyMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApplyMethod] {
        return [
            .immediate,
            .pendingReboot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .immediate: return "immediate"
        case .pendingReboot: return "pending-reboot"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApplyMethod(rawValue: rawValue) ?? ApplyMethod.sdkUnknown(rawValue)
    }
}

public struct ApplyPendingMaintenanceActionInputBodyMiddleware: Middleware {
    public let id: String = "ApplyPendingMaintenanceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyPendingMaintenanceActionOutputError>
}

extension ApplyPendingMaintenanceActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplyPendingMaintenanceActionInput(applyAction: \(String(describing: applyAction)), optInType: \(String(describing: optInType)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

extension ApplyPendingMaintenanceActionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let applyAction = applyAction {
            try container.encode(applyAction, forKey: Key("ApplyAction"))
        }
        if let optInType = optInType {
            try container.encode(optInType, forKey: Key("OptInType"))
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: Key("ResourceIdentifier"))
        }
        try container.encode("ApplyPendingMaintenanceAction", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ApplyPendingMaintenanceActionInputHeadersMiddleware: Middleware {
    public let id: String = "ApplyPendingMaintenanceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyPendingMaintenanceActionOutputError>
}

public struct ApplyPendingMaintenanceActionInputQueryItemMiddleware: Middleware {
    public let id: String = "ApplyPendingMaintenanceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyPendingMaintenanceActionOutputError>
}

public struct ApplyPendingMaintenanceActionInput: Equatable {
    /// <p>The pending maintenance action to apply to this resource.</p>
    ///          <p>Valid values: <code>system-update</code>, <code>db-upgrade</code>
    ///          </p>
    public let applyAction: String?
    /// <p>A value that specifies the type of opt-in request, or undoes an opt-in request. An opt-in
    ///       request of type <code>immediate</code> can't be undone.</p>
    ///          <p>Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>immediate</code> - Apply the maintenance action immediately.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>next-maintenance</code> - Apply the maintenance action during the next
    ///           maintenance window for the resource.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>undo-opt-in</code> - Cancel any existing <code>next-maintenance</code> opt-in
    ///           requests.</p>
    ///             </li>
    ///          </ul>
    public let optInType: String?
    /// <p>The Amazon Resource Name (ARN) of the resource that the pending maintenance action applies
    ///       to. For information about creating an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    public let resourceIdentifier: String?

    public init (
        applyAction: String? = nil,
        optInType: String? = nil,
        resourceIdentifier: String? = nil
    )
    {
        self.applyAction = applyAction
        self.optInType = optInType
        self.resourceIdentifier = resourceIdentifier
    }
}

extension ApplyPendingMaintenanceActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ApplyPendingMaintenanceActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplyPendingMaintenanceActionOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyPendingMaintenanceActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplyPendingMaintenanceActionOutputResponse(resourcePendingMaintenanceActions: \(String(describing: resourcePendingMaintenanceActions)))"}
}

extension ApplyPendingMaintenanceActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApplyPendingMaintenanceActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourcePendingMaintenanceActions = output.resourcePendingMaintenanceActions
        } else {
            self.resourcePendingMaintenanceActions = nil
        }
    }
}

public struct ApplyPendingMaintenanceActionOutputResponse: Equatable {
    /// <p>Describes the pending maintenance actions for a resource.</p>
    public let resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions?

    public init (
        resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions? = nil
    )
    {
        self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
    }
}

struct ApplyPendingMaintenanceActionOutputResponseBody: Equatable {
    public let resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions?
}

extension ApplyPendingMaintenanceActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ApplyPendingMaintenanceActionResult"))
        let resourcePendingMaintenanceActionsDecoded = try containerValues.decodeIfPresent(ResourcePendingMaintenanceActions.self, forKey: .resourcePendingMaintenanceActions)
        resourcePendingMaintenanceActions = resourcePendingMaintenanceActionsDecoded
    }
}

extension AuthorizationNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationNotFoundFault(message: \(String(describing: message)))"}
}

extension AuthorizationNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AuthorizationNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Specified CIDRIP or EC2 security group is not authorized for the specified DB security group.</p>
///          <p>Neptune may not also be authorized via IAM to perform necessary actions on your behalf.</p>
public struct AuthorizationNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationNotFoundFaultBody: Equatable {
    public let message: String?
}

extension AuthorizationNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AvailabilityZone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AvailabilityZone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailabilityZone(name: \(String(describing: name)))"}
}

/// <p>Specifies an Availability Zone.</p>
public struct AvailabilityZone: Equatable {
    /// <p>The name of the availability zone.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension CertificateNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateNotFoundFault(message: \(String(describing: message)))"}
}

extension CertificateNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CertificateNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>CertificateIdentifier</i> does not refer to an existing certificate.</p>
public struct CertificateNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateNotFoundFaultBody: Equatable {
    public let message: String?
}

extension CertificateNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CharacterSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case characterSetDescription = "CharacterSetDescription"
        case characterSetName = "CharacterSetName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let characterSetDescription = characterSetDescription {
            try container.encode(characterSetDescription, forKey: Key("CharacterSetDescription"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let characterSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let characterSetDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .characterSetDescription)
        characterSetDescription = characterSetDescriptionDecoded
    }
}

extension CharacterSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CharacterSet(characterSetDescription: \(String(describing: characterSetDescription)), characterSetName: \(String(describing: characterSetName)))"}
}

/// <p>Specifies a character set.</p>
public struct CharacterSet: Equatable {
    /// <p>The description of the character set.</p>
    public let characterSetDescription: String?
    /// <p>The name of the character set.</p>
    public let characterSetName: String?

    public init (
        characterSetDescription: String? = nil,
        characterSetName: String? = nil
    )
    {
        self.characterSetDescription = characterSetDescription
        self.characterSetName = characterSetName
    }
}

extension CloudwatchLogsExportConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case disableLogTypes = "DisableLogTypes"
        case enableLogTypes = "EnableLogTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let disableLogTypes = disableLogTypes {
            var disableLogTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DisableLogTypes"))
            for (index0, string0) in disableLogTypes.enumerated() {
                try disableLogTypesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableLogTypes = enableLogTypes {
            var enableLogTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableLogTypes"))
            for (index0, string0) in enableLogTypes.enumerated() {
                try enableLogTypesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.enableLogTypes) {
            struct KeyVal0{struct member{}}
            let enableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableLogTypes)
            if let enableLogTypesWrappedContainer = enableLogTypesWrappedContainer {
                let enableLogTypesContainer = try enableLogTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var enableLogTypesBuffer:[String]? = nil
                if let enableLogTypesContainer = enableLogTypesContainer {
                    enableLogTypesBuffer = [String]()
                    for stringContainer0 in enableLogTypesContainer {
                        enableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                enableLogTypes = enableLogTypesBuffer
            } else {
                enableLogTypes = []
            }
        } else {
            enableLogTypes = nil
        }
        if containerValues.contains(.disableLogTypes) {
            struct KeyVal0{struct member{}}
            let disableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .disableLogTypes)
            if let disableLogTypesWrappedContainer = disableLogTypesWrappedContainer {
                let disableLogTypesContainer = try disableLogTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var disableLogTypesBuffer:[String]? = nil
                if let disableLogTypesContainer = disableLogTypesContainer {
                    disableLogTypesBuffer = [String]()
                    for stringContainer0 in disableLogTypesContainer {
                        disableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                disableLogTypes = disableLogTypesBuffer
            } else {
                disableLogTypes = []
            }
        } else {
            disableLogTypes = nil
        }
    }
}

extension CloudwatchLogsExportConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudwatchLogsExportConfiguration(disableLogTypes: \(String(describing: disableLogTypes)), enableLogTypes: \(String(describing: enableLogTypes)))"}
}

/// <p>The configuration setting for the log types to be enabled for export
///       to CloudWatch Logs for a specific DB instance or DB cluster.</p>
///
///          <p>The <code>EnableLogTypes</code> and <code>DisableLogTypes</code> arrays
///       determine which logs will be exported (or not exported) to CloudWatch Logs.</p>
public struct CloudwatchLogsExportConfiguration: Equatable {
    /// <p>The list of log types to disable.</p>
    public let disableLogTypes: [String]?
    /// <p>The list of log types to enable.</p>
    public let enableLogTypes: [String]?

    public init (
        disableLogTypes: [String]? = nil,
        enableLogTypes: [String]? = nil
    )
    {
        self.disableLogTypes = disableLogTypes
        self.enableLogTypes = enableLogTypes
    }
}

public struct CopyDBClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "CopyDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterParameterGroupOutputError>
}

extension CopyDBClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBClusterParameterGroupInput(sourceDBClusterParameterGroupIdentifier: \(String(describing: sourceDBClusterParameterGroupIdentifier)), tags: \(String(describing: tags)), targetDBClusterParameterGroupDescription: \(String(describing: targetDBClusterParameterGroupDescription)), targetDBClusterParameterGroupIdentifier: \(String(describing: targetDBClusterParameterGroupIdentifier)))"}
}

extension CopyDBClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifier {
            try container.encode(sourceDBClusterParameterGroupIdentifier, forKey: Key("SourceDBClusterParameterGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescription {
            try container.encode(targetDBClusterParameterGroupDescription, forKey: Key("TargetDBClusterParameterGroupDescription"))
        }
        if let targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifier {
            try container.encode(targetDBClusterParameterGroupIdentifier, forKey: Key("TargetDBClusterParameterGroupIdentifier"))
        }
        try container.encode("CopyDBClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CopyDBClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CopyDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterParameterGroupOutputError>
}

public struct CopyDBClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterParameterGroupOutputError>
}

public struct CopyDBClusterParameterGroupInput: Equatable {
    /// <p>The identifier or Amazon Resource Name (ARN) for the source DB cluster parameter group.
    ///       For information about creating an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must specify a valid DB cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source DB cluster parameter group is in the same Amazon Region as the copy,
    ///           specify a valid DB parameter group identifier, for example
    ///           <code>my-db-cluster-param-group</code>, or a valid ARN.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source DB parameter group is in a different Amazon Region than the copy, specify a
    ///           valid DB cluster parameter group ARN, for example
    ///           <code>arn:aws:rds:us-east-1:123456789012:cluster-pg:custom-cluster-group1</code>.</p>
    ///             </li>
    ///          </ul>
    public let sourceDBClusterParameterGroupIdentifier: String?
    /// <p>The tags to be assigned to the copied DB cluster parameter group.</p>
    public let tags: [Tag]?
    /// <p>A description for the copied DB cluster parameter group.</p>
    public let targetDBClusterParameterGroupDescription: String?
    /// <p>The identifier for the copied DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Cannot be null, empty, or blank</p>
    ///             </li>
    ///             <li>
    ///                <p>Must contain from 1 to 255 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster-param-group1</code>
    ///          </p>
    public let targetDBClusterParameterGroupIdentifier: String?

    public init (
        sourceDBClusterParameterGroupIdentifier: String? = nil,
        tags: [Tag]? = nil,
        targetDBClusterParameterGroupDescription: String? = nil,
        targetDBClusterParameterGroupIdentifier: String? = nil
    )
    {
        self.sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifier
        self.tags = tags
        self.targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescription
        self.targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifier
    }
}

extension CopyDBClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBClusterParameterGroupOutputError: Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBClusterParameterGroupOutputResponse(dBClusterParameterGroup: \(String(describing: dBClusterParameterGroup)))"}
}

extension CopyDBClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterParameterGroup = output.dBClusterParameterGroup
        } else {
            self.dBClusterParameterGroup = nil
        }
    }
}

public struct CopyDBClusterParameterGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster parameter group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterParameterGroups</a> action.</p>
    public let dBClusterParameterGroup: DBClusterParameterGroup?

    public init (
        dBClusterParameterGroup: DBClusterParameterGroup? = nil
    )
    {
        self.dBClusterParameterGroup = dBClusterParameterGroup
    }
}

struct CopyDBClusterParameterGroupOutputResponseBody: Equatable {
    public let dBClusterParameterGroup: DBClusterParameterGroup?
}

extension CopyDBClusterParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroup = "DBClusterParameterGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CopyDBClusterParameterGroupResult"))
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(DBClusterParameterGroup.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
    }
}

public struct CopyDBClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "CopyDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterSnapshotOutputError>
}

extension CopyDBClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBClusterSnapshotInput(copyTags: \(String(describing: copyTags)), kmsKeyId: \(String(describing: kmsKeyId)), preSignedUrl: \(String(describing: preSignedUrl)), sourceDBClusterSnapshotIdentifier: \(String(describing: sourceDBClusterSnapshotIdentifier)), tags: \(String(describing: tags)), targetDBClusterSnapshotIdentifier: \(String(describing: targetDBClusterSnapshotIdentifier)))"}
}

extension CopyDBClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let copyTags = copyTags {
            try container.encode(copyTags, forKey: Key("CopyTags"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: Key("PreSignedUrl"))
        }
        if let sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifier {
            try container.encode(sourceDBClusterSnapshotIdentifier, forKey: Key("SourceDBClusterSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifier {
            try container.encode(targetDBClusterSnapshotIdentifier, forKey: Key("TargetDBClusterSnapshotIdentifier"))
        }
        try container.encode("CopyDBClusterSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CopyDBClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CopyDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterSnapshotOutputError>
}

public struct CopyDBClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBClusterSnapshotOutputError>
}

public struct CopyDBClusterSnapshotInput: Equatable {
    /// <p>True to copy all tags from the source DB cluster snapshot to the target DB cluster
    ///       snapshot, and otherwise false. The default is false.</p>
    public let copyTags: Bool?
    /// <p>The Amazon Amazon KMS key ID for an encrypted DB cluster snapshot. The KMS key ID is the Amazon
    ///       Resource Name (ARN), KMS key identifier, or the KMS key alias for the KMS encryption key.</p>
    ///
    ///          <p>If you copy an encrypted DB cluster snapshot from your Amazon account, you can specify a
    ///       value for <code>KmsKeyId</code> to encrypt the copy with a new KMS encryption key. If you
    ///       don't specify a value for <code>KmsKeyId</code>, then the copy of the DB cluster snapshot is
    ///       encrypted with the same KMS key as the source DB cluster snapshot.</p>
    ///
    ///          <p>If you copy an encrypted DB cluster snapshot that is shared from another Amazon account, then
    ///       you must specify a value for <code>KmsKeyId</code>.</p>
    ///          <p> KMS encryption keys are specific to the Amazon Region that they are created in, and you
    ///       can't use encryption keys from one Amazon Region in another Amazon Region.</p>
    ///
    ///          <p>You cannot encrypt an unencrypted DB cluster snapshot when you copy it. If you try to
    ///       copy an unencrypted DB cluster snapshot and specify a value for the KmsKeyId parameter, an
    ///       error is returned.</p>
    public let kmsKeyId: String?
    /// <p>Not currently supported.</p>
    public let preSignedUrl: String?
    /// <p>The identifier of the DB cluster snapshot to copy. This parameter is not
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must specify a valid system snapshot in the "available" state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Specify a valid DB snapshot identifier.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster-snapshot1</code>
    ///          </p>
    public let sourceDBClusterSnapshotIdentifier: String?
    /// <p>The tags to assign to the new DB cluster snapshot copy.</p>
    public let tags: [Tag]?
    /// <p>The identifier of the new DB cluster snapshot to create from the source DB cluster
    ///       snapshot. This parameter is not case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster-snapshot2</code>
    ///          </p>
    public let targetDBClusterSnapshotIdentifier: String?

    public init (
        copyTags: Bool? = nil,
        kmsKeyId: String? = nil,
        preSignedUrl: String? = nil,
        sourceDBClusterSnapshotIdentifier: String? = nil,
        tags: [Tag]? = nil,
        targetDBClusterSnapshotIdentifier: String? = nil
    )
    {
        self.copyTags = copyTags
        self.kmsKeyId = kmsKeyId
        self.preSignedUrl = preSignedUrl
        self.sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifier
        self.tags = tags
        self.targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifier
    }
}

extension CopyDBClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBClusterSnapshotOutputError: Equatable {
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(String(describing: dBClusterSnapshot)))"}
}

extension CopyDBClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct CopyDBClusterSnapshotOutputResponse: Equatable {
    /// <p>Contains the details for an Amazon Neptune DB cluster snapshot</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterSnapshots</a> action.</p>
    public let dBClusterSnapshot: DBClusterSnapshot?

    public init (
        dBClusterSnapshot: DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct CopyDBClusterSnapshotOutputResponseBody: Equatable {
    public let dBClusterSnapshot: DBClusterSnapshot?
}

extension CopyDBClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CopyDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct CopyDBParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "CopyDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBParameterGroupOutputError>
}

extension CopyDBParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBParameterGroupInput(sourceDBParameterGroupIdentifier: \(String(describing: sourceDBParameterGroupIdentifier)), tags: \(String(describing: tags)), targetDBParameterGroupDescription: \(String(describing: targetDBParameterGroupDescription)), targetDBParameterGroupIdentifier: \(String(describing: targetDBParameterGroupIdentifier)))"}
}

extension CopyDBParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifier {
            try container.encode(sourceDBParameterGroupIdentifier, forKey: Key("SourceDBParameterGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBParameterGroupDescription = targetDBParameterGroupDescription {
            try container.encode(targetDBParameterGroupDescription, forKey: Key("TargetDBParameterGroupDescription"))
        }
        if let targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifier {
            try container.encode(targetDBParameterGroupIdentifier, forKey: Key("TargetDBParameterGroupIdentifier"))
        }
        try container.encode("CopyDBParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CopyDBParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CopyDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBParameterGroupOutputError>
}

public struct CopyDBParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyDBParameterGroupOutputError>
}

public struct CopyDBParameterGroupInput: Equatable {
    /// <p>The identifier or ARN for the source DB parameter group. For information about creating
    ///       an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    ///
    ///          <p>Constraints:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>Must specify a valid DB parameter group.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must specify a valid DB parameter group identifier, for example
    ///         <code>my-db-param-group</code>, or a valid ARN.</p>
    ///             </li>
    ///          </ul>
    public let sourceDBParameterGroupIdentifier: String?
    /// <p>The tags to be assigned to the copied DB parameter group.</p>
    public let tags: [Tag]?
    /// <p>A description for the copied DB parameter group.</p>
    public let targetDBParameterGroupDescription: String?
    /// <p>The identifier for the copied DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Cannot be null, empty, or blank.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must contain from 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>Example: <code>my-db-parameter-group</code>
    ///          </p>
    public let targetDBParameterGroupIdentifier: String?

    public init (
        sourceDBParameterGroupIdentifier: String? = nil,
        tags: [Tag]? = nil,
        targetDBParameterGroupDescription: String? = nil,
        targetDBParameterGroupIdentifier: String? = nil
    )
    {
        self.sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifier
        self.tags = tags
        self.targetDBParameterGroupDescription = targetDBParameterGroupDescription
        self.targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifier
    }
}

extension CopyDBParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBParameterGroupOutputError: Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyDBParameterGroupOutputResponse(dBParameterGroup: \(String(describing: dBParameterGroup)))"}
}

extension CopyDBParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBParameterGroup = output.dBParameterGroup
        } else {
            self.dBParameterGroup = nil
        }
    }
}

public struct CopyDBParameterGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB parameter group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBParameterGroups</a> action.</p>
    public let dBParameterGroup: DBParameterGroup?

    public init (
        dBParameterGroup: DBParameterGroup? = nil
    )
    {
        self.dBParameterGroup = dBParameterGroup
    }
}

struct CopyDBParameterGroupOutputResponseBody: Equatable {
    public let dBParameterGroup: DBParameterGroup?
}

extension CopyDBParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroup = "DBParameterGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CopyDBParameterGroupResult"))
        let dBParameterGroupDecoded = try containerValues.decodeIfPresent(DBParameterGroup.self, forKey: .dBParameterGroup)
        dBParameterGroup = dBParameterGroupDecoded
    }
}

public struct CreateDBClusterEndpointInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterEndpointOutputError>
}

extension CreateDBClusterEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterEndpointInput(dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)), tags: \(String(describing: tags)))"}
}

extension CreateDBClusterEndpointInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterEndpoint", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBClusterEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterEndpointOutputError>
}

public struct CreateDBClusterEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterEndpointOutputError>
}

public struct CreateDBClusterEndpointInput: Equatable {
    /// <p>The identifier to use for the new endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///       stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>ANY</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///       All other eligible instances are reachable through the custom endpoint.
    ///       Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?
    /// <p>The tags to be assigned to the Amazon Neptune resource.</p>
    public let tags: [Tag]?

    public init (
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.tags = tags
    }
}

extension CreateDBClusterEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointAlreadyExistsFault" : self = .dBClusterEndpointAlreadyExistsFault(try DBClusterEndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterEndpointQuotaExceededFault" : self = .dBClusterEndpointQuotaExceededFault(try DBClusterEndpointQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterEndpointOutputError: Equatable {
    case dBClusterEndpointAlreadyExistsFault(DBClusterEndpointAlreadyExistsFault)
    case dBClusterEndpointQuotaExceededFault(DBClusterEndpointQuotaExceededFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterEndpointOutputResponse(customEndpointType: \(String(describing: customEndpointType)), dBClusterEndpointArn: \(String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), endpoint: \(String(describing: endpoint)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)), status: \(String(describing: status)))"}
}

extension CreateDBClusterEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// <p>This data type represents the information you need to connect to an Amazon Neptune DB cluster.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBClusterEndpoint</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon Neptune DB instance endpoints,
///       see <code>Endpoint</code>.</p>
public struct CreateDBClusterEndpointOutputResponse: Equatable {
    /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
    ///       <code>WRITER</code>, <code>ANY</code>.</p>
    public let customEndpointType: String?
    /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
    public let dBClusterEndpointArn: String?
    /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
    public let dBClusterEndpointResourceIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///       stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>The DNS address of the endpoint.</p>
    public let endpoint: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///       All other eligible instances are reachable through the custom endpoint.
    ///       Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?
    /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that cannot be used for a certain kind of cluster,
    ///       such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
    public let status: String?

    public init (
        customEndpointType: String? = nil,
        dBClusterEndpointArn: String? = nil,
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterEndpointResourceIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        endpoint: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil,
        status: String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct CreateDBClusterEndpointOutputResponseBody: Equatable {
    public let dBClusterEndpointIdentifier: String?
    public let dBClusterIdentifier: String?
    public let dBClusterEndpointResourceIdentifier: String?
    public let endpoint: String?
    public let status: String?
    public let endpointType: String?
    public let customEndpointType: String?
    public let staticMembers: [String]?
    public let excludedMembers: [String]?
    public let dBClusterEndpointArn: String?
}

extension CreateDBClusterEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var staticMembersBuffer:[String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var excludedMembersBuffer:[String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct CreateDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterOutputError>
}

extension CreateDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterInput(availabilityZones: \(String(describing: availabilityZones)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), characterSetName: \(String(describing: characterSetName)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), databaseName: \(String(describing: databaseName)), deletionProtection: \(String(describing: deletionProtection)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), kmsKeyId: \(String(describing: kmsKeyId)), masterUserPassword: \(String(describing: masterUserPassword)), masterUsername: \(String(describing: masterUsername)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), preSignedUrl: \(String(describing: preSignedUrl)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), replicationSourceIdentifier: \(String(describing: replicationSourceIdentifier)), storageEncrypted: \(String(describing: storageEncrypted)), tags: \(String(describing: tags)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension CreateDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: Key("PreSignedUrl"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: Key("ReplicationSourceIdentifier"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterOutputError>
}

public struct CreateDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterOutputError>
}

public struct CreateDBClusterInput: Equatable {
    /// <p>A list of EC2 Availability Zones that instances in the DB cluster can be created
    ///       in.</p>
    public let availabilityZones: [String]?
    /// <p>The number of days for which automated backups are retained. You must specify a minimum
    ///       value of 1.</p>
    ///          <p>Default: 1</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be a value from 1 to 35</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Int?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let characterSetName: String?
    /// <p>
    ///             <i>If set to <code>true</code>, tags are copied to any snapshot of
    ///       the DB cluster that is created.</i>
    ///          </p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The DB cluster identifier. This parameter is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster1</code>
    ///          </p>
    public let dBClusterIdentifier: String?
    /// <p> The name of the DB cluster parameter group to associate with this DB cluster. If this
    ///       argument is omitted, the default is used.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?
    /// <p>A DB subnet group to associate with this DB cluster.</p>
    ///          <p>Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>The name for your database of up to 64 alpha-numeric characters. If you do not provide a
    ///       name, Amazon Neptune will not create a database in the DB cluster you are creating.</p>
    public let databaseName: String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is enabled.</p>
    public let deletionProtection: Bool?
    /// <p>The list of log types that need to be enabled for exporting to CloudWatch Logs.</p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>If set to <code>true</code>, enables Amazon Identity and Access Management
    ///       (IAM) authentication for the entire DB cluster (this cannot be set at an
    ///       instance level).</p>
    ///          <p>Default: <code>false</code>.</p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>The name of the database engine to be used for this DB cluster.</p>
    ///          <p>Valid Values: <code>neptune</code>
    ///          </p>
    public let engine: String?
    /// <p>The version number of the database engine to use for the new DB cluster.</p>
    ///          <p>Example: <code>1.0.2.1</code>
    ///          </p>
    public let engineVersion: String?
    /// <p>The Amazon KMS key identifier for an encrypted DB cluster.</p>
    ///          <p>The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If
    ///       you are creating a DB cluster with the same Amazon account that owns the KMS encryption key used
    ///       to encrypt the new DB cluster, then you can use the KMS key alias instead of the ARN for the
    ///       KMS encryption key.</p>
    ///          <p>If an encryption key is not specified in <code>KmsKeyId</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If <code>ReplicationSourceIdentifier</code> identifies an encrypted source, then
    ///           Amazon Neptune will use the encryption key used to encrypt the source. Otherwise, Amazon
    ///           Neptune will use your default encryption key.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the <code>StorageEncrypted</code> parameter is true and
    ///           <code>ReplicationSourceIdentifier</code> is not specified, then Amazon Neptune will use
    ///           your default encryption key.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Amazon KMS creates the default encryption key for your Amazon account. Your Amazon account has a
    ///       different default encryption key for each Amazon Region.</p>
    ///          <p>If you create a Read Replica of an encrypted DB cluster in another Amazon Region, you must
    ///       set <code>KmsKeyId</code> to a KMS key ID that is valid in the destination Amazon Region. This
    ///       key is used to encrypt the Read Replica in that Amazon Region.</p>
    public let kmsKeyId: String?
    /// <p>Not supported by Neptune.</p>
    public let masterUserPassword: String?
    /// <p>Not supported by Neptune.</p>
    public let masterUsername: String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let optionGroupName: String?
    /// <p>The port number on which the instances in the DB cluster accept connections.</p>
    ///          <p> Default: <code>8182</code>
    ///          </p>
    public let port: Int?
    /// <p>This parameter is not currently supported.</p>
    public let preSignedUrl: String?
    /// <p>The daily time range during which automated backups are created if automated backups are
    ///       enabled using the <code>BackupRetentionPeriod</code> parameter.</p>
    ///          <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    ///       Amazon Region. To see the time blocks available, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/AdjustingTheMaintenanceWindow.html"> Adjusting the Preferred
    ///       Maintenance Window</a> in the <i>Amazon Neptune User Guide.</i>
    ///          </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be in the format <code>hh24:mi-hh24:mi</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Coordinated Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes.</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: String?
    /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated
    ///       Time (UTC).</p>
    ///          <p>Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///          </p>
    ///          <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    ///       Amazon Region, occurring on a random day of the week. To see the time blocks available, see
    ///       <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/AdjustingTheMaintenanceWindow.html"> Adjusting the Preferred
    ///       Maintenance Window</a> in the <i>Amazon Neptune User Guide.</i>
    ///          </p>
    ///          <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    ///          <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster
    ///       is created as a Read Replica.</p>
    public let replicationSourceIdentifier: String?
    /// <p>Specifies whether the DB cluster is encrypted.</p>
    public let storageEncrypted: Bool?
    /// <p>The tags to assign to the new DB cluster.</p>
    public let tags: [Tag]?
    /// <p>A list of EC2 VPC security groups to associate with this DB cluster.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        availabilityZones: [String]? = nil,
        backupRetentionPeriod: Int? = nil,
        characterSetName: String? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterParameterGroupName: String? = nil,
        dBSubnetGroupName: String? = nil,
        databaseName: String? = nil,
        deletionProtection: Bool? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        kmsKeyId: String? = nil,
        masterUserPassword: String? = nil,
        masterUsername: String? = nil,
        optionGroupName: String? = nil,
        port: Int? = nil,
        preSignedUrl: String? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        replicationSourceIdentifier: String? = nil,
        storageEncrypted: Bool? = nil,
        tags: [Tag]? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.optionGroupName = optionGroupName
        self.port = port
        self.preSignedUrl = preSignedUrl
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationSourceIdentifier = replicationSourceIdentifier
        self.storageEncrypted = storageEncrypted
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacityFault" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterOutputError: Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension CreateDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct CreateDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct CreateDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension CreateDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct CreateDBClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterParameterGroupOutputError>
}

extension CreateDBClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterParameterGroupInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), description: \(String(describing: description)), tags: \(String(describing: tags)))"}
}

extension CreateDBClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterParameterGroupOutputError>
}

public struct CreateDBClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterParameterGroupOutputError>
}

public struct CreateDBClusterParameterGroupInput: Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBClusterParameterGroupName: String?
    /// <p>The DB cluster parameter group family name. A DB cluster parameter group can be associated
    ///       with one and only one DB cluster parameter group family, and can be applied only to a DB
    ///       cluster running a database engine and engine version compatible with that DB cluster parameter
    ///       group family.</p>
    public let dBParameterGroupFamily: String?
    /// <p>The description for the DB cluster parameter group.</p>
    public let description: String?
    /// <p>The tags to be assigned to the new DB cluster parameter group.</p>
    public let tags: [Tag]?

    public init (
        dBClusterParameterGroupName: String? = nil,
        dBParameterGroupFamily: String? = nil,
        description: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.description = description
        self.tags = tags
    }
}

extension CreateDBClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterParameterGroupOutputError: Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterParameterGroupOutputResponse(dBClusterParameterGroup: \(String(describing: dBClusterParameterGroup)))"}
}

extension CreateDBClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterParameterGroup = output.dBClusterParameterGroup
        } else {
            self.dBClusterParameterGroup = nil
        }
    }
}

public struct CreateDBClusterParameterGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster parameter group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterParameterGroups</a> action.</p>
    public let dBClusterParameterGroup: DBClusterParameterGroup?

    public init (
        dBClusterParameterGroup: DBClusterParameterGroup? = nil
    )
    {
        self.dBClusterParameterGroup = dBClusterParameterGroup
    }
}

struct CreateDBClusterParameterGroupOutputResponseBody: Equatable {
    public let dBClusterParameterGroup: DBClusterParameterGroup?
}

extension CreateDBClusterParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroup = "DBClusterParameterGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBClusterParameterGroupResult"))
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(DBClusterParameterGroup.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
    }
}

public struct CreateDBClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterSnapshotOutputError>
}

extension CreateDBClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterSnapshotInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)), tags: \(String(describing: tags)))"}
}

extension CreateDBClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterSnapshotOutputError>
}

public struct CreateDBClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBClusterSnapshotOutputError>
}

public struct CreateDBClusterSnapshotInput: Equatable {
    /// <p>The identifier of the DB cluster to create a snapshot for. This parameter is not
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster1</code>
    ///          </p>
    public let dBClusterIdentifier: String?
    /// <p>The identifier of the DB cluster snapshot. This parameter is stored as a lowercase
    ///       string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster1-snapshot1</code>
    ///          </p>
    public let dBClusterSnapshotIdentifier: String?
    /// <p>The tags to be assigned to the DB cluster snapshot.</p>
    public let tags: [Tag]?

    public init (
        dBClusterIdentifier: String? = nil,
        dBClusterSnapshotIdentifier: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.tags = tags
    }
}

extension CreateDBClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterSnapshotOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(String(describing: dBClusterSnapshot)))"}
}

extension CreateDBClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct CreateDBClusterSnapshotOutputResponse: Equatable {
    /// <p>Contains the details for an Amazon Neptune DB cluster snapshot</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterSnapshots</a> action.</p>
    public let dBClusterSnapshot: DBClusterSnapshot?

    public init (
        dBClusterSnapshot: DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct CreateDBClusterSnapshotOutputResponseBody: Equatable {
    public let dBClusterSnapshot: DBClusterSnapshot?
}

extension CreateDBClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct CreateDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBInstanceOutputError>
}

extension CreateDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBInstanceInput(allocatedStorage: \(String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), availabilityZone: \(String(describing: availabilityZone)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), characterSetName: \(String(describing: characterSetName)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBName: \(String(describing: dBName)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), dBSecurityGroups: \(String(describing: dBSecurityGroups)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(String(describing: enablePerformanceInsights)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), iops: \(String(describing: iops)), kmsKeyId: \(String(describing: kmsKeyId)), licenseModel: \(String(describing: licenseModel)), masterUserPassword: \(String(describing: masterUserPassword)), masterUsername: \(String(describing: masterUsername)), monitoringInterval: \(String(describing: monitoringInterval)), monitoringRoleArn: \(String(describing: monitoringRoleArn)), multiAZ: \(String(describing: multiAZ)), optionGroupName: \(String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(String(describing: performanceInsightsKMSKeyId)), port: \(String(describing: port)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), promotionTier: \(String(describing: promotionTier)), publiclyAccessible: \(String(describing: publiclyAccessible)), storageEncrypted: \(String(describing: storageEncrypted)), storageType: \(String(describing: storageType)), tags: \(String(describing: tags)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), tdeCredentialPassword: \(String(describing: tdeCredentialPassword)), timezone: \(String(describing: timezone)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension CreateDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: Key("EnablePerformanceInsights"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: Key("PerformanceInsightsKMSKeyId"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: Key("PromotionTier"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: Key("TdeCredentialPassword"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: Key("Timezone"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBInstanceOutputError>
}

public struct CreateDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBInstanceOutputError>
}

public struct CreateDBInstanceInput: Equatable {
    /// <p>Not supported by Neptune.</p>
    public let allocatedStorage: Int?
    /// <p>Indicates that minor engine upgrades are applied automatically to the DB instance during
    ///       the maintenance window.</p>
    ///          <p>Default: <code>true</code>
    ///          </p>
    public let autoMinorVersionUpgrade: Bool?
    /// <p> The EC2 Availability Zone that the DB instance is created in</p>
    ///          <p>Default: A random, system-chosen Availability Zone in the endpoint's Amazon Region.</p>
    ///          <p> Example: <code>us-east-1d</code>
    ///          </p>
    ///          <p> Constraint: The AvailabilityZone parameter can't be specified if the MultiAZ parameter is
    ///       set to <code>true</code>. The specified Availability Zone must be in the same Amazon Region as
    ///       the current endpoint.</p>
    public let availabilityZone: String?
    /// <p>The number of days for which automated backups are
    ///       retained.</p>
    ///          <p>Not applicable. The retention period for automated backups is managed by the DB cluster.
    ///       For more information, see <a>CreateDBCluster</a>.</p>
    ///          <p>Default: 1</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be a value from 0 to 35</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be set to 0 if the DB instance is a source to Read Replicas</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Int?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let characterSetName: String?
    /// <p>True to copy all tags from the DB instance to snapshots of the DB instance, and otherwise
    ///       false. The default is false.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The identifier of the DB cluster that the instance will belong to.</p>
    ///          <p>For information on creating a DB cluster, see <a>CreateDBCluster</a>.</p>
    ///          <p>Type: String</p>
    public let dBClusterIdentifier: String?
    /// <p>The compute and memory capacity of the DB instance, for example, <code>db.m4.large</code>.
    ///       Not all DB instance classes are available in all Amazon Regions.</p>
    public let dBInstanceClass: String?
    /// <p>The DB instance identifier. This parameter is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>mydbinstance</code>
    ///          </p>
    public let dBInstanceIdentifier: String?
    /// <p>Not supported.</p>
    public let dBName: String?
    /// <p>The name of the DB parameter group to associate with this DB instance. If this argument is
    ///       omitted, the default DBParameterGroup for the specified engine is used.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>A list of DB security groups to associate with this DB instance.</p>
    ///          <p>Default: The default DB security group for the database engine.</p>
    public let dBSecurityGroups: [String]?
    /// <p>A DB subnet group to associate with this DB instance.</p>
    ///          <p>If there is no DB subnet group, then it is a non-VPC DB instance.</p>
    public let dBSubnetGroupName: String?
    /// <p>A value that indicates whether the DB instance has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is disabled. See <a href="https://docs.aws.amazon.com/neptune/latest/userguide/manage-console-instances-delete.html">Deleting
    ///       a DB Instance</a>.</p>
    ///
    ///          <p>DB instances in a DB cluster can be deleted even when deletion
    ///       protection is enabled in their parent DB cluster.</p>
    public let deletionProtection: Bool?
    /// <p>Specify the Active Directory Domain to create the instance in.</p>
    public let domain: String?
    /// <p>Specify the name of the IAM role to be used when making API calls to the Directory
    ///       Service.</p>
    public let domainIAMRoleName: String?
    /// <p>The list of log types that need to be enabled for exporting to CloudWatch Logs.</p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>Not supported by Neptune (ignored).</p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let enablePerformanceInsights: Bool?
    /// <p>The name of the database engine to be used for this instance.</p>
    ///          <p>Valid Values: <code>neptune</code>
    ///          </p>
    public let engine: String?
    /// <p>The version number of the database engine to use. Currently, setting this
    ///       parameter has no effect.</p>
    public let engineVersion: String?
    /// <p>The amount of Provisioned IOPS (input/output operations per second) to be initially
    ///       allocated for the DB instance.</p>
    public let iops: Int?
    /// <p>The Amazon KMS key identifier for an encrypted DB instance.</p>
    ///          <p>The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If
    ///       you are creating a DB instance with the same Amazon account that owns the KMS encryption key used
    ///       to encrypt the new DB instance, then you can use the KMS key alias instead of the ARN for the
    ///       KM encryption key.</p>
    ///          <p>Not applicable. The KMS key identifier is managed by the DB cluster. For more information,
    ///       see <a>CreateDBCluster</a>.</p>
    ///          <p>If the <code>StorageEncrypted</code> parameter is true, and you do not specify a value for
    ///       the <code>KmsKeyId</code> parameter, then Amazon Neptune will use your default encryption key.
    ///       Amazon KMS creates the default encryption key for your Amazon account. Your Amazon account has a
    ///       different default encryption key for each Amazon Region.</p>
    public let kmsKeyId: String?
    /// <p>License model information for this DB instance.</p>
    ///          <p> Valid values: <code>license-included</code> | <code>bring-your-own-license</code> |
    ///       <code>general-public-license</code>
    ///          </p>
    public let licenseModel: String?
    /// <p>Not supported by Neptune.</p>
    public let masterUserPassword: String?
    /// <p>Not supported by Neptune.</p>
    public let masterUsername: String?
    /// <p>The interval, in seconds, between points when Enhanced Monitoring metrics are collected
    ///       for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default
    ///       is 0.</p>
    ///          <p>If <code>MonitoringRoleArn</code> is specified, then you must also set
    ///       <code>MonitoringInterval</code> to a value other than 0.</p>
    ///          <p>Valid Values: <code>0, 1, 5, 10, 15, 30, 60</code>
    ///          </p>
    public let monitoringInterval: Int?
    /// <p>The ARN for the IAM role that permits Neptune to send enhanced monitoring metrics to
    ///       Amazon CloudWatch Logs. For example,
    ///       <code>arn:aws:iam:123456789012:role/emaccess</code>.</p>
    ///          <p>If <code>MonitoringInterval</code> is set to a value other than 0, then you must supply a
    ///       <code>MonitoringRoleArn</code> value.</p>
    public let monitoringRoleArn: String?
    /// <p>Specifies if the DB instance is a Multi-AZ deployment. You can't set the AvailabilityZone
    ///       parameter if the MultiAZ parameter is set to true.</p>
    public let multiAZ: Bool?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let optionGroupName: String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let performanceInsightsKMSKeyId: String?
    /// <p>The port number on which the database accepts connections.</p>
    ///          <p>Not applicable. The port is managed by the DB cluster. For more information, see <a>CreateDBCluster</a>.</p>
    ///          <p> Default: <code>8182</code>
    ///          </p>
    ///          <p>Type: Integer</p>
    public let port: Int?
    /// <p> The daily time range during which automated backups are created.</p>
    ///          <p>Not applicable. The daily time range for creating automated backups is managed by the DB
    ///       cluster. For more information, see <a>CreateDBCluster</a>.</p>
    public let preferredBackupWindow: String?
    /// <p>The time range each week during which system maintenance can occur, in Universal
    ///       Coordinated Time (UTC).</p>
    ///          <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///          </p>
    ///          <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    ///       Amazon Region, occurring on a random day of the week.</p>
    ///          <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    ///          <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>A value that specifies the order in which an Read Replica is promoted to the primary
    ///       instance after a failure of the existing primary instance.
    ///       </p>
    ///          <p>Default: 1</p>
    ///          <p>Valid Values: 0 - 15</p>
    public let promotionTier: Int?
    /// <p>This flag should no longer be used.</p>
    @available(*, deprecated)
    public let publiclyAccessible: Bool?
    /// <p>Specifies whether the DB instance is encrypted.</p>
    ///          <p>Not applicable. The encryption for DB instances is managed by the DB cluster. For more
    ///       information, see <a>CreateDBCluster</a>.</p>
    ///          <p>Default: false</p>
    public let storageEncrypted: Bool?
    /// <p>Specifies the storage type to be associated with the DB instance.</p>
    ///          <p>Not applicable. Storage is managed by the DB Cluster.</p>
    public let storageType: String?
    /// <p>The tags to assign to the new instance.</p>
    public let tags: [Tag]?
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>The password for the given ARN from the key store in order to access the device.</p>
    public let tdeCredentialPassword: String?
    /// <p>The time zone of the DB instance.</p>
    public let timezone: String?
    /// <p>A list of EC2 VPC security groups to associate with this DB instance.</p>
    ///          <p>Not applicable. The associated list of EC2 VPC security groups is managed by the DB
    ///       cluster. For more information, see <a>CreateDBCluster</a>.</p>
    ///          <p>Default: The default EC2 VPC security group for the DB subnet group's VPC.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        allocatedStorage: Int? = nil,
        autoMinorVersionUpgrade: Bool? = nil,
        availabilityZone: String? = nil,
        backupRetentionPeriod: Int? = nil,
        characterSetName: String? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBClusterIdentifier: String? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBName: String? = nil,
        dBParameterGroupName: String? = nil,
        dBSecurityGroups: [String]? = nil,
        dBSubnetGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        enablePerformanceInsights: Bool? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        iops: Int? = nil,
        kmsKeyId: String? = nil,
        licenseModel: String? = nil,
        masterUserPassword: String? = nil,
        masterUsername: String? = nil,
        monitoringInterval: Int? = nil,
        monitoringRoleArn: String? = nil,
        multiAZ: Bool? = nil,
        optionGroupName: String? = nil,
        performanceInsightsKMSKeyId: String? = nil,
        port: Int? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        promotionTier: Int? = nil,
        publiclyAccessible: Bool? = nil,
        storageEncrypted: Bool? = nil,
        storageType: String? = nil,
        tags: [Tag]? = nil,
        tdeCredentialArn: String? = nil,
        tdeCredentialPassword: String? = nil,
        timezone: String? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engine = engine
        self.engineVersion = engineVersion
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tags = tags
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.timezone = timezone
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExistsFault" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceededFault" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacityFault" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupportedFault" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBInstanceOutputError: Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBInstanceOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension CreateDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct CreateDBInstanceOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB instance.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBInstances</a> action.</p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct CreateDBInstanceOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension CreateDBInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct CreateDBParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBParameterGroupOutputError>
}

extension CreateDBParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBParameterGroupInput(dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), description: \(String(describing: description)), tags: \(String(describing: tags)))"}
}

extension CreateDBParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBParameterGroupOutputError>
}

public struct CreateDBParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBParameterGroupOutputError>
}

public struct CreateDBParameterGroupInput: Equatable {
    /// <p>The DB parameter group family name. A DB parameter group can be associated with one and
    ///       only one DB parameter group family, and can be applied only to a DB instance running a
    ///       database engine and engine version compatible with that DB parameter group family.</p>
    public let dBParameterGroupFamily: String?
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBParameterGroupName: String?
    /// <p>The description for the DB parameter group.</p>
    public let description: String?
    /// <p>The tags to be assigned to the new DB parameter group.</p>
    public let tags: [Tag]?

    public init (
        dBParameterGroupFamily: String? = nil,
        dBParameterGroupName: String? = nil,
        description: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.dBParameterGroupName = dBParameterGroupName
        self.description = description
        self.tags = tags
    }
}

extension CreateDBParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBParameterGroupOutputError: Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBParameterGroupOutputResponse(dBParameterGroup: \(String(describing: dBParameterGroup)))"}
}

extension CreateDBParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBParameterGroup = output.dBParameterGroup
        } else {
            self.dBParameterGroup = nil
        }
    }
}

public struct CreateDBParameterGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB parameter group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBParameterGroups</a> action.</p>
    public let dBParameterGroup: DBParameterGroup?

    public init (
        dBParameterGroup: DBParameterGroup? = nil
    )
    {
        self.dBParameterGroup = dBParameterGroup
    }
}

struct CreateDBParameterGroupOutputResponseBody: Equatable {
    public let dBParameterGroup: DBParameterGroup?
}

extension CreateDBParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroup = "DBParameterGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBParameterGroupResult"))
        let dBParameterGroupDecoded = try containerValues.decodeIfPresent(DBParameterGroup.self, forKey: .dBParameterGroup)
        dBParameterGroup = dBParameterGroupDecoded
    }
}

public struct CreateDBSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSubnetGroupOutputError>
}

extension CreateDBSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBSubnetGroupInput(dBSubnetGroupDescription: \(String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)))"}
}

extension CreateDBSubnetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBSubnetGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateDBSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSubnetGroupOutputError>
}

public struct CreateDBSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDBSubnetGroupOutputError>
}

public struct CreateDBSubnetGroupInput: Equatable {
    /// <p>The description for the DB subnet group.</p>
    public let dBSubnetGroupDescription: String?
    /// <p>The name for the DB subnet group. This value is stored as a lowercase string.</p>
    ///          <p>Constraints: Must contain no more than 255 letters, numbers, periods, underscores, spaces,
    ///       or hyphens. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>The EC2 Subnet IDs for the DB subnet group.</p>
    public let subnetIds: [String]?
    /// <p>The tags to be assigned to the new DB subnet group.</p>
    public let tags: [Tag]?

    public init (
        dBSubnetGroupDescription: String? = nil,
        dBSubnetGroupName: String? = nil,
        subnetIds: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

extension CreateDBSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupAlreadyExistsFault" : self = .dBSubnetGroupAlreadyExistsFault(try DBSubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupQuotaExceededFault" : self = .dBSubnetGroupQuotaExceededFault(try DBSubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetQuotaExceededFault" : self = .dBSubnetQuotaExceededFault(try DBSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBSubnetGroupOutputError: Equatable {
    case dBSubnetGroupAlreadyExistsFault(DBSubnetGroupAlreadyExistsFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupQuotaExceededFault(DBSubnetGroupQuotaExceededFault)
    case dBSubnetQuotaExceededFault(DBSubnetQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDBSubnetGroupOutputResponse(dBSubnetGroup: \(String(describing: dBSubnetGroup)))"}
}

extension CreateDBSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDBSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSubnetGroup = output.dBSubnetGroup
        } else {
            self.dBSubnetGroup = nil
        }
    }
}

public struct CreateDBSubnetGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB subnet group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBSubnetGroups</a> action.</p>
    public let dBSubnetGroup: DBSubnetGroup?

    public init (
        dBSubnetGroup: DBSubnetGroup? = nil
    )
    {
        self.dBSubnetGroup = dBSubnetGroup
    }
}

struct CreateDBSubnetGroupOutputResponseBody: Equatable {
    public let dBSubnetGroup: DBSubnetGroup?
}

extension CreateDBSubnetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSubnetGroup = "DBSubnetGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateDBSubnetGroupResult"))
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
    }
}

public struct CreateEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

extension CreateEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventSubscriptionInput(enabled: \(String(describing: enabled)), eventCategories: \(String(describing: eventCategories)), snsTopicArn: \(String(describing: snsTopicArn)), sourceIds: \(String(describing: sourceIds)), sourceType: \(String(describing: sourceType)), subscriptionName: \(String(describing: subscriptionName)), tags: \(String(describing: tags)))"}
}

extension CreateEventSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: Key("SnsTopicArn"))
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SourceIds"))
            for (index0, string0) in sourceIds.enumerated() {
                try sourceIdsContainer.encode(string0, forKey: Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateEventSubscription", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct CreateEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

public struct CreateEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

public struct CreateEventSubscriptionInput: Equatable {
    /// <p> A Boolean value; set to <b>true</b> to activate the
    ///       subscription, set to <b>false</b> to create the subscription but not
    ///       active it.</p>
    public let enabled: Bool?
    /// <p> A list of event categories for a SourceType that you want to subscribe to. You can see a
    ///       list of the categories for a given SourceType by using the
    ///       <b>DescribeEventCategories</b> action.</p>
    public let eventCategories: [String]?
    /// <p>The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is
    ///       created by Amazon SNS when you create a topic and subscribe to it.</p>
    public let snsTopicArn: String?
    /// <p>The list of identifiers of the event sources for which events are returned. If not
    ///       specified, then all sources are included in the response. An identifier must begin with a
    ///       letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or
    ///       contain two consecutive hyphens.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If SourceIds are supplied, SourceType must also be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB instance, then a <code>DBInstanceIdentifier</code> must be
    ///           supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB security group, a <code>DBSecurityGroupName</code> must be
    ///           supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB parameter group, a <code>DBParameterGroupName</code> must
    ///           be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB snapshot, a <code>DBSnapshotIdentifier</code> must be
    ///           supplied.</p>
    ///             </li>
    ///          </ul>
    public let sourceIds: [String]?
    /// <p>The type of source that is generating the events. For example, if you want to be notified
    ///       of events generated by a DB instance, you would set this parameter to db-instance. if this
    ///       value is not specified, all events are returned.</p>
    ///          <p>Valid values: <code>db-instance</code> | <code>db-cluster</code> |
    ///       <code>db-parameter-group</code> | <code>db-security-group</code> | <code>db-snapshot</code> |
    ///       <code>db-cluster-snapshot</code>
    ///          </p>
    public let sourceType: String?
    /// <p>The name of the subscription.</p>
    ///          <p>Constraints: The name must be less than 255 characters.</p>
    public let subscriptionName: String?
    /// <p>The tags to be applied to the new event subscription.</p>
    public let tags: [Tag]?

    public init (
        enabled: Bool? = nil,
        eventCategories: [String]? = nil,
        snsTopicArn: String? = nil,
        sourceIds: [String]? = nil,
        sourceType: String? = nil,
        subscriptionName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

extension CreateEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceededFault" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFoundFault" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionAlreadyExistFault" : self = .subscriptionAlreadyExistFault(try SubscriptionAlreadyExistFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFoundFault" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSubscriptionOutputError: Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionAlreadyExistFault(SubscriptionAlreadyExistFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension CreateEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct CreateEventSubscriptionOutputResponse: Equatable {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct CreateEventSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension CreateEventSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension DBCluster: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case automaticRestartTime = "AutomaticRestartTime"
        case availabilityZones = "AvailabilityZones"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case characterSetName = "CharacterSetName"
        case cloneGroupId = "CloneGroupId"
        case clusterCreateTime = "ClusterCreateTime"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case crossAccountClone = "CrossAccountClone"
        case dBClusterArn = "DBClusterArn"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterMembers = "DBClusterMembers"
        case dBClusterOptionGroupMemberships = "DBClusterOptionGroupMemberships"
        case dBClusterParameterGroup = "DBClusterParameterGroup"
        case dBSubnetGroup = "DBSubnetGroup"
        case databaseName = "DatabaseName"
        case dbClusterResourceId = "DbClusterResourceId"
        case deletionProtection = "DeletionProtection"
        case earliestRestorableTime = "EarliestRestorableTime"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case hostedZoneId = "HostedZoneId"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case masterUsername = "MasterUsername"
        case multiAZ = "MultiAZ"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case readReplicaIdentifiers = "ReadReplicaIdentifiers"
        case readerEndpoint = "ReaderEndpoint"
        case replicationSourceIdentifier = "ReplicationSourceIdentifier"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AssociatedRoles"))
            for (index0, dbclusterrole0) in associatedRoles.enumerated() {
                try associatedRolesContainer.encode(dbclusterrole0, forKey: Key("DBClusterRole.\(index0.advanced(by: 1))"))
            }
        }
        if let automaticRestartTime = automaticRestartTime {
            try container.encode(TimestampWrapper(automaticRestartTime, format: .dateTime), forKey: Key("automaticRestartTime"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
        if let cloneGroupId = cloneGroupId {
            try container.encode(cloneGroupId, forKey: Key("CloneGroupId"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: Key("clusterCreateTime"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let crossAccountClone = crossAccountClone {
            try container.encode(crossAccountClone, forKey: Key("CrossAccountClone"))
        }
        if let dBClusterArn = dBClusterArn {
            try container.encode(dBClusterArn, forKey: Key("DBClusterArn"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterMembers = dBClusterMembers {
            var dBClusterMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBClusterMembers"))
            for (index0, dbclustermember0) in dBClusterMembers.enumerated() {
                try dBClusterMembersContainer.encode(dbclustermember0, forKey: Key("DBClusterMember.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships {
            var dBClusterOptionGroupMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBClusterOptionGroupMemberships"))
            for (index0, dbclusteroptiongroupstatus0) in dBClusterOptionGroupMemberships.enumerated() {
                try dBClusterOptionGroupMembershipsContainer.encode(dbclusteroptiongroupstatus0, forKey: Key("DBClusterOptionGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterParameterGroup = dBClusterParameterGroup {
            try container.encode(dBClusterParameterGroup, forKey: Key("DBClusterParameterGroup"))
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: Key("DBSubnetGroup"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let dbClusterResourceId = dbClusterResourceId {
            try container.encode(dbClusterResourceId, forKey: Key("DbClusterResourceId"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let earliestRestorableTime = earliestRestorableTime {
            try container.encode(TimestampWrapper(earliestRestorableTime, format: .dateTime), forKey: Key("earliestRestorableTime"))
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: Key("HostedZoneId"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: Key("latestRestorableTime"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let percentProgress = percentProgress {
            try container.encode(percentProgress, forKey: Key("PercentProgress"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let readReplicaIdentifiers = readReplicaIdentifiers {
            var readReplicaIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReadReplicaIdentifiers"))
            for (index0, string0) in readReplicaIdentifiers.enumerated() {
                try readReplicaIdentifiersContainer.encode(string0, forKey: Key("ReadReplicaIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readerEndpoint = readerEndpoint {
            try container.encode(readerEndpoint, forKey: Key("ReaderEndpoint"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: Key("ReplicationSourceIdentifier"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let characterSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let earliestRestorableTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .earliestRestorableTime)
        var earliestRestorableTimeBuffer:Date? = nil
        if let earliestRestorableTimeDecoded = earliestRestorableTimeDecoded {
            earliestRestorableTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(earliestRestorableTimeDecoded, format: .dateTime)
        }
        earliestRestorableTime = earliestRestorableTimeBuffer
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let readerEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readerEndpoint)
        readerEndpoint = readerEndpointDecoded
        let multiAZDecoded = try containerValues.decode(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        if containerValues.contains(.dBClusterOptionGroupMemberships) {
            struct KeyVal0{struct DBClusterOptionGroup{}}
            let dBClusterOptionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterOptionGroup>.CodingKeys.self, forKey: .dBClusterOptionGroupMemberships)
            if let dBClusterOptionGroupMembershipsWrappedContainer = dBClusterOptionGroupMembershipsWrappedContainer {
                let dBClusterOptionGroupMembershipsContainer = try dBClusterOptionGroupMembershipsWrappedContainer.decodeIfPresent([DBClusterOptionGroupStatus].self, forKey: .member)
                var dBClusterOptionGroupMembershipsBuffer:[DBClusterOptionGroupStatus]? = nil
                if let dBClusterOptionGroupMembershipsContainer = dBClusterOptionGroupMembershipsContainer {
                    dBClusterOptionGroupMembershipsBuffer = [DBClusterOptionGroupStatus]()
                    for structureContainer0 in dBClusterOptionGroupMembershipsContainer {
                        dBClusterOptionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterOptionGroupMemberships = dBClusterOptionGroupMembershipsBuffer
            } else {
                dBClusterOptionGroupMemberships = []
            }
        } else {
            dBClusterOptionGroupMemberships = nil
        }
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let replicationSourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationSourceIdentifier)
        replicationSourceIdentifier = replicationSourceIdentifierDecoded
        if containerValues.contains(.readReplicaIdentifiers) {
            struct KeyVal0{struct ReadReplicaIdentifier{}}
            let readReplicaIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaIdentifier>.CodingKeys.self, forKey: .readReplicaIdentifiers)
            if let readReplicaIdentifiersWrappedContainer = readReplicaIdentifiersWrappedContainer {
                let readReplicaIdentifiersContainer = try readReplicaIdentifiersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var readReplicaIdentifiersBuffer:[String]? = nil
                if let readReplicaIdentifiersContainer = readReplicaIdentifiersContainer {
                    readReplicaIdentifiersBuffer = [String]()
                    for stringContainer0 in readReplicaIdentifiersContainer {
                        readReplicaIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaIdentifiers = readReplicaIdentifiersBuffer
            } else {
                readReplicaIdentifiers = []
            }
        } else {
            readReplicaIdentifiers = nil
        }
        if containerValues.contains(.dBClusterMembers) {
            struct KeyVal0{struct DBClusterMember{}}
            let dBClusterMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterMember>.CodingKeys.self, forKey: .dBClusterMembers)
            if let dBClusterMembersWrappedContainer = dBClusterMembersWrappedContainer {
                let dBClusterMembersContainer = try dBClusterMembersWrappedContainer.decodeIfPresent([DBClusterMember].self, forKey: .member)
                var dBClusterMembersBuffer:[DBClusterMember]? = nil
                if let dBClusterMembersContainer = dBClusterMembersContainer {
                    dBClusterMembersBuffer = [DBClusterMember]()
                    for structureContainer0 in dBClusterMembersContainer {
                        dBClusterMembersBuffer?.append(structureContainer0)
                    }
                }
                dBClusterMembers = dBClusterMembersBuffer
            } else {
                dBClusterMembers = []
            }
        } else {
            dBClusterMembers = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let storageEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbClusterResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterResourceId)
        dbClusterResourceId = dbClusterResourceIdDecoded
        let dBClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterArn)
        dBClusterArn = dBClusterArnDecoded
        if containerValues.contains(.associatedRoles) {
            struct KeyVal0{struct DBClusterRole{}}
            let associatedRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterRole>.CodingKeys.self, forKey: .associatedRoles)
            if let associatedRolesWrappedContainer = associatedRolesWrappedContainer {
                let associatedRolesContainer = try associatedRolesWrappedContainer.decodeIfPresent([DBClusterRole].self, forKey: .member)
                var associatedRolesBuffer:[DBClusterRole]? = nil
                if let associatedRolesContainer = associatedRolesContainer {
                    associatedRolesBuffer = [DBClusterRole]()
                    for structureContainer0 in associatedRolesContainer {
                        associatedRolesBuffer?.append(structureContainer0)
                    }
                }
                associatedRoles = associatedRolesBuffer
            } else {
                associatedRoles = []
            }
        } else {
            associatedRoles = nil
        }
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let cloneGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloneGroupId)
        cloneGroupId = cloneGroupIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let crossAccountCloneDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .crossAccountClone)
        crossAccountClone = crossAccountCloneDecoded
        let automaticRestartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automaticRestartTime)
        var automaticRestartTimeBuffer:Date? = nil
        if let automaticRestartTimeDecoded = automaticRestartTimeDecoded {
            automaticRestartTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(automaticRestartTimeDecoded, format: .dateTime)
        }
        automaticRestartTime = automaticRestartTimeBuffer
    }
}

extension DBCluster: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBCluster(allocatedStorage: \(String(describing: allocatedStorage)), associatedRoles: \(String(describing: associatedRoles)), automaticRestartTime: \(String(describing: automaticRestartTime)), availabilityZones: \(String(describing: availabilityZones)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), characterSetName: \(String(describing: characterSetName)), cloneGroupId: \(String(describing: cloneGroupId)), clusterCreateTime: \(String(describing: clusterCreateTime)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), crossAccountClone: \(String(describing: crossAccountClone)), dBClusterArn: \(String(describing: dBClusterArn)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterMembers: \(String(describing: dBClusterMembers)), dBClusterOptionGroupMemberships: \(String(describing: dBClusterOptionGroupMemberships)), dBClusterParameterGroup: \(String(describing: dBClusterParameterGroup)), dBSubnetGroup: \(String(describing: dBSubnetGroup)), databaseName: \(String(describing: databaseName)), dbClusterResourceId: \(String(describing: dbClusterResourceId)), deletionProtection: \(String(describing: deletionProtection)), earliestRestorableTime: \(String(describing: earliestRestorableTime)), enabledCloudwatchLogsExports: \(String(describing: enabledCloudwatchLogsExports)), endpoint: \(String(describing: endpoint)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), hostedZoneId: \(String(describing: hostedZoneId)), iAMDatabaseAuthenticationEnabled: \(String(describing: iAMDatabaseAuthenticationEnabled)), kmsKeyId: \(String(describing: kmsKeyId)), latestRestorableTime: \(String(describing: latestRestorableTime)), masterUsername: \(String(describing: masterUsername)), multiAZ: \(String(describing: multiAZ)), percentProgress: \(String(describing: percentProgress)), port: \(String(describing: port)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), readReplicaIdentifiers: \(String(describing: readReplicaIdentifiers)), readerEndpoint: \(String(describing: readerEndpoint)), replicationSourceIdentifier: \(String(describing: replicationSourceIdentifier)), status: \(String(describing: status)), storageEncrypted: \(String(describing: storageEncrypted)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

/// <p>Contains the details of an Amazon Neptune DB cluster.</p>
///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
public struct DBCluster: Equatable {
    /// <p>
    ///             <code>AllocatedStorage</code> always returns 1, because Neptune DB cluster storage size is
    ///       not fixed, but instead automatically adjusts as needed.</p>
    public let allocatedStorage: Int?
    /// <p>Provides a list of the Amazon Identity and Access Management (IAM) roles that are associated
    ///       with the DB cluster. IAM roles that are associated with a DB cluster grant permission for the
    ///       DB cluster to access other Amazon services on your behalf.</p>
    public let associatedRoles: [DBClusterRole]?
    /// <p>Time at which the DB cluster will be automatically restarted.</p>
    public let automaticRestartTime: Date?
    /// <p>Provides the list of EC2 Availability Zones that instances in the DB cluster can be
    ///       created in.</p>
    public let availabilityZones: [String]?
    /// <p>Specifies the number of days for which automatic DB snapshots are retained.</p>
    public let backupRetentionPeriod: Int?
    /// <p>Not supported by Neptune.</p>
    public let characterSetName: String?
    /// <p>Identifies the clone group to which the DB cluster is associated.</p>
    public let cloneGroupId: String?
    /// <p>Specifies the time when the DB cluster was created, in Universal Coordinated Time
    ///       (UTC).</p>
    public let clusterCreateTime: Date?
    /// <p>
    ///             <i>If set to <code>true</code>, tags are copied to any snapshot of
    ///       the DB cluster that is created.</i>
    ///          </p>
    public let copyTagsToSnapshot: Bool?
    /// <p>If set to <code>true</code>, the DB cluster can be cloned across accounts.</p>
    public let crossAccountClone: Bool?
    /// <p>The Amazon Resource Name (ARN) for the DB cluster.</p>
    public let dBClusterArn: String?
    /// <p>Contains a user-supplied DB cluster identifier. This identifier is the unique key that
    ///       identifies a DB cluster.</p>
    public let dBClusterIdentifier: String?
    /// <p>Provides the list of instances that make up the DB cluster.</p>
    public let dBClusterMembers: [DBClusterMember]?
    /// <p>Not supported by Neptune.</p>
    public let dBClusterOptionGroupMemberships: [DBClusterOptionGroupStatus]?
    /// <p>Specifies the name of the DB cluster parameter group for the DB cluster.</p>
    public let dBClusterParameterGroup: String?
    /// <p>Specifies information on the subnet group associated with the DB cluster, including the
    ///       name, description, and subnets in the subnet group.</p>
    public let dBSubnetGroup: String?
    /// <p>Contains the name of the initial database of this DB cluster that was provided at create
    ///       time, if one was specified when the DB cluster was created. This same name is returned for the
    ///       life of the DB cluster.</p>
    public let databaseName: String?
    /// <p>The Amazon Region-unique, immutable identifier for the DB cluster. This identifier is found
    ///       in Amazon CloudTrail log entries whenever the Amazon KMS key for the DB cluster is accessed.</p>
    public let dbClusterResourceId: String?
    /// <p>Indicates whether or not the DB cluster has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled.</p>
    public let deletionProtection: Bool?
    /// <p>Specifies the earliest time to which a database can be restored with point-in-time
    ///       restore.</p>
    public let earliestRestorableTime: Date?
    /// <p>A list of log types that this DB cluster is configured to export to CloudWatch Logs.</p>
    public let enabledCloudwatchLogsExports: [String]?
    /// <p>Specifies the connection endpoint for the primary instance of the DB cluster.</p>
    public let endpoint: String?
    /// <p>Provides the name of the database engine to be used for this DB cluster.</p>
    public let engine: String?
    /// <p>Indicates the database engine version.</p>
    public let engineVersion: String?
    /// <p>Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.</p>
    public let hostedZoneId: String?
    /// <p>True if mapping of Amazon Identity and Access Management (IAM) accounts to database accounts
    ///       is enabled, and otherwise false.</p>
    public let iAMDatabaseAuthenticationEnabled: Bool
    /// <p>If <code>StorageEncrypted</code> is true, the Amazon KMS key identifier for the
    ///       encrypted DB cluster.</p>
    public let kmsKeyId: String?
    /// <p>Specifies the latest time to which a database can be restored with point-in-time
    ///       restore.</p>
    public let latestRestorableTime: Date?
    /// <p>Not supported by Neptune.</p>
    public let masterUsername: String?
    /// <p>Specifies whether the DB cluster has instances in multiple Availability Zones.</p>
    public let multiAZ: Bool
    /// <p>Specifies the progress of the operation as a percentage.</p>
    public let percentProgress: String?
    /// <p>Specifies the port that the database engine is listening on.</p>
    public let port: Int?
    /// <p>Specifies the daily time range during which automated backups are created if automated
    ///       backups are enabled, as determined by the <code>BackupRetentionPeriod</code>.</p>
    public let preferredBackupWindow: String?
    /// <p>Specifies the weekly time range during which system maintenance can occur, in Universal
    ///       Coordinated Time (UTC).</p>
    public let preferredMaintenanceWindow: String?
    /// <p>Contains one or more identifiers of the Read Replicas associated with this DB
    ///       cluster.</p>
    public let readReplicaIdentifiers: [String]?
    /// <p>The reader endpoint for the DB cluster. The reader endpoint for a DB cluster load-balances
    ///       connections across the Read Replicas that are available in a DB cluster. As clients request
    ///       new connections to the reader endpoint, Neptune distributes the connection requests among the
    ///       Read Replicas in the DB cluster. This functionality can help balance your read workload across
    ///       multiple Read Replicas in your DB cluster.</p>
    ///          <p>If a failover occurs, and the Read Replica that you are connected to is promoted to be the
    ///       primary instance, your connection is dropped. To continue sending your read workload to other
    ///       Read Replicas in the cluster, you can then reconnect to the reader endpoint.</p>
    public let readerEndpoint: String?
    /// <p>Not supported by Neptune.</p>
    public let replicationSourceIdentifier: String?
    /// <p>Specifies the current state of this DB cluster.</p>
    public let status: String?
    /// <p>Specifies whether the DB cluster is encrypted.</p>
    public let storageEncrypted: Bool
    /// <p>Provides a list of VPC security groups that the DB cluster belongs to.</p>
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

    public init (
        allocatedStorage: Int? = nil,
        associatedRoles: [DBClusterRole]? = nil,
        automaticRestartTime: Date? = nil,
        availabilityZones: [String]? = nil,
        backupRetentionPeriod: Int? = nil,
        characterSetName: String? = nil,
        cloneGroupId: String? = nil,
        clusterCreateTime: Date? = nil,
        copyTagsToSnapshot: Bool? = nil,
        crossAccountClone: Bool? = nil,
        dBClusterArn: String? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterMembers: [DBClusterMember]? = nil,
        dBClusterOptionGroupMemberships: [DBClusterOptionGroupStatus]? = nil,
        dBClusterParameterGroup: String? = nil,
        dBSubnetGroup: String? = nil,
        databaseName: String? = nil,
        dbClusterResourceId: String? = nil,
        deletionProtection: Bool? = nil,
        earliestRestorableTime: Date? = nil,
        enabledCloudwatchLogsExports: [String]? = nil,
        endpoint: String? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        hostedZoneId: String? = nil,
        iAMDatabaseAuthenticationEnabled: Bool = false,
        kmsKeyId: String? = nil,
        latestRestorableTime: Date? = nil,
        masterUsername: String? = nil,
        multiAZ: Bool = false,
        percentProgress: String? = nil,
        port: Int? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        readReplicaIdentifiers: [String]? = nil,
        readerEndpoint: String? = nil,
        replicationSourceIdentifier: String? = nil,
        status: String? = nil,
        storageEncrypted: Bool = false,
        vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.associatedRoles = associatedRoles
        self.automaticRestartTime = automaticRestartTime
        self.availabilityZones = availabilityZones
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.cloneGroupId = cloneGroupId
        self.clusterCreateTime = clusterCreateTime
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.crossAccountClone = crossAccountClone
        self.dBClusterArn = dBClusterArn
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterMembers = dBClusterMembers
        self.dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships
        self.dBClusterParameterGroup = dBClusterParameterGroup
        self.dBSubnetGroup = dBSubnetGroup
        self.databaseName = databaseName
        self.dbClusterResourceId = dbClusterResourceId
        self.deletionProtection = deletionProtection
        self.earliestRestorableTime = earliestRestorableTime
        self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
        self.endpoint = endpoint
        self.engine = engine
        self.engineVersion = engineVersion
        self.hostedZoneId = hostedZoneId
        self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
        self.kmsKeyId = kmsKeyId
        self.latestRestorableTime = latestRestorableTime
        self.masterUsername = masterUsername
        self.multiAZ = multiAZ
        self.percentProgress = percentProgress
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.readReplicaIdentifiers = readReplicaIdentifiers
        self.readerEndpoint = readerEndpoint
        self.replicationSourceIdentifier = replicationSourceIdentifier
        self.status = status
        self.storageEncrypted = storageEncrypted
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

extension DBClusterAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBClusterAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User already has a DB cluster with the given identifier.</p>
public struct DBClusterAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBClusterAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customEndpointType = customEndpointType {
            try container.encode(customEndpointType, forKey: Key("CustomEndpointType"))
        }
        if let dBClusterEndpointArn = dBClusterEndpointArn {
            try container.encode(dBClusterEndpointArn, forKey: Key("DBClusterEndpointArn"))
        }
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier {
            try container.encode(dBClusterEndpointResourceIdentifier, forKey: Key("DBClusterEndpointResourceIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var staticMembersBuffer:[String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var excludedMembersBuffer:[String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

extension DBClusterEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterEndpoint(customEndpointType: \(String(describing: customEndpointType)), dBClusterEndpointArn: \(String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), endpoint: \(String(describing: endpoint)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)), status: \(String(describing: status)))"}
}

/// <p>This data type represents the information you need to connect to an Amazon Neptune DB cluster.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBClusterEndpoint</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon Neptune DB instance endpoints,
///       see <code>Endpoint</code>.</p>
public struct DBClusterEndpoint: Equatable {
    /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
    ///       <code>WRITER</code>, <code>ANY</code>.</p>
    public let customEndpointType: String?
    /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
    public let dBClusterEndpointArn: String?
    /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
    public let dBClusterEndpointResourceIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///       stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>The DNS address of the endpoint.</p>
    public let endpoint: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///       All other eligible instances are reachable through the custom endpoint.
    ///       Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?
    /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that cannot be used for a certain kind of cluster,
    ///       such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
    public let status: String?

    public init (
        customEndpointType: String? = nil,
        dBClusterEndpointArn: String? = nil,
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterEndpointResourceIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        endpoint: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil,
        status: String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

extension DBClusterEndpointAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterEndpointAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBClusterEndpointAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterEndpointAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified custom endpoint cannot be created because it already exists.</p>
public struct DBClusterEndpointAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBClusterEndpointAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpointNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterEndpointNotFoundFault(message: \(String(describing: message)))"}
}

extension DBClusterEndpointNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterEndpointNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified custom endpoint doesn't exist.</p>
public struct DBClusterEndpointNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBClusterEndpointNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpointQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterEndpointQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBClusterEndpointQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterEndpointQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster already has the maximum number of custom endpoints.</p>
public struct DBClusterEndpointQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBClusterEndpointQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroupStatus = "DBClusterParameterGroupStatus"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case isClusterWriter = "IsClusterWriter"
        case promotionTier = "PromotionTier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupStatus = dBClusterParameterGroupStatus {
            try container.encode(dBClusterParameterGroupStatus, forKey: Key("DBClusterParameterGroupStatus"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if isClusterWriter != false {
            try container.encode(isClusterWriter, forKey: Key("IsClusterWriter"))
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: Key("PromotionTier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let isClusterWriterDecoded = try containerValues.decode(Bool.self, forKey: .isClusterWriter)
        isClusterWriter = isClusterWriterDecoded
        let dBClusterParameterGroupStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroupStatus)
        dBClusterParameterGroupStatus = dBClusterParameterGroupStatusDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
    }
}

extension DBClusterMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterMember(dBClusterParameterGroupStatus: \(String(describing: dBClusterParameterGroupStatus)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), isClusterWriter: \(String(describing: isClusterWriter)), promotionTier: \(String(describing: promotionTier)))"}
}

/// <p>Contains information about an instance that is part of a DB cluster.</p>
public struct DBClusterMember: Equatable {
    /// <p>Specifies the status of the DB cluster parameter group for this member of the DB
    ///       cluster.</p>
    public let dBClusterParameterGroupStatus: String?
    /// <p>Specifies the instance identifier for this member of the DB cluster.</p>
    public let dBInstanceIdentifier: String?
    /// <p>Value that is <code>true</code> if the cluster member is the primary instance for the DB
    ///       cluster and <code>false</code> otherwise.</p>
    public let isClusterWriter: Bool
    /// <p>A value that specifies the order in which a Read Replica is promoted to the primary
    ///       instance after a failure of the existing primary instance.</p>
    public let promotionTier: Int?

    public init (
        dBClusterParameterGroupStatus: String? = nil,
        dBInstanceIdentifier: String? = nil,
        isClusterWriter: Bool = false,
        promotionTier: Int? = nil
    )
    {
        self.dBClusterParameterGroupStatus = dBClusterParameterGroupStatus
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.isClusterWriter = isClusterWriter
        self.promotionTier = promotionTier
    }
}

extension DBClusterNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterNotFoundFault(message: \(String(describing: message)))"}
}

extension DBClusterNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
public struct DBClusterNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBClusterNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterOptionGroupStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBClusterOptionGroupName = "DBClusterOptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterOptionGroupName = dBClusterOptionGroupName {
            try container.encode(dBClusterOptionGroupName, forKey: Key("DBClusterOptionGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterOptionGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterOptionGroupName)
        dBClusterOptionGroupName = dBClusterOptionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DBClusterOptionGroupStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterOptionGroupStatus(dBClusterOptionGroupName: \(String(describing: dBClusterOptionGroupName)), status: \(String(describing: status)))"}
}

/// <p>Not supported by Neptune.</p>
public struct DBClusterOptionGroupStatus: Equatable {
    /// <p>Not supported by Neptune.</p>
    public let dBClusterOptionGroupName: String?
    /// <p>Not supported by Neptune.</p>
    public let status: String?

    public init (
        dBClusterOptionGroupName: String? = nil,
        status: String? = nil
    )
    {
        self.dBClusterOptionGroupName = dBClusterOptionGroupName
        self.status = status
    }
}

extension DBClusterParameterGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroupArn = "DBClusterParameterGroupArn"
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupArn = dBClusterParameterGroupArn {
            try container.encode(dBClusterParameterGroupArn, forKey: Key("DBClusterParameterGroupArn"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dBClusterParameterGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroupArn)
        dBClusterParameterGroupArn = dBClusterParameterGroupArnDecoded
    }
}

extension DBClusterParameterGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterParameterGroup(dBClusterParameterGroupArn: \(String(describing: dBClusterParameterGroupArn)), dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), description: \(String(describing: description)))"}
}

/// <p>Contains the details of an Amazon Neptune DB cluster parameter group.</p>
///          <p>This data type is used as a response element in the <a>DescribeDBClusterParameterGroups</a> action.</p>
public struct DBClusterParameterGroup: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the DB cluster parameter group.</p>
    public let dBClusterParameterGroupArn: String?
    /// <p>Provides the name of the DB cluster parameter group.</p>
    public let dBClusterParameterGroupName: String?
    /// <p>Provides the name of the DB parameter group family that this DB cluster parameter group is
    ///       compatible with.</p>
    public let dBParameterGroupFamily: String?
    /// <p>Provides the customer-specified description for this DB cluster parameter group.</p>
    public let description: String?

    public init (
        dBClusterParameterGroupArn: String? = nil,
        dBClusterParameterGroupName: String? = nil,
        dBParameterGroupFamily: String? = nil,
        description: String? = nil
    )
    {
        self.dBClusterParameterGroupArn = dBClusterParameterGroupArn
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.description = description
    }
}

extension DBClusterParameterGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterParameterGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension DBClusterParameterGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBClusterParameterGroupName</i> does not refer to an
///       existing DB Cluster parameter group.</p>
public struct DBClusterParameterGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterParameterGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBClusterParameterGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBClusterQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User attempted to create a new DB cluster and the user has already reached the maximum allowed DB cluster quota.</p>
public struct DBClusterQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBClusterQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRole: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let featureName = featureName {
            try container.encode(featureName, forKey: Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .featureName)
        featureName = featureNameDecoded
    }
}

extension DBClusterRole: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterRole(featureName: \(String(describing: featureName)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

/// <p>Describes an Amazon Identity and Access Management (IAM) role that is associated with a DB
///       cluster.</p>
public struct DBClusterRole: Equatable {
    /// <p>The name of the feature associated with the Amazon Identity and Access Management (IAM) role.
    ///       For the list of supported feature names, see <a>DBEngineVersion</a>.
    ///     </p>
    public let featureName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that is associated with the DB
    ///       cluster.</p>
    public let roleArn: String?
    /// <p>Describes the state of association between the IAM role and the DB cluster. The Status
    ///       property returns one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - the IAM role ARN is associated with the DB cluster and can be
    ///           used to access other Amazon services on your behalf.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code> - the IAM role ARN is being associated with the DB
    ///           cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INVALID</code> - the IAM role ARN is associated with the DB cluster, but the DB
    ///           cluster is unable to assume the IAM role in order to access other Amazon services on your
    ///           behalf.</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        featureName: String? = nil,
        roleArn: String? = nil,
        status: String? = nil
    )
    {
        self.featureName = featureName
        self.roleArn = roleArn
        self.status = status
    }
}

extension DBClusterRoleAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterRoleAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBClusterRoleAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterRoleAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.</p>
public struct DBClusterRoleAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBClusterRoleAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRoleNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterRoleNotFoundFault(message: \(String(describing: message)))"}
}

extension DBClusterRoleNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterRoleNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) is not associated with the specified DB cluster.</p>
public struct DBClusterRoleNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBClusterRoleNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRoleQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterRoleQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBClusterRoleQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterRoleQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.</p>
public struct DBClusterRoleQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBClusterRoleQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterSnapshot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZones = "AvailabilityZones"
        case clusterCreateTime = "ClusterCreateTime"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterSnapshotArn = "DBClusterSnapshotArn"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotType = "SnapshotType"
        case sourceDBClusterSnapshotArn = "SourceDBClusterSnapshotArn"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: Key("clusterCreateTime"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotArn = dBClusterSnapshotArn {
            try container.encode(dBClusterSnapshotArn, forKey: Key("DBClusterSnapshotArn"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if percentProgress != 0 {
            try container.encode(percentProgress, forKey: Key("PercentProgress"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: Key("snapshotCreateTime"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: Key("SnapshotType"))
        }
        if let sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArn {
            try container.encode(sourceDBClusterSnapshotArn, forKey: Key("SourceDBClusterSnapshotArn"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let percentProgressDecoded = try containerValues.decode(Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let storageEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dBClusterSnapshotArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterSnapshotArn)
        dBClusterSnapshotArn = dBClusterSnapshotArnDecoded
        let sourceDBClusterSnapshotArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceDBClusterSnapshotArn)
        sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArnDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
    }
}

extension DBClusterSnapshot: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterSnapshot(allocatedStorage: \(String(describing: allocatedStorage)), availabilityZones: \(String(describing: availabilityZones)), clusterCreateTime: \(String(describing: clusterCreateTime)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterSnapshotArn: \(String(describing: dBClusterSnapshotArn)), dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(String(describing: iAMDatabaseAuthenticationEnabled)), kmsKeyId: \(String(describing: kmsKeyId)), licenseModel: \(String(describing: licenseModel)), masterUsername: \(String(describing: masterUsername)), percentProgress: \(String(describing: percentProgress)), port: \(String(describing: port)), snapshotCreateTime: \(String(describing: snapshotCreateTime)), snapshotType: \(String(describing: snapshotType)), sourceDBClusterSnapshotArn: \(String(describing: sourceDBClusterSnapshotArn)), status: \(String(describing: status)), storageEncrypted: \(String(describing: storageEncrypted)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains the details for an Amazon Neptune DB cluster snapshot</p>
///          <p>This data type is used as a response element in the <a>DescribeDBClusterSnapshots</a> action.</p>
public struct DBClusterSnapshot: Equatable {
    /// <p>Specifies the allocated storage size in gibibytes (GiB).</p>
    public let allocatedStorage: Int
    /// <p>Provides the list of EC2 Availability Zones that instances in the DB cluster snapshot can
    ///       be restored in.</p>
    public let availabilityZones: [String]?
    /// <p>Specifies the time when the DB cluster was created, in Universal Coordinated Time
    ///       (UTC).</p>
    public let clusterCreateTime: Date?
    /// <p>Specifies the DB cluster identifier of the DB cluster that this DB cluster snapshot was
    ///       created from.</p>
    public let dBClusterIdentifier: String?
    /// <p>The Amazon Resource Name (ARN) for the DB cluster snapshot.</p>
    public let dBClusterSnapshotArn: String?
    /// <p>Specifies the identifier for a DB cluster snapshot. Must match the identifier
    ///       of an existing snapshot.</p>
    ///
    ///          <p>After you restore a DB cluster using a <code>DBClusterSnapshotIdentifier</code>,
    ///       you must specify the same <code>DBClusterSnapshotIdentifier</code> for any future
    ///       updates to the DB cluster. When you specify this property for an update, the DB
    ///       cluster is not restored from the snapshot again, and the data in the database is not
    ///       changed.</p>
    ///
    ///          <p>However, if you don't specify the <code>DBClusterSnapshotIdentifier</code>, an empty
    ///       DB cluster is created, and the original DB cluster is deleted. If you specify a
    ///       property that is different from the previous snapshot restore property, the DB
    ///       cluster is restored from the snapshot specified by the <code>DBClusterSnapshotIdentifier</code>,
    ///       and the original DB cluster is deleted.</p>
    public let dBClusterSnapshotIdentifier: String?
    /// <p>Specifies the name of the database engine.</p>
    public let engine: String?
    /// <p>Provides the version of the database engine for this DB cluster snapshot.</p>
    public let engineVersion: String?
    /// <p>True if mapping of Amazon Identity and Access Management (IAM) accounts to database accounts
    ///       is enabled, and otherwise false.</p>
    public let iAMDatabaseAuthenticationEnabled: Bool
    /// <p>If <code>StorageEncrypted</code> is true, the Amazon KMS key identifier for the encrypted DB
    ///       cluster snapshot.</p>
    public let kmsKeyId: String?
    /// <p>Provides the license model information for this DB cluster snapshot.</p>
    public let licenseModel: String?
    /// <p>Not supported by Neptune.</p>
    public let masterUsername: String?
    /// <p>Specifies the percentage of the estimated data that has been transferred.</p>
    public let percentProgress: Int
    /// <p>Specifies the port that the DB cluster was listening on at the time of the
    ///       snapshot.</p>
    public let port: Int
    /// <p>Provides the time when the snapshot was taken, in Universal Coordinated Time (UTC).</p>
    public let snapshotCreateTime: Date?
    /// <p>Provides the type of the DB cluster snapshot.</p>
    public let snapshotType: String?
    /// <p>If the DB cluster snapshot was copied from a source DB cluster snapshot, the Amazon
    ///       Resource Name (ARN) for the source DB cluster snapshot, otherwise, a null value.</p>
    public let sourceDBClusterSnapshotArn: String?
    /// <p>Specifies the status of this DB cluster snapshot.</p>
    public let status: String?
    /// <p>Specifies whether the DB cluster snapshot is encrypted.</p>
    public let storageEncrypted: Bool
    /// <p>Provides the VPC ID associated with the DB cluster snapshot.</p>
    public let vpcId: String?

    public init (
        allocatedStorage: Int = 0,
        availabilityZones: [String]? = nil,
        clusterCreateTime: Date? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterSnapshotArn: String? = nil,
        dBClusterSnapshotIdentifier: String? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        iAMDatabaseAuthenticationEnabled: Bool = false,
        kmsKeyId: String? = nil,
        licenseModel: String? = nil,
        masterUsername: String? = nil,
        percentProgress: Int = 0,
        port: Int = 0,
        snapshotCreateTime: Date? = nil,
        snapshotType: String? = nil,
        sourceDBClusterSnapshotArn: String? = nil,
        status: String? = nil,
        storageEncrypted: Bool = false,
        vpcId: String? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.availabilityZones = availabilityZones
        self.clusterCreateTime = clusterCreateTime
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotArn = dBClusterSnapshotArn
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.engine = engine
        self.engineVersion = engineVersion
        self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUsername = masterUsername
        self.percentProgress = percentProgress
        self.port = port
        self.snapshotCreateTime = snapshotCreateTime
        self.snapshotType = snapshotType
        self.sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArn
        self.status = status
        self.storageEncrypted = storageEncrypted
        self.vpcId = vpcId
    }
}

extension DBClusterSnapshotAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterSnapshotAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBClusterSnapshotAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User already has a DB cluster snapshot with the given identifier.</p>
public struct DBClusterSnapshotAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterSnapshotAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBClusterSnapshotAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterSnapshotAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case attributeValues = "AttributeValues"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let attributeValues = attributeValues {
            var attributeValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AttributeValues"))
            for (index0, string0) in attributeValues.enumerated() {
                try attributeValuesContainer.encode(string0, forKey: Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.attributeValues) {
            struct KeyVal0{struct AttributeValue{}}
            let attributeValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .attributeValues)
            if let attributeValuesWrappedContainer = attributeValuesWrappedContainer {
                let attributeValuesContainer = try attributeValuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var attributeValuesBuffer:[String]? = nil
                if let attributeValuesContainer = attributeValuesContainer {
                    attributeValuesBuffer = [String]()
                    for stringContainer0 in attributeValuesContainer {
                        attributeValuesBuffer?.append(stringContainer0)
                    }
                }
                attributeValues = attributeValuesBuffer
            } else {
                attributeValues = []
            }
        } else {
            attributeValues = nil
        }
    }
}

extension DBClusterSnapshotAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterSnapshotAttribute(attributeName: \(String(describing: attributeName)), attributeValues: \(String(describing: attributeValues)))"}
}

/// <p>Contains the name and values of a manual DB cluster snapshot attribute.</p>
///          <p>Manual DB cluster snapshot attributes are used to authorize other Amazon accounts to restore
///       a manual DB cluster snapshot. For more information, see the <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
public struct DBClusterSnapshotAttribute: Equatable {
    /// <p>The name of the manual DB cluster snapshot attribute.</p>
    ///          <p>The attribute named <code>restore</code> refers to the list of Amazon accounts that have
    ///       permission to copy or restore the manual DB cluster snapshot. For more information, see the
    ///       <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
    public let attributeName: String?
    /// <p>The value(s) for the manual DB cluster snapshot attribute.</p>
    ///          <p>If the <code>AttributeName</code> field is set to <code>restore</code>, then this element
    ///       returns a list of IDs of the Amazon accounts that are authorized to copy or restore the manual DB
    ///       cluster snapshot. If a value of <code>all</code> is in the list, then the manual DB cluster
    ///       snapshot is public and available for any Amazon account to copy or restore.</p>
    public let attributeValues: [String]?

    public init (
        attributeName: String? = nil,
        attributeValues: [String]? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValues = attributeValues
    }
}

extension DBClusterSnapshotAttributesResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshotAttributes = "DBClusterSnapshotAttributes"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterSnapshotAttributes = dBClusterSnapshotAttributes {
            var dBClusterSnapshotAttributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBClusterSnapshotAttributes"))
            for (index0, dbclustersnapshotattribute0) in dBClusterSnapshotAttributes.enumerated() {
                try dBClusterSnapshotAttributesContainer.encode(dbclustersnapshotattribute0, forKey: Key("DBClusterSnapshotAttribute.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        if containerValues.contains(.dBClusterSnapshotAttributes) {
            struct KeyVal0{struct DBClusterSnapshotAttribute{}}
            let dBClusterSnapshotAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterSnapshotAttribute>.CodingKeys.self, forKey: .dBClusterSnapshotAttributes)
            if let dBClusterSnapshotAttributesWrappedContainer = dBClusterSnapshotAttributesWrappedContainer {
                let dBClusterSnapshotAttributesContainer = try dBClusterSnapshotAttributesWrappedContainer.decodeIfPresent([DBClusterSnapshotAttribute].self, forKey: .member)
                var dBClusterSnapshotAttributesBuffer:[DBClusterSnapshotAttribute]? = nil
                if let dBClusterSnapshotAttributesContainer = dBClusterSnapshotAttributesContainer {
                    dBClusterSnapshotAttributesBuffer = [DBClusterSnapshotAttribute]()
                    for structureContainer0 in dBClusterSnapshotAttributesContainer {
                        dBClusterSnapshotAttributesBuffer?.append(structureContainer0)
                    }
                }
                dBClusterSnapshotAttributes = dBClusterSnapshotAttributesBuffer
            } else {
                dBClusterSnapshotAttributes = []
            }
        } else {
            dBClusterSnapshotAttributes = nil
        }
    }
}

extension DBClusterSnapshotAttributesResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterSnapshotAttributesResult(dBClusterSnapshotAttributes: \(String(describing: dBClusterSnapshotAttributes)), dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)))"}
}

/// <p>Contains the results of a successful call to the <a>DescribeDBClusterSnapshotAttributes</a> API action.</p>
///          <p>Manual DB cluster snapshot attributes are used to authorize other Amazon accounts to copy or
///       restore a manual DB cluster snapshot. For more information, see the <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
public struct DBClusterSnapshotAttributesResult: Equatable {
    /// <p>The list of attributes and values for the manual DB cluster snapshot.</p>
    public let dBClusterSnapshotAttributes: [DBClusterSnapshotAttribute]?
    /// <p>The identifier of the manual DB cluster snapshot that the attributes apply to.</p>
    public let dBClusterSnapshotIdentifier: String?

    public init (
        dBClusterSnapshotAttributes: [DBClusterSnapshotAttribute]? = nil,
        dBClusterSnapshotIdentifier: String? = nil
    )
    {
        self.dBClusterSnapshotAttributes = dBClusterSnapshotAttributes
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

extension DBClusterSnapshotNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBClusterSnapshotNotFoundFault(message: \(String(describing: message)))"}
}

extension DBClusterSnapshotNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBClusterSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBClusterSnapshotIdentifier</i> does not refer to an existing
///       DB cluster snapshot.</p>
public struct DBClusterSnapshotNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterSnapshotNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBClusterSnapshotNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBEngineVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case defaultCharacterSet = "DefaultCharacterSet"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case supportedCharacterSets = "SupportedCharacterSets"
        case supportedTimezones = "SupportedTimezones"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case supportsReadReplica = "SupportsReadReplica"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBEngineDescription = dBEngineDescription {
            try container.encode(dBEngineDescription, forKey: Key("DBEngineDescription"))
        }
        if let dBEngineVersionDescription = dBEngineVersionDescription {
            try container.encode(dBEngineVersionDescription, forKey: Key("DBEngineVersionDescription"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let defaultCharacterSet = defaultCharacterSet {
            try container.encode(defaultCharacterSet, forKey: Key("DefaultCharacterSet"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let exportableLogTypes = exportableLogTypes {
            var exportableLogTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExportableLogTypes"))
            for (index0, string0) in exportableLogTypes.enumerated() {
                try exportableLogTypesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedCharacterSets = supportedCharacterSets {
            var supportedCharacterSetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedCharacterSets"))
            for (index0, characterset0) in supportedCharacterSets.enumerated() {
                try supportedCharacterSetsContainer.encode(characterset0, forKey: Key("CharacterSet.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedTimezones = supportedTimezones {
            var supportedTimezonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedTimezones"))
            for (index0, timezone0) in supportedTimezones.enumerated() {
                try supportedTimezonesContainer.encode(timezone0, forKey: Key("Timezone.\(index0.advanced(by: 1))"))
            }
        }
        if supportsLogExportsToCloudwatchLogs != false {
            try container.encode(supportsLogExportsToCloudwatchLogs, forKey: Key("SupportsLogExportsToCloudwatchLogs"))
        }
        if supportsReadReplica != false {
            try container.encode(supportsReadReplica, forKey: Key("SupportsReadReplica"))
        }
        if let validUpgradeTarget = validUpgradeTarget {
            var validUpgradeTargetContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValidUpgradeTarget"))
            for (index0, upgradetarget0) in validUpgradeTarget.enumerated() {
                try validUpgradeTargetContainer.encode(upgradetarget0, forKey: Key("UpgradeTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        let defaultCharacterSetDecoded = try containerValues.decodeIfPresent(CharacterSet.self, forKey: .defaultCharacterSet)
        defaultCharacterSet = defaultCharacterSetDecoded
        if containerValues.contains(.supportedCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedCharacterSets)
            if let supportedCharacterSetsWrappedContainer = supportedCharacterSetsWrappedContainer {
                let supportedCharacterSetsContainer = try supportedCharacterSetsWrappedContainer.decodeIfPresent([CharacterSet].self, forKey: .member)
                var supportedCharacterSetsBuffer:[CharacterSet]? = nil
                if let supportedCharacterSetsContainer = supportedCharacterSetsContainer {
                    supportedCharacterSetsBuffer = [CharacterSet]()
                    for structureContainer0 in supportedCharacterSetsContainer {
                        supportedCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedCharacterSets = supportedCharacterSetsBuffer
            } else {
                supportedCharacterSets = []
            }
        } else {
            supportedCharacterSets = nil
        }
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.supportedTimezones) {
            struct KeyVal0{struct Timezone{}}
            let supportedTimezonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Timezone>.CodingKeys.self, forKey: .supportedTimezones)
            if let supportedTimezonesWrappedContainer = supportedTimezonesWrappedContainer {
                let supportedTimezonesContainer = try supportedTimezonesWrappedContainer.decodeIfPresent([Timezone].self, forKey: .member)
                var supportedTimezonesBuffer:[Timezone]? = nil
                if let supportedTimezonesContainer = supportedTimezonesContainer {
                    supportedTimezonesBuffer = [Timezone]()
                    for structureContainer0 in supportedTimezonesContainer {
                        supportedTimezonesBuffer?.append(structureContainer0)
                    }
                }
                supportedTimezones = supportedTimezonesBuffer
            } else {
                supportedTimezones = []
            }
        } else {
            supportedTimezones = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var exportableLogTypesBuffer:[String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
        let supportsReadReplicaDecoded = try containerValues.decode(Bool.self, forKey: .supportsReadReplica)
        supportsReadReplica = supportsReadReplicaDecoded
    }
}

extension DBEngineVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBEngineVersion(dBEngineDescription: \(String(describing: dBEngineDescription)), dBEngineVersionDescription: \(String(describing: dBEngineVersionDescription)), dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), defaultCharacterSet: \(String(describing: defaultCharacterSet)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), exportableLogTypes: \(String(describing: exportableLogTypes)), supportedCharacterSets: \(String(describing: supportedCharacterSets)), supportedTimezones: \(String(describing: supportedTimezones)), supportsLogExportsToCloudwatchLogs: \(String(describing: supportsLogExportsToCloudwatchLogs)), supportsReadReplica: \(String(describing: supportsReadReplica)), validUpgradeTarget: \(String(describing: validUpgradeTarget)))"}
}

/// <p> This data type is used as a response element in the action <a>DescribeDBEngineVersions</a>.</p>
public struct DBEngineVersion: Equatable {
    /// <p>The description of the database engine.</p>
    public let dBEngineDescription: String?
    /// <p>The description of the database engine version.</p>
    public let dBEngineVersionDescription: String?
    /// <p>The name of the DB parameter group family for the database engine.</p>
    public let dBParameterGroupFamily: String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let defaultCharacterSet: CharacterSet?
    /// <p>The name of the database engine.</p>
    public let engine: String?
    /// <p>The version number of the database engine.</p>
    public let engineVersion: String?
    /// <p>The types of logs that the database engine has available for export to CloudWatch
    ///       Logs.</p>
    public let exportableLogTypes: [String]?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let supportedCharacterSets: [CharacterSet]?
    /// <p>A list of the time zones supported by this engine for the <code>Timezone</code> parameter
    ///       of the <code>CreateDBInstance</code> action.</p>
    public let supportedTimezones: [Timezone]?
    /// <p>A value that indicates whether the engine version supports exporting the log types
    ///       specified by ExportableLogTypes to CloudWatch Logs.</p>
    public let supportsLogExportsToCloudwatchLogs: Bool
    /// <p>Indicates whether the database engine version supports read replicas.</p>
    public let supportsReadReplica: Bool
    /// <p>A list of engine versions that this database engine version can be upgraded to.</p>
    public let validUpgradeTarget: [UpgradeTarget]?

    public init (
        dBEngineDescription: String? = nil,
        dBEngineVersionDescription: String? = nil,
        dBParameterGroupFamily: String? = nil,
        defaultCharacterSet: CharacterSet? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        exportableLogTypes: [String]? = nil,
        supportedCharacterSets: [CharacterSet]? = nil,
        supportedTimezones: [Timezone]? = nil,
        supportsLogExportsToCloudwatchLogs: Bool = false,
        supportsReadReplica: Bool = false,
        validUpgradeTarget: [UpgradeTarget]? = nil
    )
    {
        self.dBEngineDescription = dBEngineDescription
        self.dBEngineVersionDescription = dBEngineVersionDescription
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.defaultCharacterSet = defaultCharacterSet
        self.engine = engine
        self.engineVersion = engineVersion
        self.exportableLogTypes = exportableLogTypes
        self.supportedCharacterSets = supportedCharacterSets
        self.supportedTimezones = supportedTimezones
        self.supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogs
        self.supportsReadReplica = supportsReadReplica
        self.validUpgradeTarget = validUpgradeTarget
    }
}

extension DBInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case characterSetName = "CharacterSetName"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBInstanceArn = "DBInstanceArn"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBInstanceStatus = "DBInstanceStatus"
        case dBName = "DBName"
        case dBParameterGroups = "DBParameterGroups"
        case dBSecurityGroups = "DBSecurityGroups"
        case dBSubnetGroup = "DBSubnetGroup"
        case dbInstancePort = "DbInstancePort"
        case dbiResourceId = "DbiResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case enhancedMonitoringResourceArn = "EnhancedMonitoringResourceArn"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAZ = "MultiAZ"
        case optionGroupMemberships = "OptionGroupMemberships"
        case pendingModifiedValues = "PendingModifiedValues"
        case performanceInsightsEnabled = "PerformanceInsightsEnabled"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case promotionTier = "PromotionTier"
        case publiclyAccessible = "PubliclyAccessible"
        case readReplicaDBClusterIdentifiers = "ReadReplicaDBClusterIdentifiers"
        case readReplicaDBInstanceIdentifiers = "ReadReplicaDBInstanceIdentifiers"
        case readReplicaSourceDBInstanceIdentifier = "ReadReplicaSourceDBInstanceIdentifier"
        case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
        case statusInfos = "StatusInfos"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if autoMinorVersionUpgrade != false {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if backupRetentionPeriod != 0 {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: Key("CACertificateIdentifier"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: Key("CharacterSetName"))
        }
        if copyTagsToSnapshot != false {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBInstanceArn = dBInstanceArn {
            try container.encode(dBInstanceArn, forKey: Key("DBInstanceArn"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBInstanceStatus = dBInstanceStatus {
            try container.encode(dBInstanceStatus, forKey: Key("DBInstanceStatus"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: Key("DBName"))
        }
        if let dBParameterGroups = dBParameterGroups {
            var dBParameterGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBParameterGroups"))
            for (index0, dbparametergroupstatus0) in dBParameterGroups.enumerated() {
                try dBParameterGroupsContainer.encode(dbparametergroupstatus0, forKey: Key("DBParameterGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBSecurityGroups"))
            for (index0, dbsecuritygroupmembership0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(dbsecuritygroupmembership0, forKey: Key("DBSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: Key("DBSubnetGroup"))
        }
        if dbInstancePort != 0 {
            try container.encode(dbInstancePort, forKey: Key("DbInstancePort"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: Key("DbiResourceId"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DomainMemberships"))
            for (index0, domainmembership0) in domainMemberships.enumerated() {
                try domainMembershipsContainer.encode(domainmembership0, forKey: Key("DomainMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let enhancedMonitoringResourceArn = enhancedMonitoringResourceArn {
            try container.encode(enhancedMonitoringResourceArn, forKey: Key("EnhancedMonitoringResourceArn"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let instanceCreateTime = instanceCreateTime {
            try container.encode(TimestampWrapper(instanceCreateTime, format: .dateTime), forKey: Key("instanceCreateTime"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: Key("latestRestorableTime"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: Key("MasterUsername"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: Key("MonitoringRoleArn"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let optionGroupMemberships = optionGroupMemberships {
            var optionGroupMembershipsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OptionGroupMemberships"))
            for (index0, optiongroupmembership0) in optionGroupMemberships.enumerated() {
                try optionGroupMembershipsContainer.encode(optiongroupmembership0, forKey: Key("OptionGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: Key("PendingModifiedValues"))
        }
        if let performanceInsightsEnabled = performanceInsightsEnabled {
            try container.encode(performanceInsightsEnabled, forKey: Key("PerformanceInsightsEnabled"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: Key("PerformanceInsightsKMSKeyId"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: Key("PromotionTier"))
        }
        if publiclyAccessible != false {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers {
            var readReplicaDBClusterIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReadReplicaDBClusterIdentifiers"))
            for (index0, string0) in readReplicaDBClusterIdentifiers.enumerated() {
                try readReplicaDBClusterIdentifiersContainer.encode(string0, forKey: Key("ReadReplicaDBClusterIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers {
            var readReplicaDBInstanceIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReadReplicaDBInstanceIdentifiers"))
            for (index0, string0) in readReplicaDBInstanceIdentifiers.enumerated() {
                try readReplicaDBInstanceIdentifiersContainer.encode(string0, forKey: Key("ReadReplicaDBInstanceIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier {
            try container.encode(readReplicaSourceDBInstanceIdentifier, forKey: Key("ReadReplicaSourceDBInstanceIdentifier"))
        }
        if let secondaryAvailabilityZone = secondaryAvailabilityZone {
            try container.encode(secondaryAvailabilityZone, forKey: Key("SecondaryAvailabilityZone"))
        }
        if let statusInfos = statusInfos {
            var statusInfosContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StatusInfos"))
            for (index0, dbinstancestatusinfo0) in statusInfos.enumerated() {
                try statusInfosContainer.encode(dbinstancestatusinfo0, forKey: Key("DBInstanceStatusInfo.\(index0.advanced(by: 1))"))
            }
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: Key("TdeCredentialArn"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: Key("Timezone"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let dBInstanceStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceStatus)
        dBInstanceStatus = dBInstanceStatusDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceCreateTime)
        var instanceCreateTimeBuffer:Date? = nil
        if let instanceCreateTimeDecoded = instanceCreateTimeDecoded {
            instanceCreateTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(instanceCreateTimeDecoded, format: .dateTime)
        }
        instanceCreateTime = instanceCreateTimeBuffer
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let backupRetentionPeriodDecoded = try containerValues.decode(Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        if containerValues.contains(.dBSecurityGroups) {
            struct KeyVal0{struct DBSecurityGroup{}}
            let dBSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroup>.CodingKeys.self, forKey: .dBSecurityGroups)
            if let dBSecurityGroupsWrappedContainer = dBSecurityGroupsWrappedContainer {
                let dBSecurityGroupsContainer = try dBSecurityGroupsWrappedContainer.decodeIfPresent([DBSecurityGroupMembership].self, forKey: .member)
                var dBSecurityGroupsBuffer:[DBSecurityGroupMembership]? = nil
                if let dBSecurityGroupsContainer = dBSecurityGroupsContainer {
                    dBSecurityGroupsBuffer = [DBSecurityGroupMembership]()
                    for structureContainer0 in dBSecurityGroupsContainer {
                        dBSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSecurityGroups = dBSecurityGroupsBuffer
            } else {
                dBSecurityGroups = []
            }
        } else {
            dBSecurityGroups = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        if containerValues.contains(.dBParameterGroups) {
            struct KeyVal0{struct DBParameterGroup{}}
            let dBParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBParameterGroup>.CodingKeys.self, forKey: .dBParameterGroups)
            if let dBParameterGroupsWrappedContainer = dBParameterGroupsWrappedContainer {
                let dBParameterGroupsContainer = try dBParameterGroupsWrappedContainer.decodeIfPresent([DBParameterGroupStatus].self, forKey: .member)
                var dBParameterGroupsBuffer:[DBParameterGroupStatus]? = nil
                if let dBParameterGroupsContainer = dBParameterGroupsContainer {
                    dBParameterGroupsBuffer = [DBParameterGroupStatus]()
                    for structureContainer0 in dBParameterGroupsContainer {
                        dBParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBParameterGroups = dBParameterGroupsBuffer
            } else {
                dBParameterGroups = []
            }
        } else {
            dBParameterGroups = nil
        }
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(PendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let multiAZDecoded = try containerValues.decode(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let readReplicaSourceDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readReplicaSourceDBInstanceIdentifier)
        readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifierDecoded
        if containerValues.contains(.readReplicaDBInstanceIdentifiers) {
            struct KeyVal0{struct ReadReplicaDBInstanceIdentifier{}}
            let readReplicaDBInstanceIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaDBInstanceIdentifier>.CodingKeys.self, forKey: .readReplicaDBInstanceIdentifiers)
            if let readReplicaDBInstanceIdentifiersWrappedContainer = readReplicaDBInstanceIdentifiersWrappedContainer {
                let readReplicaDBInstanceIdentifiersContainer = try readReplicaDBInstanceIdentifiersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var readReplicaDBInstanceIdentifiersBuffer:[String]? = nil
                if let readReplicaDBInstanceIdentifiersContainer = readReplicaDBInstanceIdentifiersContainer {
                    readReplicaDBInstanceIdentifiersBuffer = [String]()
                    for stringContainer0 in readReplicaDBInstanceIdentifiersContainer {
                        readReplicaDBInstanceIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiersBuffer
            } else {
                readReplicaDBInstanceIdentifiers = []
            }
        } else {
            readReplicaDBInstanceIdentifiers = nil
        }
        if containerValues.contains(.readReplicaDBClusterIdentifiers) {
            struct KeyVal0{struct ReadReplicaDBClusterIdentifier{}}
            let readReplicaDBClusterIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaDBClusterIdentifier>.CodingKeys.self, forKey: .readReplicaDBClusterIdentifiers)
            if let readReplicaDBClusterIdentifiersWrappedContainer = readReplicaDBClusterIdentifiersWrappedContainer {
                let readReplicaDBClusterIdentifiersContainer = try readReplicaDBClusterIdentifiersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var readReplicaDBClusterIdentifiersBuffer:[String]? = nil
                if let readReplicaDBClusterIdentifiersContainer = readReplicaDBClusterIdentifiersContainer {
                    readReplicaDBClusterIdentifiersBuffer = [String]()
                    for stringContainer0 in readReplicaDBClusterIdentifiersContainer {
                        readReplicaDBClusterIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiersBuffer
            } else {
                readReplicaDBClusterIdentifiers = []
            }
        } else {
            readReplicaDBClusterIdentifiers = nil
        }
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
        if containerValues.contains(.optionGroupMemberships) {
            struct KeyVal0{struct OptionGroupMembership{}}
            let optionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupMembership>.CodingKeys.self, forKey: .optionGroupMemberships)
            if let optionGroupMembershipsWrappedContainer = optionGroupMembershipsWrappedContainer {
                let optionGroupMembershipsContainer = try optionGroupMembershipsWrappedContainer.decodeIfPresent([OptionGroupMembership].self, forKey: .member)
                var optionGroupMembershipsBuffer:[OptionGroupMembership]? = nil
                if let optionGroupMembershipsContainer = optionGroupMembershipsContainer {
                    optionGroupMembershipsBuffer = [OptionGroupMembership]()
                    for structureContainer0 in optionGroupMembershipsContainer {
                        optionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupMemberships = optionGroupMembershipsBuffer
            } else {
                optionGroupMemberships = []
            }
        } else {
            optionGroupMemberships = nil
        }
        let characterSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        if containerValues.contains(.statusInfos) {
            struct KeyVal0{struct DBInstanceStatusInfo{}}
            let statusInfosWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceStatusInfo>.CodingKeys.self, forKey: .statusInfos)
            if let statusInfosWrappedContainer = statusInfosWrappedContainer {
                let statusInfosContainer = try statusInfosWrappedContainer.decodeIfPresent([DBInstanceStatusInfo].self, forKey: .member)
                var statusInfosBuffer:[DBInstanceStatusInfo]? = nil
                if let statusInfosContainer = statusInfosContainer {
                    statusInfosBuffer = [DBInstanceStatusInfo]()
                    for structureContainer0 in statusInfosContainer {
                        statusInfosBuffer?.append(structureContainer0)
                    }
                }
                statusInfos = statusInfosBuffer
            } else {
                statusInfos = []
            }
        } else {
            statusInfos = nil
        }
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let dbInstancePortDecoded = try containerValues.decode(Int.self, forKey: .dbInstancePort)
        dbInstancePort = dbInstancePortDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let storageEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        if containerValues.contains(.domainMemberships) {
            struct KeyVal0{struct DomainMembership{}}
            let domainMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DomainMembership>.CodingKeys.self, forKey: .domainMemberships)
            if let domainMembershipsWrappedContainer = domainMembershipsWrappedContainer {
                let domainMembershipsContainer = try domainMembershipsWrappedContainer.decodeIfPresent([DomainMembership].self, forKey: .member)
                var domainMembershipsBuffer:[DomainMembership]? = nil
                if let domainMembershipsContainer = domainMembershipsContainer {
                    domainMembershipsBuffer = [DomainMembership]()
                    for structureContainer0 in domainMembershipsContainer {
                        domainMembershipsBuffer?.append(structureContainer0)
                    }
                }
                domainMemberships = domainMembershipsBuffer
            } else {
                domainMemberships = []
            }
        } else {
            domainMemberships = nil
        }
        let copyTagsToSnapshotDecoded = try containerValues.decode(Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let enhancedMonitoringResourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .enhancedMonitoringResourceArn)
        enhancedMonitoringResourceArn = enhancedMonitoringResourceArnDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
        let dBInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceArn)
        dBInstanceArn = dBInstanceArnDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let performanceInsightsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .performanceInsightsEnabled)
        performanceInsightsEnabled = performanceInsightsEnabledDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}

extension DBInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstance(allocatedStorage: \(String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), availabilityZone: \(String(describing: availabilityZone)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(String(describing: cACertificateIdentifier)), characterSetName: \(String(describing: characterSetName)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBInstanceArn: \(String(describing: dBInstanceArn)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBInstanceStatus: \(String(describing: dBInstanceStatus)), dBName: \(String(describing: dBName)), dBParameterGroups: \(String(describing: dBParameterGroups)), dBSecurityGroups: \(String(describing: dBSecurityGroups)), dBSubnetGroup: \(String(describing: dBSubnetGroup)), dbInstancePort: \(String(describing: dbInstancePort)), dbiResourceId: \(String(describing: dbiResourceId)), deletionProtection: \(String(describing: deletionProtection)), domainMemberships: \(String(describing: domainMemberships)), enabledCloudwatchLogsExports: \(String(describing: enabledCloudwatchLogsExports)), endpoint: \(String(describing: endpoint)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), enhancedMonitoringResourceArn: \(String(describing: enhancedMonitoringResourceArn)), iAMDatabaseAuthenticationEnabled: \(String(describing: iAMDatabaseAuthenticationEnabled)), instanceCreateTime: \(String(describing: instanceCreateTime)), iops: \(String(describing: iops)), kmsKeyId: \(String(describing: kmsKeyId)), latestRestorableTime: \(String(describing: latestRestorableTime)), licenseModel: \(String(describing: licenseModel)), masterUsername: \(String(describing: masterUsername)), monitoringInterval: \(String(describing: monitoringInterval)), monitoringRoleArn: \(String(describing: monitoringRoleArn)), multiAZ: \(String(describing: multiAZ)), optionGroupMemberships: \(String(describing: optionGroupMemberships)), pendingModifiedValues: \(String(describing: pendingModifiedValues)), performanceInsightsEnabled: \(String(describing: performanceInsightsEnabled)), performanceInsightsKMSKeyId: \(String(describing: performanceInsightsKMSKeyId)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), promotionTier: \(String(describing: promotionTier)), publiclyAccessible: \(String(describing: publiclyAccessible)), readReplicaDBClusterIdentifiers: \(String(describing: readReplicaDBClusterIdentifiers)), readReplicaDBInstanceIdentifiers: \(String(describing: readReplicaDBInstanceIdentifiers)), readReplicaSourceDBInstanceIdentifier: \(String(describing: readReplicaSourceDBInstanceIdentifier)), secondaryAvailabilityZone: \(String(describing: secondaryAvailabilityZone)), statusInfos: \(String(describing: statusInfos)), storageEncrypted: \(String(describing: storageEncrypted)), storageType: \(String(describing: storageType)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), timezone: \(String(describing: timezone)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

/// <p>Contains the details of an Amazon Neptune DB instance.</p>
///          <p>This data type is used as a response element in the <a>DescribeDBInstances</a> action.</p>
public struct DBInstance: Equatable {
    /// <p>Not supported by Neptune.</p>
    public let allocatedStorage: Int
    /// <p>Indicates that minor version patches are applied automatically.</p>
    public let autoMinorVersionUpgrade: Bool
    /// <p>Specifies the name of the Availability Zone the DB instance is located in.</p>
    public let availabilityZone: String?
    /// <p>Specifies the number of days for which automatic DB snapshots are retained.</p>
    public let backupRetentionPeriod: Int
    /// <p>The identifier of the CA certificate for this DB instance.</p>
    public let cACertificateIdentifier: String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let characterSetName: String?
    /// <p>Specifies whether tags are copied from the DB instance to snapshots of the DB
    ///       instance.</p>
    public let copyTagsToSnapshot: Bool
    /// <p>If the DB instance is a member of a DB cluster, contains the name of the DB cluster that
    ///       the DB instance is a member of.</p>
    public let dBClusterIdentifier: String?
    /// <p>The Amazon Resource Name (ARN) for the DB instance.</p>
    public let dBInstanceArn: String?
    /// <p>Contains the name of the compute and memory capacity class of the DB instance.</p>
    public let dBInstanceClass: String?
    /// <p>Contains a user-supplied database identifier. This identifier is the unique key that
    ///       identifies a DB instance.</p>
    public let dBInstanceIdentifier: String?
    /// <p>Specifies the current state of this database.</p>
    public let dBInstanceStatus: String?
    /// <p>The database name.</p>
    public let dBName: String?
    /// <p>Provides the list of DB parameter groups applied to this DB instance.</p>
    public let dBParameterGroups: [DBParameterGroupStatus]?
    /// <p> Provides List of DB security group elements containing only
    ///       <code>DBSecurityGroup.Name</code> and <code>DBSecurityGroup.Status</code> subelements.</p>
    public let dBSecurityGroups: [DBSecurityGroupMembership]?
    /// <p>Specifies information on the subnet group associated with the DB instance, including the
    ///       name, description, and subnets in the subnet group.</p>
    public let dBSubnetGroup: DBSubnetGroup?
    /// <p>Specifies the port that the DB instance listens on. If the DB instance is part of a DB
    ///       cluster, this can be a different port than the DB cluster port.</p>
    public let dbInstancePort: Int
    /// <p>The Amazon Region-unique, immutable identifier for the DB instance. This identifier is found
    ///       in Amazon CloudTrail log entries whenever the Amazon KMS key for the DB instance is accessed.</p>
    public let dbiResourceId: String?
    /// <p>Indicates whether or not the DB instance has deletion protection enabled.
    ///       The instance can't be deleted when deletion protection is enabled. See <a href="https://docs.aws.amazon.com/neptune/latest/userguide/manage-console-instances-delete.html">Deleting
    ///       a DB Instance</a>.</p>
    public let deletionProtection: Bool?
    /// <p>Not supported</p>
    public let domainMemberships: [DomainMembership]?
    /// <p>A list of log types that this DB instance is configured to export to CloudWatch
    ///       Logs.</p>
    public let enabledCloudwatchLogsExports: [String]?
    /// <p>Specifies the connection endpoint.</p>
    public let endpoint: Endpoint?
    /// <p>Provides the name of the database engine to be used for this DB instance.</p>
    public let engine: String?
    /// <p>Indicates the database engine version.</p>
    public let engineVersion: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log stream that receives the
    ///       Enhanced Monitoring metrics data for the DB instance.</p>
    public let enhancedMonitoringResourceArn: String?
    /// <p>True if Amazon Identity and Access Management (IAM) authentication is enabled, and otherwise
    ///       false.</p>
    public let iAMDatabaseAuthenticationEnabled: Bool
    /// <p>Provides the date and time the DB instance was created.</p>
    public let instanceCreateTime: Date?
    /// <p>Specifies the Provisioned IOPS (I/O operations per second) value.</p>
    public let iops: Int?
    /// <p> Not supported: The encryption for DB instances is managed by the DB cluster.</p>
    public let kmsKeyId: String?
    /// <p>Specifies the latest time to which a database can be restored with point-in-time
    ///       restore.</p>
    public let latestRestorableTime: Date?
    /// <p>License model information for this DB instance.</p>
    public let licenseModel: String?
    /// <p>Not supported by Neptune.</p>
    public let masterUsername: String?
    /// <p>The interval, in seconds, between points when Enhanced Monitoring metrics are collected
    ///       for the DB instance.</p>
    public let monitoringInterval: Int?
    /// <p>The ARN for the IAM role that permits Neptune to send Enhanced Monitoring metrics to
    ///       Amazon CloudWatch Logs.</p>
    public let monitoringRoleArn: String?
    /// <p>Specifies if the DB instance is a Multi-AZ deployment.</p>
    public let multiAZ: Bool
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let optionGroupMemberships: [OptionGroupMembership]?
    /// <p>Specifies that changes to the DB instance are pending. This element is only included when
    ///       changes are pending. Specific changes are identified by subelements.</p>
    public let pendingModifiedValues: PendingModifiedValues?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let performanceInsightsEnabled: Bool?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let performanceInsightsKMSKeyId: String?
    /// <p> Specifies the daily time range during which automated backups are created if automated
    ///       backups are enabled, as determined by the <code>BackupRetentionPeriod</code>.</p>
    public let preferredBackupWindow: String?
    /// <p>Specifies the weekly time range during which system maintenance can occur, in Universal
    ///       Coordinated Time (UTC).</p>
    public let preferredMaintenanceWindow: String?
    /// <p>A value that specifies the order in which a Read Replica is promoted to the primary
    ///       instance after a failure of the existing primary instance.
    ///    </p>
    public let promotionTier: Int?
    /// <p>This flag should no longer be used.</p>
    @available(*, deprecated)
    public let publiclyAccessible: Bool
    /// <p>Contains one or more identifiers of DB clusters that are Read Replicas of this DB
    ///       instance.</p>
    public let readReplicaDBClusterIdentifiers: [String]?
    /// <p>Contains one or more identifiers of the Read Replicas associated with this DB
    ///       instance.</p>
    public let readReplicaDBInstanceIdentifiers: [String]?
    /// <p>Contains the identifier of the source DB instance if this DB instance is a Read
    ///       Replica.</p>
    public let readReplicaSourceDBInstanceIdentifier: String?
    /// <p>If present, specifies the name of the secondary Availability Zone for a DB instance with
    ///       multi-AZ support.</p>
    public let secondaryAvailabilityZone: String?
    /// <p>The status of a Read Replica. If the instance is not a Read Replica, this is blank.</p>
    public let statusInfos: [DBInstanceStatusInfo]?
    /// <p>Not supported: The encryption for DB instances is managed by the DB cluster.</p>
    public let storageEncrypted: Bool
    /// <p>Specifies the storage type associated with DB instance.</p>
    public let storageType: String?
    /// <p>The ARN from the key store with which the instance is associated for TDE
    ///       encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>Not supported.</p>
    public let timezone: String?
    /// <p>Provides a list of VPC security group elements that the DB instance belongs to.</p>
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

    public init (
        allocatedStorage: Int = 0,
        autoMinorVersionUpgrade: Bool = false,
        availabilityZone: String? = nil,
        backupRetentionPeriod: Int = 0,
        cACertificateIdentifier: String? = nil,
        characterSetName: String? = nil,
        copyTagsToSnapshot: Bool = false,
        dBClusterIdentifier: String? = nil,
        dBInstanceArn: String? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBInstanceStatus: String? = nil,
        dBName: String? = nil,
        dBParameterGroups: [DBParameterGroupStatus]? = nil,
        dBSecurityGroups: [DBSecurityGroupMembership]? = nil,
        dBSubnetGroup: DBSubnetGroup? = nil,
        dbInstancePort: Int = 0,
        dbiResourceId: String? = nil,
        deletionProtection: Bool? = nil,
        domainMemberships: [DomainMembership]? = nil,
        enabledCloudwatchLogsExports: [String]? = nil,
        endpoint: Endpoint? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        enhancedMonitoringResourceArn: String? = nil,
        iAMDatabaseAuthenticationEnabled: Bool = false,
        instanceCreateTime: Date? = nil,
        iops: Int? = nil,
        kmsKeyId: String? = nil,
        latestRestorableTime: Date? = nil,
        licenseModel: String? = nil,
        masterUsername: String? = nil,
        monitoringInterval: Int? = nil,
        monitoringRoleArn: String? = nil,
        multiAZ: Bool = false,
        optionGroupMemberships: [OptionGroupMembership]? = nil,
        pendingModifiedValues: PendingModifiedValues? = nil,
        performanceInsightsEnabled: Bool? = nil,
        performanceInsightsKMSKeyId: String? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        promotionTier: Int? = nil,
        publiclyAccessible: Bool = false,
        readReplicaDBClusterIdentifiers: [String]? = nil,
        readReplicaDBInstanceIdentifiers: [String]? = nil,
        readReplicaSourceDBInstanceIdentifier: String? = nil,
        secondaryAvailabilityZone: String? = nil,
        statusInfos: [DBInstanceStatusInfo]? = nil,
        storageEncrypted: Bool = false,
        storageType: String? = nil,
        tdeCredentialArn: String? = nil,
        timezone: String? = nil,
        vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cACertificateIdentifier = cACertificateIdentifier
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBInstanceArn = dBInstanceArn
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBInstanceStatus = dBInstanceStatus
        self.dBName = dBName
        self.dBParameterGroups = dBParameterGroups
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroup = dBSubnetGroup
        self.dbInstancePort = dbInstancePort
        self.dbiResourceId = dbiResourceId
        self.deletionProtection = deletionProtection
        self.domainMemberships = domainMemberships
        self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
        self.endpoint = endpoint
        self.engine = engine
        self.engineVersion = engineVersion
        self.enhancedMonitoringResourceArn = enhancedMonitoringResourceArn
        self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
        self.instanceCreateTime = instanceCreateTime
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.latestRestorableTime = latestRestorableTime
        self.licenseModel = licenseModel
        self.masterUsername = masterUsername
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.optionGroupMemberships = optionGroupMemberships
        self.pendingModifiedValues = pendingModifiedValues
        self.performanceInsightsEnabled = performanceInsightsEnabled
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers
        self.readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers
        self.readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier
        self.secondaryAvailabilityZone = secondaryAvailabilityZone
        self.statusInfos = statusInfos
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tdeCredentialArn = tdeCredentialArn
        self.timezone = timezone
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

extension DBInstanceAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBInstanceAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBInstanceAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User already has a DB instance with the given identifier.</p>
public struct DBInstanceAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBInstanceAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceNotFoundFault(message: \(String(describing: message)))"}
}

extension DBInstanceNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBInstanceNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
public struct DBInstanceNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBInstanceNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceStatusInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case normal = "Normal"
        case status = "Status"
        case statusType = "StatusType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if normal != false {
            try container.encode(normal, forKey: Key("Normal"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let statusType = statusType {
            try container.encode(statusType, forKey: Key("StatusType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusType)
        statusType = statusTypeDecoded
        let normalDecoded = try containerValues.decode(Bool.self, forKey: .normal)
        normal = normalDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceStatusInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBInstanceStatusInfo(message: \(String(describing: message)), normal: \(String(describing: normal)), status: \(String(describing: status)), statusType: \(String(describing: statusType)))"}
}

/// <p>Provides a list of status information for a DB instance.</p>
public struct DBInstanceStatusInfo: Equatable {
    /// <p>Details of the error if there is an error for the instance. If the instance is not in an
    ///       error state, this value is blank.</p>
    public let message: String?
    /// <p>Boolean value that is true if the instance is operating normally, or false if the instance
    ///       is in an error state.</p>
    public let normal: Bool
    /// <p>Status of the DB instance. For a StatusType of read replica, the values can be
    ///       replicating, error, stopped, or terminated.</p>
    public let status: String?
    /// <p>This value is currently "read replication."</p>
    public let statusType: String?

    public init (
        message: String? = nil,
        normal: Bool = false,
        status: String? = nil,
        statusType: String? = nil
    )
    {
        self.message = message
        self.normal = normal
        self.status = status
        self.statusType = statusType
    }
}

extension DBParameterGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroupArn = "DBParameterGroupArn"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case dBParameterGroupName = "DBParameterGroupName"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupArn = dBParameterGroupArn {
            try container.encode(dBParameterGroupArn, forKey: Key("DBParameterGroupArn"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dBParameterGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupArn)
        dBParameterGroupArn = dBParameterGroupArnDecoded
    }
}

extension DBParameterGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBParameterGroup(dBParameterGroupArn: \(String(describing: dBParameterGroupArn)), dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), description: \(String(describing: description)))"}
}

/// <p>Contains the details of an Amazon Neptune DB parameter group.</p>
///          <p>This data type is used as a response element in the <a>DescribeDBParameterGroups</a> action.</p>
public struct DBParameterGroup: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the DB parameter group.</p>
    public let dBParameterGroupArn: String?
    /// <p>Provides the name of the DB parameter group family that this DB parameter group is
    ///       compatible with.</p>
    public let dBParameterGroupFamily: String?
    /// <p>Provides the name of the DB parameter group.</p>
    public let dBParameterGroupName: String?
    /// <p>Provides the customer-specified description for this DB parameter group.</p>
    public let description: String?

    public init (
        dBParameterGroupArn: String? = nil,
        dBParameterGroupFamily: String? = nil,
        dBParameterGroupName: String? = nil,
        description: String? = nil
    )
    {
        self.dBParameterGroupArn = dBParameterGroupArn
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.dBParameterGroupName = dBParameterGroupName
        self.description = description
    }
}

extension DBParameterGroupAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBParameterGroupAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBParameterGroupAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBParameterGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A DB parameter group with the same name exists.</p>
public struct DBParameterGroupAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBParameterGroupAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBParameterGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension DBParameterGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBParameterGroupName</i> does not refer to an
///       existing DB parameter group.</p>
public struct DBParameterGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBParameterGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBParameterGroupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBParameterGroupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBParameterGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed number of DB parameter groups.</p>
public struct DBParameterGroupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBParameterGroupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
        case parameterApplyStatus = "ParameterApplyStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try container.encode(parameterApplyStatus, forKey: Key("ParameterApplyStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
    }
}

extension DBParameterGroupStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBParameterGroupStatus(dBParameterGroupName: \(String(describing: dBParameterGroupName)), parameterApplyStatus: \(String(describing: parameterApplyStatus)))"}
}

/// <p>The status of the DB parameter group.</p>
///          <p>This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <a>CreateDBInstance</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>DeleteDBInstance</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ModifyDBInstance</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>RebootDBInstance</a>
///                </p>
///             </li>
///          </ul>
public struct DBParameterGroupStatus: Equatable {
    /// <p>The name of the DP parameter group.</p>
    public let dBParameterGroupName: String?
    /// <p>The status of parameter updates.</p>
    public let parameterApplyStatus: String?

    public init (
        dBParameterGroupName: String? = nil,
        parameterApplyStatus: String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameterApplyStatus = parameterApplyStatus
    }
}

extension DBSecurityGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBSecurityGroupName = "DBSecurityGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: Key("DBSecurityGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DBSecurityGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSecurityGroupMembership(dBSecurityGroupName: \(String(describing: dBSecurityGroupName)), status: \(String(describing: status)))"}
}

/// <p>Specifies membership in a designated DB security group.</p>
public struct DBSecurityGroupMembership: Equatable {
    /// <p>The name of the DB security group.</p>
    public let dBSecurityGroupName: String?
    /// <p>The status of the DB security group.</p>
    public let status: String?

    public init (
        dBSecurityGroupName: String? = nil,
        status: String? = nil
    )
    {
        self.dBSecurityGroupName = dBSecurityGroupName
        self.status = status
    }
}

extension DBSecurityGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSecurityGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension DBSecurityGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSecurityGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBSecurityGroupName</i> does not refer
///       to an existing DB security group.</p>
public struct DBSecurityGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBSecurityGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSnapshotAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSnapshotAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBSnapshotAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBSnapshotIdentifier</i> is already used by an existing snapshot.</p>
public struct DBSnapshotAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSnapshotAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBSnapshotAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSnapshotNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSnapshotNotFoundFault(message: \(String(describing: message)))"}
}

extension DBSnapshotNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBSnapshotIdentifier</i> does not refer to an existing DB snapshot.</p>
public struct DBSnapshotNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSnapshotNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBSnapshotNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBSubnetGroupArn = "DBSubnetGroupArn"
        case dBSubnetGroupDescription = "DBSubnetGroupDescription"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSubnetGroupArn = dBSubnetGroupArn {
            try container.encode(dBSubnetGroupArn, forKey: Key("DBSubnetGroupArn"))
        }
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let subnetGroupStatus = subnetGroupStatus {
            try container.encode(subnetGroupStatus, forKey: Key("SubnetGroupStatus"))
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Subnets"))
            for (index0, subnet0) in subnets.enumerated() {
                try subnetsContainer.encode(subnet0, forKey: Key("Subnet.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let dBSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSubnetGroupDescription)
        dBSubnetGroupDescription = dBSubnetGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct Subnet{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Subnet>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([Subnet].self, forKey: .member)
                var subnetsBuffer:[Subnet]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [Subnet]()
                    for structureContainer0 in subnetsContainer {
                        subnetsBuffer?.append(structureContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
        let dBSubnetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSubnetGroupArn)
        dBSubnetGroupArn = dBSubnetGroupArnDecoded
    }
}

extension DBSubnetGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetGroup(dBSubnetGroupArn: \(String(describing: dBSubnetGroupArn)), dBSubnetGroupDescription: \(String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), subnetGroupStatus: \(String(describing: subnetGroupStatus)), subnets: \(String(describing: subnets)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains the details of an Amazon Neptune DB subnet group.</p>
///          <p>This data type is used as a response element in the <a>DescribeDBSubnetGroups</a> action.</p>
public struct DBSubnetGroup: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the DB subnet group.</p>
    public let dBSubnetGroupArn: String?
    /// <p>Provides the description of the DB subnet group.</p>
    public let dBSubnetGroupDescription: String?
    /// <p>The name of the DB subnet group.</p>
    public let dBSubnetGroupName: String?
    /// <p>Provides the status of the DB subnet group.</p>
    public let subnetGroupStatus: String?
    /// <p> Contains a list of <a>Subnet</a> elements.</p>
    public let subnets: [Subnet]?
    /// <p>Provides the VpcId of the DB subnet group.</p>
    public let vpcId: String?

    public init (
        dBSubnetGroupArn: String? = nil,
        dBSubnetGroupDescription: String? = nil,
        dBSubnetGroupName: String? = nil,
        subnetGroupStatus: String? = nil,
        subnets: [Subnet]? = nil,
        vpcId: String? = nil
    )
    {
        self.dBSubnetGroupArn = dBSubnetGroupArn
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetGroupStatus = subnetGroupStatus
        self.subnets = subnets
        self.vpcId = vpcId
    }
}

extension DBSubnetGroupAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetGroupAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension DBSubnetGroupAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSubnetGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBSubnetGroupName</i> is already used by an existing DB subnet group.</p>
public struct DBSubnetGroupAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension DBSubnetGroupAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupDoesNotCoverEnoughAZs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetGroupDoesNotCoverEnoughAZs(message: \(String(describing: message)))"}
}

extension DBSubnetGroupDoesNotCoverEnoughAZs: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSubnetGroupDoesNotCoverEnoughAZsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Subnets in the DB subnet group should cover at least two Availability
///       Zones unless there is only one Availability Zone.</p>
public struct DBSubnetGroupDoesNotCoverEnoughAZs: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupDoesNotCoverEnoughAZsBody: Equatable {
    public let message: String?
}

extension DBSubnetGroupDoesNotCoverEnoughAZsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension DBSubnetGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSubnetGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBSubnetGroupName</i> does not refer to an
///       existing DB subnet group.</p>
public struct DBSubnetGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DBSubnetGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetGroupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBSubnetGroupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSubnetGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed number of DB subnet groups.</p>
public struct DBSubnetGroupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBSubnetGroupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBSubnetQuotaExceededFault(message: \(String(describing: message)))"}
}

extension DBSubnetQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBSubnetQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed number of subnets in a DB subnet groups.</p>
public struct DBSubnetQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension DBSubnetQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBUpgradeDependencyFailureFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DBUpgradeDependencyFailureFault(message: \(String(describing: message)))"}
}

extension DBUpgradeDependencyFailureFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DBUpgradeDependencyFailureFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB upgrade failed because a resource the DB depends on could not be modified.</p>
public struct DBUpgradeDependencyFailureFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DBUpgradeDependencyFailureFaultBody: Equatable {
    public let message: String?
}

extension DBUpgradeDependencyFailureFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteDBClusterEndpointInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterEndpointOutputError>
}

extension DeleteDBClusterEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterEndpointInput(dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)))"}
}

extension DeleteDBClusterEndpointInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: Key("DBClusterEndpointIdentifier"))
        }
        try container.encode("DeleteDBClusterEndpoint", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBClusterEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterEndpointOutputError>
}

public struct DeleteDBClusterEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterEndpointOutputError>
}

public struct DeleteDBClusterEndpointInput: Equatable {
    /// <p>The identifier associated with the custom endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?

    public init (
        dBClusterEndpointIdentifier: String? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
    }
}

extension DeleteDBClusterEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointNotFoundFault" : self = .dBClusterEndpointNotFoundFault(try DBClusterEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterEndpointStateFault" : self = .invalidDBClusterEndpointStateFault(try InvalidDBClusterEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterEndpointOutputError: Equatable {
    case dBClusterEndpointNotFoundFault(DBClusterEndpointNotFoundFault)
    case invalidDBClusterEndpointStateFault(InvalidDBClusterEndpointStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterEndpointOutputResponse(customEndpointType: \(String(describing: customEndpointType)), dBClusterEndpointArn: \(String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), endpoint: \(String(describing: endpoint)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)), status: \(String(describing: status)))"}
}

extension DeleteDBClusterEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// <p>This data type represents the information you need to connect to an Amazon Neptune DB cluster.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBClusterEndpoint</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon RDS DB instance endpoints,
///       see <code>Endpoint</code>.</p>
public struct DeleteDBClusterEndpointOutputResponse: Equatable {
    /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
    ///       <code>WRITER</code>, <code>ANY</code>.</p>
    public let customEndpointType: String?
    /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
    public let dBClusterEndpointArn: String?
    /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
    public let dBClusterEndpointResourceIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///       stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>The DNS address of the endpoint.</p>
    public let endpoint: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///       All other eligible instances are reachable through the custom endpoint.
    ///       Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?
    /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that cannot be used for a certain kind of cluster,
    ///       such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
    public let status: String?

    public init (
        customEndpointType: String? = nil,
        dBClusterEndpointArn: String? = nil,
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterEndpointResourceIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        endpoint: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil,
        status: String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct DeleteDBClusterEndpointOutputResponseBody: Equatable {
    public let dBClusterEndpointIdentifier: String?
    public let dBClusterIdentifier: String?
    public let dBClusterEndpointResourceIdentifier: String?
    public let endpoint: String?
    public let status: String?
    public let endpointType: String?
    public let customEndpointType: String?
    public let staticMembers: [String]?
    public let excludedMembers: [String]?
    public let dBClusterEndpointArn: String?
}

extension DeleteDBClusterEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var staticMembersBuffer:[String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var excludedMembersBuffer:[String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct DeleteDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterOutputError>
}

extension DeleteDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), finalDBSnapshotIdentifier: \(String(describing: finalDBSnapshotIdentifier)), skipFinalSnapshot: \(String(describing: skipFinalSnapshot)))"}
}

extension DeleteDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let finalDBSnapshotIdentifier = finalDBSnapshotIdentifier {
            try container.encode(finalDBSnapshotIdentifier, forKey: Key("FinalDBSnapshotIdentifier"))
        }
        if skipFinalSnapshot != false {
            try container.encode(skipFinalSnapshot, forKey: Key("SkipFinalSnapshot"))
        }
        try container.encode("DeleteDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterOutputError>
}

public struct DeleteDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterOutputError>
}

public struct DeleteDBClusterInput: Equatable {
    /// <p>The DB cluster identifier for the DB cluster to be deleted. This parameter isn't
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match an existing DBClusterIdentifier.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p> The DB cluster snapshot identifier of the new DB cluster snapshot created when
    ///       <code>SkipFinalSnapshot</code> is set to <code>false</code>.</p>
    ///          <note>
    ///             <p> Specifying this parameter and also setting the <code>SkipFinalShapshot</code> parameter
    ///         to true results in an error.</p>
    ///          </note>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let finalDBSnapshotIdentifier: String?
    /// <p> Determines whether a final DB cluster snapshot is created before the DB cluster is
    ///       deleted. If <code>true</code> is specified, no DB cluster snapshot is created. If
    ///       <code>false</code> is specified, a DB cluster snapshot is created before the DB cluster is
    ///       deleted.</p>
    ///          <note>
    ///             <p>You must specify a <code>FinalDBSnapshotIdentifier</code> parameter if
    ///         <code>SkipFinalSnapshot</code> is <code>false</code>.</p>
    ///          </note>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let skipFinalSnapshot: Bool

    public init (
        dBClusterIdentifier: String? = nil,
        finalDBSnapshotIdentifier: String? = nil,
        skipFinalSnapshot: Bool = false
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
        self.skipFinalSnapshot = skipFinalSnapshot
    }
}

extension DeleteDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension DeleteDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct DeleteDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct DeleteDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension DeleteDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct DeleteDBClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterParameterGroupOutputError>
}

extension DeleteDBClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterParameterGroupInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)))"}
}

extension DeleteDBClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        try container.encode("DeleteDBClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterParameterGroupOutputError>
}

public struct DeleteDBClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterParameterGroupOutputError>
}

public struct DeleteDBClusterParameterGroupInput: Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be the name of an existing DB cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                <p>You can't delete a default DB cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be associated with any DB clusters.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?

    public init (
        dBClusterParameterGroupName: String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

extension DeleteDBClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterParameterGroupOutputResponse()"}
}

extension DeleteDBClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBClusterParameterGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteDBClusterParameterGroupOutputResponseBody: Equatable {
}

extension DeleteDBClusterParameterGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDBClusterSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterSnapshotOutputError>
}

extension DeleteDBClusterSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterSnapshotInput(dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)))"}
}

extension DeleteDBClusterSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        try container.encode("DeleteDBClusterSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBClusterSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterSnapshotOutputError>
}

public struct DeleteDBClusterSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBClusterSnapshotOutputError>
}

public struct DeleteDBClusterSnapshotInput: Equatable {
    /// <p>The identifier of the DB cluster snapshot to delete.</p>
    ///          <p>Constraints: Must be the name of an existing DB cluster snapshot in the
    ///       <code>available</code> state.</p>
    public let dBClusterSnapshotIdentifier: String?

    public init (
        dBClusterSnapshotIdentifier: String? = nil
    )
    {
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

extension DeleteDBClusterSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterSnapshotOutputError: Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(String(describing: dBClusterSnapshot)))"}
}

extension DeleteDBClusterSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct DeleteDBClusterSnapshotOutputResponse: Equatable {
    /// <p>Contains the details for an Amazon Neptune DB cluster snapshot</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterSnapshots</a> action.</p>
    public let dBClusterSnapshot: DBClusterSnapshot?

    public init (
        dBClusterSnapshot: DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct DeleteDBClusterSnapshotOutputResponseBody: Equatable {
    public let dBClusterSnapshot: DBClusterSnapshot?
}

extension DeleteDBClusterSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct DeleteDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBInstanceOutputError>
}

extension DeleteDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBInstanceInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), finalDBSnapshotIdentifier: \(String(describing: finalDBSnapshotIdentifier)), skipFinalSnapshot: \(String(describing: skipFinalSnapshot)))"}
}

extension DeleteDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let finalDBSnapshotIdentifier = finalDBSnapshotIdentifier {
            try container.encode(finalDBSnapshotIdentifier, forKey: Key("FinalDBSnapshotIdentifier"))
        }
        if skipFinalSnapshot != false {
            try container.encode(skipFinalSnapshot, forKey: Key("SkipFinalSnapshot"))
        }
        try container.encode("DeleteDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBInstanceOutputError>
}

public struct DeleteDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBInstanceOutputError>
}

public struct DeleteDBInstanceInput: Equatable {
    /// <p>The DB instance identifier for the DB instance to be deleted. This parameter isn't
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the name of an existing DB instance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p> The DBSnapshotIdentifier of the new DBSnapshot created when SkipFinalSnapshot is set to
    ///       <code>false</code>.</p>
    ///          <note>
    ///             <p>Specifying this parameter and also setting the SkipFinalShapshot parameter to true
    ///         results in an error.</p>
    ///          </note>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be specified when deleting a Read Replica.</p>
    ///             </li>
    ///          </ul>
    public let finalDBSnapshotIdentifier: String?
    /// <p> Determines whether a final DB snapshot is created before the DB instance is deleted. If
    ///       <code>true</code> is specified, no DBSnapshot is created. If <code>false</code> is specified,
    ///       a DB snapshot is created before the DB instance is deleted.</p>
    ///          <p>Note that when a DB instance is in a failure state and has a status of 'failed',
    ///       'incompatible-restore', or 'incompatible-network', it can only be deleted when the
    ///       SkipFinalSnapshot parameter is set to "true".</p>
    ///          <p>Specify <code>true</code> when deleting a Read Replica.</p>
    ///          <note>
    ///             <p>The FinalDBSnapshotIdentifier parameter must be specified if SkipFinalSnapshot is
    ///         <code>false</code>.</p>
    ///          </note>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let skipFinalSnapshot: Bool

    public init (
        dBInstanceIdentifier: String? = nil,
        finalDBSnapshotIdentifier: String? = nil,
        skipFinalSnapshot: Bool = false
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
        self.skipFinalSnapshot = skipFinalSnapshot
    }
}

extension DeleteDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExistsFault" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBInstanceOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBInstanceOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension DeleteDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct DeleteDBInstanceOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB instance.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBInstances</a> action.</p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct DeleteDBInstanceOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension DeleteDBInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct DeleteDBParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBParameterGroupOutputError>
}

extension DeleteDBParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBParameterGroupInput(dBParameterGroupName: \(String(describing: dBParameterGroupName)))"}
}

extension DeleteDBParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        try container.encode("DeleteDBParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBParameterGroupOutputError>
}

public struct DeleteDBParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBParameterGroupOutputError>
}

public struct DeleteDBParameterGroupInput: Equatable {
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be the name of an existing DB parameter group</p>
    ///             </li>
    ///             <li>
    ///                <p>You can't delete a default DB parameter group</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be associated with any DB instances</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?

    public init (
        dBParameterGroupName: String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

extension DeleteDBParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBParameterGroupOutputResponse()"}
}

extension DeleteDBParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBParameterGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteDBParameterGroupOutputResponseBody: Equatable {
}

extension DeleteDBParameterGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDBSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSubnetGroupOutputError>
}

extension DeleteDBSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBSubnetGroupInput(dBSubnetGroupName: \(String(describing: dBSubnetGroupName)))"}
}

extension DeleteDBSubnetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        try container.encode("DeleteDBSubnetGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteDBSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSubnetGroupOutputError>
}

public struct DeleteDBSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDBSubnetGroupOutputError>
}

public struct DeleteDBSubnetGroupInput: Equatable {
    /// <p>The name of the database subnet group to delete.</p>
    ///          <note>
    ///             <p>You can't delete the default subnet group.</p>
    ///          </note>
    ///          <p>Constraints:</p>
    ///          <p>Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?

    public init (
        dBSubnetGroupName: String? = nil
    )
    {
        self.dBSubnetGroupName = dBSubnetGroupName
    }
}

extension DeleteDBSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetStateFault" : self = .invalidDBSubnetStateFault(try InvalidDBSubnetStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBSubnetGroupOutputError: Equatable {
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidDBSubnetStateFault(InvalidDBSubnetStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDBSubnetGroupOutputResponse()"}
}

extension DeleteDBSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBSubnetGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteDBSubnetGroupOutputResponseBody: Equatable {
}

extension DeleteDBSubnetGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

extension DeleteEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventSubscriptionInput(subscriptionName: \(String(describing: subscriptionName)))"}
}

extension DeleteEventSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("DeleteEventSubscription", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DeleteEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

public struct DeleteEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

public struct DeleteEventSubscriptionInput: Equatable {
    /// <p>The name of the event notification subscription you want to delete.</p>
    public let subscriptionName: String?

    public init (
        subscriptionName: String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

extension DeleteEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidEventSubscriptionStateFault" : self = .invalidEventSubscriptionStateFault(try InvalidEventSubscriptionStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSubscriptionOutputError: Equatable {
    case invalidEventSubscriptionStateFault(InvalidEventSubscriptionStateFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension DeleteEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct DeleteEventSubscriptionOutputResponse: Equatable {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct DeleteEventSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension DeleteEventSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct DescribeDBClusterEndpointsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClusterEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterEndpointsOutputError>
}

extension DescribeDBClusterEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterEndpointsInput(dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBClusterEndpointsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterEndpoints", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClusterEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClusterEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterEndpointsOutputError>
}

public struct DescribeDBClusterEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClusterEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterEndpointsOutputError>
}

public struct DescribeDBClusterEndpointsInput: Equatable {
    /// <p>The identifier of the endpoint to describe. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///       stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>A set of name-value pairs that define which endpoints to include in the output.
    ///       The filters are specified as name-value pairs, in the format
    ///       <code>Name=<i>endpoint_type</i>,Values=<i>endpoint_type1</i>,<i>endpoint_type2</i>,...</code>.
    ///       <code>Name</code> can be one of: <code>db-cluster-endpoint-type</code>, <code>db-cluster-endpoint-custom-type</code>, <code>db-cluster-endpoint-id</code>, <code>db-cluster-endpoint-status</code>.
    ///       <code>Values</code> for the <code> db-cluster-endpoint-type</code> filter can be one or more of: <code>reader</code>, <code>writer</code>, <code>custom</code>.
    ///       <code>Values</code> for the <code>db-cluster-endpoint-custom-type</code> filter can be one or more of: <code>reader</code>, <code>any</code>.
    ///       <code>Values</code> for the <code>db-cluster-endpoint-status</code> filter can be one or more of: <code>available</code>, <code>creating</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>.
    ///     </p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterEndpoints</code> request.
    ///       If this parameter is specified, the response includes
    ///       only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response.
    ///       If more records exist than the specified <code>MaxRecords</code> value,
    ///       a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///     </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClusterEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterEndpointsOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterEndpointsOutputResponse(dBClusterEndpoints: \(String(describing: dBClusterEndpoints)), marker: \(String(describing: marker)))"}
}

extension DescribeDBClusterEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClusterEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterEndpoints = output.dBClusterEndpoints
            self.marker = output.marker
        } else {
            self.dBClusterEndpoints = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBClusterEndpointsOutputResponse: Equatable {
    /// <p>Contains the details of the endpoints associated with the cluster
    ///       and matching any filter conditions.</p>
    public let dBClusterEndpoints: [DBClusterEndpoint]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterEndpoints</code> request.
    ///       If this parameter is specified, the response includes
    ///       only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: String?

    public init (
        dBClusterEndpoints: [DBClusterEndpoint]? = nil,
        marker: String? = nil
    )
    {
        self.dBClusterEndpoints = dBClusterEndpoints
        self.marker = marker
    }
}

struct DescribeDBClusterEndpointsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBClusterEndpoints: [DBClusterEndpoint]?
}

extension DescribeDBClusterEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterEndpoints = "DBClusterEndpoints"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClusterEndpointsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterEndpoints) {
            struct KeyVal0{struct DBClusterEndpointList{}}
            let dBClusterEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterEndpointList>.CodingKeys.self, forKey: .dBClusterEndpoints)
            if let dBClusterEndpointsWrappedContainer = dBClusterEndpointsWrappedContainer {
                let dBClusterEndpointsContainer = try dBClusterEndpointsWrappedContainer.decodeIfPresent([DBClusterEndpoint].self, forKey: .member)
                var dBClusterEndpointsBuffer:[DBClusterEndpoint]? = nil
                if let dBClusterEndpointsContainer = dBClusterEndpointsContainer {
                    dBClusterEndpointsBuffer = [DBClusterEndpoint]()
                    for structureContainer0 in dBClusterEndpointsContainer {
                        dBClusterEndpointsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterEndpoints = dBClusterEndpointsBuffer
            } else {
                dBClusterEndpoints = []
            }
        } else {
            dBClusterEndpoints = nil
        }
    }
}

public struct DescribeDBClusterParameterGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParameterGroupsOutputError>
}

extension DescribeDBClusterParameterGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterParameterGroupsInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBClusterParameterGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterParameterGroups", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClusterParameterGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParameterGroupsOutputError>
}

public struct DescribeDBClusterParameterGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParameterGroupsOutputError>
}

public struct DescribeDBClusterParameterGroupsInput: Equatable {
    /// <p>The name of a specific DB cluster parameter group to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterParameterGroups</code> request. If this parameter is specified, the
    ///       response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBClusterParameterGroupName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClusterParameterGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterParameterGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterParameterGroupsOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterParameterGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterParameterGroupsOutputResponse(dBClusterParameterGroups: \(String(describing: dBClusterParameterGroups)), marker: \(String(describing: marker)))"}
}

extension DescribeDBClusterParameterGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClusterParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterParameterGroups = output.dBClusterParameterGroups
            self.marker = output.marker
        } else {
            self.dBClusterParameterGroups = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBClusterParameterGroupsOutputResponse: Equatable {
    /// <p>A list of DB cluster parameter groups.</p>
    public let dBClusterParameterGroups: [DBClusterParameterGroup]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterParameterGroups</code> request. If this parameter is specified, the
    ///       response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: String?

    public init (
        dBClusterParameterGroups: [DBClusterParameterGroup]? = nil,
        marker: String? = nil
    )
    {
        self.dBClusterParameterGroups = dBClusterParameterGroups
        self.marker = marker
    }
}

struct DescribeDBClusterParameterGroupsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBClusterParameterGroups: [DBClusterParameterGroup]?
}

extension DescribeDBClusterParameterGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroups = "DBClusterParameterGroups"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClusterParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterParameterGroups) {
            struct KeyVal0{struct DBClusterParameterGroup{}}
            let dBClusterParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterParameterGroup>.CodingKeys.self, forKey: .dBClusterParameterGroups)
            if let dBClusterParameterGroupsWrappedContainer = dBClusterParameterGroupsWrappedContainer {
                let dBClusterParameterGroupsContainer = try dBClusterParameterGroupsWrappedContainer.decodeIfPresent([DBClusterParameterGroup].self, forKey: .member)
                var dBClusterParameterGroupsBuffer:[DBClusterParameterGroup]? = nil
                if let dBClusterParameterGroupsContainer = dBClusterParameterGroupsContainer {
                    dBClusterParameterGroupsBuffer = [DBClusterParameterGroup]()
                    for structureContainer0 in dBClusterParameterGroupsContainer {
                        dBClusterParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterParameterGroups = dBClusterParameterGroupsBuffer
            } else {
                dBClusterParameterGroups = []
            }
        } else {
            dBClusterParameterGroups = nil
        }
    }
}

public struct DescribeDBClusterParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParametersOutputError>
}

extension DescribeDBClusterParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterParametersInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), source: \(String(describing: source)))"}
}

extension DescribeDBClusterParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
        try container.encode("DescribeDBClusterParameters", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClusterParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParametersOutputError>
}

public struct DescribeDBClusterParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterParametersOutputError>
}

public struct DescribeDBClusterParametersInput: Equatable {
    /// <p>The name of a specific DB cluster parameter group to return parameter details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterParameters</code> request. If this parameter is specified, the response
    ///       includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.
    ///    </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p> A value that indicates to return only parameters for a specific source. Parameter sources
    ///       can be <code>engine</code>, <code>service</code>, or <code>customer</code>.</p>
    public let source: String?

    public init (
        dBClusterParameterGroupName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        source: String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.source = source
    }
}

extension DescribeDBClusterParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterParametersOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterParametersOutputResponse(marker: \(String(describing: marker)), parameters: \(String(describing: parameters)))"}
}

extension DescribeDBClusterParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

public struct DescribeDBClusterParametersOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous DescribeDBClusterParameters request.
    ///       If this parameter is specified, the response includes only records beyond the marker, up to
    ///       the value specified by <code>MaxRecords</code> .</p>
    public let marker: String?
    /// <p>Provides a list of parameters for the DB cluster parameter group.</p>
    public let parameters: [Parameter]?

    public init (
        marker: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeDBClusterParametersOutputResponseBody: Equatable {
    public let parameters: [Parameter]?
    public let marker: String?
}

extension DescribeDBClusterParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClusterParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBClusterSnapshotAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

extension DescribeDBClusterSnapshotAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterSnapshotAttributesInput(dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)))"}
}

extension DescribeDBClusterSnapshotAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        try container.encode("DescribeDBClusterSnapshotAttributes", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClusterSnapshotAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

public struct DescribeDBClusterSnapshotAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

public struct DescribeDBClusterSnapshotAttributesInput: Equatable {
    /// <p>The identifier for the DB cluster snapshot to describe the attributes for.</p>
    public let dBClusterSnapshotIdentifier: String?

    public init (
        dBClusterSnapshotIdentifier: String? = nil
    )
    {
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

extension DescribeDBClusterSnapshotAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterSnapshotAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterSnapshotAttributesOutputError: Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterSnapshotAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterSnapshotAttributesOutputResponse(dBClusterSnapshotAttributesResult: \(String(describing: dBClusterSnapshotAttributesResult)))"}
}

extension DescribeDBClusterSnapshotAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClusterSnapshotAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshotAttributesResult = output.dBClusterSnapshotAttributesResult
        } else {
            self.dBClusterSnapshotAttributesResult = nil
        }
    }
}

public struct DescribeDBClusterSnapshotAttributesOutputResponse: Equatable {
    /// <p>Contains the results of a successful call to the <a>DescribeDBClusterSnapshotAttributes</a> API action.</p>
    ///          <p>Manual DB cluster snapshot attributes are used to authorize other Amazon accounts to copy or
    ///       restore a manual DB cluster snapshot. For more information, see the <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
    public let dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult?

    public init (
        dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult? = nil
    )
    {
        self.dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResult
    }
}

struct DescribeDBClusterSnapshotAttributesOutputResponseBody: Equatable {
    public let dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult?
}

extension DescribeDBClusterSnapshotAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClusterSnapshotAttributesResult"))
        let dBClusterSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(DBClusterSnapshotAttributesResult.self, forKey: .dBClusterSnapshotAttributesResult)
        dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResultDecoded
    }
}

public struct DescribeDBClusterSnapshotsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotsOutputError>
}

extension DescribeDBClusterSnapshotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterSnapshotsInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)), filters: \(String(describing: filters)), includePublic: \(String(describing: includePublic)), includeShared: \(String(describing: includeShared)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), snapshotType: \(String(describing: snapshotType)))"}
}

extension DescribeDBClusterSnapshotsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if includePublic != false {
            try container.encode(includePublic, forKey: Key("IncludePublic"))
        }
        if includeShared != false {
            try container.encode(includeShared, forKey: Key("IncludeShared"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: Key("SnapshotType"))
        }
        try container.encode("DescribeDBClusterSnapshots", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClusterSnapshotsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotsOutputError>
}

public struct DescribeDBClusterSnapshotsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClusterSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClusterSnapshotsOutputError>
}

public struct DescribeDBClusterSnapshotsInput: Equatable {
    /// <p>The ID of the DB cluster to retrieve the list of DB cluster snapshots for. This parameter
    ///       can't be used in conjunction with the <code>DBClusterSnapshotIdentifier</code> parameter. This
    ///       parameter is not case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>A specific DB cluster snapshot identifier to describe. This parameter can't be used in
    ///       conjunction with the <code>DBClusterIdentifier</code> parameter. This value is stored as a
    ///       lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the identifier of an existing DBClusterSnapshot.</p>
    ///             </li>
    ///             <li>
    ///                <p>If this identifier is for an automated snapshot, the <code>SnapshotType</code>
    ///           parameter must also be specified.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterSnapshotIdentifier: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p>True to include manual DB cluster snapshots that are public and can be copied or restored
    ///       by any Amazon account, and otherwise false. The default is <code>false</code>. The default is
    ///       false.</p>
    ///          <p>You can share a manual DB cluster snapshot as public by using the <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
    public let includePublic: Bool
    /// <p>True to include shared manual DB cluster snapshots from other Amazon accounts that this AWS
    ///       account has been given permission to copy or restore, and otherwise false. The default is
    ///       <code>false</code>.</p>
    ///          <p>You can give an Amazon account permission to restore a manual DB cluster snapshot from
    ///       another Amazon account by the <a>ModifyDBClusterSnapshotAttribute</a> API
    ///       action.</p>
    public let includeShared: Bool
    /// <p>An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterSnapshots</code> request. If this parameter is specified, the response
    ///       includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.
    ///    </p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The type of DB cluster snapshots to be returned. You can specify one of the following
    ///       values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>automated</code> - Return all DB cluster snapshots that have been automatically
    ///           taken by Amazon Neptune for my Amazon account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>manual</code> - Return all DB cluster snapshots that have been taken by my AWS
    ///           account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>shared</code> - Return all manual DB cluster snapshots that have been shared to
    ///           my Amazon account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>public</code> - Return all DB cluster snapshots that have been marked as
    ///           public.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify a <code>SnapshotType</code> value, then both automated and manual DB
    ///       cluster snapshots are returned. You can include shared DB cluster snapshots with these results
    ///       by setting the <code>IncludeShared</code> parameter to <code>true</code>. You can include
    ///       public DB cluster snapshots with these results by setting the <code>IncludePublic</code>
    ///       parameter to <code>true</code>.</p>
    ///          <p>The <code>IncludeShared</code> and <code>IncludePublic</code> parameters don't apply for
    ///       <code>SnapshotType</code> values of <code>manual</code> or <code>automated</code>. The
    ///       <code>IncludePublic</code> parameter doesn't apply when <code>SnapshotType</code> is set to
    ///       <code>shared</code>. The <code>IncludeShared</code> parameter doesn't apply when
    ///       <code>SnapshotType</code> is set to <code>public</code>.</p>
    public let snapshotType: String?

    public init (
        dBClusterIdentifier: String? = nil,
        dBClusterSnapshotIdentifier: String? = nil,
        filters: [Filter]? = nil,
        includePublic: Bool = false,
        includeShared: Bool = false,
        marker: String? = nil,
        maxRecords: Int? = nil,
        snapshotType: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.filters = filters
        self.includePublic = includePublic
        self.includeShared = includeShared
        self.marker = marker
        self.maxRecords = maxRecords
        self.snapshotType = snapshotType
    }
}

extension DescribeDBClusterSnapshotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterSnapshotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterSnapshotsOutputError: Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterSnapshotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClusterSnapshotsOutputResponse(dBClusterSnapshots: \(String(describing: dBClusterSnapshots)), marker: \(String(describing: marker)))"}
}

extension DescribeDBClusterSnapshotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshots = output.dBClusterSnapshots
            self.marker = output.marker
        } else {
            self.dBClusterSnapshots = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBClusterSnapshotsOutputResponse: Equatable {
    /// <p>Provides a list of DB cluster snapshots for the user.</p>
    public let dBClusterSnapshots: [DBClusterSnapshot]?
    /// <p> An optional pagination token provided by a previous <a>DescribeDBClusterSnapshots</a> request. If this parameter is specified, the response
    ///       includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.
    ///    </p>
    public let marker: String?

    public init (
        dBClusterSnapshots: [DBClusterSnapshot]? = nil,
        marker: String? = nil
    )
    {
        self.dBClusterSnapshots = dBClusterSnapshots
        self.marker = marker
    }
}

struct DescribeDBClusterSnapshotsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBClusterSnapshots: [DBClusterSnapshot]?
}

extension DescribeDBClusterSnapshotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshots = "DBClusterSnapshots"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClusterSnapshotsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterSnapshots) {
            struct KeyVal0{struct DBClusterSnapshot{}}
            let dBClusterSnapshotsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterSnapshot>.CodingKeys.self, forKey: .dBClusterSnapshots)
            if let dBClusterSnapshotsWrappedContainer = dBClusterSnapshotsWrappedContainer {
                let dBClusterSnapshotsContainer = try dBClusterSnapshotsWrappedContainer.decodeIfPresent([DBClusterSnapshot].self, forKey: .member)
                var dBClusterSnapshotsBuffer:[DBClusterSnapshot]? = nil
                if let dBClusterSnapshotsContainer = dBClusterSnapshotsContainer {
                    dBClusterSnapshotsBuffer = [DBClusterSnapshot]()
                    for structureContainer0 in dBClusterSnapshotsContainer {
                        dBClusterSnapshotsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterSnapshots = dBClusterSnapshotsBuffer
            } else {
                dBClusterSnapshots = []
            }
        } else {
            dBClusterSnapshots = nil
        }
    }
}

public struct DescribeDBClustersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClustersOutputError>
}

extension DescribeDBClustersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClustersInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBClustersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusters", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBClustersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClustersOutputError>
}

public struct DescribeDBClustersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBClustersOutputError>
}

public struct DescribeDBClustersInput: Equatable {
    /// <p>The user-supplied DB cluster identifier. If this parameter is specified, information from
    ///       only the specific DB cluster is returned. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match an existing DBClusterIdentifier.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>A filter that specifies one or more DB clusters to describe.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-id</code> - Accepts DB cluster identifiers and DB cluster Amazon
    ///         Resource Names (ARNs). The results list will only include information about the DB
    ///         clusters identified by these ARNs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>engine</code> - Accepts an engine name (such as <code>neptune</code>),
    ///         and restricts the results list to DB clusters created by that engine.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>For example, to invoke this API from the Amazon CLI and filter so that only
    ///       Neptune DB clusters are returned, you could use the following command:</p>
    public let filters: [Filter]?
    /// <p>An optional pagination token provided by a previous <a>DescribeDBClusters</a>
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBClusterIdentifier: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClustersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClustersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClustersOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClustersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBClustersOutputResponse(dBClusters: \(String(describing: dBClusters)), marker: \(String(describing: marker)))"}
}

extension DescribeDBClustersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBClustersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusters = output.dBClusters
            self.marker = output.marker
        } else {
            self.dBClusters = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBClustersOutputResponse: Equatable {
    /// <p>Contains a list of DB clusters for the user.</p>
    public let dBClusters: [DBCluster]?
    /// <p>A pagination token that can be used in a subsequent DescribeDBClusters request.</p>
    public let marker: String?

    public init (
        dBClusters: [DBCluster]? = nil,
        marker: String? = nil
    )
    {
        self.dBClusters = dBClusters
        self.marker = marker
    }
}

struct DescribeDBClustersOutputResponseBody: Equatable {
    public let marker: String?
    public let dBClusters: [DBCluster]?
}

extension DescribeDBClustersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusters = "DBClusters"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBClustersResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusters) {
            struct KeyVal0{struct DBCluster{}}
            let dBClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBCluster>.CodingKeys.self, forKey: .dBClusters)
            if let dBClustersWrappedContainer = dBClustersWrappedContainer {
                let dBClustersContainer = try dBClustersWrappedContainer.decodeIfPresent([DBCluster].self, forKey: .member)
                var dBClustersBuffer:[DBCluster]? = nil
                if let dBClustersContainer = dBClustersContainer {
                    dBClustersBuffer = [DBCluster]()
                    for structureContainer0 in dBClustersContainer {
                        dBClustersBuffer?.append(structureContainer0)
                    }
                }
                dBClusters = dBClustersBuffer
            } else {
                dBClusters = []
            }
        } else {
            dBClusters = nil
        }
    }
}

public struct DescribeDBEngineVersionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBEngineVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBEngineVersionsOutputError>
}

extension DescribeDBEngineVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBEngineVersionsInput(dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), defaultOnly: \(String(describing: defaultOnly)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), filters: \(String(describing: filters)), listSupportedCharacterSets: \(String(describing: listSupportedCharacterSets)), listSupportedTimezones: \(String(describing: listSupportedTimezones)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBEngineVersionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if defaultOnly != false {
            try container.encode(defaultOnly, forKey: Key("DefaultOnly"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let listSupportedCharacterSets = listSupportedCharacterSets {
            try container.encode(listSupportedCharacterSets, forKey: Key("ListSupportedCharacterSets"))
        }
        if let listSupportedTimezones = listSupportedTimezones {
            try container.encode(listSupportedTimezones, forKey: Key("ListSupportedTimezones"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBEngineVersions", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBEngineVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBEngineVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBEngineVersionsOutputError>
}

public struct DescribeDBEngineVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBEngineVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBEngineVersionsOutputError>
}

public struct DescribeDBEngineVersionsInput: Equatable {
    /// <p>The name of a specific DB parameter group family to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match an existing DBParameterGroupFamily.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupFamily: String?
    /// <p>Indicates that only the default version of the specified engine or engine and major
    ///       version combination is returned.</p>
    public let defaultOnly: Bool
    /// <p>The database engine to return.</p>
    public let engine: String?
    /// <p>The database engine version to return.</p>
    ///          <p>Example: <code>5.1.49</code>
    ///          </p>
    public let engineVersion: String?
    /// <p>Not currently supported.</p>
    public let filters: [Filter]?
    /// <p>If this parameter is specified and the requested engine supports the
    ///       <code>CharacterSetName</code> parameter for <code>CreateDBInstance</code>, the response
    ///       includes a list of supported character sets for each engine version.</p>
    public let listSupportedCharacterSets: Bool?
    /// <p>If this parameter is specified and the requested engine supports the <code>TimeZone</code>
    ///       parameter for <code>CreateDBInstance</code>, the response includes a list of supported time
    ///       zones for each engine version.</p>
    public let listSupportedTimezones: Bool?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more than the
    ///       <code>MaxRecords</code> value is available, a pagination token called a marker is included in
    ///       the response so that the following results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBParameterGroupFamily: String? = nil,
        defaultOnly: Bool = false,
        engine: String? = nil,
        engineVersion: String? = nil,
        filters: [Filter]? = nil,
        listSupportedCharacterSets: Bool? = nil,
        listSupportedTimezones: Bool? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.defaultOnly = defaultOnly
        self.engine = engine
        self.engineVersion = engineVersion
        self.filters = filters
        self.listSupportedCharacterSets = listSupportedCharacterSets
        self.listSupportedTimezones = listSupportedTimezones
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBEngineVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBEngineVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBEngineVersionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBEngineVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBEngineVersionsOutputResponse(dBEngineVersions: \(String(describing: dBEngineVersions)), marker: \(String(describing: marker)))"}
}

extension DescribeDBEngineVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBEngineVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBEngineVersions = output.dBEngineVersions
            self.marker = output.marker
        } else {
            self.dBEngineVersions = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBEngineVersionsOutputResponse: Equatable {
    /// <p> A list of <code>DBEngineVersion</code> elements.</p>
    public let dBEngineVersions: [DBEngineVersion]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: String?

    public init (
        dBEngineVersions: [DBEngineVersion]? = nil,
        marker: String? = nil
    )
    {
        self.dBEngineVersions = dBEngineVersions
        self.marker = marker
    }
}

struct DescribeDBEngineVersionsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBEngineVersions: [DBEngineVersion]?
}

extension DescribeDBEngineVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBEngineVersions = "DBEngineVersions"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBEngineVersionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBEngineVersions) {
            struct KeyVal0{struct DBEngineVersion{}}
            let dBEngineVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBEngineVersion>.CodingKeys.self, forKey: .dBEngineVersions)
            if let dBEngineVersionsWrappedContainer = dBEngineVersionsWrappedContainer {
                let dBEngineVersionsContainer = try dBEngineVersionsWrappedContainer.decodeIfPresent([DBEngineVersion].self, forKey: .member)
                var dBEngineVersionsBuffer:[DBEngineVersion]? = nil
                if let dBEngineVersionsContainer = dBEngineVersionsContainer {
                    dBEngineVersionsBuffer = [DBEngineVersion]()
                    for structureContainer0 in dBEngineVersionsContainer {
                        dBEngineVersionsBuffer?.append(structureContainer0)
                    }
                }
                dBEngineVersions = dBEngineVersionsBuffer
            } else {
                dBEngineVersions = []
            }
        } else {
            dBEngineVersions = nil
        }
    }
}

public struct DescribeDBInstancesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBInstancesOutputError>
}

extension DescribeDBInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBInstancesInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBInstancesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBInstances", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBInstancesOutputError>
}

public struct DescribeDBInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBInstancesOutputError>
}

public struct DescribeDBInstancesInput: Equatable {
    /// <p>The user-supplied instance identifier. If this parameter is specified, information from
    ///       only the specific DB instance is returned. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p>A filter that specifies one or more DB instances to describe.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-id</code> - Accepts DB cluster identifiers and DB cluster Amazon
    ///         Resource Names (ARNs). The results list will only include information about the DB
    ///         instances associated with the DB clusters identified by these ARNs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>engine</code> - Accepts an engine name (such as <code>neptune</code>),
    ///         and restricts the results list to DB instances created by that engine.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>For example, to invoke this API from the Amazon CLI and filter so that only
    ///       Neptune DB instances are returned, you could use the following command:</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous <code>DescribeDBInstances</code>
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBInstanceIdentifier: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBInstancesOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBInstancesOutputResponse(dBInstances: \(String(describing: dBInstances)), marker: \(String(describing: marker)))"}
}

extension DescribeDBInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstances = output.dBInstances
            self.marker = output.marker
        } else {
            self.dBInstances = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBInstancesOutputResponse: Equatable {
    /// <p> A list of <a>DBInstance</a> instances.</p>
    public let dBInstances: [DBInstance]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code> .</p>
    public let marker: String?

    public init (
        dBInstances: [DBInstance]? = nil,
        marker: String? = nil
    )
    {
        self.dBInstances = dBInstances
        self.marker = marker
    }
}

struct DescribeDBInstancesOutputResponseBody: Equatable {
    public let marker: String?
    public let dBInstances: [DBInstance]?
}

extension DescribeDBInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstances = "DBInstances"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBInstancesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBInstances) {
            struct KeyVal0{struct DBInstance{}}
            let dBInstancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstance>.CodingKeys.self, forKey: .dBInstances)
            if let dBInstancesWrappedContainer = dBInstancesWrappedContainer {
                let dBInstancesContainer = try dBInstancesWrappedContainer.decodeIfPresent([DBInstance].self, forKey: .member)
                var dBInstancesBuffer:[DBInstance]? = nil
                if let dBInstancesContainer = dBInstancesContainer {
                    dBInstancesBuffer = [DBInstance]()
                    for structureContainer0 in dBInstancesContainer {
                        dBInstancesBuffer?.append(structureContainer0)
                    }
                }
                dBInstances = dBInstancesBuffer
            } else {
                dBInstances = []
            }
        } else {
            dBInstances = nil
        }
    }
}

public struct DescribeDBParameterGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParameterGroupsOutputError>
}

extension DescribeDBParameterGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBParameterGroupsInput(dBParameterGroupName: \(String(describing: dBParameterGroupName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBParameterGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBParameterGroups", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBParameterGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParameterGroupsOutputError>
}

public struct DescribeDBParameterGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParameterGroupsOutputError>
}

public struct DescribeDBParameterGroupsInput: Equatable {
    /// <p>The name of a specific DB parameter group to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p>An optional pagination token provided by a previous
    ///       <code>DescribeDBParameterGroups</code> request. If this parameter is specified, the response
    ///       includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBParameterGroupName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBParameterGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBParameterGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBParameterGroupsOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBParameterGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBParameterGroupsOutputResponse(dBParameterGroups: \(String(describing: dBParameterGroups)), marker: \(String(describing: marker)))"}
}

extension DescribeDBParameterGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBParameterGroups = output.dBParameterGroups
            self.marker = output.marker
        } else {
            self.dBParameterGroups = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBParameterGroupsOutputResponse: Equatable {
    /// <p>A list of <a>DBParameterGroup</a> instances.</p>
    public let dBParameterGroups: [DBParameterGroup]?
    /// <p>An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: String?

    public init (
        dBParameterGroups: [DBParameterGroup]? = nil,
        marker: String? = nil
    )
    {
        self.dBParameterGroups = dBParameterGroups
        self.marker = marker
    }
}

struct DescribeDBParameterGroupsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBParameterGroups: [DBParameterGroup]?
}

extension DescribeDBParameterGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroups = "DBParameterGroups"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBParameterGroups) {
            struct KeyVal0{struct DBParameterGroup{}}
            let dBParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBParameterGroup>.CodingKeys.self, forKey: .dBParameterGroups)
            if let dBParameterGroupsWrappedContainer = dBParameterGroupsWrappedContainer {
                let dBParameterGroupsContainer = try dBParameterGroupsWrappedContainer.decodeIfPresent([DBParameterGroup].self, forKey: .member)
                var dBParameterGroupsBuffer:[DBParameterGroup]? = nil
                if let dBParameterGroupsContainer = dBParameterGroupsContainer {
                    dBParameterGroupsBuffer = [DBParameterGroup]()
                    for structureContainer0 in dBParameterGroupsContainer {
                        dBParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBParameterGroups = dBParameterGroupsBuffer
            } else {
                dBParameterGroups = []
            }
        } else {
            dBParameterGroups = nil
        }
    }
}

public struct DescribeDBParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParametersOutputError>
}

extension DescribeDBParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBParametersInput(dBParameterGroupName: \(String(describing: dBParameterGroupName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), source: \(String(describing: source)))"}
}

extension DescribeDBParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
        try container.encode("DescribeDBParameters", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParametersOutputError>
}

public struct DescribeDBParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBParametersOutputError>
}

public struct DescribeDBParametersInput: Equatable {
    /// <p>The name of a specific DB parameter group to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p>An optional pagination token provided by a previous <code>DescribeDBParameters</code>
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The parameter types to return.</p>
    ///          <p>Default: All parameter types returned</p>
    ///          <p>Valid Values: <code>user | system | engine-default</code>
    ///          </p>
    public let source: String?

    public init (
        dBParameterGroupName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        source: String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.source = source
    }
}

extension DescribeDBParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBParametersOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBParametersOutputResponse(marker: \(String(describing: marker)), parameters: \(String(describing: parameters)))"}
}

extension DescribeDBParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

public struct DescribeDBParametersOutputResponse: Equatable {
    /// <p>An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>A list of <a>Parameter</a> values.</p>
    public let parameters: [Parameter]?

    public init (
        marker: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeDBParametersOutputResponseBody: Equatable {
    public let parameters: [Parameter]?
    public let marker: String?
}

extension DescribeDBParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBSubnetGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDBSubnetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSubnetGroupsOutputError>
}

extension DescribeDBSubnetGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBSubnetGroupsInput(dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeDBSubnetGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeDBSubnetGroups", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeDBSubnetGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDBSubnetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSubnetGroupsOutputError>
}

public struct DescribeDBSubnetGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDBSubnetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDBSubnetGroupsOutputError>
}

public struct DescribeDBSubnetGroupsInput: Equatable {
    /// <p>The name of the DB subnet group to return details for.</p>
    public let dBSubnetGroupName: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous DescribeDBSubnetGroups request. If
    ///       this parameter is specified, the response includes only records beyond the marker, up to the
    ///       value specified by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBSubnetGroupName: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBSubnetGroupName = dBSubnetGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBSubnetGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSubnetGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSubnetGroupsOutputError: Equatable {
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSubnetGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDBSubnetGroupsOutputResponse(dBSubnetGroups: \(String(describing: dBSubnetGroups)), marker: \(String(describing: marker)))"}
}

extension DescribeDBSubnetGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDBSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSubnetGroups = output.dBSubnetGroups
            self.marker = output.marker
        } else {
            self.dBSubnetGroups = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBSubnetGroupsOutputResponse: Equatable {
    /// <p> A list of <a>DBSubnetGroup</a> instances.</p>
    public let dBSubnetGroups: [DBSubnetGroup]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: String?

    public init (
        dBSubnetGroups: [DBSubnetGroup]? = nil,
        marker: String? = nil
    )
    {
        self.dBSubnetGroups = dBSubnetGroups
        self.marker = marker
    }
}

struct DescribeDBSubnetGroupsOutputResponseBody: Equatable {
    public let marker: String?
    public let dBSubnetGroups: [DBSubnetGroup]?
}

extension DescribeDBSubnetGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSubnetGroups = "DBSubnetGroups"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeDBSubnetGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBSubnetGroups) {
            struct KeyVal0{struct DBSubnetGroup{}}
            let dBSubnetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSubnetGroup>.CodingKeys.self, forKey: .dBSubnetGroups)
            if let dBSubnetGroupsWrappedContainer = dBSubnetGroupsWrappedContainer {
                let dBSubnetGroupsContainer = try dBSubnetGroupsWrappedContainer.decodeIfPresent([DBSubnetGroup].self, forKey: .member)
                var dBSubnetGroupsBuffer:[DBSubnetGroup]? = nil
                if let dBSubnetGroupsContainer = dBSubnetGroupsContainer {
                    dBSubnetGroupsBuffer = [DBSubnetGroup]()
                    for structureContainer0 in dBSubnetGroupsContainer {
                        dBSubnetGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSubnetGroups = dBSubnetGroupsBuffer
            } else {
                dBSubnetGroups = []
            }
        } else {
            dBSubnetGroups = nil
        }
    }
}

public struct DescribeEngineDefaultClusterParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

extension DescribeEngineDefaultClusterParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEngineDefaultClusterParametersInput(dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeEngineDefaultClusterParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeEngineDefaultClusterParameters", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeEngineDefaultClusterParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

public struct DescribeEngineDefaultClusterParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

public struct DescribeEngineDefaultClusterParametersInput: Equatable {
    /// <p>The name of the DB cluster parameter group family to return engine parameter information
    ///       for.</p>
    public let dBParameterGroupFamily: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeEngineDefaultClusterParameters</code> request. If this parameter is specified,
    ///       the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBParameterGroupFamily: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeEngineDefaultClusterParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEngineDefaultClusterParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngineDefaultClusterParametersOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngineDefaultClusterParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEngineDefaultClusterParametersOutputResponse(engineDefaults: \(String(describing: engineDefaults)))"}
}

extension DescribeEngineDefaultClusterParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEngineDefaultClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.engineDefaults = output.engineDefaults
        } else {
            self.engineDefaults = nil
        }
    }
}

public struct DescribeEngineDefaultClusterParametersOutputResponse: Equatable {
    /// <p> Contains the result of a successful invocation of the <a>DescribeEngineDefaultParameters</a> action.</p>
    public let engineDefaults: EngineDefaults?

    public init (
        engineDefaults: EngineDefaults? = nil
    )
    {
        self.engineDefaults = engineDefaults
    }
}

struct DescribeEngineDefaultClusterParametersOutputResponseBody: Equatable {
    public let engineDefaults: EngineDefaults?
}

extension DescribeEngineDefaultClusterParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engineDefaults = "EngineDefaults"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEngineDefaultClusterParametersResult"))
        let engineDefaultsDecoded = try containerValues.decodeIfPresent(EngineDefaults.self, forKey: .engineDefaults)
        engineDefaults = engineDefaultsDecoded
    }
}

public struct DescribeEngineDefaultParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultParametersOutputError>
}

extension DescribeEngineDefaultParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEngineDefaultParametersInput(dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeEngineDefaultParametersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        try container.encode("DescribeEngineDefaultParameters", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeEngineDefaultParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultParametersOutputError>
}

public struct DescribeEngineDefaultParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEngineDefaultParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngineDefaultParametersOutputError>
}

public struct DescribeEngineDefaultParametersInput: Equatable {
    /// <p>The name of the DB parameter group family.</p>
    public let dBParameterGroupFamily: String?
    /// <p>Not currently supported.</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeEngineDefaultParameters</code> request. If this parameter is specified, the
    ///       response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        dBParameterGroupFamily: String? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeEngineDefaultParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEngineDefaultParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngineDefaultParametersOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngineDefaultParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEngineDefaultParametersOutputResponse(engineDefaults: \(String(describing: engineDefaults)))"}
}

extension DescribeEngineDefaultParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEngineDefaultParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.engineDefaults = output.engineDefaults
        } else {
            self.engineDefaults = nil
        }
    }
}

public struct DescribeEngineDefaultParametersOutputResponse: Equatable {
    /// <p> Contains the result of a successful invocation of the <a>DescribeEngineDefaultParameters</a> action.</p>
    public let engineDefaults: EngineDefaults?

    public init (
        engineDefaults: EngineDefaults? = nil
    )
    {
        self.engineDefaults = engineDefaults
    }
}

struct DescribeEngineDefaultParametersOutputResponseBody: Equatable {
    public let engineDefaults: EngineDefaults?
}

extension DescribeEngineDefaultParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engineDefaults = "EngineDefaults"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEngineDefaultParametersResult"))
        let engineDefaultsDecoded = try containerValues.decodeIfPresent(EngineDefaults.self, forKey: .engineDefaults)
        engineDefaults = engineDefaultsDecoded
    }
}

public struct DescribeEventCategoriesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

extension DescribeEventCategoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventCategoriesInput(filters: \(String(describing: filters)), sourceType: \(String(describing: sourceType)))"}
}

extension DescribeEventCategoriesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        try container.encode("DescribeEventCategories", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeEventCategoriesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

public struct DescribeEventCategoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

public struct DescribeEventCategoriesInput: Equatable {
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p>The type of source that is generating the events.</p>
    ///          <p>Valid values: db-instance | db-parameter-group | db-security-group | db-snapshot</p>
    public let sourceType: String?

    public init (
        filters: [Filter]? = nil,
        sourceType: String? = nil
    )
    {
        self.filters = filters
        self.sourceType = sourceType
    }
}

extension DescribeEventCategoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventCategoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventCategoriesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventCategoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventCategoriesOutputResponse(eventCategoriesMapList: \(String(describing: eventCategoriesMapList)))"}
}

extension DescribeEventCategoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventCategoriesMapList = output.eventCategoriesMapList
        } else {
            self.eventCategoriesMapList = nil
        }
    }
}

public struct DescribeEventCategoriesOutputResponse: Equatable {
    /// <p>A list of EventCategoriesMap data types.</p>
    public let eventCategoriesMapList: [EventCategoriesMap]?

    public init (
        eventCategoriesMapList: [EventCategoriesMap]? = nil
    )
    {
        self.eventCategoriesMapList = eventCategoriesMapList
    }
}

struct DescribeEventCategoriesOutputResponseBody: Equatable {
    public let eventCategoriesMapList: [EventCategoriesMap]?
}

extension DescribeEventCategoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventCategoriesMapList = "EventCategoriesMapList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEventCategoriesResult"))
        if containerValues.contains(.eventCategoriesMapList) {
            struct KeyVal0{struct EventCategoriesMap{}}
            let eventCategoriesMapListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategoriesMap>.CodingKeys.self, forKey: .eventCategoriesMapList)
            if let eventCategoriesMapListWrappedContainer = eventCategoriesMapListWrappedContainer {
                let eventCategoriesMapListContainer = try eventCategoriesMapListWrappedContainer.decodeIfPresent([EventCategoriesMap].self, forKey: .member)
                var eventCategoriesMapListBuffer:[EventCategoriesMap]? = nil
                if let eventCategoriesMapListContainer = eventCategoriesMapListContainer {
                    eventCategoriesMapListBuffer = [EventCategoriesMap]()
                    for structureContainer0 in eventCategoriesMapListContainer {
                        eventCategoriesMapListBuffer?.append(structureContainer0)
                    }
                }
                eventCategoriesMapList = eventCategoriesMapListBuffer
            } else {
                eventCategoriesMapList = []
            }
        } else {
            eventCategoriesMapList = nil
        }
    }
}

public struct DescribeEventSubscriptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

extension DescribeEventSubscriptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventSubscriptionsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), subscriptionName: \(String(describing: subscriptionName)))"}
}

extension DescribeEventSubscriptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("DescribeEventSubscriptions", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeEventSubscriptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

public struct DescribeEventSubscriptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

public struct DescribeEventSubscriptionsInput: Equatable {
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code> .</p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The name of the event notification subscription you want to describe.</p>
    public let subscriptionName: String?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        subscriptionName: String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
    }
}

extension DescribeEventSubscriptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventSubscriptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventSubscriptionsOutputError: Equatable {
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSubscriptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventSubscriptionsOutputResponse(eventSubscriptionsList: \(String(describing: eventSubscriptionsList)), marker: \(String(describing: marker)))"}
}

extension DescribeEventSubscriptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscriptionsList = output.eventSubscriptionsList
            self.marker = output.marker
        } else {
            self.eventSubscriptionsList = nil
            self.marker = nil
        }
    }
}

public struct DescribeEventSubscriptionsOutputResponse: Equatable {
    /// <p>A list of EventSubscriptions data types.</p>
    public let eventSubscriptionsList: [EventSubscription]?
    /// <p> An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?

    public init (
        eventSubscriptionsList: [EventSubscription]? = nil,
        marker: String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

struct DescribeEventSubscriptionsOutputResponseBody: Equatable {
    public let marker: String?
    public let eventSubscriptionsList: [EventSubscription]?
}

extension DescribeEventSubscriptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscriptionsList = "EventSubscriptionsList"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEventSubscriptionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.eventSubscriptionsList) {
            struct KeyVal0{struct EventSubscription{}}
            let eventSubscriptionsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventSubscription>.CodingKeys.self, forKey: .eventSubscriptionsList)
            if let eventSubscriptionsListWrappedContainer = eventSubscriptionsListWrappedContainer {
                let eventSubscriptionsListContainer = try eventSubscriptionsListWrappedContainer.decodeIfPresent([EventSubscription].self, forKey: .member)
                var eventSubscriptionsListBuffer:[EventSubscription]? = nil
                if let eventSubscriptionsListContainer = eventSubscriptionsListContainer {
                    eventSubscriptionsListBuffer = [EventSubscription]()
                    for structureContainer0 in eventSubscriptionsListContainer {
                        eventSubscriptionsListBuffer?.append(structureContainer0)
                    }
                }
                eventSubscriptionsList = eventSubscriptionsListBuffer
            } else {
                eventSubscriptionsList = []
            }
        } else {
            eventSubscriptionsList = nil
        }
    }
}

public struct DescribeEventsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsInput(duration: \(String(describing: duration)), endTime: \(String(describing: endTime)), eventCategories: \(String(describing: eventCategories)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), sourceIdentifier: \(String(describing: sourceIdentifier)), sourceType: \(String(describing: sourceType)), startTime: \(String(describing: startTime)))"}
}

extension DescribeEventsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let duration = duration {
            try container.encode(duration, forKey: Key("Duration"))
        }
        if let endTime = endTime {
            try container.encode(TimestampWrapper(endTime, format: .dateTime), forKey: Key("endTime"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let startTime = startTime {
            try container.encode(TimestampWrapper(startTime, format: .dateTime), forKey: Key("startTime"))
        }
        try container.encode("DescribeEvents", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeEventsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInput: Equatable {
    /// <p>The number of minutes to retrieve events for.</p>
    ///          <p>Default: 60</p>
    public let duration: Int?
    /// <p> The end of the time interval for which to retrieve events, specified in ISO 8601 format.
    ///       For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///          </p>
    ///          <p>Example: 2009-07-08T18:00Z</p>
    public let endTime: Date?
    /// <p>A list of event categories that trigger notifications for a event notification
    ///       subscription.</p>
    public let eventCategories: [String]?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous DescribeEvents request. If this
    ///       parameter is specified, the response includes only records beyond the marker, up to the value
    ///       specified by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The identifier of the event source for which events are returned. If not specified, then
    ///       all sources are included in the response.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If SourceIdentifier is supplied, SourceType must also be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is <code>DBInstance</code>, then a
    ///           <code>DBInstanceIdentifier</code> must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is <code>DBSecurityGroup</code>, a <code>DBSecurityGroupName</code>
    ///           must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is <code>DBParameterGroup</code>, a
    ///           <code>DBParameterGroupName</code> must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is <code>DBSnapshot</code>, a <code>DBSnapshotIdentifier</code>
    ///           must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let sourceIdentifier: String?
    /// <p>The event source to retrieve events for. If no value is specified, all events are
    ///       returned.</p>
    public let sourceType: SourceType?
    /// <p> The beginning of the time interval to retrieve events for, specified in ISO 8601 format.
    ///       For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///          </p>
    ///          <p>Example: 2009-07-08T18:00Z</p>
    public let startTime: Date?

    public init (
        duration: Int? = nil,
        endTime: Date? = nil,
        eventCategories: [String]? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        sourceIdentifier: String? = nil,
        sourceType: SourceType? = nil,
        startTime: Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.eventCategories = eventCategories
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

extension DescribeEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsOutputResponse(events: \(String(describing: events)), marker: \(String(describing: marker)))"}
}

extension DescribeEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
            self.marker = output.marker
        } else {
            self.events = nil
            self.marker = nil
        }
    }
}

public struct DescribeEventsOutputResponse: Equatable {
    /// <p> A list of <a>Event</a> instances.</p>
    public let events: [Event]?
    /// <p> An optional pagination token provided by a previous Events request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code> .</p>
    public let marker: String?

    public init (
        events: [Event]? = nil,
        marker: String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

struct DescribeEventsOutputResponseBody: Equatable {
    public let marker: String?
    public let events: [Event]?
}

extension DescribeEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeEventsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.events) {
            struct KeyVal0{struct Event{}}
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Event>.CodingKeys.self, forKey: .events)
            if let eventsWrappedContainer = eventsWrappedContainer {
                let eventsContainer = try eventsWrappedContainer.decodeIfPresent([Event].self, forKey: .member)
                var eventsBuffer:[Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [Event]()
                    for structureContainer0 in eventsContainer {
                        eventsBuffer?.append(structureContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
    }
}

public struct DescribeOrderableDBInstanceOptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOrderableDBInstanceOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

extension DescribeOrderableDBInstanceOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrderableDBInstanceOptionsInput(dBInstanceClass: \(String(describing: dBInstanceClass)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), filters: \(String(describing: filters)), licenseModel: \(String(describing: licenseModel)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), vpc: \(String(describing: vpc)))"}
}

extension DescribeOrderableDBInstanceOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let vpc = vpc {
            try container.encode(vpc, forKey: Key("Vpc"))
        }
        try container.encode("DescribeOrderableDBInstanceOptions", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeOrderableDBInstanceOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrderableDBInstanceOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

public struct DescribeOrderableDBInstanceOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrderableDBInstanceOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

public struct DescribeOrderableDBInstanceOptionsInput: Equatable {
    /// <p>The DB instance class filter value. Specify this parameter to show only the available
    ///       offerings matching the specified DB instance class.</p>
    public let dBInstanceClass: String?
    /// <p>The name of the engine to retrieve DB instance options for.</p>
    public let engine: String?
    /// <p>The engine version filter value. Specify this parameter to show only the available
    ///       offerings matching the specified engine version.</p>
    public let engineVersion: String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p>The license model filter value. Specify this parameter to show only the available
    ///       offerings matching the specified license model.</p>
    public let licenseModel: String?
    /// <p> An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code> .</p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The VPC filter value. Specify this parameter to show only the available VPC or non-VPC
    ///       offerings.</p>
    public let vpc: Bool?

    public init (
        dBInstanceClass: String? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        filters: [Filter]? = nil,
        licenseModel: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        vpc: Bool? = nil
    )
    {
        self.dBInstanceClass = dBInstanceClass
        self.engine = engine
        self.engineVersion = engineVersion
        self.filters = filters
        self.licenseModel = licenseModel
        self.marker = marker
        self.maxRecords = maxRecords
        self.vpc = vpc
    }
}

extension DescribeOrderableDBInstanceOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOrderableDBInstanceOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrderableDBInstanceOptionsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrderableDBInstanceOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrderableDBInstanceOptionsOutputResponse(marker: \(String(describing: marker)), orderableDBInstanceOptions: \(String(describing: orderableDBInstanceOptions)))"}
}

extension DescribeOrderableDBInstanceOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOrderableDBInstanceOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.orderableDBInstanceOptions = output.orderableDBInstanceOptions
        } else {
            self.marker = nil
            self.orderableDBInstanceOptions = nil
        }
    }
}

public struct DescribeOrderableDBInstanceOptionsOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous OrderableDBInstanceOptions request.
    ///       If this parameter is specified, the response includes only records beyond the marker, up to
    ///       the value specified by <code>MaxRecords</code> .</p>
    public let marker: String?
    /// <p>An <a>OrderableDBInstanceOption</a> structure
    ///       containing information about orderable options for the DB instance.</p>
    public let orderableDBInstanceOptions: [OrderableDBInstanceOption]?

    public init (
        marker: String? = nil,
        orderableDBInstanceOptions: [OrderableDBInstanceOption]? = nil
    )
    {
        self.marker = marker
        self.orderableDBInstanceOptions = orderableDBInstanceOptions
    }
}

struct DescribeOrderableDBInstanceOptionsOutputResponseBody: Equatable {
    public let orderableDBInstanceOptions: [OrderableDBInstanceOption]?
    public let marker: String?
}

extension DescribeOrderableDBInstanceOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case orderableDBInstanceOptions = "OrderableDBInstanceOptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeOrderableDBInstanceOptionsResult"))
        if containerValues.contains(.orderableDBInstanceOptions) {
            struct KeyVal0{struct OrderableDBInstanceOption{}}
            let orderableDBInstanceOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OrderableDBInstanceOption>.CodingKeys.self, forKey: .orderableDBInstanceOptions)
            if let orderableDBInstanceOptionsWrappedContainer = orderableDBInstanceOptionsWrappedContainer {
                let orderableDBInstanceOptionsContainer = try orderableDBInstanceOptionsWrappedContainer.decodeIfPresent([OrderableDBInstanceOption].self, forKey: .member)
                var orderableDBInstanceOptionsBuffer:[OrderableDBInstanceOption]? = nil
                if let orderableDBInstanceOptionsContainer = orderableDBInstanceOptionsContainer {
                    orderableDBInstanceOptionsBuffer = [OrderableDBInstanceOption]()
                    for structureContainer0 in orderableDBInstanceOptionsContainer {
                        orderableDBInstanceOptionsBuffer?.append(structureContainer0)
                    }
                }
                orderableDBInstanceOptions = orderableDBInstanceOptionsBuffer
            } else {
                orderableDBInstanceOptions = []
            }
        } else {
            orderableDBInstanceOptions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribePendingMaintenanceActionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribePendingMaintenanceActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingMaintenanceActionsOutputError>
}

extension DescribePendingMaintenanceActionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePendingMaintenanceActionsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

extension DescribePendingMaintenanceActionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: Key("MaxRecords"))
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: Key("ResourceIdentifier"))
        }
        try container.encode("DescribePendingMaintenanceActions", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribePendingMaintenanceActionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePendingMaintenanceActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingMaintenanceActionsOutputError>
}

public struct DescribePendingMaintenanceActionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePendingMaintenanceActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingMaintenanceActionsOutputError>
}

public struct DescribePendingMaintenanceActionsInput: Equatable {
    /// <p>A filter that specifies one or more resources to return pending maintenance actions
    ///       for.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-id</code> - Accepts DB cluster identifiers and DB cluster Amazon
    ///           Resource Names (ARNs). The results list will only include pending maintenance actions for
    ///           the DB clusters identified by these ARNs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db-instance-id</code> - Accepts DB instance identifiers and DB instance ARNs.
    ///           The results list will only include pending maintenance actions for the DB instances
    ///           identified by these ARNs.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribePendingMaintenanceActions</code> request. If this parameter is specified, the
    ///       response includes only records beyond the marker, up to a number of records specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The ARN of a resource to return pending maintenance actions for.</p>
    public let resourceIdentifier: String?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        resourceIdentifier: String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.resourceIdentifier = resourceIdentifier
    }
}

extension DescribePendingMaintenanceActionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribePendingMaintenanceActionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePendingMaintenanceActionsOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePendingMaintenanceActionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePendingMaintenanceActionsOutputResponse(marker: \(String(describing: marker)), pendingMaintenanceActions: \(String(describing: pendingMaintenanceActions)))"}
}

extension DescribePendingMaintenanceActionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePendingMaintenanceActionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.pendingMaintenanceActions = output.pendingMaintenanceActions
        } else {
            self.marker = nil
            self.pendingMaintenanceActions = nil
        }
    }
}

public struct DescribePendingMaintenanceActionsOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribePendingMaintenanceActions</code> request. If this parameter is specified, the
    ///       response includes only records beyond the marker, up to a number of records specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>A list of the pending maintenance actions for the resource.</p>
    public let pendingMaintenanceActions: [ResourcePendingMaintenanceActions]?

    public init (
        marker: String? = nil,
        pendingMaintenanceActions: [ResourcePendingMaintenanceActions]? = nil
    )
    {
        self.marker = marker
        self.pendingMaintenanceActions = pendingMaintenanceActions
    }
}

struct DescribePendingMaintenanceActionsOutputResponseBody: Equatable {
    public let pendingMaintenanceActions: [ResourcePendingMaintenanceActions]?
    public let marker: String?
}

extension DescribePendingMaintenanceActionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case pendingMaintenanceActions = "PendingMaintenanceActions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribePendingMaintenanceActionsResult"))
        if containerValues.contains(.pendingMaintenanceActions) {
            struct KeyVal0{struct ResourcePendingMaintenanceActions{}}
            let pendingMaintenanceActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ResourcePendingMaintenanceActions>.CodingKeys.self, forKey: .pendingMaintenanceActions)
            if let pendingMaintenanceActionsWrappedContainer = pendingMaintenanceActionsWrappedContainer {
                let pendingMaintenanceActionsContainer = try pendingMaintenanceActionsWrappedContainer.decodeIfPresent([ResourcePendingMaintenanceActions].self, forKey: .member)
                var pendingMaintenanceActionsBuffer:[ResourcePendingMaintenanceActions]? = nil
                if let pendingMaintenanceActionsContainer = pendingMaintenanceActionsContainer {
                    pendingMaintenanceActionsBuffer = [ResourcePendingMaintenanceActions]()
                    for structureContainer0 in pendingMaintenanceActionsContainer {
                        pendingMaintenanceActionsBuffer?.append(structureContainer0)
                    }
                }
                pendingMaintenanceActions = pendingMaintenanceActionsBuffer
            } else {
                pendingMaintenanceActions = []
            }
        } else {
            pendingMaintenanceActions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeValidDBInstanceModificationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeValidDBInstanceModificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeValidDBInstanceModificationsOutputError>
}

extension DescribeValidDBInstanceModificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeValidDBInstanceModificationsInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)))"}
}

extension DescribeValidDBInstanceModificationsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        try container.encode("DescribeValidDBInstanceModifications", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct DescribeValidDBInstanceModificationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeValidDBInstanceModificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeValidDBInstanceModificationsOutputError>
}

public struct DescribeValidDBInstanceModificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeValidDBInstanceModificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeValidDBInstanceModificationsOutputError>
}

public struct DescribeValidDBInstanceModificationsInput: Equatable {
    /// <p>The customer identifier or the ARN of your DB instance.</p>
    public let dBInstanceIdentifier: String?

    public init (
        dBInstanceIdentifier: String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
    }
}

extension DescribeValidDBInstanceModificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeValidDBInstanceModificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeValidDBInstanceModificationsOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeValidDBInstanceModificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeValidDBInstanceModificationsOutputResponse(validDBInstanceModificationsMessage: \(String(describing: validDBInstanceModificationsMessage)))"}
}

extension DescribeValidDBInstanceModificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeValidDBInstanceModificationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.validDBInstanceModificationsMessage = output.validDBInstanceModificationsMessage
        } else {
            self.validDBInstanceModificationsMessage = nil
        }
    }
}

public struct DescribeValidDBInstanceModificationsOutputResponse: Equatable {
    /// <p>Information about valid modifications that you can make to your DB instance. Contains the
    ///       result of a successful call to the <a>DescribeValidDBInstanceModifications</a>
    ///       action. You can use this information when you call <a>ModifyDBInstance</a>.
    ///    </p>
    public let validDBInstanceModificationsMessage: ValidDBInstanceModificationsMessage?

    public init (
        validDBInstanceModificationsMessage: ValidDBInstanceModificationsMessage? = nil
    )
    {
        self.validDBInstanceModificationsMessage = validDBInstanceModificationsMessage
    }
}

struct DescribeValidDBInstanceModificationsOutputResponseBody: Equatable {
    public let validDBInstanceModificationsMessage: ValidDBInstanceModificationsMessage?
}

extension DescribeValidDBInstanceModificationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case validDBInstanceModificationsMessage = "ValidDBInstanceModificationsMessage"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeValidDBInstanceModificationsResult"))
        let validDBInstanceModificationsMessageDecoded = try containerValues.decodeIfPresent(ValidDBInstanceModificationsMessage.self, forKey: .validDBInstanceModificationsMessage)
        validDBInstanceModificationsMessage = validDBInstanceModificationsMessageDecoded
    }
}

extension DomainMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
        case fQDN = "FQDN"
        case iAMRoleName = "IAMRoleName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let fQDN = fQDN {
            try container.encode(fQDN, forKey: Key("FQDN"))
        }
        if let iAMRoleName = iAMRoleName {
            try container.encode(iAMRoleName, forKey: Key("IAMRoleName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let fQDNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fQDN)
        fQDN = fQDNDecoded
        let iAMRoleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iAMRoleName)
        iAMRoleName = iAMRoleNameDecoded
    }
}

extension DomainMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainMembership(domain: \(String(describing: domain)), fQDN: \(String(describing: fQDN)), iAMRoleName: \(String(describing: iAMRoleName)), status: \(String(describing: status)))"}
}

/// <p>An Active Directory Domain membership record associated with a DB instance.</p>
public struct DomainMembership: Equatable {
    /// <p>The identifier of the Active Directory Domain.</p>
    public let domain: String?
    /// <p>The fully qualified domain name of the Active Directory Domain.</p>
    public let fQDN: String?
    /// <p>The name of the IAM role to be used when making API calls to the Directory Service.</p>
    public let iAMRoleName: String?
    /// <p>The status of the DB instance's Active Directory Domain membership, such as joined,
    ///       pending-join, failed etc).</p>
    public let status: String?

    public init (
        domain: String? = nil,
        fQDN: String? = nil,
        iAMRoleName: String? = nil,
        status: String? = nil
    )
    {
        self.domain = domain
        self.fQDN = fQDN
        self.iAMRoleName = iAMRoleName
        self.status = status
    }
}

extension DomainNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainNotFoundFault(message: \(String(describing: message)))"}
}

extension DomainNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DomainNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>Domain</i> does not refer to an existing Active Directory Domain.</p>
public struct DomainNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DomainNotFoundFaultBody: Equatable {
    public let message: String?
}

extension DomainNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DoubleRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case from = "From"
        case to = "To"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if from != 0.0 {
            try container.encode(String(from), forKey: Key("From"))
        }
        if to != 0.0 {
            try container.encode(String(to), forKey: Key("To"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decode(Double.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decode(Double.self, forKey: .to)
        to = toDecoded
    }
}

extension DoubleRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DoubleRange(from: \(String(describing: from)), to: \(String(describing: to)))"}
}

/// <p>A range of double values.</p>
public struct DoubleRange: Equatable {
    /// <p>The minimum value in the range.</p>
    public let from: Double
    /// <p>The maximum value in the range.</p>
    public let to: Double

    public init (
        from: Double = 0.0,
        to: Double = 0.0
    )
    {
        self.from = from
        self.to = to
    }
}

extension Endpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case hostedZoneId = "HostedZoneId"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let address = address {
            try container.encode(address, forKey: Key("Address"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: Key("HostedZoneId"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension Endpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Endpoint(address: \(String(describing: address)), hostedZoneId: \(String(describing: hostedZoneId)), port: \(String(describing: port)))"}
}

/// <p>Specifies a connection endpoint.</p>
///
///          <p>For the data structure that represents Amazon Neptune DB cluster endpoints,
///       see <code>DBClusterEndpoint</code>.</p>
public struct Endpoint: Equatable {
    /// <p>Specifies the DNS address of the DB instance.</p>
    public let address: String?
    /// <p>Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.</p>
    public let hostedZoneId: String?
    /// <p>Specifies the port that the database engine is listening on.</p>
    public let port: Int

    public init (
        address: String? = nil,
        hostedZoneId: String? = nil,
        port: Int = 0
    )
    {
        self.address = address
        self.hostedZoneId = hostedZoneId
        self.port = port
    }
}

extension EngineDefaults: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: Key("DBParameterGroupFamily"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
    }
}

extension EngineDefaults: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EngineDefaults(dBParameterGroupFamily: \(String(describing: dBParameterGroupFamily)), marker: \(String(describing: marker)), parameters: \(String(describing: parameters)))"}
}

/// <p> Contains the result of a successful invocation of the <a>DescribeEngineDefaultParameters</a> action.</p>
public struct EngineDefaults: Equatable {
    /// <p>Specifies the name of the DB parameter group family that the engine default parameters
    ///       apply to.</p>
    public let dBParameterGroupFamily: String?
    /// <p> An optional pagination token provided by a previous EngineDefaults request. If this
    ///       parameter is specified, the response includes only records beyond the marker, up to the value
    ///       specified by <code>MaxRecords</code> .</p>
    public let marker: String?
    /// <p>Contains a list of engine default parameters.</p>
    public let parameters: [Parameter]?

    public init (
        dBParameterGroupFamily: String? = nil,
        marker: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.marker = marker
        self.parameters = parameters
    }
}

extension Event: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case date = "Date"
        case eventCategories = "EventCategories"
        case message = "Message"
        case sourceArn = "SourceArn"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let date = date {
            try container.encode(TimestampWrapper(date, format: .dateTime), forKey: Key("date"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: Key("SourceArn"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var eventCategoriesBuffer:[String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        let dateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .date)
        var dateBuffer:Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
    }
}

extension Event: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Event(date: \(String(describing: date)), eventCategories: \(String(describing: eventCategories)), message: \(String(describing: message)), sourceArn: \(String(describing: sourceArn)), sourceIdentifier: \(String(describing: sourceIdentifier)), sourceType: \(String(describing: sourceType)))"}
}

/// <p> This data type is used as a response element in the <a>DescribeEvents</a>
///       action.</p>
public struct Event: Equatable {
    /// <p>Specifies the date and time of the event.</p>
    public let date: Date?
    /// <p>Specifies the category for the event.</p>
    public let eventCategories: [String]?
    /// <p>Provides the text of this event.</p>
    public let message: String?
    /// <p>The Amazon Resource Name (ARN) for the event.</p>
    public let sourceArn: String?
    /// <p>Provides the identifier for the source of the event.</p>
    public let sourceIdentifier: String?
    /// <p>Specifies the source type for this event.</p>
    public let sourceType: SourceType?

    public init (
        date: Date? = nil,
        eventCategories: [String]? = nil,
        message: String? = nil,
        sourceArn: String? = nil,
        sourceIdentifier: String? = nil,
        sourceType: SourceType? = nil
    )
    {
        self.date = date
        self.eventCategories = eventCategories
        self.message = message
        self.sourceArn = sourceArn
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
    }
}

extension EventCategoriesMap: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventCategories = "EventCategories"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var eventCategoriesBuffer:[String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
    }
}

extension EventCategoriesMap: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventCategoriesMap(eventCategories: \(String(describing: eventCategories)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>Contains the results of a successful invocation of the <a>DescribeEventCategories</a> action.</p>
public struct EventCategoriesMap: Equatable {
    /// <p>The event categories for the specified source type</p>
    public let eventCategories: [String]?
    /// <p>The source type that the returned categories belong to</p>
    public let sourceType: String?

    public init (
        eventCategories: [String]? = nil,
        sourceType: String? = nil
    )
    {
        self.eventCategories = eventCategories
        self.sourceType = sourceType
    }
}

extension EventSubscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case eventSubscriptionArn = "EventSubscriptionArn"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let custSubscriptionId = custSubscriptionId {
            try container.encode(custSubscriptionId, forKey: Key("CustSubscriptionId"))
        }
        if let customerAwsId = customerAwsId {
            try container.encode(customerAwsId, forKey: Key("CustomerAwsId"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategoriesList"))
            for (index0, string0) in eventCategoriesList.enumerated() {
                try eventCategoriesListContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let eventSubscriptionArn = eventSubscriptionArn {
            try container.encode(eventSubscriptionArn, forKey: Key("EventSubscriptionArn"))
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: Key("SnsTopicArn"))
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SourceIdsList"))
            for (index0, string0) in sourceIdsList.enumerated() {
                try sourceIdsListContainer.encode(string0, forKey: Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let subscriptionCreationTime = subscriptionCreationTime {
            try container.encode(subscriptionCreationTime, forKey: Key("SubscriptionCreationTime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionCreationTime)
        subscriptionCreationTime = subscriptionCreationTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.sourceIdsList) {
            struct KeyVal0{struct SourceId{}}
            let sourceIdsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SourceId>.CodingKeys.self, forKey: .sourceIdsList)
            if let sourceIdsListWrappedContainer = sourceIdsListWrappedContainer {
                let sourceIdsListContainer = try sourceIdsListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var sourceIdsListBuffer:[String]? = nil
                if let sourceIdsListContainer = sourceIdsListContainer {
                    sourceIdsListBuffer = [String]()
                    for stringContainer0 in sourceIdsListContainer {
                        sourceIdsListBuffer?.append(stringContainer0)
                    }
                }
                sourceIdsList = sourceIdsListBuffer
            } else {
                sourceIdsList = []
            }
        } else {
            sourceIdsList = nil
        }
        if containerValues.contains(.eventCategoriesList) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategoriesList)
            if let eventCategoriesListWrappedContainer = eventCategoriesListWrappedContainer {
                let eventCategoriesListContainer = try eventCategoriesListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var eventCategoriesListBuffer:[String]? = nil
                if let eventCategoriesListContainer = eventCategoriesListContainer {
                    eventCategoriesListBuffer = [String]()
                    for stringContainer0 in eventCategoriesListContainer {
                        eventCategoriesListBuffer?.append(stringContainer0)
                    }
                }
                eventCategoriesList = eventCategoriesListBuffer
            } else {
                eventCategoriesList = []
            }
        } else {
            eventCategoriesList = nil
        }
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let eventSubscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSubscriptionArn)
        eventSubscriptionArn = eventSubscriptionArnDecoded
    }
}

extension EventSubscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSubscription(custSubscriptionId: \(String(describing: custSubscriptionId)), customerAwsId: \(String(describing: customerAwsId)), enabled: \(String(describing: enabled)), eventCategoriesList: \(String(describing: eventCategoriesList)), eventSubscriptionArn: \(String(describing: eventSubscriptionArn)), snsTopicArn: \(String(describing: snsTopicArn)), sourceIdsList: \(String(describing: sourceIdsList)), sourceType: \(String(describing: sourceType)), status: \(String(describing: status)), subscriptionCreationTime: \(String(describing: subscriptionCreationTime)))"}
}

/// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
public struct EventSubscription: Equatable {
    /// <p>The event notification subscription Id.</p>
    public let custSubscriptionId: String?
    /// <p>The Amazon customer account associated with the event notification subscription.</p>
    public let customerAwsId: String?
    /// <p>A Boolean value indicating if the subscription is enabled. True indicates the subscription
    ///       is enabled.</p>
    public let enabled: Bool
    /// <p>A list of event categories for the event notification subscription.</p>
    public let eventCategoriesList: [String]?
    /// <p>The Amazon Resource Name (ARN) for the event subscription.</p>
    public let eventSubscriptionArn: String?
    /// <p>The topic ARN of the event notification subscription.</p>
    public let snsTopicArn: String?
    /// <p>A list of source IDs for the event notification subscription.</p>
    public let sourceIdsList: [String]?
    /// <p>The source type for the event notification subscription.</p>
    public let sourceType: String?
    /// <p>The status of the event notification subscription.</p>
    ///          <p>Constraints:</p>
    ///          <p>Can be one of the following: creating | modifying | deleting | active | no-permission |
    ///       topic-not-exist</p>
    ///          <p>The status "no-permission" indicates that Neptune no longer has permission to post to the
    ///       SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the
    ///       subscription was created.</p>
    public let status: String?
    /// <p>The time the event notification subscription was created.</p>
    public let subscriptionCreationTime: String?

    public init (
        custSubscriptionId: String? = nil,
        customerAwsId: String? = nil,
        enabled: Bool = false,
        eventCategoriesList: [String]? = nil,
        eventSubscriptionArn: String? = nil,
        snsTopicArn: String? = nil,
        sourceIdsList: [String]? = nil,
        sourceType: String? = nil,
        status: String? = nil,
        subscriptionCreationTime: String? = nil
    )
    {
        self.custSubscriptionId = custSubscriptionId
        self.customerAwsId = customerAwsId
        self.enabled = enabled
        self.eventCategoriesList = eventCategoriesList
        self.eventSubscriptionArn = eventSubscriptionArn
        self.snsTopicArn = snsTopicArn
        self.sourceIdsList = sourceIdsList
        self.sourceType = sourceType
        self.status = status
        self.subscriptionCreationTime = subscriptionCreationTime
    }
}

extension EventSubscriptionQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSubscriptionQuotaExceededFault(message: \(String(describing: message)))"}
}

extension EventSubscriptionQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EventSubscriptionQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the number of events you can subscribe to.</p>
public struct EventSubscriptionQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EventSubscriptionQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension EventSubscriptionQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct FailoverDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "FailoverDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FailoverDBClusterOutputError>
}

extension FailoverDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailoverDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), targetDBInstanceIdentifier: \(String(describing: targetDBInstanceIdentifier)))"}
}

extension FailoverDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let targetDBInstanceIdentifier = targetDBInstanceIdentifier {
            try container.encode(targetDBInstanceIdentifier, forKey: Key("TargetDBInstanceIdentifier"))
        }
        try container.encode("FailoverDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct FailoverDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "FailoverDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FailoverDBClusterOutputError>
}

public struct FailoverDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "FailoverDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FailoverDBClusterOutputError>
}

public struct FailoverDBClusterInput: Equatable {
    /// <p>A DB cluster identifier to force a failover for. This parameter is not
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>The name of the instance to promote to the primary instance.</p>
    ///          <p>You must specify the instance identifier for an Read Replica in the DB cluster. For
    ///       example, <code>mydbcluster-replica1</code>.</p>
    public let targetDBInstanceIdentifier: String?

    public init (
        dBClusterIdentifier: String? = nil,
        targetDBInstanceIdentifier: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.targetDBInstanceIdentifier = targetDBInstanceIdentifier
    }
}

extension FailoverDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension FailoverDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FailoverDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension FailoverDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailoverDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension FailoverDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FailoverDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct FailoverDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct FailoverDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension FailoverDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("FailoverDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, string0) in values.enumerated() {
                try valuesContainer.encode(string0, forKey: Key("Value.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct Value{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Value>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>This type is not currently supported.</p>
public struct Filter: Equatable {
    /// <p>This parameter is not currently supported.</p>
    public let name: String?
    /// <p>This parameter is not currently supported.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension InstanceQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceQuotaExceededFault(message: \(String(describing: message)))"}
}

extension InstanceQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InstanceQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed number of DB instances.</p>
public struct InstanceQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InstanceQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension InstanceQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientDBClusterCapacityFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientDBClusterCapacityFault(message: \(String(describing: message)))"}
}

extension InsufficientDBClusterCapacityFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InsufficientDBClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB cluster does not have enough capacity for the current operation.</p>
public struct InsufficientDBClusterCapacityFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDBClusterCapacityFaultBody: Equatable {
    public let message: String?
}

extension InsufficientDBClusterCapacityFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientDBInstanceCapacityFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientDBInstanceCapacityFault(message: \(String(describing: message)))"}
}

extension InsufficientDBInstanceCapacityFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InsufficientDBInstanceCapacityFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Specified DB instance class is not available in the specified Availability Zone.</p>
public struct InsufficientDBInstanceCapacityFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDBInstanceCapacityFaultBody: Equatable {
    public let message: String?
}

extension InsufficientDBInstanceCapacityFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientStorageClusterCapacityFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientStorageClusterCapacityFault(message: \(String(describing: message)))"}
}

extension InsufficientStorageClusterCapacityFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InsufficientStorageClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is insufficient storage available for the current action. You may
///        be able to resolve this error by updating your subnet group to use different
///        Availability Zones that have more storage available.</p>
public struct InsufficientStorageClusterCapacityFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientStorageClusterCapacityFaultBody: Equatable {
    public let message: String?
}

extension InsufficientStorageClusterCapacityFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterEndpointStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBClusterEndpointStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBClusterEndpointStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBClusterEndpointStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation cannot be performed on the endpoint while the endpoint is in this state.</p>
public struct InvalidDBClusterEndpointStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterEndpointStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBClusterEndpointStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterSnapshotStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBClusterSnapshotStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBClusterSnapshotStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBClusterSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The supplied value is not a valid DB cluster snapshot state.</p>
public struct InvalidDBClusterSnapshotStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterSnapshotStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBClusterSnapshotStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBClusterStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBClusterStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBClusterStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB cluster is not in a valid state.</p>
public struct InvalidDBClusterStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBClusterStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBInstanceStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBInstanceStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBInstanceStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBInstanceStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified DB instance is not in the <i>available</i> state.</p>
public struct InvalidDBInstanceStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBInstanceStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBInstanceStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBParameterGroupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBParameterGroupStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBParameterGroupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBParameterGroupStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB parameter group is in use or is in an invalid state. If you are attempting to
///       delete the parameter group, you cannot delete it when the parameter group is in this state.</p>
public struct InvalidDBParameterGroupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBParameterGroupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBParameterGroupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSecurityGroupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBSecurityGroupStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBSecurityGroupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBSecurityGroupStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the DB security group does not allow deletion.</p>
public struct InvalidDBSecurityGroupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSecurityGroupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBSecurityGroupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSnapshotStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBSnapshotStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBSnapshotStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the DB snapshot does not allow deletion.</p>
public struct InvalidDBSnapshotStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSnapshotStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBSnapshotStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetGroupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBSubnetGroupStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBSubnetGroupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBSubnetGroupStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB subnet group cannot be deleted because it is in use.</p>
public struct InvalidDBSubnetGroupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetGroupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBSubnetGroupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDBSubnetStateFault(message: \(String(describing: message)))"}
}

extension InvalidDBSubnetStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDBSubnetStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB subnet is not in the <i>available</i> state.</p>
public struct InvalidDBSubnetStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidDBSubnetStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventSubscriptionStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEventSubscriptionStateFault(message: \(String(describing: message)))"}
}

extension InvalidEventSubscriptionStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidEventSubscriptionStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The event subscription is in an invalid state.</p>
public struct InvalidEventSubscriptionStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventSubscriptionStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidEventSubscriptionStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRestoreFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRestoreFault(message: \(String(describing: message)))"}
}

extension InvalidRestoreFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidRestoreFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot restore from vpc backup to non-vpc DB instance.</p>
public struct InvalidRestoreFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRestoreFaultBody: Equatable {
    public let message: String?
}

extension InvalidRestoreFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSubnet(message: \(String(describing: message)))"}
}

extension InvalidSubnet: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSubnetBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested subnet is invalid, or multiple subnets were requested that are
///       not all in a common VPC.</p>
public struct InvalidSubnet: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Equatable {
    public let message: String?
}

extension InvalidSubnetBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidVPCNetworkStateFault(message: \(String(describing: message)))"}
}

extension InvalidVPCNetworkStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidVPCNetworkStateFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>DB subnet group does not cover all Availability Zones after it is created
///       because users' change.</p>
public struct InvalidVPCNetworkStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidVPCNetworkStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSKeyNotAccessibleFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSKeyNotAccessibleFault(message: \(String(describing: message)))"}
}

extension KMSKeyNotAccessibleFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<KMSKeyNotAccessibleFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Error accessing KMS key.</p>
public struct KMSKeyNotAccessibleFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSKeyNotAccessibleFaultBody: Equatable {
    public let message: String?
}

extension KMSKeyNotAccessibleFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(filters: \(String(describing: filters)), resourceName: \(String(describing: resourceName)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
        try container.encode("ListTagsForResource", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>This parameter is not currently supported.</p>
    public let filters: [Filter]?
    /// <p>The Amazon Neptune resource with tags to be listed. This value is an Amazon Resource Name
    ///       (ARN). For information about creating an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    public let resourceName: String?

    public init (
        filters: [Filter]? = nil,
        resourceName: String? = nil
    )
    {
        self.filters = filters
        self.resourceName = resourceName
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tagList: \(String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>List of tags returned by the ListTagsForResource operation.</p>
    public let tagList: [Tag]?

    public init (
        tagList: [Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tagList: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListTagsForResourceResult"))
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagListBuffer:[Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

public struct ModifyDBClusterEndpointInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterEndpointOutputError>
}

extension ModifyDBClusterEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterEndpointInput(dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)))"}
}

extension ModifyDBClusterEndpointInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: Key("DBClusterEndpointIdentifier"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterEndpoint", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBClusterEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterEndpointOutputError>
}

public struct ModifyDBClusterEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterEndpointOutputError>
}

public struct ModifyDBClusterEndpointInput: Equatable {
    /// <p>The identifier of the endpoint to modify. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>ANY</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///       All other eligible instances are reachable through the custom endpoint.
    ///       Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?

    public init (
        dBClusterEndpointIdentifier: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
    }
}

extension ModifyDBClusterEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointNotFoundFault" : self = .dBClusterEndpointNotFoundFault(try DBClusterEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterEndpointStateFault" : self = .invalidDBClusterEndpointStateFault(try InvalidDBClusterEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterEndpointOutputError: Equatable {
    case dBClusterEndpointNotFoundFault(DBClusterEndpointNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterEndpointStateFault(InvalidDBClusterEndpointStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterEndpointOutputResponse(customEndpointType: \(String(describing: customEndpointType)), dBClusterEndpointArn: \(String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), endpoint: \(String(describing: endpoint)), endpointType: \(String(describing: endpointType)), excludedMembers: \(String(describing: excludedMembers)), staticMembers: \(String(describing: staticMembers)), status: \(String(describing: status)))"}
}

extension ModifyDBClusterEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// <p>This data type represents the information you need to connect to an Amazon Aurora DB cluster.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBClusterEndpoint</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon RDS DB instance endpoints,
///       see <code>Endpoint</code>.</p>
public struct ModifyDBClusterEndpointOutputResponse: Equatable {
    /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
    ///       <code>WRITER</code>, <code>ANY</code>.</p>
    public let customEndpointType: String?
    /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
    public let dBClusterEndpointArn: String?
    /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: String?
    /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
    public let dBClusterEndpointResourceIdentifier: String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///       stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?
    /// <p>The DNS address of the endpoint.</p>
    public let endpoint: String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
    public let endpointType: String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///       All other eligible instances are reachable through the custom endpoint.
    ///       Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [String]?
    /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that cannot be used for a certain kind of cluster,
    ///       such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
    public let status: String?

    public init (
        customEndpointType: String? = nil,
        dBClusterEndpointArn: String? = nil,
        dBClusterEndpointIdentifier: String? = nil,
        dBClusterEndpointResourceIdentifier: String? = nil,
        dBClusterIdentifier: String? = nil,
        endpoint: String? = nil,
        endpointType: String? = nil,
        excludedMembers: [String]? = nil,
        staticMembers: [String]? = nil,
        status: String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct ModifyDBClusterEndpointOutputResponseBody: Equatable {
    public let dBClusterEndpointIdentifier: String?
    public let dBClusterIdentifier: String?
    public let dBClusterEndpointResourceIdentifier: String?
    public let endpoint: String?
    public let status: String?
    public let endpointType: String?
    public let customEndpointType: String?
    public let staticMembers: [String]?
    public let excludedMembers: [String]?
    public let dBClusterEndpointArn: String?
}

extension ModifyDBClusterEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var staticMembersBuffer:[String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var excludedMembersBuffer:[String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct ModifyDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterOutputError>
}

extension ModifyDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterInput(applyImmediately: \(String(describing: applyImmediately)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), cloudwatchLogsExportConfiguration: \(String(describing: cloudwatchLogsExportConfiguration)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), deletionProtection: \(String(describing: deletionProtection)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), engineVersion: \(String(describing: engineVersion)), masterUserPassword: \(String(describing: masterUserPassword)), newDBClusterIdentifier: \(String(describing: newDBClusterIdentifier)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: Key("ApplyImmediately"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration {
            try container.encode(cloudwatchLogsExportConfiguration, forKey: Key("CloudwatchLogsExportConfiguration"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let newDBClusterIdentifier = newDBClusterIdentifier {
            try container.encode(newDBClusterIdentifier, forKey: Key("NewDBClusterIdentifier"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterOutputError>
}

public struct ModifyDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterOutputError>
}

public struct ModifyDBClusterInput: Equatable {
    /// <p>A value that specifies whether the modifications in this request and any pending
    ///       modifications are asynchronously applied as soon as possible, regardless of the
    ///       <code>PreferredMaintenanceWindow</code> setting for the DB cluster. If this parameter is set
    ///       to <code>false</code>, changes to the DB cluster are applied during the next maintenance
    ///       window.</p>
    ///          <p>The <code>ApplyImmediately</code> parameter only affects <code>NewDBClusterIdentifier</code>
    ///       values. If you set the <code>ApplyImmediately</code> parameter value to false, then changes to
    ///       <code>NewDBClusterIdentifier</code> values are applied during the next maintenance window.
    ///       All other changes are applied immediately, regardless of the value of the
    ///       <code>ApplyImmediately</code> parameter.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let applyImmediately: Bool
    /// <p>The number of days for which automated backups are retained. You must specify a minimum
    ///       value of 1.</p>
    ///          <p>Default: 1</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be a value from 1 to 35</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Int?
    /// <p>The configuration setting for the log types to be enabled for export to CloudWatch Logs
    ///       for a specific DB cluster.</p>
    public let cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration?
    /// <p>
    ///             <i>If set to <code>true</code>, tags are copied to any snapshot of
    ///       the DB cluster that is created.</i>
    ///          </p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The DB cluster identifier for the cluster being modified. This parameter is not
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>The name of the DB cluster parameter group to use for the DB cluster.</p>
    public let dBClusterParameterGroupName: String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is disabled.</p>
    public let deletionProtection: Bool?
    /// <p>True to enable mapping of Amazon Identity and Access Management (IAM) accounts to database
    ///       accounts, and otherwise false.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>The version number of the database engine to which you want to upgrade. Changing this
    ///       parameter results in an outage. The change is applied during the next maintenance window
    ///       unless the <code>ApplyImmediately</code> parameter is set to true.</p>
    ///          <p>For a list of valid engine versions, see <a href="https://docs.aws.amazon.com/neptune/latest/userguide/engine-releases.html">Engine Releases for Amazon
    ///       Neptune</a>, or call <a href="https://docs.aws.amazon.com/neptune/latest/userguide/api-other-apis.html#DescribeDBEngineVersions">DescribeDBEngineVersions</a>.</p>
    public let engineVersion: String?
    /// <p>Not supported by Neptune.</p>
    public let masterUserPassword: String?
    /// <p>The new DB cluster identifier for the DB cluster when renaming a DB cluster. This value is
    ///       stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>The first character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster2</code>
    ///          </p>
    public let newDBClusterIdentifier: String?
    /// <p>
    ///             <i>Not supported by Neptune.</i>
    ///          </p>
    public let optionGroupName: String?
    /// <p>The port number on which the DB cluster accepts connections.</p>
    ///          <p>Constraints: Value must be <code>1150-65535</code>
    ///          </p>
    ///          <p>Default: The same port as the original DB cluster.</p>
    public let port: Int?
    /// <p>The daily time range during which automated backups are created if automated backups are
    ///       enabled, using the <code>BackupRetentionPeriod</code> parameter.</p>
    ///          <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    ///       Amazon Region.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be in the format <code>hh24:mi-hh24:mi</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Coordinated Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes.</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: String?
    /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated
    ///       Time (UTC).</p>
    ///          <p>Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///          </p>
    ///          <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    ///       Amazon Region, occurring on a random day of the
    ///       week.</p>
    ///          <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    ///          <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>A list of VPC security groups that the DB cluster will belong to.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        applyImmediately: Bool = false,
        backupRetentionPeriod: Int? = nil,
        cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterParameterGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        engineVersion: String? = nil,
        masterUserPassword: String? = nil,
        newDBClusterIdentifier: String? = nil,
        optionGroupName: String? = nil,
        port: Int? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.deletionProtection = deletionProtection
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engineVersion = engineVersion
        self.masterUserPassword = masterUserPassword
        self.newDBClusterIdentifier = newDBClusterIdentifier
        self.optionGroupName = optionGroupName
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupStateFault" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterOutputError: Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension ModifyDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct ModifyDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct ModifyDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension ModifyDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct ModifyDBClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterParameterGroupOutputError>
}

extension ModifyDBClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterParameterGroupInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), parameters: \(String(describing: parameters)))"}
}

extension ModifyDBClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterParameterGroupOutputError>
}

public struct ModifyDBClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterParameterGroupOutputError>
}

public struct ModifyDBClusterParameterGroupInput: Equatable {
    /// <p>The name of the DB cluster parameter group to modify.</p>
    public let dBClusterParameterGroupName: String?
    /// <p>A list of parameters in the DB cluster parameter group to modify.</p>
    public let parameters: [Parameter]?

    public init (
        dBClusterParameterGroupName: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.parameters = parameters
    }
}

extension ModifyDBClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterParameterGroupOutputResponse(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)))"}
}

extension ModifyDBClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterParameterGroupName = output.dBClusterParameterGroupName
        } else {
            self.dBClusterParameterGroupName = nil
        }
    }
}

public struct ModifyDBClusterParameterGroupOutputResponse: Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBClusterParameterGroupName: String?

    public init (
        dBClusterParameterGroupName: String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

struct ModifyDBClusterParameterGroupOutputResponseBody: Equatable {
    public let dBClusterParameterGroupName: String?
}

extension ModifyDBClusterParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBClusterParameterGroupResult"))
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
    }
}

public struct ModifyDBClusterSnapshotAttributeInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBClusterSnapshotAttributeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

extension ModifyDBClusterSnapshotAttributeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterSnapshotAttributeInput(attributeName: \(String(describing: attributeName)), dBClusterSnapshotIdentifier: \(String(describing: dBClusterSnapshotIdentifier)), valuesToAdd: \(String(describing: valuesToAdd)), valuesToRemove: \(String(describing: valuesToRemove)))"}
}

extension ModifyDBClusterSnapshotAttributeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: Key("DBClusterSnapshotIdentifier"))
        }
        if let valuesToAdd = valuesToAdd {
            var valuesToAddContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValuesToAdd"))
            for (index0, string0) in valuesToAdd.enumerated() {
                try valuesToAddContainer.encode(string0, forKey: Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        if let valuesToRemove = valuesToRemove {
            var valuesToRemoveContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ValuesToRemove"))
            for (index0, string0) in valuesToRemove.enumerated() {
                try valuesToRemoveContainer.encode(string0, forKey: Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterSnapshotAttribute", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBClusterSnapshotAttributeInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBClusterSnapshotAttributeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

public struct ModifyDBClusterSnapshotAttributeInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBClusterSnapshotAttributeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

public struct ModifyDBClusterSnapshotAttributeInput: Equatable {
    /// <p>The name of the DB cluster snapshot attribute to modify.</p>
    ///          <p>To manage authorization for other Amazon accounts to copy or restore a manual DB cluster
    ///       snapshot, set this value to <code>restore</code>.</p>
    public let attributeName: String?
    /// <p>The identifier for the DB cluster snapshot to modify the attributes for.</p>
    public let dBClusterSnapshotIdentifier: String?
    /// <p>A list of DB cluster snapshot attributes to add to the attribute specified by
    ///       <code>AttributeName</code>.</p>
    ///          <p>To authorize other Amazon accounts to copy or restore a manual DB cluster snapshot, set this
    ///       list to include one or more Amazon account IDs, or <code>all</code> to make the manual DB cluster
    ///       snapshot restorable by any Amazon account. Do not add the <code>all</code> value for any manual
    ///       DB cluster snapshots that contain private information that you don't want available to all AWS
    ///       accounts.</p>
    public let valuesToAdd: [String]?
    /// <p>A list of DB cluster snapshot attributes to remove from the attribute specified by
    ///       <code>AttributeName</code>.</p>
    ///          <p>To remove authorization for other Amazon accounts to copy or restore a manual DB cluster
    ///       snapshot, set this list to include one or more Amazon account identifiers, or <code>all</code> to
    ///       remove authorization for any Amazon account to copy or restore the DB cluster snapshot. If you
    ///       specify <code>all</code>, an Amazon account whose account ID is explicitly added to the
    ///       <code>restore</code> attribute can still copy or restore a manual DB cluster snapshot.</p>
    public let valuesToRemove: [String]?

    public init (
        attributeName: String? = nil,
        dBClusterSnapshotIdentifier: String? = nil,
        valuesToAdd: [String]? = nil,
        valuesToRemove: [String]? = nil
    )
    {
        self.attributeName = attributeName
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.valuesToAdd = valuesToAdd
        self.valuesToRemove = valuesToRemove
    }
}

extension ModifyDBClusterSnapshotAttributeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterSnapshotAttributeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SharedSnapshotQuotaExceededFault" : self = .sharedSnapshotQuotaExceededFault(try SharedSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterSnapshotAttributeOutputError: Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case sharedSnapshotQuotaExceededFault(SharedSnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterSnapshotAttributeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBClusterSnapshotAttributeOutputResponse(dBClusterSnapshotAttributesResult: \(String(describing: dBClusterSnapshotAttributesResult)))"}
}

extension ModifyDBClusterSnapshotAttributeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBClusterSnapshotAttributeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterSnapshotAttributesResult = output.dBClusterSnapshotAttributesResult
        } else {
            self.dBClusterSnapshotAttributesResult = nil
        }
    }
}

public struct ModifyDBClusterSnapshotAttributeOutputResponse: Equatable {
    /// <p>Contains the results of a successful call to the <a>DescribeDBClusterSnapshotAttributes</a> API action.</p>
    ///          <p>Manual DB cluster snapshot attributes are used to authorize other Amazon accounts to copy or
    ///       restore a manual DB cluster snapshot. For more information, see the <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
    public let dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult?

    public init (
        dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult? = nil
    )
    {
        self.dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResult
    }
}

struct ModifyDBClusterSnapshotAttributeOutputResponseBody: Equatable {
    public let dBClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult?
}

extension ModifyDBClusterSnapshotAttributeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBClusterSnapshotAttributeResult"))
        let dBClusterSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(DBClusterSnapshotAttributesResult.self, forKey: .dBClusterSnapshotAttributesResult)
        dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResultDecoded
    }
}

public struct ModifyDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBInstanceOutputError>
}

extension ModifyDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBInstanceInput(allocatedStorage: \(String(describing: allocatedStorage)), allowMajorVersionUpgrade: \(String(describing: allowMajorVersionUpgrade)), applyImmediately: \(String(describing: applyImmediately)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(String(describing: cACertificateIdentifier)), cloudwatchLogsExportConfiguration: \(String(describing: cloudwatchLogsExportConfiguration)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBParameterGroupName: \(String(describing: dBParameterGroupName)), dBPortNumber: \(String(describing: dBPortNumber)), dBSecurityGroups: \(String(describing: dBSecurityGroups)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), deletionProtection: \(String(describing: deletionProtection)), domain: \(String(describing: domain)), domainIAMRoleName: \(String(describing: domainIAMRoleName)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(String(describing: enablePerformanceInsights)), engineVersion: \(String(describing: engineVersion)), iops: \(String(describing: iops)), licenseModel: \(String(describing: licenseModel)), masterUserPassword: \(String(describing: masterUserPassword)), monitoringInterval: \(String(describing: monitoringInterval)), monitoringRoleArn: \(String(describing: monitoringRoleArn)), multiAZ: \(String(describing: multiAZ)), newDBInstanceIdentifier: \(String(describing: newDBInstanceIdentifier)), optionGroupName: \(String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(String(describing: performanceInsightsKMSKeyId)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), promotionTier: \(String(describing: promotionTier)), publiclyAccessible: \(String(describing: publiclyAccessible)), storageType: \(String(describing: storageType)), tdeCredentialArn: \(String(describing: tdeCredentialArn)), tdeCredentialPassword: \(String(describing: tdeCredentialPassword)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if allowMajorVersionUpgrade != false {
            try container.encode(allowMajorVersionUpgrade, forKey: Key("AllowMajorVersionUpgrade"))
        }
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: Key("ApplyImmediately"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: Key("AutoMinorVersionUpgrade"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: Key("CACertificateIdentifier"))
        }
        if let cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration {
            try container.encode(cloudwatchLogsExportConfiguration, forKey: Key("CloudwatchLogsExportConfiguration"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let dBPortNumber = dBPortNumber {
            try container.encode(dBPortNumber, forKey: Key("DBPortNumber"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: Key("DomainIAMRoleName"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: Key("EnablePerformanceInsights"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let newDBInstanceIdentifier = newDBInstanceIdentifier {
            try container.encode(newDBInstanceIdentifier, forKey: Key("NewDBInstanceIdentifier"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: Key("PerformanceInsightsKMSKeyId"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: Key("PreferredMaintenanceWindow"))
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: Key("PromotionTier"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: Key("PubliclyAccessible"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: Key("TdeCredentialPassword"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBInstanceOutputError>
}

public struct ModifyDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBInstanceOutputError>
}

public struct ModifyDBInstanceInput: Equatable {
    /// <p>Not supported by Neptune.</p>
    public let allocatedStorage: Int?
    /// <p>Indicates that major version upgrades are allowed. Changing this parameter doesn't result
    ///       in an outage and the change is asynchronously applied as soon as possible.</p>
    public let allowMajorVersionUpgrade: Bool
    /// <p>Specifies whether the modifications in this request and any pending modifications are
    ///       asynchronously applied as soon as possible, regardless of the
    ///       <code>PreferredMaintenanceWindow</code> setting for the DB instance.</p>
    ///          <p> If this parameter is set to <code>false</code>, changes to the DB instance are applied
    ///       during the next maintenance window. Some parameter changes can cause an outage and are applied
    ///       on the next call to <a>RebootDBInstance</a>, or the next
    ///       failure reboot.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let applyImmediately: Bool
    /// <p> Indicates that minor version upgrades are applied automatically to the DB instance during
    ///       the maintenance window. Changing this parameter doesn't result in an outage except in the
    ///       following case and the change is asynchronously applied as soon as possible. An outage will
    ///       result if this parameter is set to <code>true</code> during the maintenance window, and a
    ///       newer minor version is available, and Neptune has enabled auto patching for that engine
    ///       version.</p>
    public let autoMinorVersionUpgrade: Bool?
    /// <p>Not applicable. The retention period for automated backups is managed by the DB cluster.
    ///       For more information, see <a>ModifyDBCluster</a>.</p>
    ///          <p>Default: Uses existing setting</p>
    public let backupRetentionPeriod: Int?
    /// <p>Indicates the certificate that needs to be associated with the instance.</p>
    public let cACertificateIdentifier: String?
    /// <p>The configuration setting for the log types to be enabled for export to CloudWatch Logs
    ///       for a specific DB instance or DB cluster.</p>
    public let cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration?
    /// <p>True to copy all tags from the DB instance to snapshots of the DB instance, and otherwise
    ///       false. The default is false.</p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The new compute and memory capacity of the DB instance, for example,
    ///       <code>db.m4.large</code>. Not all DB instance classes are available in all AWS
    ///       Regions.</p>
    ///          <p>If you modify the DB instance class, an outage occurs during the change. The change is
    ///       applied during the next maintenance window, unless <code>ApplyImmediately</code> is specified
    ///       as <code>true</code> for this request.</p>
    ///          <p>Default: Uses existing setting</p>
    public let dBInstanceClass: String?
    /// <p>The DB instance identifier. This value is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p>The name of the DB parameter group to apply to the DB instance. Changing this setting
    ///       doesn't result in an outage. The parameter group name itself is changed immediately, but the
    ///       actual parameter changes are not applied until you reboot the instance without failover. The
    ///       db instance will NOT be rebooted automatically and the parameter changes will NOT be applied
    ///       during the next maintenance window.</p>
    ///          <p>Default: Uses existing setting</p>
    ///          <p>Constraints: The DB parameter group must be in the same DB parameter group family as this
    ///       DB instance.</p>
    public let dBParameterGroupName: String?
    /// <p>The port number on which the database accepts connections.</p>
    ///          <p>The value of the <code>DBPortNumber</code> parameter must not match any of the port values
    ///       specified for options in the option group for the DB instance.</p>
    ///          <p>Your database will restart when you change the <code>DBPortNumber</code> value regardless
    ///       of the value of the <code>ApplyImmediately</code> parameter.</p>
    ///          <p> Default: <code>8182</code>
    ///          </p>
    public let dBPortNumber: Int?
    /// <p>A list of DB security groups to authorize on this DB instance. Changing this setting
    ///       doesn't result in an outage and the change is asynchronously applied as soon as
    ///       possible.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match existing DBSecurityGroups.</p>
    ///             </li>
    ///          </ul>
    public let dBSecurityGroups: [String]?
    /// <p>The new DB subnet group for the DB instance. You can use this parameter to move your DB
    ///       instance to a different VPC.</p>
    ///          <p>Changing the subnet group causes an outage during the change. The change is applied during
    ///       the next maintenance window, unless you specify <code>true</code> for the
    ///       <code>ApplyImmediately</code> parameter.</p>
    ///          <p>Constraints: If supplied, must match the name of an existing DBSubnetGroup.</p>
    ///          <p>Example: <code>mySubnetGroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>A value that indicates whether the DB instance has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is disabled.  See <a href="https://docs.aws.amazon.com/neptune/latest/userguide/manage-console-instances-delete.html">Deleting
    ///       a DB Instance</a>.</p>
    public let deletionProtection: Bool?
    /// <p>Not supported.</p>
    public let domain: String?
    /// <p>Not supported</p>
    public let domainIAMRoleName: String?
    /// <p>True to enable mapping of Amazon Identity and Access Management (IAM) accounts to database
    ///       accounts, and otherwise false.</p>
    ///          <p>You can enable IAM database authentication for the following database engines</p>
    ///          <p>Not applicable. Mapping Amazon IAM accounts to database accounts is managed by the DB
    ///       cluster. For more information, see <a>ModifyDBCluster</a>.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let enablePerformanceInsights: Bool?
    /// <p>The version number of the database engine to upgrade to. Currently, setting this
    ///       parameter has no effect. To upgrade your database engine to the most recent release,
    ///       use the <a>ApplyPendingMaintenanceAction</a> API.</p>
    public let engineVersion: String?
    /// <p>The new Provisioned IOPS (I/O operations per second) value for the instance.</p>
    ///          <p>Changing this setting doesn't result in an outage and the change is applied during the
    ///       next maintenance window unless the <code>ApplyImmediately</code> parameter is set to
    ///       <code>true</code> for this request.</p>
    ///          <p>Default: Uses existing setting</p>
    public let iops: Int?
    /// <p>Not supported by Neptune.</p>
    public let licenseModel: String?
    /// <p>Not supported by Neptune.</p>
    public let masterUserPassword: String?
    /// <p>The interval, in seconds, between points when Enhanced Monitoring metrics are collected
    ///       for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default
    ///       is 0.</p>
    ///          <p>If <code>MonitoringRoleArn</code> is specified, then you must also set
    ///       <code>MonitoringInterval</code> to a value other than 0.</p>
    ///          <p>Valid Values: <code>0, 1, 5, 10, 15, 30, 60</code>
    ///          </p>
    public let monitoringInterval: Int?
    /// <p>The ARN for the IAM role that permits Neptune to send enhanced monitoring metrics to
    ///       Amazon CloudWatch Logs. For example, <code>arn:aws:iam:123456789012:role/emaccess</code>.</p>
    ///          <p>If <code>MonitoringInterval</code> is set to a value other than 0, then you must supply a
    ///       <code>MonitoringRoleArn</code> value.</p>
    public let monitoringRoleArn: String?
    /// <p>Specifies if the DB instance is a Multi-AZ deployment. Changing this parameter doesn't
    ///       result in an outage and the change is applied during the next maintenance window unless the
    ///       <code>ApplyImmediately</code> parameter is set to <code>true</code> for this request.</p>
    public let multiAZ: Bool?
    /// <p> The new DB instance identifier for the DB instance when renaming a DB instance. When you
    ///       change the DB instance identifier, an instance reboot will occur immediately if you set
    ///       <code>Apply Immediately</code> to true, or will occur during the next maintenance window if
    ///       <code>Apply Immediately</code> to false. This value is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>The first character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>mydbinstance</code>
    ///          </p>
    public let newDBInstanceIdentifier: String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let optionGroupName: String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let performanceInsightsKMSKeyId: String?
    /// <p> The daily time range during which automated backups are created if automated backups are
    ///       enabled.</p>
    ///          <p>Not applicable. The daily time range for creating automated backups is managed by the DB
    ///       cluster. For more information, see <a>ModifyDBCluster</a>.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be in the format hh24:mi-hh24:mi</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Time Coordinated (UTC)</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: String?
    /// <p>The weekly time range (in UTC) during which system maintenance can occur, which might
    ///       result in an outage. Changing this parameter doesn't result in an outage, except in the
    ///       following situation, and the change is asynchronously applied as soon as possible. If there
    ///       are pending actions that cause a reboot, and the maintenance window is changed to include the
    ///       current time, then changing this parameter will cause a reboot of the DB instance. If moving
    ///       this window to the current time, there must be at least 30 minutes between the current time
    ///       and end of the window to ensure pending changes are applied.</p>
    ///          <p>Default: Uses existing setting</p>
    ///          <p>Format: ddd:hh24:mi-ddd:hh24:mi</p>
    ///          <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
    ///          <p>Constraints: Must be at least 30 minutes</p>
    public let preferredMaintenanceWindow: String?
    /// <p>A value that specifies the order in which a Read Replica is promoted to the primary
    ///       instance after a failure of the existing primary instance.</p>
    ///          <p>Default: 1</p>
    ///          <p>Valid Values: 0 - 15</p>
    public let promotionTier: Int?
    /// <p>This flag should no longer be used.</p>
    @available(*, deprecated)
    public let publiclyAccessible: Bool?
    /// <p>Not supported.</p>
    public let storageType: String?
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    public let tdeCredentialArn: String?
    /// <p>The password for the given ARN from the key store in order to access the device.</p>
    public let tdeCredentialPassword: String?
    /// <p>A list of EC2 VPC security groups to authorize on this DB instance. This change is
    ///       asynchronously applied as soon as possible.</p>
    ///          <p>Not applicable. The associated list of EC2 VPC security groups is managed by the DB
    ///       cluster. For more information, see <a>ModifyDBCluster</a>.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match existing VpcSecurityGroupIds.</p>
    ///             </li>
    ///          </ul>
    public let vpcSecurityGroupIds: [String]?

    public init (
        allocatedStorage: Int? = nil,
        allowMajorVersionUpgrade: Bool = false,
        applyImmediately: Bool = false,
        autoMinorVersionUpgrade: Bool? = nil,
        backupRetentionPeriod: Int? = nil,
        cACertificateIdentifier: String? = nil,
        cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBParameterGroupName: String? = nil,
        dBPortNumber: Int? = nil,
        dBSecurityGroups: [String]? = nil,
        dBSubnetGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        domain: String? = nil,
        domainIAMRoleName: String? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        enablePerformanceInsights: Bool? = nil,
        engineVersion: String? = nil,
        iops: Int? = nil,
        licenseModel: String? = nil,
        masterUserPassword: String? = nil,
        monitoringInterval: Int? = nil,
        monitoringRoleArn: String? = nil,
        multiAZ: Bool? = nil,
        newDBInstanceIdentifier: String? = nil,
        optionGroupName: String? = nil,
        performanceInsightsKMSKeyId: String? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        promotionTier: Int? = nil,
        publiclyAccessible: Bool? = nil,
        storageType: String? = nil,
        tdeCredentialArn: String? = nil,
        tdeCredentialPassword: String? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cACertificateIdentifier = cACertificateIdentifier
        self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBParameterGroupName = dBParameterGroupName
        self.dBPortNumber = dBPortNumber
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engineVersion = engineVersion
        self.iops = iops
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.newDBInstanceIdentifier = newDBInstanceIdentifier
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.storageType = storageType
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFoundFault" : self = .certificateNotFoundFault(try CertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExistsFault" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBUpgradeDependencyFailureFault" : self = .dBUpgradeDependencyFailureFault(try DBUpgradeDependencyFailureFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacityFault" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupStateFault" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupportedFault" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBInstanceOutputError: Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case certificateNotFoundFault(CertificateNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBUpgradeDependencyFailureFault(DBUpgradeDependencyFailureFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBInstanceOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension ModifyDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct ModifyDBInstanceOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB instance.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBInstances</a> action.</p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct ModifyDBInstanceOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension ModifyDBInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct ModifyDBParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBParameterGroupOutputError>
}

extension ModifyDBParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBParameterGroupInput(dBParameterGroupName: \(String(describing: dBParameterGroupName)), parameters: \(String(describing: parameters)))"}
}

extension ModifyDBParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBParameterGroupOutputError>
}

public struct ModifyDBParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBParameterGroupOutputError>
}

public struct ModifyDBParameterGroupInput: Equatable {
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>An array of parameter names, values, and the apply method for the parameter update. At
    ///       least one parameter name, value, and apply method must be supplied; subsequent arguments are
    ///       optional. A maximum of 20 parameters can be modified in a single request.</p>
    ///          <p>Valid Values (for the application method): <code>immediate | pending-reboot</code>
    ///          </p>
    ///          <note>
    ///             <p>You can use the immediate value with dynamic parameters only. You can use the
    ///         pending-reboot value for both dynamic and static parameters, and changes are applied when
    ///         you reboot the DB instance without failover.</p>
    ///          </note>
    public let parameters: [Parameter]?

    public init (
        dBParameterGroupName: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameters = parameters
    }
}

extension ModifyDBParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBParameterGroupOutputResponse(dBParameterGroupName: \(String(describing: dBParameterGroupName)))"}
}

extension ModifyDBParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBParameterGroupName = output.dBParameterGroupName
        } else {
            self.dBParameterGroupName = nil
        }
    }
}

public struct ModifyDBParameterGroupOutputResponse: Equatable {
    /// <p>Provides the name of the DB parameter group.</p>
    public let dBParameterGroupName: String?

    public init (
        dBParameterGroupName: String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

struct ModifyDBParameterGroupOutputResponseBody: Equatable {
    public let dBParameterGroupName: String?
}

extension ModifyDBParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBParameterGroupResult"))
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
    }
}

public struct ModifyDBSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSubnetGroupOutputError>
}

extension ModifyDBSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBSubnetGroupInput(dBSubnetGroupDescription: \(String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), subnetIds: \(String(describing: subnetIds)))"}
}

extension ModifyDBSubnetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBSubnetGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyDBSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSubnetGroupOutputError>
}

public struct ModifyDBSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDBSubnetGroupOutputError>
}

public struct ModifyDBSubnetGroupInput: Equatable {
    /// <p>The description for the DB subnet group.</p>
    public let dBSubnetGroupDescription: String?
    /// <p>The name for the DB subnet group. This value is stored as a lowercase string. You can't
    ///       modify the default subnet group.</p>
    ///          <p>Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>The EC2 subnet IDs for the DB subnet group.</p>
    public let subnetIds: [String]?

    public init (
        dBSubnetGroupDescription: String? = nil,
        dBSubnetGroupName: String? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetIds = subnetIds
    }
}

extension ModifyDBSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetQuotaExceededFault" : self = .dBSubnetQuotaExceededFault(try DBSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetAlreadyInUse" : self = .subnetAlreadyInUse(try SubnetAlreadyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBSubnetGroupOutputError: Equatable {
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case dBSubnetQuotaExceededFault(DBSubnetQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case subnetAlreadyInUse(SubnetAlreadyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDBSubnetGroupOutputResponse(dBSubnetGroup: \(String(describing: dBSubnetGroup)))"}
}

extension ModifyDBSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyDBSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBSubnetGroup = output.dBSubnetGroup
        } else {
            self.dBSubnetGroup = nil
        }
    }
}

public struct ModifyDBSubnetGroupOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB subnet group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBSubnetGroups</a> action.</p>
    public let dBSubnetGroup: DBSubnetGroup?

    public init (
        dBSubnetGroup: DBSubnetGroup? = nil
    )
    {
        self.dBSubnetGroup = dBSubnetGroup
    }
}

struct ModifyDBSubnetGroupOutputResponseBody: Equatable {
    public let dBSubnetGroup: DBSubnetGroup?
}

extension ModifyDBSubnetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBSubnetGroup = "DBSubnetGroup"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyDBSubnetGroupResult"))
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
    }
}

public struct ModifyEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

extension ModifyEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEventSubscriptionInput(enabled: \(String(describing: enabled)), eventCategories: \(String(describing: eventCategories)), snsTopicArn: \(String(describing: snsTopicArn)), sourceType: \(String(describing: sourceType)), subscriptionName: \(String(describing: subscriptionName)))"}
}

extension ModifyEventSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: Key("SnsTopicArn"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("ModifyEventSubscription", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ModifyEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

public struct ModifyEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

public struct ModifyEventSubscriptionInput: Equatable {
    /// <p> A Boolean value; set to <b>true</b> to activate the
    ///       subscription.</p>
    public let enabled: Bool?
    /// <p> A list of event categories for a SourceType that you want to subscribe to. You can see a
    ///       list of the categories for a given SourceType
    ///
    ///       by using the <b>DescribeEventCategories</b> action.</p>
    public let eventCategories: [String]?
    /// <p>The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is
    ///       created by Amazon SNS when you create a topic and subscribe to it.</p>
    public let snsTopicArn: String?
    /// <p>The type of source that is generating the events. For example, if you want to be notified
    ///       of events generated by a DB instance, you would set this parameter to db-instance. if this
    ///       value is not specified, all events are returned.</p>
    ///          <p>Valid values: db-instance | db-parameter-group | db-security-group | db-snapshot</p>
    public let sourceType: String?
    /// <p>The name of the event notification subscription.</p>
    public let subscriptionName: String?

    public init (
        enabled: Bool? = nil,
        eventCategories: [String]? = nil,
        snsTopicArn: String? = nil,
        sourceType: String? = nil,
        subscriptionName: String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

extension ModifyEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceededFault" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFoundFault" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFoundFault" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEventSubscriptionOutputError: Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEventSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension ModifyEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct ModifyEventSubscriptionOutputResponse: Equatable {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct ModifyEventSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension ModifyEventSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension OptionGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case optionGroupName = "OptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension OptionGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionGroupMembership(optionGroupName: \(String(describing: optionGroupName)), status: \(String(describing: status)))"}
}

/// <p>Not supported by Neptune.</p>
public struct OptionGroupMembership: Equatable {
    /// <p>Not supported by Neptune.</p>
    public let optionGroupName: String?
    /// <p>Not supported by Neptune.</p>
    public let status: String?

    public init (
        optionGroupName: String? = nil,
        status: String? = nil
    )
    {
        self.optionGroupName = optionGroupName
        self.status = status
    }
}

extension OptionGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptionGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension OptionGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OptionGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The designated option group could not be found.</p>
public struct OptionGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OptionGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension OptionGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrderableDBInstanceOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case dBInstanceClass = "DBInstanceClass"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case licenseModel = "LicenseModel"
        case maxIopsPerDbInstance = "MaxIopsPerDbInstance"
        case maxIopsPerGib = "MaxIopsPerGib"
        case maxStorageSize = "MaxStorageSize"
        case minIopsPerDbInstance = "MinIopsPerDbInstance"
        case minIopsPerGib = "MinIopsPerGib"
        case minStorageSize = "MinStorageSize"
        case multiAZCapable = "MultiAZCapable"
        case readReplicaCapable = "ReadReplicaCapable"
        case storageType = "StorageType"
        case supportsEnhancedMonitoring = "SupportsEnhancedMonitoring"
        case supportsIAMDatabaseAuthentication = "SupportsIAMDatabaseAuthentication"
        case supportsIops = "SupportsIops"
        case supportsPerformanceInsights = "SupportsPerformanceInsights"
        case supportsStorageEncryption = "SupportsStorageEncryption"
        case vpc = "Vpc"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let maxIopsPerDbInstance = maxIopsPerDbInstance {
            try container.encode(maxIopsPerDbInstance, forKey: Key("MaxIopsPerDbInstance"))
        }
        if let maxIopsPerGib = maxIopsPerGib {
            try container.encode(maxIopsPerGib, forKey: Key("MaxIopsPerGib"))
        }
        if let maxStorageSize = maxStorageSize {
            try container.encode(maxStorageSize, forKey: Key("MaxStorageSize"))
        }
        if let minIopsPerDbInstance = minIopsPerDbInstance {
            try container.encode(minIopsPerDbInstance, forKey: Key("MinIopsPerDbInstance"))
        }
        if let minIopsPerGib = minIopsPerGib {
            try container.encode(minIopsPerGib, forKey: Key("MinIopsPerGib"))
        }
        if let minStorageSize = minStorageSize {
            try container.encode(minStorageSize, forKey: Key("MinStorageSize"))
        }
        if multiAZCapable != false {
            try container.encode(multiAZCapable, forKey: Key("MultiAZCapable"))
        }
        if readReplicaCapable != false {
            try container.encode(readReplicaCapable, forKey: Key("ReadReplicaCapable"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
        if supportsEnhancedMonitoring != false {
            try container.encode(supportsEnhancedMonitoring, forKey: Key("SupportsEnhancedMonitoring"))
        }
        if supportsIAMDatabaseAuthentication != false {
            try container.encode(supportsIAMDatabaseAuthentication, forKey: Key("SupportsIAMDatabaseAuthentication"))
        }
        if supportsIops != false {
            try container.encode(supportsIops, forKey: Key("SupportsIops"))
        }
        if supportsPerformanceInsights != false {
            try container.encode(supportsPerformanceInsights, forKey: Key("SupportsPerformanceInsights"))
        }
        if supportsStorageEncryption != false {
            try container.encode(supportsStorageEncryption, forKey: Key("SupportsStorageEncryption"))
        }
        if vpc != false {
            try container.encode(vpc, forKey: Key("Vpc"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let multiAZCapableDecoded = try containerValues.decode(Bool.self, forKey: .multiAZCapable)
        multiAZCapable = multiAZCapableDecoded
        let readReplicaCapableDecoded = try containerValues.decode(Bool.self, forKey: .readReplicaCapable)
        readReplicaCapable = readReplicaCapableDecoded
        let vpcDecoded = try containerValues.decode(Bool.self, forKey: .vpc)
        vpc = vpcDecoded
        let supportsStorageEncryptionDecoded = try containerValues.decode(Bool.self, forKey: .supportsStorageEncryption)
        supportsStorageEncryption = supportsStorageEncryptionDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let supportsIopsDecoded = try containerValues.decode(Bool.self, forKey: .supportsIops)
        supportsIops = supportsIopsDecoded
        let supportsEnhancedMonitoringDecoded = try containerValues.decode(Bool.self, forKey: .supportsEnhancedMonitoring)
        supportsEnhancedMonitoring = supportsEnhancedMonitoringDecoded
        let supportsIAMDatabaseAuthenticationDecoded = try containerValues.decode(Bool.self, forKey: .supportsIAMDatabaseAuthentication)
        supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthenticationDecoded
        let supportsPerformanceInsightsDecoded = try containerValues.decode(Bool.self, forKey: .supportsPerformanceInsights)
        supportsPerformanceInsights = supportsPerformanceInsightsDecoded
        let minStorageSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minStorageSize)
        minStorageSize = minStorageSizeDecoded
        let maxStorageSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxStorageSize)
        maxStorageSize = maxStorageSizeDecoded
        let minIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minIopsPerDbInstance)
        minIopsPerDbInstance = minIopsPerDbInstanceDecoded
        let maxIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxIopsPerDbInstance)
        maxIopsPerDbInstance = maxIopsPerDbInstanceDecoded
        let minIopsPerGibDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .minIopsPerGib)
        minIopsPerGib = minIopsPerGibDecoded
        let maxIopsPerGibDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxIopsPerGib)
        maxIopsPerGib = maxIopsPerGibDecoded
    }
}

extension OrderableDBInstanceOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrderableDBInstanceOption(availabilityZones: \(String(describing: availabilityZones)), dBInstanceClass: \(String(describing: dBInstanceClass)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), licenseModel: \(String(describing: licenseModel)), maxIopsPerDbInstance: \(String(describing: maxIopsPerDbInstance)), maxIopsPerGib: \(String(describing: maxIopsPerGib)), maxStorageSize: \(String(describing: maxStorageSize)), minIopsPerDbInstance: \(String(describing: minIopsPerDbInstance)), minIopsPerGib: \(String(describing: minIopsPerGib)), minStorageSize: \(String(describing: minStorageSize)), multiAZCapable: \(String(describing: multiAZCapable)), readReplicaCapable: \(String(describing: readReplicaCapable)), storageType: \(String(describing: storageType)), supportsEnhancedMonitoring: \(String(describing: supportsEnhancedMonitoring)), supportsIAMDatabaseAuthentication: \(String(describing: supportsIAMDatabaseAuthentication)), supportsIops: \(String(describing: supportsIops)), supportsPerformanceInsights: \(String(describing: supportsPerformanceInsights)), supportsStorageEncryption: \(String(describing: supportsStorageEncryption)), vpc: \(String(describing: vpc)))"}
}

/// <p>Contains a list of available options for a DB instance.</p>
///          <p> This data type is used as a response element in the <a>DescribeOrderableDBInstanceOptions</a> action.</p>
public struct OrderableDBInstanceOption: Equatable {
    /// <p>A list of Availability Zones for a DB instance.</p>
    public let availabilityZones: [AvailabilityZone]?
    /// <p>The DB instance class for a DB instance.</p>
    public let dBInstanceClass: String?
    /// <p>The engine type of a DB instance.</p>
    public let engine: String?
    /// <p>The engine version of a DB instance.</p>
    public let engineVersion: String?
    /// <p>The license model for a DB instance.</p>
    public let licenseModel: String?
    /// <p>Maximum total provisioned IOPS for a DB instance.</p>
    public let maxIopsPerDbInstance: Int?
    /// <p>Maximum provisioned IOPS per GiB for a DB instance.</p>
    public let maxIopsPerGib: Double?
    /// <p>Maximum storage size for a DB instance.</p>
    public let maxStorageSize: Int?
    /// <p>Minimum total provisioned IOPS for a DB instance.</p>
    public let minIopsPerDbInstance: Int?
    /// <p>Minimum provisioned IOPS per GiB for a DB instance.</p>
    public let minIopsPerGib: Double?
    /// <p>Minimum storage size for a DB instance.</p>
    public let minStorageSize: Int?
    /// <p>Indicates whether a DB instance is Multi-AZ capable.</p>
    public let multiAZCapable: Bool
    /// <p>Indicates whether a DB instance can have a Read Replica.</p>
    public let readReplicaCapable: Bool
    /// <p>Indicates the storage type for a DB instance.</p>
    public let storageType: String?
    /// <p>Indicates whether a DB instance supports Enhanced Monitoring at intervals from 1 to 60
    ///       seconds.</p>
    public let supportsEnhancedMonitoring: Bool
    /// <p>Indicates whether a DB instance supports IAM database authentication.</p>
    public let supportsIAMDatabaseAuthentication: Bool
    /// <p>Indicates whether a DB instance supports provisioned IOPS.</p>
    public let supportsIops: Bool
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let supportsPerformanceInsights: Bool
    /// <p>Indicates whether a DB instance supports encrypted storage.</p>
    public let supportsStorageEncryption: Bool
    /// <p>Indicates whether a DB instance is in a VPC.</p>
    public let vpc: Bool

    public init (
        availabilityZones: [AvailabilityZone]? = nil,
        dBInstanceClass: String? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        licenseModel: String? = nil,
        maxIopsPerDbInstance: Int? = nil,
        maxIopsPerGib: Double? = nil,
        maxStorageSize: Int? = nil,
        minIopsPerDbInstance: Int? = nil,
        minIopsPerGib: Double? = nil,
        minStorageSize: Int? = nil,
        multiAZCapable: Bool = false,
        readReplicaCapable: Bool = false,
        storageType: String? = nil,
        supportsEnhancedMonitoring: Bool = false,
        supportsIAMDatabaseAuthentication: Bool = false,
        supportsIops: Bool = false,
        supportsPerformanceInsights: Bool = false,
        supportsStorageEncryption: Bool = false,
        vpc: Bool = false
    )
    {
        self.availabilityZones = availabilityZones
        self.dBInstanceClass = dBInstanceClass
        self.engine = engine
        self.engineVersion = engineVersion
        self.licenseModel = licenseModel
        self.maxIopsPerDbInstance = maxIopsPerDbInstance
        self.maxIopsPerGib = maxIopsPerGib
        self.maxStorageSize = maxStorageSize
        self.minIopsPerDbInstance = minIopsPerDbInstance
        self.minIopsPerGib = minIopsPerGib
        self.minStorageSize = minStorageSize
        self.multiAZCapable = multiAZCapable
        self.readReplicaCapable = readReplicaCapable
        self.storageType = storageType
        self.supportsEnhancedMonitoring = supportsEnhancedMonitoring
        self.supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthentication
        self.supportsIops = supportsIops
        self.supportsPerformanceInsights = supportsPerformanceInsights
        self.supportsStorageEncryption = supportsStorageEncryption
        self.vpc = vpc
    }
}

extension Parameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedValues = "AllowedValues"
        case applyMethod = "ApplyMethod"
        case applyType = "ApplyType"
        case dataType = "DataType"
        case description = "Description"
        case isModifiable = "IsModifiable"
        case minimumEngineVersion = "MinimumEngineVersion"
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: Key("AllowedValues"))
        }
        if let applyMethod = applyMethod {
            try container.encode(applyMethod, forKey: Key("ApplyMethod"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: Key("ApplyType"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: Key("DataType"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: Key("IsModifiable"))
        }
        if let minimumEngineVersion = minimumEngineVersion {
            try container.encode(minimumEngineVersion, forKey: Key("MinimumEngineVersion"))
        }
        if let parameterName = parameterName {
            try container.encode(parameterName, forKey: Key("ParameterName"))
        }
        if let parameterValue = parameterValue {
            try container.encode(parameterValue, forKey: Key("ParameterValue"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decode(Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
        let applyMethodDecoded = try containerValues.decodeIfPresent(ApplyMethod.self, forKey: .applyMethod)
        applyMethod = applyMethodDecoded
    }
}

extension Parameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Parameter(allowedValues: \(String(describing: allowedValues)), applyMethod: \(String(describing: applyMethod)), applyType: \(String(describing: applyType)), dataType: \(String(describing: dataType)), description: \(String(describing: description)), isModifiable: \(String(describing: isModifiable)), minimumEngineVersion: \(String(describing: minimumEngineVersion)), parameterName: \(String(describing: parameterName)), parameterValue: \(String(describing: parameterValue)), source: \(String(describing: source)))"}
}

/// <p>Specifies a parameter.</p>
public struct Parameter: Equatable {
    /// <p>Specifies the valid range of values for the parameter.</p>
    public let allowedValues: String?
    /// <p>Indicates when to apply parameter updates.</p>
    public let applyMethod: ApplyMethod?
    /// <p>Specifies the engine specific parameters type.</p>
    public let applyType: String?
    /// <p>Specifies the valid data type for the parameter.</p>
    public let dataType: String?
    /// <p>Provides a description of the parameter.</p>
    public let description: String?
    /// <p> Indicates whether (<code>true</code>) or not (<code>false</code>) the parameter can be
    ///       modified. Some parameters have security or operational implications that prevent them from
    ///       being changed.</p>
    public let isModifiable: Bool
    /// <p>The earliest engine version to which the parameter can apply.</p>
    public let minimumEngineVersion: String?
    /// <p>Specifies the name of the parameter.</p>
    public let parameterName: String?
    /// <p>Specifies the value of the parameter.</p>
    public let parameterValue: String?
    /// <p>Indicates the source of the parameter value.</p>
    public let source: String?

    public init (
        allowedValues: String? = nil,
        applyMethod: ApplyMethod? = nil,
        applyType: String? = nil,
        dataType: String? = nil,
        description: String? = nil,
        isModifiable: Bool = false,
        minimumEngineVersion: String? = nil,
        parameterName: String? = nil,
        parameterValue: String? = nil,
        source: String? = nil
    )
    {
        self.allowedValues = allowedValues
        self.applyMethod = applyMethod
        self.applyType = applyType
        self.dataType = dataType
        self.description = description
        self.isModifiable = isModifiable
        self.minimumEngineVersion = minimumEngineVersion
        self.parameterName = parameterName
        self.parameterValue = parameterValue
        self.source = source
    }
}

extension PendingCloudwatchLogsExports: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logTypesToDisable = "LogTypesToDisable"
        case logTypesToEnable = "LogTypesToEnable"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let logTypesToDisable = logTypesToDisable {
            var logTypesToDisableContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LogTypesToDisable"))
            for (index0, string0) in logTypesToDisable.enumerated() {
                try logTypesToDisableContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let logTypesToEnable = logTypesToEnable {
            var logTypesToEnableContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LogTypesToEnable"))
            for (index0, string0) in logTypesToEnable.enumerated() {
                try logTypesToEnableContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.logTypesToEnable) {
            struct KeyVal0{struct member{}}
            let logTypesToEnableWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .logTypesToEnable)
            if let logTypesToEnableWrappedContainer = logTypesToEnableWrappedContainer {
                let logTypesToEnableContainer = try logTypesToEnableWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var logTypesToEnableBuffer:[String]? = nil
                if let logTypesToEnableContainer = logTypesToEnableContainer {
                    logTypesToEnableBuffer = [String]()
                    for stringContainer0 in logTypesToEnableContainer {
                        logTypesToEnableBuffer?.append(stringContainer0)
                    }
                }
                logTypesToEnable = logTypesToEnableBuffer
            } else {
                logTypesToEnable = []
            }
        } else {
            logTypesToEnable = nil
        }
        if containerValues.contains(.logTypesToDisable) {
            struct KeyVal0{struct member{}}
            let logTypesToDisableWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .logTypesToDisable)
            if let logTypesToDisableWrappedContainer = logTypesToDisableWrappedContainer {
                let logTypesToDisableContainer = try logTypesToDisableWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var logTypesToDisableBuffer:[String]? = nil
                if let logTypesToDisableContainer = logTypesToDisableContainer {
                    logTypesToDisableBuffer = [String]()
                    for stringContainer0 in logTypesToDisableContainer {
                        logTypesToDisableBuffer?.append(stringContainer0)
                    }
                }
                logTypesToDisable = logTypesToDisableBuffer
            } else {
                logTypesToDisable = []
            }
        } else {
            logTypesToDisable = nil
        }
    }
}

extension PendingCloudwatchLogsExports: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingCloudwatchLogsExports(logTypesToDisable: \(String(describing: logTypesToDisable)), logTypesToEnable: \(String(describing: logTypesToEnable)))"}
}

/// <p>A list of the log types whose configuration is still pending. In other
///       words, these log types are in the process of being activated or deactivated.</p>
public struct PendingCloudwatchLogsExports: Equatable {
    /// <p>Log types that are in the process of being enabled. After they are
    ///       enabled, these log types are exported to CloudWatch Logs.</p>
    public let logTypesToDisable: [String]?
    /// <p>Log types that are in the process of being deactivated. After they are
    ///       deactivated, these log types aren't exported to CloudWatch Logs.</p>
    public let logTypesToEnable: [String]?

    public init (
        logTypesToDisable: [String]? = nil,
        logTypesToEnable: [String]? = nil
    )
    {
        self.logTypesToDisable = logTypesToDisable
        self.logTypesToEnable = logTypesToEnable
    }
}

extension PendingMaintenanceAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case autoAppliedAfterDate = "AutoAppliedAfterDate"
        case currentApplyDate = "CurrentApplyDate"
        case description = "Description"
        case forcedApplyDate = "ForcedApplyDate"
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let action = action {
            try container.encode(action, forKey: Key("Action"))
        }
        if let autoAppliedAfterDate = autoAppliedAfterDate {
            try container.encode(TimestampWrapper(autoAppliedAfterDate, format: .dateTime), forKey: Key("autoAppliedAfterDate"))
        }
        if let currentApplyDate = currentApplyDate {
            try container.encode(TimestampWrapper(currentApplyDate, format: .dateTime), forKey: Key("currentApplyDate"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let forcedApplyDate = forcedApplyDate {
            try container.encode(TimestampWrapper(forcedApplyDate, format: .dateTime), forKey: Key("forcedApplyDate"))
        }
        if let optInStatus = optInStatus {
            try container.encode(optInStatus, forKey: Key("OptInStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let autoAppliedAfterDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoAppliedAfterDate)
        var autoAppliedAfterDateBuffer:Date? = nil
        if let autoAppliedAfterDateDecoded = autoAppliedAfterDateDecoded {
            autoAppliedAfterDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(autoAppliedAfterDateDecoded, format: .dateTime)
        }
        autoAppliedAfterDate = autoAppliedAfterDateBuffer
        let forcedApplyDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forcedApplyDate)
        var forcedApplyDateBuffer:Date? = nil
        if let forcedApplyDateDecoded = forcedApplyDateDecoded {
            forcedApplyDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(forcedApplyDateDecoded, format: .dateTime)
        }
        forcedApplyDate = forcedApplyDateBuffer
        let optInStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
        let currentApplyDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentApplyDate)
        var currentApplyDateBuffer:Date? = nil
        if let currentApplyDateDecoded = currentApplyDateDecoded {
            currentApplyDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(currentApplyDateDecoded, format: .dateTime)
        }
        currentApplyDate = currentApplyDateBuffer
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension PendingMaintenanceAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingMaintenanceAction(action: \(String(describing: action)), autoAppliedAfterDate: \(String(describing: autoAppliedAfterDate)), currentApplyDate: \(String(describing: currentApplyDate)), description: \(String(describing: description)), forcedApplyDate: \(String(describing: forcedApplyDate)), optInStatus: \(String(describing: optInStatus)))"}
}

/// <p>Provides information about a pending maintenance action for a resource.</p>
public struct PendingMaintenanceAction: Equatable {
    /// <p>The type of pending maintenance action that is available for the resource.</p>
    public let action: String?
    /// <p>The date of the maintenance window when the action is applied. The maintenance action is
    ///       applied to the resource during its first maintenance window after this date. If this date is
    ///       specified, any <code>next-maintenance</code> opt-in requests are ignored.</p>
    public let autoAppliedAfterDate: Date?
    /// <p>The effective date when the pending maintenance action is applied to the resource. This
    ///       date takes into account opt-in requests received from the <a>ApplyPendingMaintenanceAction</a> API, the <code>AutoAppliedAfterDate</code>, and the
    ///       <code>ForcedApplyDate</code>. This value is blank if an opt-in request has not been received
    ///       and nothing has been specified as <code>AutoAppliedAfterDate</code> or
    ///       <code>ForcedApplyDate</code>.</p>
    public let currentApplyDate: Date?
    /// <p>A description providing more detail about the maintenance action.</p>
    public let description: String?
    /// <p>The date when the maintenance action is automatically applied. The maintenance action is
    ///       applied to the resource on this date regardless of the maintenance window for the resource. If
    ///       this date is specified, any <code>immediate</code> opt-in requests are ignored.</p>
    public let forcedApplyDate: Date?
    /// <p>Indicates the type of opt-in request that has been received for the resource.</p>
    public let optInStatus: String?

    public init (
        action: String? = nil,
        autoAppliedAfterDate: Date? = nil,
        currentApplyDate: Date? = nil,
        description: String? = nil,
        forcedApplyDate: Date? = nil,
        optInStatus: String? = nil
    )
    {
        self.action = action
        self.autoAppliedAfterDate = autoAppliedAfterDate
        self.currentApplyDate = currentApplyDate
        self.description = description
        self.forcedApplyDate = forcedApplyDate
        self.optInStatus = optInStatus
    }
}

extension PendingModifiedValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case engineVersion = "EngineVersion"
        case iops = "Iops"
        case licenseModel = "LicenseModel"
        case masterUserPassword = "MasterUserPassword"
        case multiAZ = "MultiAZ"
        case pendingCloudwatchLogsExports = "PendingCloudwatchLogsExports"
        case port = "Port"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: Key("AllocatedStorage"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: Key("CACertificateIdentifier"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: Key("MasterUserPassword"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: Key("MultiAZ"))
        }
        if let pendingCloudwatchLogsExports = pendingCloudwatchLogsExports {
            try container.encode(pendingCloudwatchLogsExports, forKey: Key("PendingCloudwatchLogsExports"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let pendingCloudwatchLogsExportsDecoded = try containerValues.decodeIfPresent(PendingCloudwatchLogsExports.self, forKey: .pendingCloudwatchLogsExports)
        pendingCloudwatchLogsExports = pendingCloudwatchLogsExportsDecoded
    }
}

extension PendingModifiedValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingModifiedValues(allocatedStorage: \(String(describing: allocatedStorage)), backupRetentionPeriod: \(String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(String(describing: cACertificateIdentifier)), dBInstanceClass: \(String(describing: dBInstanceClass)), dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), engineVersion: \(String(describing: engineVersion)), iops: \(String(describing: iops)), licenseModel: \(String(describing: licenseModel)), masterUserPassword: \(String(describing: masterUserPassword)), multiAZ: \(String(describing: multiAZ)), pendingCloudwatchLogsExports: \(String(describing: pendingCloudwatchLogsExports)), port: \(String(describing: port)), storageType: \(String(describing: storageType)))"}
}

/// <p> This data type is used as a response element in the <a>ModifyDBInstance</a>
///       action.</p>
public struct PendingModifiedValues: Equatable {
    /// <p> Contains the new <code>AllocatedStorage</code> size for the DB instance that will be
    ///       applied or is currently being applied.</p>
    public let allocatedStorage: Int?
    /// <p>Specifies the pending number of days for which automated backups are retained.</p>
    public let backupRetentionPeriod: Int?
    /// <p>Specifies the identifier of the CA certificate for the DB instance.</p>
    public let cACertificateIdentifier: String?
    /// <p> Contains the new <code>DBInstanceClass</code> for the DB instance that will be applied or
    ///       is currently being applied.</p>
    public let dBInstanceClass: String?
    /// <p> Contains the new <code>DBInstanceIdentifier</code> for the DB instance that will be
    ///       applied or is currently being applied.</p>
    public let dBInstanceIdentifier: String?
    /// <p>The new DB subnet group for the DB instance.</p>
    public let dBSubnetGroupName: String?
    /// <p>Indicates the database engine version.</p>
    public let engineVersion: String?
    /// <p>Specifies the new Provisioned IOPS value for the DB instance that will be applied or is
    ///       currently being applied.</p>
    public let iops: Int?
    /// <p>Not supported by Neptune.</p>
    public let licenseModel: String?
    /// <p>Not supported by Neptune.</p>
    public let masterUserPassword: String?
    /// <p>Indicates that the Single-AZ DB instance is to change to a Multi-AZ deployment.</p>
    public let multiAZ: Bool?
    /// <p>This <code>PendingCloudwatchLogsExports</code> structure specifies
    ///       pending changes to which CloudWatch logs are enabled and which are disabled.</p>
    public let pendingCloudwatchLogsExports: PendingCloudwatchLogsExports?
    /// <p>Specifies the pending port for the DB instance.</p>
    public let port: Int?
    /// <p>Specifies the storage type to be associated with the DB instance.</p>
    public let storageType: String?

    public init (
        allocatedStorage: Int? = nil,
        backupRetentionPeriod: Int? = nil,
        cACertificateIdentifier: String? = nil,
        dBInstanceClass: String? = nil,
        dBInstanceIdentifier: String? = nil,
        dBSubnetGroupName: String? = nil,
        engineVersion: String? = nil,
        iops: Int? = nil,
        licenseModel: String? = nil,
        masterUserPassword: String? = nil,
        multiAZ: Bool? = nil,
        pendingCloudwatchLogsExports: PendingCloudwatchLogsExports? = nil,
        port: Int? = nil,
        storageType: String? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cACertificateIdentifier = cACertificateIdentifier
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSubnetGroupName = dBSubnetGroupName
        self.engineVersion = engineVersion
        self.iops = iops
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.multiAZ = multiAZ
        self.pendingCloudwatchLogsExports = pendingCloudwatchLogsExports
        self.port = port
        self.storageType = storageType
    }
}

public struct PromoteReadReplicaDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "PromoteReadReplicaDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PromoteReadReplicaDBClusterOutputError>
}

extension PromoteReadReplicaDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PromoteReadReplicaDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)))"}
}

extension PromoteReadReplicaDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        try container.encode("PromoteReadReplicaDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct PromoteReadReplicaDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "PromoteReadReplicaDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PromoteReadReplicaDBClusterOutputError>
}

public struct PromoteReadReplicaDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "PromoteReadReplicaDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PromoteReadReplicaDBClusterOutputError>
}

public struct PromoteReadReplicaDBClusterInput: Equatable {
    /// <p>Not supported.</p>
    public let dBClusterIdentifier: String?

    public init (
        dBClusterIdentifier: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension PromoteReadReplicaDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PromoteReadReplicaDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PromoteReadReplicaDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteReadReplicaDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PromoteReadReplicaDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension PromoteReadReplicaDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PromoteReadReplicaDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct PromoteReadReplicaDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct PromoteReadReplicaDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension PromoteReadReplicaDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("PromoteReadReplicaDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension ProvisionedIopsNotAvailableInAZFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionedIopsNotAvailableInAZFault(message: \(String(describing: message)))"}
}

extension ProvisionedIopsNotAvailableInAZFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ProvisionedIopsNotAvailableInAZFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provisioned IOPS not available in the specified Availability Zone.</p>
public struct ProvisionedIopsNotAvailableInAZFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ProvisionedIopsNotAvailableInAZFaultBody: Equatable {
    public let message: String?
}

extension ProvisionedIopsNotAvailableInAZFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Range: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case from = "From"
        case step = "Step"
        case to = "To"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if from != 0 {
            try container.encode(from, forKey: Key("From"))
        }
        if let step = step {
            try container.encode(step, forKey: Key("Step"))
        }
        if to != 0 {
            try container.encode(to, forKey: Key("To"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decode(Int.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decode(Int.self, forKey: .to)
        to = toDecoded
        let stepDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .step)
        step = stepDecoded
    }
}

extension Range: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Range(from: \(String(describing: from)), step: \(String(describing: step)), to: \(String(describing: to)))"}
}

/// <p>A range of integer values.</p>
public struct Range: Equatable {
    /// <p>The minimum value in the range.</p>
    public let from: Int
    /// <p>The step value for the range. For example, if you have a range of 5,000 to 10,000, with a
    ///       step value of 1,000, the valid values start at 5,000 and step up by 1,000. Even though 7,500
    ///       is within the range, it isn't a valid value for the range. The valid values are 5,000, 6,000,
    ///       7,000, 8,000...</p>
    public let step: Int?
    /// <p>The maximum value in the range.</p>
    public let to: Int

    public init (
        from: Int = 0,
        step: Int? = nil,
        to: Int = 0
    )
    {
        self.from = from
        self.step = step
        self.to = to
    }
}

public struct RebootDBInstanceInputBodyMiddleware: Middleware {
    public let id: String = "RebootDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootDBInstanceOutputError>
}

extension RebootDBInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootDBInstanceInput(dBInstanceIdentifier: \(String(describing: dBInstanceIdentifier)), forceFailover: \(String(describing: forceFailover)))"}
}

extension RebootDBInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: Key("DBInstanceIdentifier"))
        }
        if let forceFailover = forceFailover {
            try container.encode(forceFailover, forKey: Key("ForceFailover"))
        }
        try container.encode("RebootDBInstance", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RebootDBInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "RebootDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootDBInstanceOutputError>
}

public struct RebootDBInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "RebootDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootDBInstanceOutputError>
}

public struct RebootDBInstanceInput: Equatable {
    /// <p>The DB instance identifier. This parameter is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: String?
    /// <p> When <code>true</code>, the reboot is conducted through a MultiAZ failover.</p>
    ///          <p>Constraint: You can't specify <code>true</code> if the instance is not configured for
    ///       MultiAZ.</p>
    public let forceFailover: Bool?

    public init (
        dBInstanceIdentifier: String? = nil,
        forceFailover: Bool? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.forceFailover = forceFailover
    }
}

extension RebootDBInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RebootDBInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootDBInstanceOutputError: Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootDBInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootDBInstanceOutputResponse(dBInstance: \(String(describing: dBInstance)))"}
}

extension RebootDBInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RebootDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RebootDBInstanceOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB instance.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBInstances</a> action.</p>
    public let dBInstance: DBInstance?

    public init (
        dBInstance: DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RebootDBInstanceOutputResponseBody: Equatable {
    public let dBInstance: DBInstance?
}

extension RebootDBInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RebootDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct RemoveRoleFromDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "RemoveRoleFromDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromDBClusterOutputError>
}

extension RemoveRoleFromDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRoleFromDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), featureName: \(String(describing: featureName)), roleArn: \(String(describing: roleArn)))"}
}

extension RemoveRoleFromDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        try container.encode("RemoveRoleFromDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RemoveRoleFromDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveRoleFromDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromDBClusterOutputError>
}

public struct RemoveRoleFromDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveRoleFromDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRoleFromDBClusterOutputError>
}

public struct RemoveRoleFromDBClusterInput: Equatable {
    /// <p>The name of the DB cluster to disassociate the IAM role from.</p>
    public let dBClusterIdentifier: String?
    /// <p>The name of the feature for the DB cluster that the IAM role is to be disassociated from.
    ///       For the list of supported feature names, see <a>DBEngineVersion</a>.</p>
    public let featureName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to disassociate from the DB cluster, for
    ///       example <code>arn:aws:iam::123456789012:role/NeptuneAccessRole</code>.</p>
    public let roleArn: String?

    public init (
        dBClusterIdentifier: String? = nil,
        featureName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension RemoveRoleFromDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveRoleFromDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleNotFoundFault" : self = .dBClusterRoleNotFoundFault(try DBClusterRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRoleFromDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterRoleNotFoundFault(DBClusterRoleNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRoleFromDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRoleFromDBClusterOutputResponse()"}
}

extension RemoveRoleFromDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveRoleFromDBClusterOutputResponse: Equatable {

    public init() {}
}

struct RemoveRoleFromDBClusterOutputResponseBody: Equatable {
}

extension RemoveRoleFromDBClusterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveSourceIdentifierFromSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "RemoveSourceIdentifierFromSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

extension RemoveSourceIdentifierFromSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveSourceIdentifierFromSubscriptionInput(sourceIdentifier: \(String(describing: sourceIdentifier)), subscriptionName: \(String(describing: subscriptionName)))"}
}

extension RemoveSourceIdentifierFromSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: Key("SourceIdentifier"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: Key("SubscriptionName"))
        }
        try container.encode("RemoveSourceIdentifierFromSubscription", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RemoveSourceIdentifierFromSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveSourceIdentifierFromSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

public struct RemoveSourceIdentifierFromSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveSourceIdentifierFromSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

public struct RemoveSourceIdentifierFromSubscriptionInput: Equatable {
    /// <p> The source identifier to be removed from the subscription, such as the <b>DB instance identifier</b> for a DB instance or the name of a security
    ///       group.</p>
    public let sourceIdentifier: String?
    /// <p>The name of the event notification subscription you want to remove a source identifier
    ///       from.</p>
    public let subscriptionName: String?

    public init (
        sourceIdentifier: String? = nil,
        subscriptionName: String? = nil
    )
    {
        self.sourceIdentifier = sourceIdentifier
        self.subscriptionName = subscriptionName
    }
}

extension RemoveSourceIdentifierFromSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveSourceIdentifierFromSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveSourceIdentifierFromSubscriptionOutputError: Equatable {
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveSourceIdentifierFromSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveSourceIdentifierFromSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct RemoveSourceIdentifierFromSubscriptionOutputResponse: Equatable {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct RemoveSourceIdentifierFromSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RemoveSourceIdentifierFromSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceInput(resourceName: \(String(describing: resourceName)), tagKeys: \(String(describing: tagKeys)))"}
}

extension RemoveTagsFromResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: Key("ResourceName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RemoveTagsFromResource", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInput: Equatable {
    /// <p>The Amazon Neptune resource that the tags are removed from. This value is an Amazon
    ///       Resource Name (ARN). For information about creating an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    public let resourceName: String?
    /// <p>The tag key (name) of the tag to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceName: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceName = resourceName
        self.tagKeys = tagKeys
    }
}

extension RemoveTagsFromResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceOutputResponse()"}
}

extension RemoveTagsFromResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromResourceOutputResponse: Equatable {

    public init() {}
}

struct RemoveTagsFromResourceOutputResponseBody: Equatable {
}

extension RemoveTagsFromResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ResetDBClusterParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "ResetDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBClusterParameterGroupOutputError>
}

extension ResetDBClusterParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetDBClusterParameterGroupInput(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), parameters: \(String(describing: parameters)), resetAllParameters: \(String(describing: resetAllParameters)))"}
}

extension ResetDBClusterParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: Key("ResetAllParameters"))
        }
        try container.encode("ResetDBClusterParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ResetDBClusterParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ResetDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBClusterParameterGroupOutputError>
}

public struct ResetDBClusterParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBClusterParameterGroupOutputError>
}

public struct ResetDBClusterParameterGroupInput: Equatable {
    /// <p>The name of the DB cluster parameter group to reset.</p>
    public let dBClusterParameterGroupName: String?
    /// <p>A list of parameter names in the DB cluster parameter group to reset to the default
    ///       values. You can't use this parameter if the <code>ResetAllParameters</code> parameter is set
    ///       to <code>true</code>.</p>
    public let parameters: [Parameter]?
    /// <p>A value that is set to <code>true</code> to reset all parameters in the DB cluster
    ///       parameter group to their default values, and <code>false</code> otherwise. You can't use this
    ///       parameter if there is a list of parameter names specified for the <code>Parameters</code>
    ///       parameter.</p>
    public let resetAllParameters: Bool

    public init (
        dBClusterParameterGroupName: String? = nil,
        parameters: [Parameter]? = nil,
        resetAllParameters: Bool = false
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

extension ResetDBClusterParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetDBClusterParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetDBClusterParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDBClusterParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetDBClusterParameterGroupOutputResponse(dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)))"}
}

extension ResetDBClusterParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResetDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBClusterParameterGroupName = output.dBClusterParameterGroupName
        } else {
            self.dBClusterParameterGroupName = nil
        }
    }
}

public struct ResetDBClusterParameterGroupOutputResponse: Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBClusterParameterGroupName: String?

    public init (
        dBClusterParameterGroupName: String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

struct ResetDBClusterParameterGroupOutputResponseBody: Equatable {
    public let dBClusterParameterGroupName: String?
}

extension ResetDBClusterParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ResetDBClusterParameterGroupResult"))
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
    }
}

public struct ResetDBParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "ResetDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBParameterGroupOutputError>
}

extension ResetDBParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetDBParameterGroupInput(dBParameterGroupName: \(String(describing: dBParameterGroupName)), parameters: \(String(describing: parameters)), resetAllParameters: \(String(describing: resetAllParameters)))"}
}

extension ResetDBParameterGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: Key("DBParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: Key("ResetAllParameters"))
        }
        try container.encode("ResetDBParameterGroup", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct ResetDBParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ResetDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBParameterGroupOutputError>
}

public struct ResetDBParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetDBParameterGroupOutputError>
}

public struct ResetDBParameterGroupInput: Equatable {
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the name of an existing DBParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: String?
    /// <p>To reset the entire DB parameter group, specify the <code>DBParameterGroup</code> name and
    ///       <code>ResetAllParameters</code> parameters. To reset specific parameters, provide a list of
    ///       the following: <code>ParameterName</code> and <code>ApplyMethod</code>. A maximum of 20
    ///       parameters can be modified in a single request.</p>
    ///          <p>Valid Values (for Apply method): <code>pending-reboot</code>
    ///          </p>
    public let parameters: [Parameter]?
    /// <p>Specifies whether (<code>true</code>) or not (<code>false</code>) to reset all parameters
    ///       in the DB parameter group to default values.</p>
    ///          <p>Default: <code>true</code>
    ///          </p>
    public let resetAllParameters: Bool

    public init (
        dBParameterGroupName: String? = nil,
        parameters: [Parameter]? = nil,
        resetAllParameters: Bool = false
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

extension ResetDBParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetDBParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetDBParameterGroupOutputError: Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDBParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetDBParameterGroupOutputResponse(dBParameterGroupName: \(String(describing: dBParameterGroupName)))"}
}

extension ResetDBParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResetDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBParameterGroupName = output.dBParameterGroupName
        } else {
            self.dBParameterGroupName = nil
        }
    }
}

public struct ResetDBParameterGroupOutputResponse: Equatable {
    /// <p>Provides the name of the DB parameter group.</p>
    public let dBParameterGroupName: String?

    public init (
        dBParameterGroupName: String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

struct ResetDBParameterGroupOutputResponseBody: Equatable {
    public let dBParameterGroupName: String?
}

extension ResetDBParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ResetDBParameterGroupResult"))
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
    }
}

extension ResourceNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundFault(message: \(String(describing: message)))"}
}

extension ResourceNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ResourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource ID was not found.</p>
public struct ResourceNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourcePendingMaintenanceActions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let pendingMaintenanceActionDetails = pendingMaintenanceActionDetails {
            var pendingMaintenanceActionDetailsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PendingMaintenanceActionDetails"))
            for (index0, pendingmaintenanceaction0) in pendingMaintenanceActionDetails.enumerated() {
                try pendingMaintenanceActionDetailsContainer.encode(pendingmaintenanceaction0, forKey: Key("PendingMaintenanceAction.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: Key("ResourceIdentifier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        if containerValues.contains(.pendingMaintenanceActionDetails) {
            struct KeyVal0{struct PendingMaintenanceAction{}}
            let pendingMaintenanceActionDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PendingMaintenanceAction>.CodingKeys.self, forKey: .pendingMaintenanceActionDetails)
            if let pendingMaintenanceActionDetailsWrappedContainer = pendingMaintenanceActionDetailsWrappedContainer {
                let pendingMaintenanceActionDetailsContainer = try pendingMaintenanceActionDetailsWrappedContainer.decodeIfPresent([PendingMaintenanceAction].self, forKey: .member)
                var pendingMaintenanceActionDetailsBuffer:[PendingMaintenanceAction]? = nil
                if let pendingMaintenanceActionDetailsContainer = pendingMaintenanceActionDetailsContainer {
                    pendingMaintenanceActionDetailsBuffer = [PendingMaintenanceAction]()
                    for structureContainer0 in pendingMaintenanceActionDetailsContainer {
                        pendingMaintenanceActionDetailsBuffer?.append(structureContainer0)
                    }
                }
                pendingMaintenanceActionDetails = pendingMaintenanceActionDetailsBuffer
            } else {
                pendingMaintenanceActionDetails = []
            }
        } else {
            pendingMaintenanceActionDetails = nil
        }
    }
}

extension ResourcePendingMaintenanceActions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourcePendingMaintenanceActions(pendingMaintenanceActionDetails: \(String(describing: pendingMaintenanceActionDetails)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

/// <p>Describes the pending maintenance actions for a resource.</p>
public struct ResourcePendingMaintenanceActions: Equatable {
    /// <p>A list that provides details about the pending maintenance actions for the
    ///       resource.</p>
    public let pendingMaintenanceActionDetails: [PendingMaintenanceAction]?
    /// <p>The ARN of the resource that has pending maintenance actions.</p>
    public let resourceIdentifier: String?

    public init (
        pendingMaintenanceActionDetails: [PendingMaintenanceAction]? = nil,
        resourceIdentifier: String? = nil
    )
    {
        self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct RestoreDBClusterFromSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "RestoreDBClusterFromSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterFromSnapshotOutputError>
}

extension RestoreDBClusterFromSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBClusterFromSnapshotInput(availabilityZones: \(String(describing: availabilityZones)), copyTagsToSnapshot: \(String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), databaseName: \(String(describing: databaseName)), deletionProtection: \(String(describing: deletionProtection)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), kmsKeyId: \(String(describing: kmsKeyId)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), snapshotIdentifier: \(String(describing: snapshotIdentifier)), tags: \(String(describing: tags)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBClusterFromSnapshotInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: Key("SnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterFromSnapshot", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RestoreDBClusterFromSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreDBClusterFromSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterFromSnapshotOutputError>
}

public struct RestoreDBClusterFromSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreDBClusterFromSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterFromSnapshotOutputError>
}

public struct RestoreDBClusterFromSnapshotInput: Equatable {
    /// <p>Provides the list of EC2 Availability Zones that instances in the restored DB cluster can
    ///       be created in.</p>
    public let availabilityZones: [String]?
    /// <p>
    ///             <i>If set to <code>true</code>, tags are copied to any snapshot of
    ///       the restored DB cluster that is created.</i>
    ///          </p>
    public let copyTagsToSnapshot: Bool?
    /// <p>The name of the DB cluster to create from the DB snapshot or DB cluster snapshot. This
    ///       parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-snapshot-id</code>
    ///          </p>
    public let dBClusterIdentifier: String?
    /// <p>The name of the DB cluster parameter group to associate with the new DB cluster.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?
    /// <p>The name of the DB subnet group to use for the new DB cluster.</p>
    ///          <p>Constraints: If supplied, must match the name of an existing DBSubnetGroup.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>Not supported.</p>
    public let databaseName: String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is disabled.
    ///     </p>
    public let deletionProtection: Bool?
    /// <p>The list of logs that the restored DB cluster is to export to Amazon CloudWatch Logs.</p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>True to enable mapping of Amazon Identity and Access Management (IAM) accounts to database
    ///       accounts, and otherwise false.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>The database engine to use for the new DB cluster.</p>
    ///          <p>Default: The same as source</p>
    ///          <p>Constraint: Must be compatible with the engine of the source</p>
    public let engine: String?
    /// <p>The version of the database engine to use for the new DB cluster.</p>
    public let engineVersion: String?
    /// <p>The Amazon KMS key identifier to use when restoring an encrypted DB cluster from a DB
    ///       snapshot or DB cluster snapshot.</p>
    ///          <p>The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If
    ///       you are restoring a DB cluster with the same Amazon account that owns the KMS encryption key used
    ///       to encrypt the new DB cluster, then you can use the KMS key alias instead of the ARN for the
    ///       KMS encryption key.</p>
    ///          <p>If you do not specify a value for the <code>KmsKeyId</code> parameter, then the following
    ///       will occur:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the DB snapshot or DB cluster snapshot in <code>SnapshotIdentifier</code> is
    ///           encrypted, then the restored DB cluster is encrypted using the KMS key that was used to
    ///           encrypt the DB snapshot or DB cluster snapshot.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the DB snapshot or DB cluster snapshot in <code>SnapshotIdentifier</code> is not
    ///           encrypted, then the restored DB cluster is not encrypted.</p>
    ///             </li>
    ///          </ul>
    public let kmsKeyId: String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let optionGroupName: String?
    /// <p>The port number on which the new DB cluster accepts connections.</p>
    ///          <p>Constraints: Value must be <code>1150-65535</code>
    ///          </p>
    ///          <p>Default: The same port as the original DB cluster.</p>
    public let port: Int?
    /// <p>The identifier for the DB snapshot or DB cluster snapshot to restore from.</p>
    ///          <p>You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster
    ///       snapshot. However, you can use only the ARN to specify a DB snapshot.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing Snapshot.</p>
    ///             </li>
    ///          </ul>
    public let snapshotIdentifier: String?
    /// <p>The tags to be assigned to the restored DB cluster.</p>
    public let tags: [Tag]?
    /// <p>A list of VPC security groups that the new DB cluster will belong to.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        availabilityZones: [String]? = nil,
        copyTagsToSnapshot: Bool? = nil,
        dBClusterIdentifier: String? = nil,
        dBClusterParameterGroupName: String? = nil,
        dBSubnetGroupName: String? = nil,
        databaseName: String? = nil,
        deletionProtection: Bool? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        kmsKeyId: String? = nil,
        optionGroupName: String? = nil,
        port: Int? = nil,
        snapshotIdentifier: String? = nil,
        tags: [Tag]? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.port = port
        self.snapshotIdentifier = snapshotIdentifier
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBClusterFromSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterFromSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBClusterCapacityFault" : self = .insufficientDBClusterCapacityFault(try InsufficientDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacityFault" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotStateFault" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterFromSnapshotOutputError: Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case insufficientDBClusterCapacityFault(InsufficientDBClusterCapacityFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterFromSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBClusterFromSnapshotOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension RestoreDBClusterFromSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreDBClusterFromSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterFromSnapshotOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterFromSnapshotOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension RestoreDBClusterFromSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RestoreDBClusterFromSnapshotResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct RestoreDBClusterToPointInTimeInputBodyMiddleware: Middleware {
    public let id: String = "RestoreDBClusterToPointInTimeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterToPointInTimeOutputError>
}

extension RestoreDBClusterToPointInTimeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBClusterToPointInTimeInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(String(describing: dBSubnetGroupName)), deletionProtection: \(String(describing: deletionProtection)), enableCloudwatchLogsExports: \(String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(String(describing: enableIAMDatabaseAuthentication)), kmsKeyId: \(String(describing: kmsKeyId)), optionGroupName: \(String(describing: optionGroupName)), port: \(String(describing: port)), restoreToTime: \(String(describing: restoreToTime)), restoreType: \(String(describing: restoreType)), sourceDBClusterIdentifier: \(String(describing: sourceDBClusterIdentifier)), tags: \(String(describing: tags)), useLatestRestorableTime: \(String(describing: useLatestRestorableTime)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBClusterToPointInTimeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: Key("DeletionProtection"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: Key("EnableIAMDatabaseAuthentication"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let restoreToTime = restoreToTime {
            try container.encode(TimestampWrapper(restoreToTime, format: .dateTime), forKey: Key("restoreToTime"))
        }
        if let restoreType = restoreType {
            try container.encode(restoreType, forKey: Key("RestoreType"))
        }
        if let sourceDBClusterIdentifier = sourceDBClusterIdentifier {
            try container.encode(sourceDBClusterIdentifier, forKey: Key("SourceDBClusterIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if useLatestRestorableTime != false {
            try container.encode(useLatestRestorableTime, forKey: Key("UseLatestRestorableTime"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterToPointInTime", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct RestoreDBClusterToPointInTimeInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreDBClusterToPointInTimeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterToPointInTimeOutputError>
}

public struct RestoreDBClusterToPointInTimeInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreDBClusterToPointInTimeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDBClusterToPointInTimeOutputError>
}

public struct RestoreDBClusterToPointInTimeInput: Equatable {
    /// <p>The name of the new DB cluster to be created.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: String?
    /// <p>The name of the DB cluster parameter group to associate with the new DB cluster.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: String?
    /// <p>The DB subnet group name to use for the new DB cluster.</p>
    ///          <p>Constraints: If supplied, must match the name of an existing DBSubnetGroup.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is disabled.
    ///     </p>
    public let deletionProtection: Bool?
    /// <p>The list of logs that the restored DB cluster is to export to CloudWatch Logs.</p>
    public let enableCloudwatchLogsExports: [String]?
    /// <p>True to enable mapping of Amazon Identity and Access Management (IAM) accounts to database
    ///       accounts, and otherwise false.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Bool?
    /// <p>The Amazon KMS key identifier to use when restoring an encrypted DB cluster from an encrypted
    ///       DB cluster.</p>
    ///          <p>The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If
    ///       you are restoring a DB cluster with the same Amazon account that owns the KMS encryption key used
    ///       to encrypt the new DB cluster, then you can use the KMS key alias instead of the ARN for the
    ///       KMS encryption key.</p>
    ///          <p>You can restore to a new DB cluster and encrypt the new DB cluster with a KMS key that is
    ///       different than the KMS key used to encrypt the source DB cluster. The new DB cluster is
    ///       encrypted with the KMS key identified by the <code>KmsKeyId</code> parameter.</p>
    ///          <p>If you do not specify a value for the <code>KmsKeyId</code> parameter, then the following
    ///       will occur:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the DB cluster is encrypted, then the restored DB cluster is encrypted using the
    ///           KMS key that was used to encrypt the source DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the DB cluster is not encrypted, then the restored DB cluster is not
    ///           encrypted.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If <code>DBClusterIdentifier</code> refers to a DB cluster that is not encrypted, then the
    ///       restore request is rejected.</p>
    public let kmsKeyId: String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let optionGroupName: String?
    /// <p>The port number on which the new DB cluster accepts connections.</p>
    ///          <p>Constraints: Value must be <code>1150-65535</code>
    ///          </p>
    ///          <p>Default: The same port as the original DB cluster.</p>
    public let port: Int?
    /// <p>The date and time to restore the DB cluster to.</p>
    ///          <p>Valid Values: Value must be a time in Universal Coordinated Time (UTC) format</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be before the latest restorable time for the DB instance</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be specified if <code>UseLatestRestorableTime</code> parameter is not
    ///           provided</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be specified if <code>UseLatestRestorableTime</code> parameter is true</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be specified if <code>RestoreType</code> parameter is
    ///           <code>copy-on-write</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>2015-03-07T23:45:00Z</code>
    ///          </p>
    public let restoreToTime: Date?
    /// <p>The type of restore to be performed. You can specify one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>full-copy</code> - The new DB cluster is restored as a full copy of the source
    ///           DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>copy-on-write</code> - The new DB cluster is restored as a clone of the source
    ///           DB cluster.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify a <code>RestoreType</code> value, then the new DB cluster is restored
    ///       as a full copy of the source DB cluster.</p>
    public let restoreType: String?
    /// <p>The identifier of the source DB cluster from which to restore.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    public let sourceDBClusterIdentifier: String?
    /// <p>The tags to be applied to the restored DB cluster.</p>
    public let tags: [Tag]?
    /// <p>A value that is set to <code>true</code> to restore the DB cluster to the latest
    ///       restorable backup time, and <code>false</code> otherwise.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    ///          <p>Constraints: Cannot be specified if <code>RestoreToTime</code> parameter is
    ///       provided.</p>
    public let useLatestRestorableTime: Bool
    /// <p>A list of VPC security groups that the new DB cluster belongs to.</p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        dBClusterIdentifier: String? = nil,
        dBClusterParameterGroupName: String? = nil,
        dBSubnetGroupName: String? = nil,
        deletionProtection: Bool? = nil,
        enableCloudwatchLogsExports: [String]? = nil,
        enableIAMDatabaseAuthentication: Bool? = nil,
        kmsKeyId: String? = nil,
        optionGroupName: String? = nil,
        port: Int? = nil,
        restoreToTime: Date? = nil,
        restoreType: String? = nil,
        sourceDBClusterIdentifier: String? = nil,
        tags: [Tag]? = nil,
        useLatestRestorableTime: Bool = false,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.port = port
        self.restoreToTime = restoreToTime
        self.restoreType = restoreType
        self.sourceDBClusterIdentifier = sourceDBClusterIdentifier
        self.tags = tags
        self.useLatestRestorableTime = useLatestRestorableTime
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBClusterToPointInTimeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterToPointInTimeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBClusterCapacityFault" : self = .insufficientDBClusterCapacityFault(try InsufficientDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacityFault" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotStateFault" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterToPointInTimeOutputError: Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case insufficientDBClusterCapacityFault(InsufficientDBClusterCapacityFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterToPointInTimeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDBClusterToPointInTimeOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension RestoreDBClusterToPointInTimeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreDBClusterToPointInTimeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterToPointInTimeOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterToPointInTimeOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension RestoreDBClusterToPointInTimeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RestoreDBClusterToPointInTimeResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension SNSInvalidTopicFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSInvalidTopicFault(message: \(String(describing: message)))"}
}

extension SNSInvalidTopicFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SNSInvalidTopicFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The SNS topic is invalid.</p>
public struct SNSInvalidTopicFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SNSInvalidTopicFaultBody: Equatable {
    public let message: String?
}

extension SNSInvalidTopicFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSNoAuthorizationFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSNoAuthorizationFault(message: \(String(describing: message)))"}
}

extension SNSNoAuthorizationFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SNSNoAuthorizationFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no SNS authorization.</p>
public struct SNSNoAuthorizationFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SNSNoAuthorizationFaultBody: Equatable {
    public let message: String?
}

extension SNSNoAuthorizationFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSTopicArnNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSTopicArnNotFoundFault(message: \(String(describing: message)))"}
}

extension SNSTopicArnNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SNSTopicArnNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The ARN of the SNS topic could not be found.</p>
public struct SNSTopicArnNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SNSTopicArnNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SNSTopicArnNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SharedSnapshotQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SharedSnapshotQuotaExceededFault(message: \(String(describing: message)))"}
}

extension SharedSnapshotQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SharedSnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.</p>
public struct SharedSnapshotQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SharedSnapshotQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension SharedSnapshotQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotQuotaExceededFault(message: \(String(describing: message)))"}
}

extension SnapshotQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed number of DB snapshots.</p>
public struct SnapshotQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension SnapshotQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceNotFoundFault(message: \(String(describing: message)))"}
}

extension SourceNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The source could not be found.</p>
public struct SourceNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SourceNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SourceNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SourceType {
    case dbCluster
    case dbClusterSnapshot
    case dbInstance
    case dbParameterGroup
    case dbSecurityGroup
    case dbSnapshot
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .dbCluster,
            .dbClusterSnapshot,
            .dbInstance,
            .dbParameterGroup,
            .dbSecurityGroup,
            .dbSnapshot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dbCluster: return "db-cluster"
        case .dbClusterSnapshot: return "db-cluster-snapshot"
        case .dbInstance: return "db-instance"
        case .dbParameterGroup: return "db-parameter-group"
        case .dbSecurityGroup: return "db-security-group"
        case .dbSnapshot: return "db-snapshot"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

public struct StartDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "StartDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBClusterOutputError>
}

extension StartDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)))"}
}

extension StartDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        try container.encode("StartDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct StartDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "StartDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBClusterOutputError>
}

public struct StartDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDBClusterOutputError>
}

public struct StartDBClusterInput: Equatable {
    /// <p>The DB cluster identifier of the Neptune DB cluster to be started.
    ///       This parameter is stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?

    public init (
        dBClusterIdentifier: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension StartDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension StartDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct StartDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct StartDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension StartDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("StartDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct StopDBClusterInputBodyMiddleware: Middleware {
    public let id: String = "StopDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBClusterOutputError>
}

extension StopDBClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDBClusterInput(dBClusterIdentifier: \(String(describing: dBClusterIdentifier)))"}
}

extension StopDBClusterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: Key("DBClusterIdentifier"))
        }
        try container.encode("StopDBCluster", forKey:Key("Action"))
        try container.encode("2014-10-31", forKey:Key("Version"))
    }
}

public struct StopDBClusterInputHeadersMiddleware: Middleware {
    public let id: String = "StopDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBClusterOutputError>
}

public struct StopDBClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "StopDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDBClusterOutputError>
}

public struct StopDBClusterInput: Equatable {
    /// <p>The DB cluster identifier of the Neptune DB cluster to be stopped.
    ///       This parameter is stored as a lowercase string.</p>
    public let dBClusterIdentifier: String?

    public init (
        dBClusterIdentifier: String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension StopDBClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopDBClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDBClusterOutputError: Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDBClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDBClusterOutputResponse(dBCluster: \(String(describing: dBCluster)))"}
}

extension StopDBClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct StopDBClusterOutputResponse: Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: DBCluster?

    public init (
        dBCluster: DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct StopDBClusterOutputResponseBody: Equatable {
    public let dBCluster: DBCluster?
}

extension StopDBClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("StopDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension StorageQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageQuotaExceededFault(message: \(String(describing: message)))"}
}

extension StorageQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<StorageQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed amount of storage available across all DB instances.</p>
public struct StorageQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StorageQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension StorageQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StorageTypeNotSupportedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageTypeNotSupportedFault(message: \(String(describing: message)))"}
}

extension StorageTypeNotSupportedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<StorageTypeNotSupportedFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>StorageType</i> specified cannot be associated with the DB Instance.</p>
public struct StorageTypeNotSupportedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StorageTypeNotSupportedFaultBody: Equatable {
    public let message: String?
}

extension StorageTypeNotSupportedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Subnet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try container.encode(subnetAvailabilityZone, forKey: Key("SubnetAvailabilityZone"))
        }
        if let subnetIdentifier = subnetIdentifier {
            try container.encode(subnetIdentifier, forKey: Key("SubnetIdentifier"))
        }
        if let subnetStatus = subnetStatus {
            try container.encode(subnetStatus, forKey: Key("SubnetStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(AvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension Subnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subnet(subnetAvailabilityZone: \(String(describing: subnetAvailabilityZone)), subnetIdentifier: \(String(describing: subnetIdentifier)), subnetStatus: \(String(describing: subnetStatus)))"}
}

/// <p>Specifies a subnet.</p>
///          <p> This data type is used as a response element in the <a>DescribeDBSubnetGroups</a> action.</p>
public struct Subnet: Equatable {
    /// <p>Specifies the EC2 Availability Zone that the subnet is in.</p>
    public let subnetAvailabilityZone: AvailabilityZone?
    /// <p>Specifies the identifier of the subnet.</p>
    public let subnetIdentifier: String?
    /// <p>Specifies the status of the subnet.</p>
    public let subnetStatus: String?

    public init (
        subnetAvailabilityZone: AvailabilityZone? = nil,
        subnetIdentifier: String? = nil,
        subnetStatus: String? = nil
    )
    {
        self.subnetAvailabilityZone = subnetAvailabilityZone
        self.subnetIdentifier = subnetIdentifier
        self.subnetStatus = subnetStatus
    }
}

extension SubnetAlreadyInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetAlreadyInUse(message: \(String(describing: message)))"}
}

extension SubnetAlreadyInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubnetAlreadyInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB subnet is already in use in the Availability Zone.</p>
public struct SubnetAlreadyInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetAlreadyInUseBody: Equatable {
    public let message: String?
}

extension SubnetAlreadyInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionAlreadyExistFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionAlreadyExistFault(message: \(String(describing: message)))"}
}

extension SubscriptionAlreadyExistFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionAlreadyExistFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This subscription already exists.</p>
public struct SubscriptionAlreadyExistFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionAlreadyExistFaultBody: Equatable {
    public let message: String?
}

extension SubscriptionAlreadyExistFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionCategoryNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionCategoryNotFoundFault(message: \(String(describing: message)))"}
}

extension SubscriptionCategoryNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionCategoryNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The designated subscription category could not be found.</p>
public struct SubscriptionCategoryNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionCategoryNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SubscriptionCategoryNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionNotFoundFault(message: \(String(describing: message)))"}
}

extension SubscriptionNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionNotFoundFaultBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The designated subscription could not be found.</p>
public struct SubscriptionNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SubscriptionNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Metadata assigned to an Amazon Neptune resource consisting of a key-value pair.</p>
public struct Tag: Equatable {
    /// <p>A key is the required name of the tag. The string value can be from 1 to 128 Unicode
    ///       characters in length and can't be prefixed with "aws:" or "rds:". The string can only contain
    ///       only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java
    ///       regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").</p>
    public let key: String?
    /// <p>A value is the optional value of the tag. The string value can be from 1 to 256 Unicode
    ///       characters in length and can't be prefixed with "aws:" or "rds:". The string can only contain
    ///       only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java
    ///       regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension Timezone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timezoneName = "TimezoneName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let timezoneName = timezoneName {
            try container.encode(timezoneName, forKey: Key("TimezoneName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timezoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezoneName)
        timezoneName = timezoneNameDecoded
    }
}

extension Timezone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Timezone(timezoneName: \(String(describing: timezoneName)))"}
}

/// <p>A time zone associated with a <a>DBInstance</a>.</p>
public struct Timezone: Equatable {
    /// <p>The name of the time zone.</p>
    public let timezoneName: String?

    public init (
        timezoneName: String? = nil
    )
    {
        self.timezoneName = timezoneName
    }
}

extension UpgradeTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoUpgrade = "AutoUpgrade"
        case description = "Description"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case isMajorVersionUpgrade = "IsMajorVersionUpgrade"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if autoUpgrade != false {
            try container.encode(autoUpgrade, forKey: Key("AutoUpgrade"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: Key("EngineVersion"))
        }
        if isMajorVersionUpgrade != false {
            try container.encode(isMajorVersionUpgrade, forKey: Key("IsMajorVersionUpgrade"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let autoUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoUpgrade)
        autoUpgrade = autoUpgradeDecoded
        let isMajorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .isMajorVersionUpgrade)
        isMajorVersionUpgrade = isMajorVersionUpgradeDecoded
    }
}

extension UpgradeTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpgradeTarget(autoUpgrade: \(String(describing: autoUpgrade)), description: \(String(describing: description)), engine: \(String(describing: engine)), engineVersion: \(String(describing: engineVersion)), isMajorVersionUpgrade: \(String(describing: isMajorVersionUpgrade)))"}
}

/// <p>The version of the database engine that a DB instance can be upgraded to.</p>
public struct UpgradeTarget: Equatable {
    /// <p>A value that indicates whether the target version is applied to any source DB instances
    ///       that have AutoMinorVersionUpgrade set to true.</p>
    public let autoUpgrade: Bool
    /// <p>The version of the database engine that a DB instance can be upgraded to.</p>
    public let description: String?
    /// <p>The name of the upgrade target database engine.</p>
    public let engine: String?
    /// <p>The version number of the upgrade target database engine.</p>
    public let engineVersion: String?
    /// <p>A value that indicates whether a database engine is upgraded to a major version.</p>
    public let isMajorVersionUpgrade: Bool

    public init (
        autoUpgrade: Bool = false,
        description: String? = nil,
        engine: String? = nil,
        engineVersion: String? = nil,
        isMajorVersionUpgrade: Bool = false
    )
    {
        self.autoUpgrade = autoUpgrade
        self.description = description
        self.engine = engine
        self.engineVersion = engineVersion
        self.isMajorVersionUpgrade = isMajorVersionUpgrade
    }
}

extension ValidDBInstanceModificationsMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case storage = "Storage"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let storage = storage {
            var storageContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Storage"))
            for (index0, validstorageoptions0) in storage.enumerated() {
                try storageContainer.encode(validstorageoptions0, forKey: Key("ValidStorageOptions.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.storage) {
            struct KeyVal0{struct ValidStorageOptions{}}
            let storageWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ValidStorageOptions>.CodingKeys.self, forKey: .storage)
            if let storageWrappedContainer = storageWrappedContainer {
                let storageContainer = try storageWrappedContainer.decodeIfPresent([ValidStorageOptions].self, forKey: .member)
                var storageBuffer:[ValidStorageOptions]? = nil
                if let storageContainer = storageContainer {
                    storageBuffer = [ValidStorageOptions]()
                    for structureContainer0 in storageContainer {
                        storageBuffer?.append(structureContainer0)
                    }
                }
                storage = storageBuffer
            } else {
                storage = []
            }
        } else {
            storage = nil
        }
    }
}

extension ValidDBInstanceModificationsMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidDBInstanceModificationsMessage(storage: \(String(describing: storage)))"}
}

/// <p>Information about valid modifications that you can make to your DB instance. Contains the
///       result of a successful call to the <a>DescribeValidDBInstanceModifications</a>
///       action. You can use this information when you call <a>ModifyDBInstance</a>.
///    </p>
public struct ValidDBInstanceModificationsMessage: Equatable {
    /// <p>Valid storage options for your DB instance.</p>
    public let storage: [ValidStorageOptions]?

    public init (
        storage: [ValidStorageOptions]? = nil
    )
    {
        self.storage = storage
    }
}

extension ValidStorageOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iopsToStorageRatio = "IopsToStorageRatio"
        case provisionedIops = "ProvisionedIops"
        case storageSize = "StorageSize"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let iopsToStorageRatio = iopsToStorageRatio {
            var iopsToStorageRatioContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("IopsToStorageRatio"))
            for (index0, doublerange0) in iopsToStorageRatio.enumerated() {
                try iopsToStorageRatioContainer.encode(doublerange0, forKey: Key("DoubleRange.\(index0.advanced(by: 1))"))
            }
        }
        if let provisionedIops = provisionedIops {
            var provisionedIopsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProvisionedIops"))
            for (index0, range0) in provisionedIops.enumerated() {
                try provisionedIopsContainer.encode(range0, forKey: Key("Range.\(index0.advanced(by: 1))"))
            }
        }
        if let storageSize = storageSize {
            var storageSizeContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StorageSize"))
            for (index0, range0) in storageSize.enumerated() {
                try storageSizeContainer.encode(range0, forKey: Key("Range.\(index0.advanced(by: 1))"))
            }
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: Key("StorageType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        if containerValues.contains(.storageSize) {
            struct KeyVal0{struct Range{}}
            let storageSizeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Range>.CodingKeys.self, forKey: .storageSize)
            if let storageSizeWrappedContainer = storageSizeWrappedContainer {
                let storageSizeContainer = try storageSizeWrappedContainer.decodeIfPresent([Range].self, forKey: .member)
                var storageSizeBuffer:[Range]? = nil
                if let storageSizeContainer = storageSizeContainer {
                    storageSizeBuffer = [Range]()
                    for structureContainer0 in storageSizeContainer {
                        storageSizeBuffer?.append(structureContainer0)
                    }
                }
                storageSize = storageSizeBuffer
            } else {
                storageSize = []
            }
        } else {
            storageSize = nil
        }
        if containerValues.contains(.provisionedIops) {
            struct KeyVal0{struct Range{}}
            let provisionedIopsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Range>.CodingKeys.self, forKey: .provisionedIops)
            if let provisionedIopsWrappedContainer = provisionedIopsWrappedContainer {
                let provisionedIopsContainer = try provisionedIopsWrappedContainer.decodeIfPresent([Range].self, forKey: .member)
                var provisionedIopsBuffer:[Range]? = nil
                if let provisionedIopsContainer = provisionedIopsContainer {
                    provisionedIopsBuffer = [Range]()
                    for structureContainer0 in provisionedIopsContainer {
                        provisionedIopsBuffer?.append(structureContainer0)
                    }
                }
                provisionedIops = provisionedIopsBuffer
            } else {
                provisionedIops = []
            }
        } else {
            provisionedIops = nil
        }
        if containerValues.contains(.iopsToStorageRatio) {
            struct KeyVal0{struct DoubleRange{}}
            let iopsToStorageRatioWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DoubleRange>.CodingKeys.self, forKey: .iopsToStorageRatio)
            if let iopsToStorageRatioWrappedContainer = iopsToStorageRatioWrappedContainer {
                let iopsToStorageRatioContainer = try iopsToStorageRatioWrappedContainer.decodeIfPresent([DoubleRange].self, forKey: .member)
                var iopsToStorageRatioBuffer:[DoubleRange]? = nil
                if let iopsToStorageRatioContainer = iopsToStorageRatioContainer {
                    iopsToStorageRatioBuffer = [DoubleRange]()
                    for structureContainer0 in iopsToStorageRatioContainer {
                        iopsToStorageRatioBuffer?.append(structureContainer0)
                    }
                }
                iopsToStorageRatio = iopsToStorageRatioBuffer
            } else {
                iopsToStorageRatio = []
            }
        } else {
            iopsToStorageRatio = nil
        }
    }
}

extension ValidStorageOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidStorageOptions(iopsToStorageRatio: \(String(describing: iopsToStorageRatio)), provisionedIops: \(String(describing: provisionedIops)), storageSize: \(String(describing: storageSize)), storageType: \(String(describing: storageType)))"}
}

/// <p>Information about valid modifications that you can make to your DB
///       instance.</p>
///          <p>Contains the result of a successful call to the <a>DescribeValidDBInstanceModifications</a> action.</p>
public struct ValidStorageOptions: Equatable {
    /// <p>The valid range of Provisioned IOPS to gibibytes of storage multiplier. For example, 3-10,
    ///       which means that provisioned IOPS can be between 3 and 10 times storage.</p>
    public let iopsToStorageRatio: [DoubleRange]?
    /// <p>The valid range of provisioned IOPS. For example, 1000-20000.</p>
    public let provisionedIops: [Range]?
    /// <p>The valid range of storage in gibibytes. For example, 100 to 16384.</p>
    public let storageSize: [Range]?
    /// <p>The valid storage types for your DB instance. For example, gp2, io1.</p>
    public let storageType: String?

    public init (
        iopsToStorageRatio: [DoubleRange]? = nil,
        provisionedIops: [Range]? = nil,
        storageSize: [Range]? = nil,
        storageType: String? = nil
    )
    {
        self.iopsToStorageRatio = iopsToStorageRatio
        self.provisionedIops = provisionedIops
        self.storageSize = storageSize
        self.storageType = storageType
    }
}

extension VpcSecurityGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let vpcSecurityGroupId = vpcSecurityGroupId {
            try container.encode(vpcSecurityGroupId, forKey: Key("VpcSecurityGroupId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension VpcSecurityGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcSecurityGroupMembership(status: \(String(describing: status)), vpcSecurityGroupId: \(String(describing: vpcSecurityGroupId)))"}
}

/// <p>This data type is used as a response element for queries on VPC security group
///       membership.</p>
public struct VpcSecurityGroupMembership: Equatable {
    /// <p>The status of the VPC security group.</p>
    public let status: String?
    /// <p>The name of the VPC security group.</p>
    public let vpcSecurityGroupId: String?

    public init (
        status: String? = nil,
        vpcSecurityGroupId: String? = nil
    )
    {
        self.status = status
        self.vpcSecurityGroupId = vpcSecurityGroupId
    }
}
