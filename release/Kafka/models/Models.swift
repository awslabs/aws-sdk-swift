// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(invalidParameter: \(String(describing: invalidParameter)), message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returns information about an error.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The parameter that caused the error.</p>
    public var invalidParameter: String?
    /// <p>The description of the error.</p>
    public var message: String?

    public init (
        invalidParameter: String? = nil,
        message: String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let invalidParameter: String?
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct BatchAssociateScramSecretInputBodyMiddleware: Middleware {
    public let id: String = "BatchAssociateScramSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateScramSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateScramSecretInput>
    public typealias MOutput = OperationOutput<BatchAssociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateScramSecretOutputError>
}

extension BatchAssociateScramSecretInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateScramSecretInput(clusterArn: \(String(describing: clusterArn)), secretArnList: \(String(describing: secretArnList)))"}
}

extension BatchAssociateScramSecretInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretArnList = "secretArnList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretArnList = secretArnList {
            var secretArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secretArnList)
            for __listof__string0 in secretArnList {
                try secretArnListContainer.encode(__listof__string0)
            }
        }
    }
}

public struct BatchAssociateScramSecretInputHeadersMiddleware: Middleware {
    public let id: String = "BatchAssociateScramSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateScramSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateScramSecretInput>
    public typealias MOutput = OperationOutput<BatchAssociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateScramSecretOutputError>
}

public struct BatchAssociateScramSecretInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchAssociateScramSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateScramSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateScramSecretInput>
    public typealias MOutput = OperationOutput<BatchAssociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateScramSecretOutputError>
}

/// <p>Associates sasl scram secrets to cluster.</p>
public struct BatchAssociateScramSecretInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
    public let clusterArn: String?
    /// <p>List of AWS Secrets Manager secret ARNs.</p>
    public let secretArnList: [String]?

    public init (
        clusterArn: String? = nil,
        secretArnList: [String]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.secretArnList = secretArnList
    }
}

struct BatchAssociateScramSecretInputBody: Equatable {
    public let secretArnList: [String]?
}

extension BatchAssociateScramSecretInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretArnList = "secretArnList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretArnListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .secretArnList)
        var secretArnListDecoded0:[String]? = nil
        if let secretArnListContainer = secretArnListContainer {
            secretArnListDecoded0 = [String]()
            for string0 in secretArnListContainer {
                if let string0 = string0 {
                    secretArnListDecoded0?.append(string0)
                }
            }
        }
        secretArnList = secretArnListDecoded0
    }
}

extension BatchAssociateScramSecretOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateScramSecretOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateScramSecretOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateScramSecretOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateScramSecretOutputResponse(clusterArn: \(String(describing: clusterArn)), unprocessedScramSecrets: \(String(describing: unprocessedScramSecrets)))"}
}

extension BatchAssociateScramSecretOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchAssociateScramSecretOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterArn = output.clusterArn
            self.unprocessedScramSecrets = output.unprocessedScramSecrets
        } else {
            self.clusterArn = nil
            self.unprocessedScramSecrets = nil
        }
    }
}

public struct BatchAssociateScramSecretOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterArn: String?
    /// <p>List of errors when associating secrets to cluster.</p>
    public let unprocessedScramSecrets: [UnprocessedScramSecret]?

    public init (
        clusterArn: String? = nil,
        unprocessedScramSecrets: [UnprocessedScramSecret]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.unprocessedScramSecrets = unprocessedScramSecrets
    }
}

struct BatchAssociateScramSecretOutputResponseBody: Equatable {
    public let clusterArn: String?
    public let unprocessedScramSecrets: [UnprocessedScramSecret]?
}

extension BatchAssociateScramSecretOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterArn = "clusterArn"
        case unprocessedScramSecrets = "unprocessedScramSecrets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let unprocessedScramSecretsContainer = try containerValues.decodeIfPresent([UnprocessedScramSecret?].self, forKey: .unprocessedScramSecrets)
        var unprocessedScramSecretsDecoded0:[UnprocessedScramSecret]? = nil
        if let unprocessedScramSecretsContainer = unprocessedScramSecretsContainer {
            unprocessedScramSecretsDecoded0 = [UnprocessedScramSecret]()
            for structure0 in unprocessedScramSecretsContainer {
                if let structure0 = structure0 {
                    unprocessedScramSecretsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedScramSecrets = unprocessedScramSecretsDecoded0
    }
}

public struct BatchDisassociateScramSecretInputBodyMiddleware: Middleware {
    public let id: String = "BatchDisassociateScramSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateScramSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateScramSecretInput>
    public typealias MOutput = OperationOutput<BatchDisassociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateScramSecretOutputError>
}

extension BatchDisassociateScramSecretInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateScramSecretInput(clusterArn: \(String(describing: clusterArn)), secretArnList: \(String(describing: secretArnList)))"}
}

extension BatchDisassociateScramSecretInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretArnList = "secretArnList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretArnList = secretArnList {
            var secretArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secretArnList)
            for __listof__string0 in secretArnList {
                try secretArnListContainer.encode(__listof__string0)
            }
        }
    }
}

public struct BatchDisassociateScramSecretInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDisassociateScramSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateScramSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateScramSecretInput>
    public typealias MOutput = OperationOutput<BatchDisassociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateScramSecretOutputError>
}

public struct BatchDisassociateScramSecretInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDisassociateScramSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateScramSecretInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateScramSecretInput>
    public typealias MOutput = OperationOutput<BatchDisassociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateScramSecretOutputError>
}

/// <p>Disassociates sasl scram secrets to cluster.</p>
public struct BatchDisassociateScramSecretInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
    public let clusterArn: String?
    /// <p>List of AWS Secrets Manager secret ARNs.</p>
    public let secretArnList: [String]?

    public init (
        clusterArn: String? = nil,
        secretArnList: [String]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.secretArnList = secretArnList
    }
}

struct BatchDisassociateScramSecretInputBody: Equatable {
    public let secretArnList: [String]?
}

extension BatchDisassociateScramSecretInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretArnList = "secretArnList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretArnListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .secretArnList)
        var secretArnListDecoded0:[String]? = nil
        if let secretArnListContainer = secretArnListContainer {
            secretArnListDecoded0 = [String]()
            for string0 in secretArnListContainer {
                if let string0 = string0 {
                    secretArnListDecoded0?.append(string0)
                }
            }
        }
        secretArnList = secretArnListDecoded0
    }
}

extension BatchDisassociateScramSecretOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateScramSecretOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateScramSecretOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateScramSecretOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateScramSecretOutputResponse(clusterArn: \(String(describing: clusterArn)), unprocessedScramSecrets: \(String(describing: unprocessedScramSecrets)))"}
}

extension BatchDisassociateScramSecretOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDisassociateScramSecretOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterArn = output.clusterArn
            self.unprocessedScramSecrets = output.unprocessedScramSecrets
        } else {
            self.clusterArn = nil
            self.unprocessedScramSecrets = nil
        }
    }
}

public struct BatchDisassociateScramSecretOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterArn: String?
    /// <p>List of errors when disassociating secrets to cluster.</p>
    public let unprocessedScramSecrets: [UnprocessedScramSecret]?

    public init (
        clusterArn: String? = nil,
        unprocessedScramSecrets: [UnprocessedScramSecret]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.unprocessedScramSecrets = unprocessedScramSecrets
    }
}

struct BatchDisassociateScramSecretOutputResponseBody: Equatable {
    public let clusterArn: String?
    public let unprocessedScramSecrets: [UnprocessedScramSecret]?
}

extension BatchDisassociateScramSecretOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterArn = "clusterArn"
        case unprocessedScramSecrets = "unprocessedScramSecrets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let unprocessedScramSecretsContainer = try containerValues.decodeIfPresent([UnprocessedScramSecret?].self, forKey: .unprocessedScramSecrets)
        var unprocessedScramSecretsDecoded0:[UnprocessedScramSecret]? = nil
        if let unprocessedScramSecretsContainer = unprocessedScramSecretsContainer {
            unprocessedScramSecretsDecoded0 = [UnprocessedScramSecret]()
            for structure0 in unprocessedScramSecretsContainer {
                if let structure0 = structure0 {
                    unprocessedScramSecretsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedScramSecrets = unprocessedScramSecretsDecoded0
    }
}

/// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
///          <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
public enum BrokerAZDistribution {
    case `default`
    case sdkUnknown(String)
}

extension BrokerAZDistribution : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BrokerAZDistribution] {
        return [
            .default,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .default: return "DEFAULT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BrokerAZDistribution(rawValue: rawValue) ?? BrokerAZDistribution.sdkUnknown(rawValue)
    }
}

extension BrokerEBSVolumeInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kafkaBrokerNodeId = "kafkaBrokerNodeId"
        case volumeSizeGB = "volumeSizeGB"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kafkaBrokerNodeId = kafkaBrokerNodeId {
            try encodeContainer.encode(kafkaBrokerNodeId, forKey: .kafkaBrokerNodeId)
        }
        if volumeSizeGB != 0 {
            try encodeContainer.encode(volumeSizeGB, forKey: .volumeSizeGB)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kafkaBrokerNodeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kafkaBrokerNodeId)
        kafkaBrokerNodeId = kafkaBrokerNodeIdDecoded
        let volumeSizeGBDecoded = try containerValues.decode(Int.self, forKey: .volumeSizeGB)
        volumeSizeGB = volumeSizeGBDecoded
    }
}

extension BrokerEBSVolumeInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BrokerEBSVolumeInfo(kafkaBrokerNodeId: \(String(describing: kafkaBrokerNodeId)), volumeSizeGB: \(String(describing: volumeSizeGB)))"}
}

/// <p>Specifies the EBS volume upgrade information. The broker identifier must be set to the keyword ALL. This means the changes apply to all the brokers in the cluster.</p>
public struct BrokerEBSVolumeInfo: Equatable {
    /// <p>The ID of the broker to update.</p>
    public let kafkaBrokerNodeId: String?
    /// <p>Size of the EBS volume to update.</p>
    public let volumeSizeGB: Int

    public init (
        kafkaBrokerNodeId: String? = nil,
        volumeSizeGB: Int = 0
    )
    {
        self.kafkaBrokerNodeId = kafkaBrokerNodeId
        self.volumeSizeGB = volumeSizeGB
    }
}

extension BrokerLogs: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogs = "cloudWatchLogs"
        case firehose = "firehose"
        case s3 = "s3"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let firehose = firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(CloudWatchLogs.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
        let firehoseDecoded = try containerValues.decodeIfPresent(Firehose.self, forKey: .firehose)
        firehose = firehoseDecoded
        let s3Decoded = try containerValues.decodeIfPresent(S3.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension BrokerLogs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BrokerLogs(cloudWatchLogs: \(String(describing: cloudWatchLogs)), firehose: \(String(describing: firehose)), s3: \(String(describing: s3)))"}
}

public struct BrokerLogs: Equatable {
    public let cloudWatchLogs: CloudWatchLogs?
    public let firehose: Firehose?
    public let s3: S3?

    public init (
        cloudWatchLogs: CloudWatchLogs? = nil,
        firehose: Firehose? = nil,
        s3: S3? = nil
    )
    {
        self.cloudWatchLogs = cloudWatchLogs
        self.firehose = firehose
        self.s3 = s3
    }
}

extension BrokerNodeGroupInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case brokerAZDistribution = "brokerAZDistribution"
        case clientSubnets = "clientSubnets"
        case instanceType = "instanceType"
        case securityGroups = "securityGroups"
        case storageInfo = "storageInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerAZDistribution = brokerAZDistribution {
            try encodeContainer.encode(brokerAZDistribution.rawValue, forKey: .brokerAZDistribution)
        }
        if let clientSubnets = clientSubnets {
            var clientSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientSubnets)
            for __listof__string0 in clientSubnets {
                try clientSubnetsContainer.encode(__listof__string0)
            }
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __listof__string0 in securityGroups {
                try securityGroupsContainer.encode(__listof__string0)
            }
        }
        if let storageInfo = storageInfo {
            try encodeContainer.encode(storageInfo, forKey: .storageInfo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerAZDistributionDecoded = try containerValues.decodeIfPresent(BrokerAZDistribution.self, forKey: .brokerAZDistribution)
        brokerAZDistribution = brokerAZDistributionDecoded
        let clientSubnetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .clientSubnets)
        var clientSubnetsDecoded0:[String]? = nil
        if let clientSubnetsContainer = clientSubnetsContainer {
            clientSubnetsDecoded0 = [String]()
            for string0 in clientSubnetsContainer {
                if let string0 = string0 {
                    clientSubnetsDecoded0?.append(string0)
                }
            }
        }
        clientSubnets = clientSubnetsDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let storageInfoDecoded = try containerValues.decodeIfPresent(StorageInfo.self, forKey: .storageInfo)
        storageInfo = storageInfoDecoded
    }
}

extension BrokerNodeGroupInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BrokerNodeGroupInfo(brokerAZDistribution: \(String(describing: brokerAZDistribution)), clientSubnets: \(String(describing: clientSubnets)), instanceType: \(String(describing: instanceType)), securityGroups: \(String(describing: securityGroups)), storageInfo: \(String(describing: storageInfo)))"}
}

/// <p>Describes the setup to be used for Kafka broker nodes in the cluster.</p>
public struct BrokerNodeGroupInfo: Equatable {
    /// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
    ///          <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
    public let brokerAZDistribution: BrokerAZDistribution?
    /// <p>The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't be in Availability Zone us-east-1e.</p>
    public let clientSubnets: [String]?
    /// <p>The type of Amazon EC2 instances to use for Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge,
    /// kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.</p>
    public let instanceType: String?
    /// <p>The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.</p>
    public let securityGroups: [String]?
    /// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
    public let storageInfo: StorageInfo?

    public init (
        brokerAZDistribution: BrokerAZDistribution? = nil,
        clientSubnets: [String]? = nil,
        instanceType: String? = nil,
        securityGroups: [String]? = nil,
        storageInfo: StorageInfo? = nil
    )
    {
        self.brokerAZDistribution = brokerAZDistribution
        self.clientSubnets = clientSubnets
        self.instanceType = instanceType
        self.securityGroups = securityGroups
        self.storageInfo = storageInfo
    }
}

extension BrokerNodeInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachedENIId = "attachedENIId"
        case brokerId = "brokerId"
        case clientSubnet = "clientSubnet"
        case clientVpcIpAddress = "clientVpcIpAddress"
        case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
        case endpoints = "endpoints"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedENIId = attachedENIId {
            try encodeContainer.encode(attachedENIId, forKey: .attachedENIId)
        }
        if brokerId != 0.0 {
            try encodeContainer.encode(brokerId, forKey: .brokerId)
        }
        if let clientSubnet = clientSubnet {
            try encodeContainer.encode(clientSubnet, forKey: .clientSubnet)
        }
        if let clientVpcIpAddress = clientVpcIpAddress {
            try encodeContainer.encode(clientVpcIpAddress, forKey: .clientVpcIpAddress)
        }
        if let currentBrokerSoftwareInfo = currentBrokerSoftwareInfo {
            try encodeContainer.encode(currentBrokerSoftwareInfo, forKey: .currentBrokerSoftwareInfo)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for __listof__string0 in endpoints {
                try endpointsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedENIIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachedENIId)
        attachedENIId = attachedENIIdDecoded
        let brokerIdDecoded = try containerValues.decode(Double.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let clientSubnetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSubnet)
        clientSubnet = clientSubnetDecoded
        let clientVpcIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientVpcIpAddress)
        clientVpcIpAddress = clientVpcIpAddressDecoded
        let currentBrokerSoftwareInfoDecoded = try containerValues.decodeIfPresent(BrokerSoftwareInfo.self, forKey: .currentBrokerSoftwareInfo)
        currentBrokerSoftwareInfo = currentBrokerSoftwareInfoDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .endpoints)
        var endpointsDecoded0:[String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [String]()
            for string0 in endpointsContainer {
                if let string0 = string0 {
                    endpointsDecoded0?.append(string0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension BrokerNodeInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BrokerNodeInfo(attachedENIId: \(String(describing: attachedENIId)), brokerId: \(String(describing: brokerId)), clientSubnet: \(String(describing: clientSubnet)), clientVpcIpAddress: \(String(describing: clientVpcIpAddress)), currentBrokerSoftwareInfo: \(String(describing: currentBrokerSoftwareInfo)), endpoints: \(String(describing: endpoints)))"}
}

/// <p>BrokerNodeInfo</p>
public struct BrokerNodeInfo: Equatable {
    /// <p>The attached elastic network interface of the broker.</p>
    public let attachedENIId: String?
    /// <p>The ID of the broker.</p>
    public let brokerId: Double
    /// <p>The client subnet to which this broker node belongs.</p>
    public let clientSubnet: String?
    /// <p>The virtual private cloud (VPC) of the client.</p>
    public let clientVpcIpAddress: String?
    /// <p>Information about the version of software currently deployed on the Kafka brokers in the cluster.</p>
    public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
    /// <p>Endpoints for accessing the broker.</p>
    public let endpoints: [String]?

    public init (
        attachedENIId: String? = nil,
        brokerId: Double = 0.0,
        clientSubnet: String? = nil,
        clientVpcIpAddress: String? = nil,
        currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil,
        endpoints: [String]? = nil
    )
    {
        self.attachedENIId = attachedENIId
        self.brokerId = brokerId
        self.clientSubnet = clientSubnet
        self.clientVpcIpAddress = clientVpcIpAddress
        self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
        self.endpoints = endpoints
    }
}

extension BrokerSoftwareInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationArn = "configurationArn"
        case configurationRevision = "configurationRevision"
        case kafkaVersion = "kafkaVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationArn = configurationArn {
            try encodeContainer.encode(configurationArn, forKey: .configurationArn)
        }
        if configurationRevision != 0 {
            try encodeContainer.encode(configurationRevision, forKey: .configurationRevision)
        }
        if let kafkaVersion = kafkaVersion {
            try encodeContainer.encode(kafkaVersion, forKey: .kafkaVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationArn)
        configurationArn = configurationArnDecoded
        let configurationRevisionDecoded = try containerValues.decode(Int.self, forKey: .configurationRevision)
        configurationRevision = configurationRevisionDecoded
        let kafkaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kafkaVersion)
        kafkaVersion = kafkaVersionDecoded
    }
}

extension BrokerSoftwareInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BrokerSoftwareInfo(configurationArn: \(String(describing: configurationArn)), configurationRevision: \(String(describing: configurationRevision)), kafkaVersion: \(String(describing: kafkaVersion)))"}
}

/// <p>Information about the current software installed on the cluster.</p>
public struct BrokerSoftwareInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.</p>
    public let configurationArn: String?
    /// <p>The revision of the configuration to use. This field isn't visible in this preview release.</p>
    public let configurationRevision: Int
    /// <p>The version of Apache Kafka.</p>
    public let kafkaVersion: String?

    public init (
        configurationArn: String? = nil,
        configurationRevision: Int = 0,
        kafkaVersion: String? = nil
    )
    {
        self.configurationArn = configurationArn
        self.configurationRevision = configurationRevision
        self.kafkaVersion = kafkaVersion
    }
}

extension ClientAuthentication: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sasl = "sasl"
        case tls = "tls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sasl = sasl {
            try encodeContainer.encode(sasl, forKey: .sasl)
        }
        if let tls = tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let saslDecoded = try containerValues.decodeIfPresent(Sasl.self, forKey: .sasl)
        sasl = saslDecoded
        let tlsDecoded = try containerValues.decodeIfPresent(Tls.self, forKey: .tls)
        tls = tlsDecoded
    }
}

extension ClientAuthentication: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientAuthentication(sasl: \(String(describing: sasl)), tls: \(String(describing: tls)))"}
}

/// <p>Includes all client authentication information.</p>
public struct ClientAuthentication: Equatable {
    /// <p>Details for ClientAuthentication using SASL.</p>
    public let sasl: Sasl?
    /// <p>Details for ClientAuthentication using TLS.</p>
    public let tls: Tls?

    public init (
        sasl: Sasl? = nil,
        tls: Tls? = nil
    )
    {
        self.sasl = sasl
        self.tls = tls
    }
}

/// <p>Client-broker encryption in transit setting.</p>
public enum ClientBroker {
    case plaintext
    case tls
    case tlsPlaintext
    case sdkUnknown(String)
}

extension ClientBroker : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ClientBroker] {
        return [
            .plaintext,
            .tls,
            .tlsPlaintext,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .plaintext: return "PLAINTEXT"
        case .tls: return "TLS"
        case .tlsPlaintext: return "TLS_PLAINTEXT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ClientBroker(rawValue: rawValue) ?? ClientBroker.sdkUnknown(rawValue)
    }
}

extension CloudWatchLogs: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
        case logGroup = "logGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logGroup = logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension CloudWatchLogs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLogs(enabled: \(String(describing: enabled)), logGroup: \(String(describing: logGroup)))"}
}

public struct CloudWatchLogs: Equatable {
    public let enabled: Bool
    public let logGroup: String?

    public init (
        enabled: Bool = false,
        logGroup: String? = nil
    )
    {
        self.enabled = enabled
        self.logGroup = logGroup
    }
}

extension ClusterInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeOperationArn = "activeOperationArn"
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case clusterArn = "clusterArn"
        case clusterName = "clusterName"
        case creationTime = "creationTime"
        case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
        case currentVersion = "currentVersion"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case state = "state"
        case stateInfo = "stateInfo"
        case tags = "tags"
        case zookeeperConnectString = "zookeeperConnectString"
        case zookeeperConnectStringTls = "zookeeperConnectStringTls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeOperationArn = activeOperationArn {
            try encodeContainer.encode(activeOperationArn, forKey: .activeOperationArn)
        }
        if let brokerNodeGroupInfo = brokerNodeGroupInfo {
            try encodeContainer.encode(brokerNodeGroupInfo, forKey: .brokerNodeGroupInfo)
        }
        if let clientAuthentication = clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let clusterArn = clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let currentBrokerSoftwareInfo = currentBrokerSoftwareInfo {
            try encodeContainer.encode(currentBrokerSoftwareInfo, forKey: .currentBrokerSoftwareInfo)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let encryptionInfo = encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if numberOfBrokerNodes != 0 {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateInfo = stateInfo {
            try encodeContainer.encode(stateInfo, forKey: .stateInfo)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let zookeeperConnectString = zookeeperConnectString {
            try encodeContainer.encode(zookeeperConnectString, forKey: .zookeeperConnectString)
        }
        if let zookeeperConnectStringTls = zookeeperConnectStringTls {
            try encodeContainer.encode(zookeeperConnectStringTls, forKey: .zookeeperConnectStringTls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeOperationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activeOperationArn)
        activeOperationArn = activeOperationArnDecoded
        let brokerNodeGroupInfoDecoded = try containerValues.decodeIfPresent(BrokerNodeGroupInfo.self, forKey: .brokerNodeGroupInfo)
        brokerNodeGroupInfo = brokerNodeGroupInfoDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let currentBrokerSoftwareInfoDecoded = try containerValues.decodeIfPresent(BrokerSoftwareInfo.self, forKey: .currentBrokerSoftwareInfo)
        currentBrokerSoftwareInfo = currentBrokerSoftwareInfoDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(OpenMonitoring.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ClusterState.self, forKey: .state)
        state = stateDecoded
        let stateInfoDecoded = try containerValues.decodeIfPresent(StateInfo.self, forKey: .stateInfo)
        stateInfo = stateInfoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let zookeeperConnectStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .zookeeperConnectString)
        zookeeperConnectString = zookeeperConnectStringDecoded
        let zookeeperConnectStringTlsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .zookeeperConnectStringTls)
        zookeeperConnectStringTls = zookeeperConnectStringTlsDecoded
    }
}

extension ClusterInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterInfo(activeOperationArn: \(String(describing: activeOperationArn)), brokerNodeGroupInfo: \(String(describing: brokerNodeGroupInfo)), clientAuthentication: \(String(describing: clientAuthentication)), clusterArn: \(String(describing: clusterArn)), clusterName: \(String(describing: clusterName)), creationTime: \(String(describing: creationTime)), currentBrokerSoftwareInfo: \(String(describing: currentBrokerSoftwareInfo)), currentVersion: \(String(describing: currentVersion)), encryptionInfo: \(String(describing: encryptionInfo)), enhancedMonitoring: \(String(describing: enhancedMonitoring)), loggingInfo: \(String(describing: loggingInfo)), numberOfBrokerNodes: \(String(describing: numberOfBrokerNodes)), openMonitoring: \(String(describing: openMonitoring)), state: \(String(describing: state)), stateInfo: \(String(describing: stateInfo)), tags: \(String(describing: tags)), zookeeperConnectString: \(String(describing: zookeeperConnectString)), zookeeperConnectStringTls: \(String(describing: zookeeperConnectStringTls)))"}
}

/// <p>Returns information about a cluster.</p>
public struct ClusterInfo: Equatable {
    /// <p>Arn of active cluster operation.</p>
    public let activeOperationArn: String?
    /// <p>Information about the broker nodes.</p>
    public let brokerNodeGroupInfo: BrokerNodeGroupInfo?
    /// <p>Includes all client authentication information.</p>
    public let clientAuthentication: ClientAuthentication?
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    public let clusterArn: String?
    /// <p>The name of the cluster.</p>
    public let clusterName: String?
    /// <p>The time when the cluster was created.</p>
    public let creationTime: Date?
    /// <p>Information about the version of software currently deployed on the Kafka brokers in the cluster.</p>
    public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
    /// <p>The current version of the MSK cluster.</p>
    public let currentVersion: String?
    /// <p>Includes all encryption-related information.</p>
    public let encryptionInfo: EncryptionInfo?
    /// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
    public let enhancedMonitoring: EnhancedMonitoring?
    public let loggingInfo: LoggingInfo?
    /// <p>The number of broker nodes in the cluster.</p>
    public let numberOfBrokerNodes: Int
    /// <p>Settings for open monitoring using Prometheus.</p>
    public let openMonitoring: OpenMonitoring?
    /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
    public let state: ClusterState?
    public let stateInfo: StateInfo?
    /// <p>Tags attached to the cluster.</p>
    public let tags: [String:String]?
    /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
    public let zookeeperConnectString: String?
    /// <p>The connection string to use to connect to zookeeper cluster on Tls port.</p>
    public let zookeeperConnectStringTls: String?

    public init (
        activeOperationArn: String? = nil,
        brokerNodeGroupInfo: BrokerNodeGroupInfo? = nil,
        clientAuthentication: ClientAuthentication? = nil,
        clusterArn: String? = nil,
        clusterName: String? = nil,
        creationTime: Date? = nil,
        currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil,
        currentVersion: String? = nil,
        encryptionInfo: EncryptionInfo? = nil,
        enhancedMonitoring: EnhancedMonitoring? = nil,
        loggingInfo: LoggingInfo? = nil,
        numberOfBrokerNodes: Int = 0,
        openMonitoring: OpenMonitoring? = nil,
        state: ClusterState? = nil,
        stateInfo: StateInfo? = nil,
        tags: [String:String]? = nil,
        zookeeperConnectString: String? = nil,
        zookeeperConnectStringTls: String? = nil
    )
    {
        self.activeOperationArn = activeOperationArn
        self.brokerNodeGroupInfo = brokerNodeGroupInfo
        self.clientAuthentication = clientAuthentication
        self.clusterArn = clusterArn
        self.clusterName = clusterName
        self.creationTime = creationTime
        self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
        self.currentVersion = currentVersion
        self.encryptionInfo = encryptionInfo
        self.enhancedMonitoring = enhancedMonitoring
        self.loggingInfo = loggingInfo
        self.numberOfBrokerNodes = numberOfBrokerNodes
        self.openMonitoring = openMonitoring
        self.state = state
        self.stateInfo = stateInfo
        self.tags = tags
        self.zookeeperConnectString = zookeeperConnectString
        self.zookeeperConnectStringTls = zookeeperConnectStringTls
    }
}

extension ClusterOperationInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestId = "clientRequestId"
        case clusterArn = "clusterArn"
        case creationTime = "creationTime"
        case endTime = "endTime"
        case errorInfo = "errorInfo"
        case operationArn = "operationArn"
        case operationState = "operationState"
        case operationSteps = "operationSteps"
        case operationType = "operationType"
        case sourceClusterInfo = "sourceClusterInfo"
        case targetClusterInfo = "targetClusterInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestId = clientRequestId {
            try encodeContainer.encode(clientRequestId, forKey: .clientRequestId)
        }
        if let clusterArn = clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let operationArn = operationArn {
            try encodeContainer.encode(operationArn, forKey: .operationArn)
        }
        if let operationState = operationState {
            try encodeContainer.encode(operationState, forKey: .operationState)
        }
        if let operationSteps = operationSteps {
            var operationStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operationSteps)
            for __listofclusteroperationstep0 in operationSteps {
                try operationStepsContainer.encode(__listofclusteroperationstep0)
            }
        }
        if let operationType = operationType {
            try encodeContainer.encode(operationType, forKey: .operationType)
        }
        if let sourceClusterInfo = sourceClusterInfo {
            try encodeContainer.encode(sourceClusterInfo, forKey: .sourceClusterInfo)
        }
        if let targetClusterInfo = targetClusterInfo {
            try encodeContainer.encode(targetClusterInfo, forKey: .targetClusterInfo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestId)
        clientRequestId = clientRequestIdDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let operationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationArn)
        operationArn = operationArnDecoded
        let operationStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationState)
        operationState = operationStateDecoded
        let operationStepsContainer = try containerValues.decodeIfPresent([ClusterOperationStep?].self, forKey: .operationSteps)
        var operationStepsDecoded0:[ClusterOperationStep]? = nil
        if let operationStepsContainer = operationStepsContainer {
            operationStepsDecoded0 = [ClusterOperationStep]()
            for structure0 in operationStepsContainer {
                if let structure0 = structure0 {
                    operationStepsDecoded0?.append(structure0)
                }
            }
        }
        operationSteps = operationStepsDecoded0
        let operationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let sourceClusterInfoDecoded = try containerValues.decodeIfPresent(MutableClusterInfo.self, forKey: .sourceClusterInfo)
        sourceClusterInfo = sourceClusterInfoDecoded
        let targetClusterInfoDecoded = try containerValues.decodeIfPresent(MutableClusterInfo.self, forKey: .targetClusterInfo)
        targetClusterInfo = targetClusterInfoDecoded
    }
}

extension ClusterOperationInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterOperationInfo(clientRequestId: \(String(describing: clientRequestId)), clusterArn: \(String(describing: clusterArn)), creationTime: \(String(describing: creationTime)), endTime: \(String(describing: endTime)), errorInfo: \(String(describing: errorInfo)), operationArn: \(String(describing: operationArn)), operationState: \(String(describing: operationState)), operationSteps: \(String(describing: operationSteps)), operationType: \(String(describing: operationType)), sourceClusterInfo: \(String(describing: sourceClusterInfo)), targetClusterInfo: \(String(describing: targetClusterInfo)))"}
}

/// <p>Returns information about a cluster operation.</p>
public struct ClusterOperationInfo: Equatable {
    /// <p>The ID of the API request that triggered this operation.</p>
    public let clientRequestId: String?
    /// <p>ARN of the cluster.</p>
    public let clusterArn: String?
    /// <p>The time that the operation was created.</p>
    public let creationTime: Date?
    /// <p>The time at which the operation finished.</p>
    public let endTime: Date?
    /// <p>Describes the error if the operation fails.</p>
    public let errorInfo: ErrorInfo?
    /// <p>ARN of the cluster operation.</p>
    public let operationArn: String?
    /// <p>State of the cluster operation.</p>
    public let operationState: String?
    /// <p>Steps completed during the operation.</p>
    public let operationSteps: [ClusterOperationStep]?
    /// <p>Type of the cluster operation.</p>
    public let operationType: String?
    /// <p>Information about cluster attributes before a cluster is updated.</p>
    public let sourceClusterInfo: MutableClusterInfo?
    /// <p>Information about cluster attributes after a cluster is updated.</p>
    public let targetClusterInfo: MutableClusterInfo?

    public init (
        clientRequestId: String? = nil,
        clusterArn: String? = nil,
        creationTime: Date? = nil,
        endTime: Date? = nil,
        errorInfo: ErrorInfo? = nil,
        operationArn: String? = nil,
        operationState: String? = nil,
        operationSteps: [ClusterOperationStep]? = nil,
        operationType: String? = nil,
        sourceClusterInfo: MutableClusterInfo? = nil,
        targetClusterInfo: MutableClusterInfo? = nil
    )
    {
        self.clientRequestId = clientRequestId
        self.clusterArn = clusterArn
        self.creationTime = creationTime
        self.endTime = endTime
        self.errorInfo = errorInfo
        self.operationArn = operationArn
        self.operationState = operationState
        self.operationSteps = operationSteps
        self.operationType = operationType
        self.sourceClusterInfo = sourceClusterInfo
        self.targetClusterInfo = targetClusterInfo
    }
}

extension ClusterOperationStep: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stepInfo = "stepInfo"
        case stepName = "stepName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stepInfo = stepInfo {
            try encodeContainer.encode(stepInfo, forKey: .stepInfo)
        }
        if let stepName = stepName {
            try encodeContainer.encode(stepName, forKey: .stepName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepInfoDecoded = try containerValues.decodeIfPresent(ClusterOperationStepInfo.self, forKey: .stepInfo)
        stepInfo = stepInfoDecoded
        let stepNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stepName)
        stepName = stepNameDecoded
    }
}

extension ClusterOperationStep: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterOperationStep(stepInfo: \(String(describing: stepInfo)), stepName: \(String(describing: stepName)))"}
}

/// <p>Step taken during a cluster operation.</p>
public struct ClusterOperationStep: Equatable {
    /// <p>Information about the step and its status.</p>
    public let stepInfo: ClusterOperationStepInfo?
    /// <p>The name of the step.</p>
    public let stepName: String?

    public init (
        stepInfo: ClusterOperationStepInfo? = nil,
        stepName: String? = nil
    )
    {
        self.stepInfo = stepInfo
        self.stepName = stepName
    }
}

extension ClusterOperationStepInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stepStatus = "stepStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stepStatus = stepStatus {
            try encodeContainer.encode(stepStatus, forKey: .stepStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stepStatus)
        stepStatus = stepStatusDecoded
    }
}

extension ClusterOperationStepInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterOperationStepInfo(stepStatus: \(String(describing: stepStatus)))"}
}

/// <p>State information about the operation step.</p>
public struct ClusterOperationStepInfo: Equatable {
    /// <p>The steps current status.</p>
    public let stepStatus: String?

    public init (
        stepStatus: String? = nil
    )
    {
        self.stepStatus = stepStatus
    }
}

/// <p>The state of a Kafka cluster.</p>
public enum ClusterState {
    case active
    case creating
    case deleting
    case failed
    case healing
    case maintenance
    case rebootingBroker
    case updating
    case sdkUnknown(String)
}

extension ClusterState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ClusterState] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .healing,
            .maintenance,
            .rebootingBroker,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .healing: return "HEALING"
        case .maintenance: return "MAINTENANCE"
        case .rebootingBroker: return "REBOOTING_BROKER"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ClusterState(rawValue: rawValue) ?? ClusterState.sdkUnknown(rawValue)
    }
}

extension CompatibleKafkaVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceVersion = "sourceVersion"
        case targetVersions = "targetVersions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let targetVersions = targetVersions {
            var targetVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetVersions)
            for __listof__string0 in targetVersions {
                try targetVersionsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let targetVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetVersions)
        var targetVersionsDecoded0:[String]? = nil
        if let targetVersionsContainer = targetVersionsContainer {
            targetVersionsDecoded0 = [String]()
            for string0 in targetVersionsContainer {
                if let string0 = string0 {
                    targetVersionsDecoded0?.append(string0)
                }
            }
        }
        targetVersions = targetVersionsDecoded0
    }
}

extension CompatibleKafkaVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompatibleKafkaVersion(sourceVersion: \(String(describing: sourceVersion)), targetVersions: \(String(describing: targetVersions)))"}
}

/// <p>Contains source Kafka versions and compatible target Kafka versions.</p>
public struct CompatibleKafkaVersion: Equatable {
    /// <p>A Kafka version.</p>
    public let sourceVersion: String?
    /// <p>A list of Kafka versions.</p>
    public let targetVersions: [String]?

    public init (
        sourceVersion: String? = nil,
        targetVersions: [String]? = nil
    )
    {
        self.sourceVersion = sourceVersion
        self.targetVersions = targetVersions
    }
}

extension Configuration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case latestRevision = "latestRevision"
        case name = "name"
        case state = "state"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kafkaVersions = kafkaVersions {
            var kafkaVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .kafkaVersions)
            for __listof__string0 in kafkaVersions {
                try kafkaVersionsContainer.encode(__listof__string0)
            }
        }
        if let latestRevision = latestRevision {
            try encodeContainer.encode(latestRevision, forKey: .latestRevision)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[String]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [String]()
            for string0 in kafkaVersionsContainer {
                if let string0 = string0 {
                    kafkaVersionsDecoded0?.append(string0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let latestRevisionDecoded = try containerValues.decodeIfPresent(ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension Configuration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Configuration(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), kafkaVersions: \(String(describing: kafkaVersions)), latestRevision: \(String(describing: latestRevision)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

/// <p>Represents an MSK Configuration.</p>
public struct Configuration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
    public let arn: String?
    /// <p>The time when the configuration was created.</p>
    public let creationTime: Date?
    /// <p>The description of the configuration.</p>
    public let description: String?
    /// <p>An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.</p>
    public let kafkaVersions: [String]?
    /// <p>Latest revision of the configuration.</p>
    public let latestRevision: ConfigurationRevision?
    /// <p>The name of the configuration.</p>
    public let name: String?
    /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
    public let state: ConfigurationState?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        kafkaVersions: [String]? = nil,
        latestRevision: ConfigurationRevision? = nil,
        name: String? = nil,
        state: ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.kafkaVersions = kafkaVersions
        self.latestRevision = latestRevision
        self.name = name
        self.state = state
    }
}

extension ConfigurationInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case revision = "revision"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let revisionDecoded = try containerValues.decode(Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension ConfigurationInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationInfo(arn: \(String(describing: arn)), revision: \(String(describing: revision)))"}
}

/// <p>Specifies the configuration to use for the brokers.</p>
public struct ConfigurationInfo: Equatable {
    /// <p>ARN of the configuration to use.</p>
    public let arn: String?
    /// <p>The revision of the configuration to use.</p>
    public let revision: Int

    public init (
        arn: String? = nil,
        revision: Int = 0
    )
    {
        self.arn = arn
        self.revision = revision
    }
}

extension ConfigurationRevision: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "creationTime"
        case description = "description"
        case revision = "revision"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let revisionDecoded = try containerValues.decode(Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension ConfigurationRevision: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationRevision(creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), revision: \(String(describing: revision)))"}
}

/// <p>Describes a configuration revision.</p>
public struct ConfigurationRevision: Equatable {
    /// <p>The time when the configuration revision was created.</p>
    public let creationTime: Date?
    /// <p>The description of the configuration revision.</p>
    public let description: String?
    /// <p>The revision number.</p>
    public let revision: Int

    public init (
        creationTime: Date? = nil,
        description: String? = nil,
        revision: Int = 0
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.revision = revision
    }
}

/// <p>The state of a configuration.</p>
public enum ConfigurationState {
    case active
    case deleteFailed
    case deleting
    case sdkUnknown(String)
}

extension ConfigurationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationState] {
        return [
            .active,
            .deleteFailed,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationState(rawValue: rawValue) ?? ConfigurationState.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(invalidParameter: \(String(describing: invalidParameter)), message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returns information about an error.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The parameter that caused the error.</p>
    public var invalidParameter: String?
    /// <p>The description of the error.</p>
    public var message: String?

    public init (
        invalidParameter: String? = nil,
        message: String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let invalidParameter: String?
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateClusterInputBodyMiddleware: Middleware {
    public let id: String = "CreateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

extension CreateClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterInput(brokerNodeGroupInfo: \(String(describing: brokerNodeGroupInfo)), clientAuthentication: \(String(describing: clientAuthentication)), clusterName: \(String(describing: clusterName)), configurationInfo: \(String(describing: configurationInfo)), encryptionInfo: \(String(describing: encryptionInfo)), enhancedMonitoring: \(String(describing: enhancedMonitoring)), kafkaVersion: \(String(describing: kafkaVersion)), loggingInfo: \(String(describing: loggingInfo)), numberOfBrokerNodes: \(String(describing: numberOfBrokerNodes)), openMonitoring: \(String(describing: openMonitoring)), tags: \(String(describing: tags)))"}
}

extension CreateClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case clusterName = "clusterName"
        case configurationInfo = "configurationInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case kafkaVersion = "kafkaVersion"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerNodeGroupInfo = brokerNodeGroupInfo {
            try encodeContainer.encode(brokerNodeGroupInfo, forKey: .brokerNodeGroupInfo)
        }
        if let clientAuthentication = clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let configurationInfo = configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let encryptionInfo = encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let kafkaVersion = kafkaVersion {
            try encodeContainer.encode(kafkaVersion, forKey: .kafkaVersion)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if numberOfBrokerNodes != 0 {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateClusterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

public struct CreateClusterInput: Equatable {
    /// <p>Information about the broker nodes in the cluster.</p>
    public let brokerNodeGroupInfo: BrokerNodeGroupInfo?
    /// <p>Includes all client authentication related information.</p>
    public let clientAuthentication: ClientAuthentication?
    /// <p>The name of the cluster.</p>
    public let clusterName: String?
    /// <p>Represents the configuration that you want MSK to use for the brokers in a cluster.</p>
    public let configurationInfo: ConfigurationInfo?
    /// <p>Includes all encryption-related information.</p>
    public let encryptionInfo: EncryptionInfo?
    /// <p>Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.</p>
    public let enhancedMonitoring: EnhancedMonitoring?
    /// <p>The version of Apache Kafka.</p>
    public let kafkaVersion: String?
    public let loggingInfo: LoggingInfo?
    /// <p>The number of broker nodes in the cluster.</p>
    public let numberOfBrokerNodes: Int
    /// <p>The settings for open monitoring.</p>
    public let openMonitoring: OpenMonitoringInfo?
    /// <p>Create tags when creating the cluster.</p>
    public let tags: [String:String]?

    public init (
        brokerNodeGroupInfo: BrokerNodeGroupInfo? = nil,
        clientAuthentication: ClientAuthentication? = nil,
        clusterName: String? = nil,
        configurationInfo: ConfigurationInfo? = nil,
        encryptionInfo: EncryptionInfo? = nil,
        enhancedMonitoring: EnhancedMonitoring? = nil,
        kafkaVersion: String? = nil,
        loggingInfo: LoggingInfo? = nil,
        numberOfBrokerNodes: Int = 0,
        openMonitoring: OpenMonitoringInfo? = nil,
        tags: [String:String]? = nil
    )
    {
        self.brokerNodeGroupInfo = brokerNodeGroupInfo
        self.clientAuthentication = clientAuthentication
        self.clusterName = clusterName
        self.configurationInfo = configurationInfo
        self.encryptionInfo = encryptionInfo
        self.enhancedMonitoring = enhancedMonitoring
        self.kafkaVersion = kafkaVersion
        self.loggingInfo = loggingInfo
        self.numberOfBrokerNodes = numberOfBrokerNodes
        self.openMonitoring = openMonitoring
        self.tags = tags
    }
}

struct CreateClusterInputBody: Equatable {
    public let brokerNodeGroupInfo: BrokerNodeGroupInfo?
    public let clientAuthentication: ClientAuthentication?
    public let clusterName: String?
    public let configurationInfo: ConfigurationInfo?
    public let encryptionInfo: EncryptionInfo?
    public let enhancedMonitoring: EnhancedMonitoring?
    public let openMonitoring: OpenMonitoringInfo?
    public let kafkaVersion: String?
    public let loggingInfo: LoggingInfo?
    public let numberOfBrokerNodes: Int
    public let tags: [String:String]?
}

extension CreateClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case clusterName = "clusterName"
        case configurationInfo = "configurationInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case kafkaVersion = "kafkaVersion"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerNodeGroupInfoDecoded = try containerValues.decodeIfPresent(BrokerNodeGroupInfo.self, forKey: .brokerNodeGroupInfo)
        brokerNodeGroupInfo = brokerNodeGroupInfoDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let configurationInfoDecoded = try containerValues.decodeIfPresent(ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(OpenMonitoringInfo.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let kafkaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kafkaVersion)
        kafkaVersion = kafkaVersionDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterOutputResponse(clusterArn: \(String(describing: clusterArn)), clusterName: \(String(describing: clusterName)), state: \(String(describing: state)))"}
}

extension CreateClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterArn = output.clusterArn
            self.clusterName = output.clusterName
            self.state = output.state
        } else {
            self.clusterArn = nil
            self.clusterName = nil
            self.state = nil
        }
    }
}

public struct CreateClusterOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterArn: String?
    /// <p>The name of the MSK cluster.</p>
    public let clusterName: String?
    /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
    public let state: ClusterState?

    public init (
        clusterArn: String? = nil,
        clusterName: String? = nil,
        state: ClusterState? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterName = clusterName
        self.state = state
    }
}

struct CreateClusterOutputResponseBody: Equatable {
    public let clusterArn: String?
    public let clusterName: String?
    public let state: ClusterState?
}

extension CreateClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterArn = "clusterArn"
        case clusterName = "clusterName"
        case state = "state"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ClusterState.self, forKey: .state)
        state = stateDecoded
    }
}

public struct CreateConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationOutputError>
}

extension CreateConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationInput(description: \(String(describing: description)), kafkaVersions: \(String(describing: kafkaVersions)), name: \(String(describing: name)), serverProperties: \(String(describing: serverProperties)))"}
}

extension CreateConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case name = "name"
        case serverProperties = "serverProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kafkaVersions = kafkaVersions {
            var kafkaVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .kafkaVersions)
            for __listof__string0 in kafkaVersions {
                try kafkaVersionsContainer.encode(__listof__string0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverProperties = serverProperties {
            try encodeContainer.encode(serverProperties.base64EncodedString(), forKey: .serverProperties)
        }
    }
}

public struct CreateConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationOutputError>
}

public struct CreateConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationOutputError>
}

public struct CreateConfigurationInput: Equatable {
    /// <p>The description of the configuration.</p>
    public let description: String?
    /// <p>The versions of Apache Kafka with which you can use this MSK configuration.</p>
    public let kafkaVersions: [String]?
    /// <p>The name of the configuration.</p>
    public let name: String?
    /// <p>Contents of the <filename>server.properties</filename> file. When using the API, you must ensure that the contents of the file are base64 encoded.
    ///                When using the AWS Management Console, the SDK, or the AWS CLI, the contents of <filename>server.properties</filename> can be in plaintext.</p>
    public let serverProperties: Data?

    public init (
        description: String? = nil,
        kafkaVersions: [String]? = nil,
        name: String? = nil,
        serverProperties: Data? = nil
    )
    {
        self.description = description
        self.kafkaVersions = kafkaVersions
        self.name = name
        self.serverProperties = serverProperties
    }
}

struct CreateConfigurationInputBody: Equatable {
    public let description: String?
    public let kafkaVersions: [String]?
    public let name: String?
    public let serverProperties: Data?
}

extension CreateConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case name = "name"
        case serverProperties = "serverProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[String]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [String]()
            for string0 in kafkaVersionsContainer {
                if let string0 = string0 {
                    kafkaVersionsDecoded0?.append(string0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let serverPropertiesDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .serverProperties)
        serverProperties = serverPropertiesDecoded
    }
}

extension CreateConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationOutputResponse(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), latestRevision: \(String(describing: latestRevision)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

extension CreateConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.creationTime = nil
            self.latestRevision = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct CreateConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
    public let arn: String?
    /// <p>The time when the configuration was created.</p>
    public let creationTime: Date?
    /// <p>Latest revision of the configuration.</p>
    public let latestRevision: ConfigurationRevision?
    /// <p>The name of the configuration.</p>
    public let name: String?
    /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
    public let state: ConfigurationState?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        latestRevision: ConfigurationRevision? = nil,
        name: String? = nil,
        state: ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.latestRevision = latestRevision
        self.name = name
        self.state = state
    }
}

struct CreateConfigurationOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTime: Date?
    public let latestRevision: ConfigurationRevision?
    public let name: String?
    public let state: ConfigurationState?
}

extension CreateConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case latestRevision = "latestRevision"
        case name = "name"
        case state = "state"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension DeleteClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterInput(clusterArn: \(String(describing: clusterArn)), currentVersion: \(String(describing: currentVersion)))"}
}

extension DeleteClusterInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let currentVersion = input.operationInput.currentVersion {
            let currentVersionQueryItem = URLQueryItem(name: "currentVersion".urlPercentEncoding(), value: String(currentVersion).urlPercentEncoding())
            input.builder.withQueryItem(currentVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    public let clusterArn: String?
    /// <p>The current version of the MSK cluster.</p>
    public let currentVersion: String?

    public init (
        clusterArn: String? = nil,
        currentVersion: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
    }
}

struct DeleteClusterInputBody: Equatable {
}

extension DeleteClusterInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterOutputResponse(clusterArn: \(String(describing: clusterArn)), state: \(String(describing: state)))"}
}

extension DeleteClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterArn = output.clusterArn
            self.state = output.state
        } else {
            self.clusterArn = nil
            self.state = nil
        }
    }
}

public struct DeleteClusterOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterArn: String?
    /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
    public let state: ClusterState?

    public init (
        clusterArn: String? = nil,
        state: ClusterState? = nil
    )
    {
        self.clusterArn = clusterArn
        self.state = state
    }
}

struct DeleteClusterOutputResponseBody: Equatable {
    public let clusterArn: String?
    public let state: ClusterState?
}

extension DeleteClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterArn = "clusterArn"
        case state = "state"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ClusterState.self, forKey: .state)
        state = stateDecoded
    }
}

extension DeleteConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationInput(arn: \(String(describing: arn)))"}
}

extension DeleteConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationOutputError>
}

public struct DeleteConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationOutputError>
}

public struct DeleteConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteConfigurationInputBody: Equatable {
}

extension DeleteConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationOutputResponse(arn: \(String(describing: arn)), state: \(String(describing: state)))"}
}

extension DeleteConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.state = output.state
        } else {
            self.arn = nil
            self.state = nil
        }
    }
}

public struct DeleteConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.</p>
    public let arn: String?
    /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
    public let state: ConfigurationState?

    public init (
        arn: String? = nil,
        state: ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.state = state
    }
}

struct DeleteConfigurationOutputResponseBody: Equatable {
    public let arn: String?
    public let state: ConfigurationState?
}

extension DeleteConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case state = "state"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension DescribeClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterInput(clusterArn: \(String(describing: clusterArn)))"}
}

extension DescribeClusterInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterInput>
    public typealias MOutput = OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterOutputError>
}

public struct DescribeClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterInput>
    public typealias MOutput = OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterOutputError>
}

public struct DescribeClusterInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    public let clusterArn: String?

    public init (
        clusterArn: String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct DescribeClusterInputBody: Equatable {
}

extension DescribeClusterInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeClusterOperationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterOperationInput(clusterOperationArn: \(String(describing: clusterOperationArn)))"}
}

extension DescribeClusterOperationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeClusterOperationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClusterOperationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterOperationInput>
    public typealias MOutput = OperationOutput<DescribeClusterOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterOperationOutputError>
}

public struct DescribeClusterOperationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClusterOperationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterOperationInput>
    public typealias MOutput = OperationOutput<DescribeClusterOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterOperationOutputError>
}

public struct DescribeClusterOperationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster operation.</p>
    public let clusterOperationArn: String?

    public init (
        clusterOperationArn: String? = nil
    )
    {
        self.clusterOperationArn = clusterOperationArn
    }
}

struct DescribeClusterOperationInputBody: Equatable {
}

extension DescribeClusterOperationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeClusterOperationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClusterOperationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterOperationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterOperationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterOperationOutputResponse(clusterOperationInfo: \(String(describing: clusterOperationInfo)))"}
}

extension DescribeClusterOperationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClusterOperationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterOperationInfo = output.clusterOperationInfo
        } else {
            self.clusterOperationInfo = nil
        }
    }
}

public struct DescribeClusterOperationOutputResponse: Equatable {
    /// <p>Cluster operation information</p>
    public let clusterOperationInfo: ClusterOperationInfo?

    public init (
        clusterOperationInfo: ClusterOperationInfo? = nil
    )
    {
        self.clusterOperationInfo = clusterOperationInfo
    }
}

struct DescribeClusterOperationOutputResponseBody: Equatable {
    public let clusterOperationInfo: ClusterOperationInfo?
}

extension DescribeClusterOperationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterOperationInfo = "clusterOperationInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterOperationInfoDecoded = try containerValues.decodeIfPresent(ClusterOperationInfo.self, forKey: .clusterOperationInfo)
        clusterOperationInfo = clusterOperationInfoDecoded
    }
}

extension DescribeClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterOutputResponse(clusterInfo: \(String(describing: clusterInfo)))"}
}

extension DescribeClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterInfo = output.clusterInfo
        } else {
            self.clusterInfo = nil
        }
    }
}

public struct DescribeClusterOutputResponse: Equatable {
    /// <p>The cluster information.</p>
    public let clusterInfo: ClusterInfo?

    public init (
        clusterInfo: ClusterInfo? = nil
    )
    {
        self.clusterInfo = clusterInfo
    }
}

struct DescribeClusterOutputResponseBody: Equatable {
    public let clusterInfo: ClusterInfo?
}

extension DescribeClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterInfo = "clusterInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterInfoDecoded = try containerValues.decodeIfPresent(ClusterInfo.self, forKey: .clusterInfo)
        clusterInfo = clusterInfoDecoded
    }
}

extension DescribeConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationInput(arn: \(String(describing: arn)))"}
}

extension DescribeConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DescribeConfigurationInputBody: Equatable {
}

extension DescribeConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationOutputResponse(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), kafkaVersions: \(String(describing: kafkaVersions)), latestRevision: \(String(describing: latestRevision)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

extension DescribeConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.kafkaVersions = output.kafkaVersions
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.kafkaVersions = nil
            self.latestRevision = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DescribeConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
    public let arn: String?
    /// <p>The time when the configuration was created.</p>
    public let creationTime: Date?
    /// <p>The description of the configuration.</p>
    public let description: String?
    /// <p>The versions of Apache Kafka with which you can use this MSK configuration.</p>
    public let kafkaVersions: [String]?
    /// <p>Latest revision of the configuration.</p>
    public let latestRevision: ConfigurationRevision?
    /// <p>The name of the configuration.</p>
    public let name: String?
    /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
    public let state: ConfigurationState?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        kafkaVersions: [String]? = nil,
        latestRevision: ConfigurationRevision? = nil,
        name: String? = nil,
        state: ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.kafkaVersions = kafkaVersions
        self.latestRevision = latestRevision
        self.name = name
        self.state = state
    }
}

struct DescribeConfigurationOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTime: Date?
    public let description: String?
    public let kafkaVersions: [String]?
    public let latestRevision: ConfigurationRevision?
    public let name: String?
    public let state: ConfigurationState?
}

extension DescribeConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case latestRevision = "latestRevision"
        case name = "name"
        case state = "state"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[String]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [String]()
            for string0 in kafkaVersionsContainer {
                if let string0 = string0 {
                    kafkaVersionsDecoded0?.append(string0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let latestRevisionDecoded = try containerValues.decodeIfPresent(ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension DescribeConfigurationRevisionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationRevisionInput(arn: \(String(describing: arn)), revision: \(String(describing: revision)))"}
}

extension DescribeConfigurationRevisionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeConfigurationRevisionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationRevisionInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationRevisionInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
    public let arn: String?
    /// <p>A string that uniquely identifies a revision of an MSK configuration.</p>
    public let revision: Int

    public init (
        arn: String? = nil,
        revision: Int = 0
    )
    {
        self.arn = arn
        self.revision = revision
    }
}

struct DescribeConfigurationRevisionInputBody: Equatable {
}

extension DescribeConfigurationRevisionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeConfigurationRevisionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationRevisionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationRevisionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationRevisionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationRevisionOutputResponse(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), revision: \(String(describing: revision)), serverProperties: \(String(describing: serverProperties)))"}
}

extension DescribeConfigurationRevisionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationRevisionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.revision = output.revision
            self.serverProperties = output.serverProperties
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.revision = 0
            self.serverProperties = nil
        }
    }
}

public struct DescribeConfigurationRevisionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
    public let arn: String?
    /// <p>The time when the configuration was created.</p>
    public let creationTime: Date?
    /// <p>The description of the configuration.</p>
    public let description: String?
    /// <p>The revision number.</p>
    public let revision: Int
    /// <p>Contents of the <filename>server.properties</filename> file. When using the API, you must ensure that the contents of the file are base64 encoded.
    ///                When using the AWS Management Console, the SDK, or the AWS CLI, the contents of <filename>server.properties</filename> can be in plaintext.</p>
    public let serverProperties: Data?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        revision: Int = 0,
        serverProperties: Data? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.revision = revision
        self.serverProperties = serverProperties
    }
}

struct DescribeConfigurationRevisionOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTime: Date?
    public let description: String?
    public let revision: Int
    public let serverProperties: Data?
}

extension DescribeConfigurationRevisionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case description = "description"
        case revision = "revision"
        case serverProperties = "serverProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let revisionDecoded = try containerValues.decode(Int.self, forKey: .revision)
        revision = revisionDecoded
        let serverPropertiesDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .serverProperties)
        serverProperties = serverPropertiesDecoded
    }
}

extension EBSStorageInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case volumeSize = "volumeSize"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if volumeSize != 0 {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeSizeDecoded = try containerValues.decode(Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
    }
}

extension EBSStorageInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EBSStorageInfo(volumeSize: \(String(describing: volumeSize)))"}
}

/// <p>Contains information about the EBS storage volumes attached to Kafka broker nodes.</p>
public struct EBSStorageInfo: Equatable {
    /// <p>The size in GiB of the EBS volume for the data drive on each broker node.</p>
    public let volumeSize: Int

    public init (
        volumeSize: Int = 0
    )
    {
        self.volumeSize = volumeSize
    }
}

extension EncryptionAtRest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataVolumeKMSKeyId = "dataVolumeKMSKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataVolumeKMSKeyId = dataVolumeKMSKeyId {
            try encodeContainer.encode(dataVolumeKMSKeyId, forKey: .dataVolumeKMSKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataVolumeKMSKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataVolumeKMSKeyId)
        dataVolumeKMSKeyId = dataVolumeKMSKeyIdDecoded
    }
}

extension EncryptionAtRest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionAtRest(dataVolumeKMSKeyId: \(String(describing: dataVolumeKMSKeyId)))"}
}

/// <p>The data-volume encryption details.</p>
public struct EncryptionAtRest: Equatable {
    /// <p>The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.</p>
    public let dataVolumeKMSKeyId: String?

    public init (
        dataVolumeKMSKeyId: String? = nil
    )
    {
        self.dataVolumeKMSKeyId = dataVolumeKMSKeyId
    }
}

extension EncryptionInTransit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientBroker = "clientBroker"
        case inCluster = "inCluster"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientBroker = clientBroker {
            try encodeContainer.encode(clientBroker.rawValue, forKey: .clientBroker)
        }
        if inCluster != false {
            try encodeContainer.encode(inCluster, forKey: .inCluster)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientBrokerDecoded = try containerValues.decodeIfPresent(ClientBroker.self, forKey: .clientBroker)
        clientBroker = clientBrokerDecoded
        let inClusterDecoded = try containerValues.decode(Bool.self, forKey: .inCluster)
        inCluster = inClusterDecoded
    }
}

extension EncryptionInTransit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionInTransit(clientBroker: \(String(describing: clientBroker)), inCluster: \(String(describing: inCluster)))"}
}

/// <p>The settings for encrypting data in transit.</p>
public struct EncryptionInTransit: Equatable {
    /// <p>Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values.</p>
    ///             <p>
    ///                TLS means that client-broker communication is enabled with TLS only.</p>
    ///             <p>
    ///                TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.</p>
    ///             <p>
    ///                PLAINTEXT means that client-broker communication is enabled in plaintext only.</p>
    ///             <p>The default value is TLS_PLAINTEXT.</p>
    public let clientBroker: ClientBroker?
    /// <p>When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext.</p>
    ///             <p>The default value is true.</p>
    public let inCluster: Bool

    public init (
        clientBroker: ClientBroker? = nil,
        inCluster: Bool = false
    )
    {
        self.clientBroker = clientBroker
        self.inCluster = inCluster
    }
}

extension EncryptionInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionAtRest = "encryptionAtRest"
        case encryptionInTransit = "encryptionInTransit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionAtRest = encryptionAtRest {
            try encodeContainer.encode(encryptionAtRest, forKey: .encryptionAtRest)
        }
        if let encryptionInTransit = encryptionInTransit {
            try encodeContainer.encode(encryptionInTransit, forKey: .encryptionInTransit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionAtRestDecoded = try containerValues.decodeIfPresent(EncryptionAtRest.self, forKey: .encryptionAtRest)
        encryptionAtRest = encryptionAtRestDecoded
        let encryptionInTransitDecoded = try containerValues.decodeIfPresent(EncryptionInTransit.self, forKey: .encryptionInTransit)
        encryptionInTransit = encryptionInTransitDecoded
    }
}

extension EncryptionInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionInfo(encryptionAtRest: \(String(describing: encryptionAtRest)), encryptionInTransit: \(String(describing: encryptionInTransit)))"}
}

/// <p>Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.</p>
public struct EncryptionInfo: Equatable {
    /// <p>The data-volume encryption details.</p>
    public let encryptionAtRest: EncryptionAtRest?
    /// <p>The details for encryption in transit.</p>
    public let encryptionInTransit: EncryptionInTransit?

    public init (
        encryptionAtRest: EncryptionAtRest? = nil,
        encryptionInTransit: EncryptionInTransit? = nil
    )
    {
        self.encryptionAtRest = encryptionAtRest
        self.encryptionInTransit = encryptionInTransit
    }
}

/// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
public enum EnhancedMonitoring {
    case `default`
    case perBroker
    case perTopicPerBroker
    case perTopicPerPartition
    case sdkUnknown(String)
}

extension EnhancedMonitoring : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnhancedMonitoring] {
        return [
            .default,
            .perBroker,
            .perTopicPerBroker,
            .perTopicPerPartition,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .default: return "DEFAULT"
        case .perBroker: return "PER_BROKER"
        case .perTopicPerBroker: return "PER_TOPIC_PER_BROKER"
        case .perTopicPerPartition: return "PER_TOPIC_PER_PARTITION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnhancedMonitoring(rawValue: rawValue) ?? EnhancedMonitoring.sdkUnknown(rawValue)
    }
}

extension ErrorInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "errorCode"
        case errorString = "errorString"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorString = errorString {
            try encodeContainer.encode(errorString, forKey: .errorString)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorString)
        errorString = errorStringDecoded
    }
}

extension ErrorInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorInfo(errorCode: \(String(describing: errorCode)), errorString: \(String(describing: errorString)))"}
}

/// <p>Returns information about an error state of the cluster.</p>
public struct ErrorInfo: Equatable {
    /// <p>A number describing the error programmatically.</p>
    public let errorCode: String?
    /// <p>An optional field to provide more details about the error.</p>
    public let errorString: String?

    public init (
        errorCode: String? = nil,
        errorString: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorString = errorString
    }
}

extension Firehose: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryStream = "deliveryStream"
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStream = deliveryStream {
            try encodeContainer.encode(deliveryStream, forKey: .deliveryStream)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryStream)
        deliveryStream = deliveryStreamDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension Firehose: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Firehose(deliveryStream: \(String(describing: deliveryStream)), enabled: \(String(describing: enabled)))"}
}

public struct Firehose: Equatable {
    public let deliveryStream: String?
    public let enabled: Bool

    public init (
        deliveryStream: String? = nil,
        enabled: Bool = false
    )
    {
        self.deliveryStream = deliveryStream
        self.enabled = enabled
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(invalidParameter: \(String(describing: invalidParameter)), message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returns information about an error.</p>
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The parameter that caused the error.</p>
    public var invalidParameter: String?
    /// <p>The description of the error.</p>
    public var message: String?

    public init (
        invalidParameter: String? = nil,
        message: String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let invalidParameter: String?
    public let message: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetBootstrapBrokersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBootstrapBrokersInput(clusterArn: \(String(describing: clusterArn)))"}
}

extension GetBootstrapBrokersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBootstrapBrokersInputHeadersMiddleware: Middleware {
    public let id: String = "GetBootstrapBrokersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBootstrapBrokersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBootstrapBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBootstrapBrokersInput>
    public typealias MOutput = OperationOutput<GetBootstrapBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBootstrapBrokersOutputError>
}

public struct GetBootstrapBrokersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBootstrapBrokersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBootstrapBrokersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBootstrapBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBootstrapBrokersInput>
    public typealias MOutput = OperationOutput<GetBootstrapBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBootstrapBrokersOutputError>
}

public struct GetBootstrapBrokersInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    public let clusterArn: String?

    public init (
        clusterArn: String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct GetBootstrapBrokersInputBody: Equatable {
}

extension GetBootstrapBrokersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBootstrapBrokersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBootstrapBrokersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBootstrapBrokersOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBootstrapBrokersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBootstrapBrokersOutputResponse(bootstrapBrokerString: \(String(describing: bootstrapBrokerString)), bootstrapBrokerStringSaslIam: \(String(describing: bootstrapBrokerStringSaslIam)), bootstrapBrokerStringSaslScram: \(String(describing: bootstrapBrokerStringSaslScram)), bootstrapBrokerStringTls: \(String(describing: bootstrapBrokerStringTls)))"}
}

extension GetBootstrapBrokersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBootstrapBrokersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bootstrapBrokerString = output.bootstrapBrokerString
            self.bootstrapBrokerStringSaslIam = output.bootstrapBrokerStringSaslIam
            self.bootstrapBrokerStringSaslScram = output.bootstrapBrokerStringSaslScram
            self.bootstrapBrokerStringTls = output.bootstrapBrokerStringTls
        } else {
            self.bootstrapBrokerString = nil
            self.bootstrapBrokerStringSaslIam = nil
            self.bootstrapBrokerStringSaslScram = nil
            self.bootstrapBrokerStringTls = nil
        }
    }
}

public struct GetBootstrapBrokersOutputResponse: Equatable {
    /// <p>A string containing one or more hostname:port pairs.</p>
    public let bootstrapBrokerString: String?
    /// <p>A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs.</p>
    public let bootstrapBrokerStringSaslIam: String?
    /// <p>A string containing one or more DNS names (or IP) and Sasl Scram port pairs.</p>
    public let bootstrapBrokerStringSaslScram: String?
    /// <p>A string containing one or more DNS names (or IP) and TLS port pairs.</p>
    public let bootstrapBrokerStringTls: String?

    public init (
        bootstrapBrokerString: String? = nil,
        bootstrapBrokerStringSaslIam: String? = nil,
        bootstrapBrokerStringSaslScram: String? = nil,
        bootstrapBrokerStringTls: String? = nil
    )
    {
        self.bootstrapBrokerString = bootstrapBrokerString
        self.bootstrapBrokerStringSaslIam = bootstrapBrokerStringSaslIam
        self.bootstrapBrokerStringSaslScram = bootstrapBrokerStringSaslScram
        self.bootstrapBrokerStringTls = bootstrapBrokerStringTls
    }
}

struct GetBootstrapBrokersOutputResponseBody: Equatable {
    public let bootstrapBrokerString: String?
    public let bootstrapBrokerStringTls: String?
    public let bootstrapBrokerStringSaslScram: String?
    public let bootstrapBrokerStringSaslIam: String?
}

extension GetBootstrapBrokersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bootstrapBrokerString = "bootstrapBrokerString"
        case bootstrapBrokerStringSaslIam = "bootstrapBrokerStringSaslIam"
        case bootstrapBrokerStringSaslScram = "bootstrapBrokerStringSaslScram"
        case bootstrapBrokerStringTls = "bootstrapBrokerStringTls"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bootstrapBrokerStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bootstrapBrokerString)
        bootstrapBrokerString = bootstrapBrokerStringDecoded
        let bootstrapBrokerStringTlsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bootstrapBrokerStringTls)
        bootstrapBrokerStringTls = bootstrapBrokerStringTlsDecoded
        let bootstrapBrokerStringSaslScramDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bootstrapBrokerStringSaslScram)
        bootstrapBrokerStringSaslScram = bootstrapBrokerStringSaslScramDecoded
        let bootstrapBrokerStringSaslIamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bootstrapBrokerStringSaslIam)
        bootstrapBrokerStringSaslIam = bootstrapBrokerStringSaslIamDecoded
    }
}

extension GetCompatibleKafkaVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCompatibleKafkaVersionsInput(clusterArn: \(String(describing: clusterArn)))"}
}

extension GetCompatibleKafkaVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCompatibleKafkaVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetCompatibleKafkaVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCompatibleKafkaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCompatibleKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCompatibleKafkaVersionsInput>
    public typealias MOutput = OperationOutput<GetCompatibleKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCompatibleKafkaVersionsOutputError>
}

public struct GetCompatibleKafkaVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCompatibleKafkaVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCompatibleKafkaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCompatibleKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clusterArn = input.operationInput.clusterArn {
            let clusterArnQueryItem = URLQueryItem(name: "clusterArn".urlPercentEncoding(), value: String(clusterArn).urlPercentEncoding())
            input.builder.withQueryItem(clusterArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCompatibleKafkaVersionsInput>
    public typealias MOutput = OperationOutput<GetCompatibleKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCompatibleKafkaVersionsOutputError>
}

public struct GetCompatibleKafkaVersionsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster check.</p>
    public let clusterArn: String?

    public init (
        clusterArn: String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct GetCompatibleKafkaVersionsInputBody: Equatable {
}

extension GetCompatibleKafkaVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCompatibleKafkaVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCompatibleKafkaVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCompatibleKafkaVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCompatibleKafkaVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCompatibleKafkaVersionsOutputResponse(compatibleKafkaVersions: \(String(describing: compatibleKafkaVersions)))"}
}

extension GetCompatibleKafkaVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCompatibleKafkaVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.compatibleKafkaVersions = output.compatibleKafkaVersions
        } else {
            self.compatibleKafkaVersions = nil
        }
    }
}

public struct GetCompatibleKafkaVersionsOutputResponse: Equatable {
    /// <p>A list of CompatibleKafkaVersion objects.</p>
    public let compatibleKafkaVersions: [CompatibleKafkaVersion]?

    public init (
        compatibleKafkaVersions: [CompatibleKafkaVersion]? = nil
    )
    {
        self.compatibleKafkaVersions = compatibleKafkaVersions
    }
}

struct GetCompatibleKafkaVersionsOutputResponseBody: Equatable {
    public let compatibleKafkaVersions: [CompatibleKafkaVersion]?
}

extension GetCompatibleKafkaVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibleKafkaVersions = "compatibleKafkaVersions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compatibleKafkaVersionsContainer = try containerValues.decodeIfPresent([CompatibleKafkaVersion?].self, forKey: .compatibleKafkaVersions)
        var compatibleKafkaVersionsDecoded0:[CompatibleKafkaVersion]? = nil
        if let compatibleKafkaVersionsContainer = compatibleKafkaVersionsContainer {
            compatibleKafkaVersionsDecoded0 = [CompatibleKafkaVersion]()
            for structure0 in compatibleKafkaVersionsContainer {
                if let structure0 = structure0 {
                    compatibleKafkaVersionsDecoded0?.append(structure0)
                }
            }
        }
        compatibleKafkaVersions = compatibleKafkaVersionsDecoded0
    }
}

extension Iam: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension Iam: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Iam(enabled: \(String(describing: enabled)))"}
}

/// <p>Details for IAM access control.</p>
public struct Iam: Equatable {
    /// <p>Indicates whether IAM access control is enabled.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(invalidParameter: \(String(describing: invalidParameter)), message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returns information about an error.</p>
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The parameter that caused the error.</p>
    public var invalidParameter: String?
    /// <p>The description of the error.</p>
    public var message: String?

    public init (
        invalidParameter: String? = nil,
        message: String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let invalidParameter: String?
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JmxExporter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabledInBroker != false {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decode(Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension JmxExporter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JmxExporter(enabledInBroker: \(String(describing: enabledInBroker)))"}
}

/// <p>Indicates whether you want to enable or disable the JMX Exporter.</p>
public struct JmxExporter: Equatable {
    /// <p>Indicates whether you want to enable or disable the JMX Exporter.</p>
    public let enabledInBroker: Bool

    public init (
        enabledInBroker: Bool = false
    )
    {
        self.enabledInBroker = enabledInBroker
    }
}

extension JmxExporterInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabledInBroker != false {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decode(Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension JmxExporterInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JmxExporterInfo(enabledInBroker: \(String(describing: enabledInBroker)))"}
}

/// <p>Indicates whether you want to enable or disable the JMX Exporter.</p>
public struct JmxExporterInfo: Equatable {
    /// <p>Indicates whether you want to enable or disable the JMX Exporter.</p>
    public let enabledInBroker: Bool

    public init (
        enabledInBroker: Bool = false
    )
    {
        self.enabledInBroker = enabledInBroker
    }
}

extension KafkaVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "status"
        case version = "version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KafkaVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KafkaVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KafkaVersion(status: \(String(describing: status)), version: \(String(describing: version)))"}
}

public struct KafkaVersion: Equatable {
    public let status: KafkaVersionStatus?
    public let version: String?

    public init (
        status: KafkaVersionStatus? = nil,
        version: String? = nil
    )
    {
        self.status = status
        self.version = version
    }
}

public enum KafkaVersionStatus {
    case active
    case deprecated
    case sdkUnknown(String)
}

extension KafkaVersionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KafkaVersionStatus] {
        return [
            .active,
            .deprecated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deprecated: return "DEPRECATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KafkaVersionStatus(rawValue: rawValue) ?? KafkaVersionStatus.sdkUnknown(rawValue)
    }
}

extension ListClusterOperationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListClusterOperationsInput(clusterArn: \(String(describing: clusterArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListClusterOperationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListClusterOperationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListClusterOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClusterOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClusterOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClusterOperationsInput>
    public typealias MOutput = OperationOutput<ListClusterOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClusterOperationsOutputError>
}

public struct ListClusterOperationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListClusterOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClusterOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClusterOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClusterOperationsInput>
    public typealias MOutput = OperationOutput<ListClusterOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClusterOperationsOutputError>
}

public struct ListClusterOperationsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    public let clusterArn: String?
    /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
    public let maxResults: Int
    /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.
    ///             To get the next batch, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        clusterArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClusterOperationsInputBody: Equatable {
}

extension ListClusterOperationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListClusterOperationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClusterOperationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListClusterOperationsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClusterOperationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListClusterOperationsOutputResponse(clusterOperationInfoList: \(String(describing: clusterOperationInfoList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListClusterOperationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListClusterOperationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterOperationInfoList = output.clusterOperationInfoList
            self.nextToken = output.nextToken
        } else {
            self.clusterOperationInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListClusterOperationsOutputResponse: Equatable {
    /// <p>An array of cluster operation information objects.</p>
    public let clusterOperationInfoList: [ClusterOperationInfo]?
    /// <p>If the response of ListClusterOperations is truncated, it returns a NextToken in the response. This Nexttoken should be sent in the subsequent request to ListClusterOperations.</p>
    public let nextToken: String?

    public init (
        clusterOperationInfoList: [ClusterOperationInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.clusterOperationInfoList = clusterOperationInfoList
        self.nextToken = nextToken
    }
}

struct ListClusterOperationsOutputResponseBody: Equatable {
    public let clusterOperationInfoList: [ClusterOperationInfo]?
    public let nextToken: String?
}

extension ListClusterOperationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterOperationInfoList = "clusterOperationInfoList"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterOperationInfoListContainer = try containerValues.decodeIfPresent([ClusterOperationInfo?].self, forKey: .clusterOperationInfoList)
        var clusterOperationInfoListDecoded0:[ClusterOperationInfo]? = nil
        if let clusterOperationInfoListContainer = clusterOperationInfoListContainer {
            clusterOperationInfoListDecoded0 = [ClusterOperationInfo]()
            for structure0 in clusterOperationInfoListContainer {
                if let structure0 = structure0 {
                    clusterOperationInfoListDecoded0?.append(structure0)
                }
            }
        }
        clusterOperationInfoList = clusterOperationInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClustersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListClustersInput(clusterNameFilter: \(String(describing: clusterNameFilter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListClustersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListClustersInputHeadersMiddleware: Middleware {
    public let id: String = "ListClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClustersInput>
    public typealias MOutput = OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClustersOutputError>
}

public struct ListClustersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let clusterNameFilter = input.operationInput.clusterNameFilter {
            let clusterNameFilterQueryItem = URLQueryItem(name: "clusterNameFilter".urlPercentEncoding(), value: String(clusterNameFilter).urlPercentEncoding())
            input.builder.withQueryItem(clusterNameFilterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClustersInput>
    public typealias MOutput = OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClustersOutputError>
}

public struct ListClustersInput: Equatable {
    /// <p>Specify a prefix of the name of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.</p>
    public let clusterNameFilter: String?
    /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
    public let maxResults: Int
    /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.
    ///             To get the next batch, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        clusterNameFilter: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.clusterNameFilter = clusterNameFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClustersInputBody: Equatable {
}

extension ListClustersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListClustersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClustersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListClustersOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClustersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListClustersOutputResponse(clusterInfoList: \(String(describing: clusterInfoList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListClustersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListClustersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterInfoList = output.clusterInfoList
            self.nextToken = output.nextToken
        } else {
            self.clusterInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListClustersOutputResponse: Equatable {
    /// <p>Information on each of the MSK clusters in the response.</p>
    public let clusterInfoList: [ClusterInfo]?
    /// <p>The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response.
    ///                To get another batch of clusters, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        clusterInfoList: [ClusterInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.clusterInfoList = clusterInfoList
        self.nextToken = nextToken
    }
}

struct ListClustersOutputResponseBody: Equatable {
    public let clusterInfoList: [ClusterInfo]?
    public let nextToken: String?
}

extension ListClustersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterInfoList = "clusterInfoList"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterInfoListContainer = try containerValues.decodeIfPresent([ClusterInfo?].self, forKey: .clusterInfoList)
        var clusterInfoListDecoded0:[ClusterInfo]? = nil
        if let clusterInfoListContainer = clusterInfoListContainer {
            clusterInfoListDecoded0 = [ClusterInfo]()
            for structure0 in clusterInfoListContainer {
                if let structure0 = structure0 {
                    clusterInfoListDecoded0?.append(structure0)
                }
            }
        }
        clusterInfoList = clusterInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConfigurationRevisionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationRevisionsInput(arn: \(String(describing: arn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationRevisionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListConfigurationRevisionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigurationRevisionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationRevisionsInput>
    public typealias MOutput = OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigurationRevisionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationRevisionsInput>
    public typealias MOutput = OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
    public let arn: String?
    /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
    public let maxResults: Int
    /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.
    ///             To get the next batch, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationRevisionsInputBody: Equatable {
}

extension ListConfigurationRevisionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListConfigurationRevisionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationRevisionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationRevisionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationRevisionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationRevisionsOutputResponse(nextToken: \(String(describing: nextToken)), revisions: \(String(describing: revisions)))"}
}

extension ListConfigurationRevisionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConfigurationRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.revisions = output.revisions
        } else {
            self.nextToken = nil
            self.revisions = nil
        }
    }
}

public struct ListConfigurationRevisionsOutputResponse: Equatable {
    /// <p>Paginated results marker.</p>
    public let nextToken: String?
    /// <p>List of ConfigurationRevision objects.</p>
    public let revisions: [ConfigurationRevision]?

    public init (
        nextToken: String? = nil,
        revisions: [ConfigurationRevision]? = nil
    )
    {
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

struct ListConfigurationRevisionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let revisions: [ConfigurationRevision]?
}

extension ListConfigurationRevisionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case revisions = "revisions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let revisionsContainer = try containerValues.decodeIfPresent([ConfigurationRevision?].self, forKey: .revisions)
        var revisionsDecoded0:[ConfigurationRevision]? = nil
        if let revisionsContainer = revisionsContainer {
            revisionsDecoded0 = [ConfigurationRevision]()
            for structure0 in revisionsContainer {
                if let structure0 = structure0 {
                    revisionsDecoded0?.append(structure0)
                }
            }
        }
        revisions = revisionsDecoded0
    }
}

extension ListConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationsInput>
    public typealias MOutput = OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationsInput>
    public typealias MOutput = OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInput: Equatable {
    /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
    public let maxResults: Int
    /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.
    ///             To get the next batch, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationsInputBody: Equatable {
}

extension ListConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationsOutputResponse(configurations: \(String(describing: configurations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurations = output.configurations
            self.nextToken = output.nextToken
        } else {
            self.configurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationsOutputResponse: Equatable {
    /// <p>An array of MSK configurations.</p>
    public let configurations: [Configuration]?
    /// <p>The paginated results marker. When the result of a ListConfigurations operation is truncated, the call returns NextToken in the response.
    ///                To get another batch of configurations, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        configurations: [Configuration]? = nil,
        nextToken: String? = nil
    )
    {
        self.configurations = configurations
        self.nextToken = nextToken
    }
}

struct ListConfigurationsOutputResponseBody: Equatable {
    public let configurations: [Configuration]?
    public let nextToken: String?
}

extension ListConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurations = "configurations"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListKafkaVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKafkaVersionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListKafkaVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListKafkaVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListKafkaVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKafkaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKafkaVersionsInput>
    public typealias MOutput = OperationOutput<ListKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKafkaVersionsOutputError>
}

public struct ListKafkaVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListKafkaVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKafkaVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKafkaVersionsInput>
    public typealias MOutput = OperationOutput<ListKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKafkaVersionsOutputError>
}

public struct ListKafkaVersionsInput: Equatable {
    /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
    public let maxResults: Int
    /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKafkaVersionsInputBody: Equatable {
}

extension ListKafkaVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListKafkaVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListKafkaVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListKafkaVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKafkaVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKafkaVersionsOutputResponse(kafkaVersions: \(String(describing: kafkaVersions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListKafkaVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListKafkaVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.kafkaVersions = output.kafkaVersions
            self.nextToken = output.nextToken
        } else {
            self.kafkaVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListKafkaVersionsOutputResponse: Equatable {
    public let kafkaVersions: [KafkaVersion]?
    public let nextToken: String?

    public init (
        kafkaVersions: [KafkaVersion]? = nil,
        nextToken: String? = nil
    )
    {
        self.kafkaVersions = kafkaVersions
        self.nextToken = nextToken
    }
}

struct ListKafkaVersionsOutputResponseBody: Equatable {
    public let kafkaVersions: [KafkaVersion]?
    public let nextToken: String?
}

extension ListKafkaVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case kafkaVersions = "kafkaVersions"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([KafkaVersion?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[KafkaVersion]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [KafkaVersion]()
            for structure0 in kafkaVersionsContainer {
                if let structure0 = structure0 {
                    kafkaVersionsDecoded0?.append(structure0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNodesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNodesInput(clusterArn: \(String(describing: clusterArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListNodesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListNodesInputHeadersMiddleware: Middleware {
    public let id: String = "ListNodesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNodesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNodesInput>
    public typealias MOutput = OperationOutput<ListNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNodesOutputError>
}

public struct ListNodesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListNodesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNodesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNodesInput>
    public typealias MOutput = OperationOutput<ListNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNodesOutputError>
}

public struct ListNodesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    public let clusterArn: String?
    /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
    public let maxResults: Int
    /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.
    ///             To get the next batch, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        clusterArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNodesInputBody: Equatable {
}

extension ListNodesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListNodesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNodesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNodesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNodesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNodesOutputResponse(nextToken: \(String(describing: nextToken)), nodeInfoList: \(String(describing: nodeInfoList)))"}
}

extension ListNodesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListNodesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.nodeInfoList = output.nodeInfoList
        } else {
            self.nextToken = nil
            self.nodeInfoList = nil
        }
    }
}

public struct ListNodesOutputResponse: Equatable {
    /// <p>The paginated results marker. When the result of a ListNodes operation is truncated, the call returns NextToken in the response.
    ///                To get another batch of nodes, provide this token in your next request.</p>
    public let nextToken: String?
    /// <p>List containing a NodeInfo object.</p>
    public let nodeInfoList: [NodeInfo]?

    public init (
        nextToken: String? = nil,
        nodeInfoList: [NodeInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodeInfoList = nodeInfoList
    }
}

struct ListNodesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let nodeInfoList: [NodeInfo]?
}

extension ListNodesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case nodeInfoList = "nodeInfoList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let nodeInfoListContainer = try containerValues.decodeIfPresent([NodeInfo?].self, forKey: .nodeInfoList)
        var nodeInfoListDecoded0:[NodeInfo]? = nil
        if let nodeInfoListContainer = nodeInfoListContainer {
            nodeInfoListDecoded0 = [NodeInfo]()
            for structure0 in nodeInfoListContainer {
                if let structure0 = structure0 {
                    nodeInfoListDecoded0?.append(structure0)
                }
            }
        }
        nodeInfoList = nodeInfoListDecoded0
    }
}

extension ListScramSecretsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListScramSecretsInput(clusterArn: \(String(describing: clusterArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListScramSecretsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListScramSecretsInputHeadersMiddleware: Middleware {
    public let id: String = "ListScramSecretsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListScramSecretsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListScramSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListScramSecretsInput>
    public typealias MOutput = OperationOutput<ListScramSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListScramSecretsOutputError>
}

public struct ListScramSecretsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListScramSecretsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListScramSecretsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListScramSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListScramSecretsInput>
    public typealias MOutput = OperationOutput<ListScramSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListScramSecretsOutputError>
}

public struct ListScramSecretsInput: Equatable {
    /// <p>The arn of the cluster.</p>
    public let clusterArn: String?
    /// <p>The maxResults of the query.</p>
    public let maxResults: Int
    /// <p>The nextToken of the query.</p>
    public let nextToken: String?

    public init (
        clusterArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListScramSecretsInputBody: Equatable {
}

extension ListScramSecretsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListScramSecretsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListScramSecretsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListScramSecretsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListScramSecretsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListScramSecretsOutputResponse(nextToken: \(String(describing: nextToken)), secretArnList: \(String(describing: secretArnList)))"}
}

extension ListScramSecretsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListScramSecretsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.secretArnList = output.secretArnList
        } else {
            self.nextToken = nil
            self.secretArnList = nil
        }
    }
}

public struct ListScramSecretsOutputResponse: Equatable {
    /// <p>Paginated results marker.</p>
    public let nextToken: String?
    /// <p>The list of scram secrets associated with the cluster.</p>
    public let secretArnList: [String]?

    public init (
        nextToken: String? = nil,
        secretArnList: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.secretArnList = secretArnList
    }
}

struct ListScramSecretsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let secretArnList: [String]?
}

extension ListScramSecretsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case secretArnList = "secretArnList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let secretArnListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .secretArnList)
        var secretArnListDecoded0:[String]? = nil
        if let secretArnListContainer = secretArnListContainer {
            secretArnListDecoded0 = [String]()
            for string0 in secretArnListContainer {
                if let string0 = string0 {
                    secretArnListDecoded0?.append(string0)
                }
            }
        }
        secretArnList = secretArnListDecoded0
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The key-value pair for the resource tag.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LoggingInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case brokerLogs = "brokerLogs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerLogs = brokerLogs {
            try encodeContainer.encode(brokerLogs, forKey: .brokerLogs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerLogsDecoded = try containerValues.decodeIfPresent(BrokerLogs.self, forKey: .brokerLogs)
        brokerLogs = brokerLogsDecoded
    }
}

extension LoggingInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingInfo(brokerLogs: \(String(describing: brokerLogs)))"}
}

public struct LoggingInfo: Equatable {
    public let brokerLogs: BrokerLogs?

    public init (
        brokerLogs: BrokerLogs? = nil
    )
    {
        self.brokerLogs = brokerLogs
    }
}

extension MutableClusterInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case brokerEBSVolumeInfo = "brokerEBSVolumeInfo"
        case configurationInfo = "configurationInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case instanceType = "instanceType"
        case kafkaVersion = "kafkaVersion"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerEBSVolumeInfo = brokerEBSVolumeInfo {
            var brokerEBSVolumeInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .brokerEBSVolumeInfo)
            for __listofbrokerebsvolumeinfo0 in brokerEBSVolumeInfo {
                try brokerEBSVolumeInfoContainer.encode(__listofbrokerebsvolumeinfo0)
            }
        }
        if let configurationInfo = configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let kafkaVersion = kafkaVersion {
            try encodeContainer.encode(kafkaVersion, forKey: .kafkaVersion)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if numberOfBrokerNodes != 0 {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerEBSVolumeInfoContainer = try containerValues.decodeIfPresent([BrokerEBSVolumeInfo?].self, forKey: .brokerEBSVolumeInfo)
        var brokerEBSVolumeInfoDecoded0:[BrokerEBSVolumeInfo]? = nil
        if let brokerEBSVolumeInfoContainer = brokerEBSVolumeInfoContainer {
            brokerEBSVolumeInfoDecoded0 = [BrokerEBSVolumeInfo]()
            for structure0 in brokerEBSVolumeInfoContainer {
                if let structure0 = structure0 {
                    brokerEBSVolumeInfoDecoded0?.append(structure0)
                }
            }
        }
        brokerEBSVolumeInfo = brokerEBSVolumeInfoDecoded0
        let configurationInfoDecoded = try containerValues.decodeIfPresent(ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decode(Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(OpenMonitoring.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let kafkaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kafkaVersion)
        kafkaVersion = kafkaVersionDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
    }
}

extension MutableClusterInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MutableClusterInfo(brokerEBSVolumeInfo: \(String(describing: brokerEBSVolumeInfo)), configurationInfo: \(String(describing: configurationInfo)), enhancedMonitoring: \(String(describing: enhancedMonitoring)), instanceType: \(String(describing: instanceType)), kafkaVersion: \(String(describing: kafkaVersion)), loggingInfo: \(String(describing: loggingInfo)), numberOfBrokerNodes: \(String(describing: numberOfBrokerNodes)), openMonitoring: \(String(describing: openMonitoring)))"}
}

/// <p>Information about cluster attributes that can be updated via update APIs.</p>
public struct MutableClusterInfo: Equatable {
    /// <p>Specifies the size of the EBS volume and the ID of the associated broker.</p>
    public let brokerEBSVolumeInfo: [BrokerEBSVolumeInfo]?
    /// <p>Information about the changes in the configuration of the brokers.</p>
    public let configurationInfo: ConfigurationInfo?
    /// <p>Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.</p>
    public let enhancedMonitoring: EnhancedMonitoring?
    /// <p>Information about the Amazon MSK broker type.</p>
    public let instanceType: String?
    /// <p>The Kafka version.</p>
    public let kafkaVersion: String?
    public let loggingInfo: LoggingInfo?
    /// <p>The number of broker nodes in the cluster.</p>
    public let numberOfBrokerNodes: Int
    /// <p>The settings for open monitoring.</p>
    public let openMonitoring: OpenMonitoring?

    public init (
        brokerEBSVolumeInfo: [BrokerEBSVolumeInfo]? = nil,
        configurationInfo: ConfigurationInfo? = nil,
        enhancedMonitoring: EnhancedMonitoring? = nil,
        instanceType: String? = nil,
        kafkaVersion: String? = nil,
        loggingInfo: LoggingInfo? = nil,
        numberOfBrokerNodes: Int = 0,
        openMonitoring: OpenMonitoring? = nil
    )
    {
        self.brokerEBSVolumeInfo = brokerEBSVolumeInfo
        self.configurationInfo = configurationInfo
        self.enhancedMonitoring = enhancedMonitoring
        self.instanceType = instanceType
        self.kafkaVersion = kafkaVersion
        self.loggingInfo = loggingInfo
        self.numberOfBrokerNodes = numberOfBrokerNodes
        self.openMonitoring = openMonitoring
    }
}

extension NodeExporter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabledInBroker != false {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decode(Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension NodeExporter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NodeExporter(enabledInBroker: \(String(describing: enabledInBroker)))"}
}

/// <p>Indicates whether you want to enable or disable the Node Exporter.</p>
public struct NodeExporter: Equatable {
    /// <p>Indicates whether you want to enable or disable the Node Exporter.</p>
    public let enabledInBroker: Bool

    public init (
        enabledInBroker: Bool = false
    )
    {
        self.enabledInBroker = enabledInBroker
    }
}

extension NodeExporterInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabledInBroker != false {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decode(Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension NodeExporterInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NodeExporterInfo(enabledInBroker: \(String(describing: enabledInBroker)))"}
}

/// <p>Indicates whether you want to enable or disable the Node Exporter.</p>
public struct NodeExporterInfo: Equatable {
    /// <p>Indicates whether you want to enable or disable the Node Exporter.</p>
    public let enabledInBroker: Bool

    public init (
        enabledInBroker: Bool = false
    )
    {
        self.enabledInBroker = enabledInBroker
    }
}

extension NodeInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addedToClusterTime = "addedToClusterTime"
        case brokerNodeInfo = "brokerNodeInfo"
        case instanceType = "instanceType"
        case nodeARN = "nodeARN"
        case nodeType = "nodeType"
        case zookeeperNodeInfo = "zookeeperNodeInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addedToClusterTime = addedToClusterTime {
            try encodeContainer.encode(addedToClusterTime, forKey: .addedToClusterTime)
        }
        if let brokerNodeInfo = brokerNodeInfo {
            try encodeContainer.encode(brokerNodeInfo, forKey: .brokerNodeInfo)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let nodeARN = nodeARN {
            try encodeContainer.encode(nodeARN, forKey: .nodeARN)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType.rawValue, forKey: .nodeType)
        }
        if let zookeeperNodeInfo = zookeeperNodeInfo {
            try encodeContainer.encode(zookeeperNodeInfo, forKey: .zookeeperNodeInfo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addedToClusterTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addedToClusterTime)
        addedToClusterTime = addedToClusterTimeDecoded
        let brokerNodeInfoDecoded = try containerValues.decodeIfPresent(BrokerNodeInfo.self, forKey: .brokerNodeInfo)
        brokerNodeInfo = brokerNodeInfoDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let nodeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeARN)
        nodeARN = nodeARNDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(NodeType.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let zookeeperNodeInfoDecoded = try containerValues.decodeIfPresent(ZookeeperNodeInfo.self, forKey: .zookeeperNodeInfo)
        zookeeperNodeInfo = zookeeperNodeInfoDecoded
    }
}

extension NodeInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NodeInfo(addedToClusterTime: \(String(describing: addedToClusterTime)), brokerNodeInfo: \(String(describing: brokerNodeInfo)), instanceType: \(String(describing: instanceType)), nodeARN: \(String(describing: nodeARN)), nodeType: \(String(describing: nodeType)), zookeeperNodeInfo: \(String(describing: zookeeperNodeInfo)))"}
}

/// <p>The node information object.</p>
public struct NodeInfo: Equatable {
    /// <p>The start time.</p>
    public let addedToClusterTime: String?
    /// <p>The broker node info.</p>
    public let brokerNodeInfo: BrokerNodeInfo?
    /// <p>The instance type.</p>
    public let instanceType: String?
    /// <p>The Amazon Resource Name (ARN) of the node.</p>
    public let nodeARN: String?
    /// <p>The node type.</p>
    public let nodeType: NodeType?
    /// <p>The ZookeeperNodeInfo.</p>
    public let zookeeperNodeInfo: ZookeeperNodeInfo?

    public init (
        addedToClusterTime: String? = nil,
        brokerNodeInfo: BrokerNodeInfo? = nil,
        instanceType: String? = nil,
        nodeARN: String? = nil,
        nodeType: NodeType? = nil,
        zookeeperNodeInfo: ZookeeperNodeInfo? = nil
    )
    {
        self.addedToClusterTime = addedToClusterTime
        self.brokerNodeInfo = brokerNodeInfo
        self.instanceType = instanceType
        self.nodeARN = nodeARN
        self.nodeType = nodeType
        self.zookeeperNodeInfo = zookeeperNodeInfo
    }
}

/// <p>The broker or Zookeeper node.</p>
public enum NodeType {
    case broker
    case sdkUnknown(String)
}

extension NodeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NodeType] {
        return [
            .broker,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .broker: return "BROKER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NodeType(rawValue: rawValue) ?? NodeType.sdkUnknown(rawValue)
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(invalidParameter: \(String(describing: invalidParameter)), message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returns information about an error.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The parameter that caused the error.</p>
    public var invalidParameter: String?
    /// <p>The description of the error.</p>
    public var message: String?

    public init (
        invalidParameter: String? = nil,
        message: String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let invalidParameter: String?
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenMonitoring: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prometheus = "prometheus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prometheus = prometheus {
            try encodeContainer.encode(prometheus, forKey: .prometheus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prometheusDecoded = try containerValues.decodeIfPresent(Prometheus.self, forKey: .prometheus)
        prometheus = prometheusDecoded
    }
}

extension OpenMonitoring: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpenMonitoring(prometheus: \(String(describing: prometheus)))"}
}

/// <p>JMX and Node monitoring for the MSK cluster.</p>
public struct OpenMonitoring: Equatable {
    /// <p>Prometheus settings.</p>
    public let prometheus: Prometheus?

    public init (
        prometheus: Prometheus? = nil
    )
    {
        self.prometheus = prometheus
    }
}

extension OpenMonitoringInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prometheus = "prometheus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prometheus = prometheus {
            try encodeContainer.encode(prometheus, forKey: .prometheus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prometheusDecoded = try containerValues.decodeIfPresent(PrometheusInfo.self, forKey: .prometheus)
        prometheus = prometheusDecoded
    }
}

extension OpenMonitoringInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpenMonitoringInfo(prometheus: \(String(describing: prometheus)))"}
}

/// <p>JMX and Node monitoring for the MSK cluster.</p>
public struct OpenMonitoringInfo: Equatable {
    /// <p>Prometheus settings.</p>
    public let prometheus: PrometheusInfo?

    public init (
        prometheus: PrometheusInfo? = nil
    )
    {
        self.prometheus = prometheus
    }
}

extension Prometheus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jmxExporter = "jmxExporter"
        case nodeExporter = "nodeExporter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jmxExporter = jmxExporter {
            try encodeContainer.encode(jmxExporter, forKey: .jmxExporter)
        }
        if let nodeExporter = nodeExporter {
            try encodeContainer.encode(nodeExporter, forKey: .nodeExporter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jmxExporterDecoded = try containerValues.decodeIfPresent(JmxExporter.self, forKey: .jmxExporter)
        jmxExporter = jmxExporterDecoded
        let nodeExporterDecoded = try containerValues.decodeIfPresent(NodeExporter.self, forKey: .nodeExporter)
        nodeExporter = nodeExporterDecoded
    }
}

extension Prometheus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Prometheus(jmxExporter: \(String(describing: jmxExporter)), nodeExporter: \(String(describing: nodeExporter)))"}
}

/// <p>Prometheus settings.</p>
public struct Prometheus: Equatable {
    /// <p>Indicates whether you want to enable or disable the JMX Exporter.</p>
    public let jmxExporter: JmxExporter?
    /// <p>Indicates whether you want to enable or disable the Node Exporter.</p>
    public let nodeExporter: NodeExporter?

    public init (
        jmxExporter: JmxExporter? = nil,
        nodeExporter: NodeExporter? = nil
    )
    {
        self.jmxExporter = jmxExporter
        self.nodeExporter = nodeExporter
    }
}

extension PrometheusInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jmxExporter = "jmxExporter"
        case nodeExporter = "nodeExporter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jmxExporter = jmxExporter {
            try encodeContainer.encode(jmxExporter, forKey: .jmxExporter)
        }
        if let nodeExporter = nodeExporter {
            try encodeContainer.encode(nodeExporter, forKey: .nodeExporter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jmxExporterDecoded = try containerValues.decodeIfPresent(JmxExporterInfo.self, forKey: .jmxExporter)
        jmxExporter = jmxExporterDecoded
        let nodeExporterDecoded = try containerValues.decodeIfPresent(NodeExporterInfo.self, forKey: .nodeExporter)
        nodeExporter = nodeExporterDecoded
    }
}

extension PrometheusInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PrometheusInfo(jmxExporter: \(String(describing: jmxExporter)), nodeExporter: \(String(describing: nodeExporter)))"}
}

/// <p>Prometheus settings.</p>
public struct PrometheusInfo: Equatable {
    /// <p>Indicates whether you want to enable or disable the JMX Exporter.</p>
    public let jmxExporter: JmxExporterInfo?
    /// <p>Indicates whether you want to enable or disable the Node Exporter.</p>
    public let nodeExporter: NodeExporterInfo?

    public init (
        jmxExporter: JmxExporterInfo? = nil,
        nodeExporter: NodeExporterInfo? = nil
    )
    {
        self.jmxExporter = jmxExporter
        self.nodeExporter = nodeExporter
    }
}

public struct RebootBrokerInputBodyMiddleware: Middleware {
    public let id: String = "RebootBrokerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootBrokerInput>
    public typealias MOutput = OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootBrokerOutputError>
}

extension RebootBrokerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootBrokerInput(brokerIds: \(String(describing: brokerIds)), clusterArn: \(String(describing: clusterArn)))"}
}

extension RebootBrokerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case brokerIds = "brokerIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerIds = brokerIds {
            var brokerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .brokerIds)
            for __listof__string0 in brokerIds {
                try brokerIdsContainer.encode(__listof__string0)
            }
        }
    }
}

public struct RebootBrokerInputHeadersMiddleware: Middleware {
    public let id: String = "RebootBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootBrokerInput>
    public typealias MOutput = OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootBrokerOutputError>
}

public struct RebootBrokerInputQueryItemMiddleware: Middleware {
    public let id: String = "RebootBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootBrokerInput>
    public typealias MOutput = OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootBrokerOutputError>
}

/// Reboots a node.
public struct RebootBrokerInput: Equatable {
    /// <p>The list of broker IDs to be rebooted. The reboot-broker operation supports rebooting one broker at a time.</p>
    public let brokerIds: [String]?
    /// <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
    public let clusterArn: String?

    public init (
        brokerIds: [String]? = nil,
        clusterArn: String? = nil
    )
    {
        self.brokerIds = brokerIds
        self.clusterArn = clusterArn
    }
}

struct RebootBrokerInputBody: Equatable {
    public let brokerIds: [String]?
}

extension RebootBrokerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case brokerIds = "brokerIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .brokerIds)
        var brokerIdsDecoded0:[String]? = nil
        if let brokerIdsContainer = brokerIdsContainer {
            brokerIdsDecoded0 = [String]()
            for string0 in brokerIdsContainer {
                if let string0 = string0 {
                    brokerIdsDecoded0?.append(string0)
                }
            }
        }
        brokerIds = brokerIdsDecoded0
    }
}

extension RebootBrokerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootBrokerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootBrokerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootBrokerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootBrokerOutputResponse(clusterArn: \(String(describing: clusterArn)), clusterOperationArn: \(String(describing: clusterOperationArn)))"}
}

extension RebootBrokerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RebootBrokerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct RebootBrokerOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterArn: String?
    /// <p>The Amazon Resource Name (ARN) of the cluster operation.</p>
    public let clusterOperationArn: String?

    public init (
        clusterArn: String? = nil,
        clusterOperationArn: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct RebootBrokerOutputResponseBody: Equatable {
    public let clusterArn: String?
    public let clusterOperationArn: String?
}

extension RebootBrokerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

extension S3: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "bucket"
        case enabled = "enabled"
        case prefix = "prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension S3: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3(bucket: \(String(describing: bucket)), enabled: \(String(describing: enabled)), prefix: \(String(describing: prefix)))"}
}

public struct S3: Equatable {
    public let bucket: String?
    public let enabled: Bool
    public let prefix: String?

    public init (
        bucket: String? = nil,
        enabled: Bool = false,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.enabled = enabled
        self.prefix = prefix
    }
}

extension Sasl: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iam = "iam"
        case scram = "scram"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iam = iam {
            try encodeContainer.encode(iam, forKey: .iam)
        }
        if let scram = scram {
            try encodeContainer.encode(scram, forKey: .scram)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scramDecoded = try containerValues.decodeIfPresent(Scram.self, forKey: .scram)
        scram = scramDecoded
        let iamDecoded = try containerValues.decodeIfPresent(Iam.self, forKey: .iam)
        iam = iamDecoded
    }
}

extension Sasl: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Sasl(iam: \(String(describing: iam)), scram: \(String(describing: scram)))"}
}

/// <p>Details for client authentication using SASL.</p>
public struct Sasl: Equatable {
    /// <p>Indicates whether IAM access control is enabled.</p>
    public let iam: Iam?
    /// <p>Details for SASL/SCRAM client authentication.</p>
    public let scram: Scram?

    public init (
        iam: Iam? = nil,
        scram: Scram? = nil
    )
    {
        self.iam = iam
        self.scram = scram
    }
}

extension Scram: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension Scram: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Scram(enabled: \(String(describing: enabled)))"}
}

/// <p>Details for SASL/SCRAM client authentication.</p>
public struct Scram: Equatable {
    /// <p>SASL/SCRAM authentication is enabled or not.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(invalidParameter: \(String(describing: invalidParameter)), message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returns information about an error.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The parameter that caused the error.</p>
    public var invalidParameter: String?
    /// <p>The description of the error.</p>
    public var message: String?

    public init (
        invalidParameter: String? = nil,
        message: String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let invalidParameter: String?
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StateInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "code"
        case message = "message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StateInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StateInfo(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

public struct StateInfo: Equatable {
    public let code: String?
    public let message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

extension StorageInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ebsStorageInfo = "ebsStorageInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsStorageInfo = ebsStorageInfo {
            try encodeContainer.encode(ebsStorageInfo, forKey: .ebsStorageInfo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsStorageInfoDecoded = try containerValues.decodeIfPresent(EBSStorageInfo.self, forKey: .ebsStorageInfo)
        ebsStorageInfo = ebsStorageInfoDecoded
    }
}

extension StorageInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageInfo(ebsStorageInfo: \(String(describing: ebsStorageInfo)))"}
}

/// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
public struct StorageInfo: Equatable {
    /// <p>EBS volume information.</p>
    public let ebsStorageInfo: EBSStorageInfo?

    public init (
        ebsStorageInfo: EBSStorageInfo? = nil
    )
    {
        self.ebsStorageInfo = ebsStorageInfo
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
    public let resourceArn: String?
    /// <p>The key-value pair for the resource tag.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tls: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArnList = "certificateAuthorityArnList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArnList = certificateAuthorityArnList {
            var certificateAuthorityArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateAuthorityArnList)
            for __listof__string0 in certificateAuthorityArnList {
                try certificateAuthorityArnListContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .certificateAuthorityArnList)
        var certificateAuthorityArnListDecoded0:[String]? = nil
        if let certificateAuthorityArnListContainer = certificateAuthorityArnListContainer {
            certificateAuthorityArnListDecoded0 = [String]()
            for string0 in certificateAuthorityArnListContainer {
                if let string0 = string0 {
                    certificateAuthorityArnListDecoded0?.append(string0)
                }
            }
        }
        certificateAuthorityArnList = certificateAuthorityArnListDecoded0
    }
}

extension Tls: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tls(certificateAuthorityArnList: \(String(describing: certificateAuthorityArnList)))"}
}

/// <p>Details for client authentication using TLS.</p>
public struct Tls: Equatable {
    /// <p>List of ACM Certificate Authority ARNs.</p>
    public let certificateAuthorityArnList: [String]?

    public init (
        certificateAuthorityArnList: [String]? = nil
    )
    {
        self.certificateAuthorityArnList = certificateAuthorityArnList
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(invalidParameter: \(String(describing: invalidParameter)), message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returns information about an error.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The parameter that caused the error.</p>
    public var invalidParameter: String?
    /// <p>The description of the error.</p>
    public var message: String?

    public init (
        invalidParameter: String? = nil,
        message: String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let invalidParameter: String?
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(invalidParameter: \(String(describing: invalidParameter)), message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returns information about an error.</p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The parameter that caused the error.</p>
    public var invalidParameter: String?
    /// <p>The description of the error.</p>
    public var message: String?

    public init (
        invalidParameter: String? = nil,
        message: String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let invalidParameter: String?
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessedScramSecret: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "errorCode"
        case errorMessage = "errorMessage"
        case secretArn = "secretArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
    }
}

extension UnprocessedScramSecret: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnprocessedScramSecret(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), secretArn: \(String(describing: secretArn)))"}
}

/// <p>Error info for scram secret associate/disassociate failure.</p>
public struct UnprocessedScramSecret: Equatable {
    /// <p>Error code for associate/disassociate failure.</p>
    public let errorCode: String?
    /// <p>Error message for associate/disassociate failure.</p>
    public let errorMessage: String?
    /// <p>AWS Secrets Manager secret ARN.</p>
    public let secretArn: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        secretArn: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.secretArn = secretArn
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
    public let resourceArn: String?
    /// <p>Tag keys must be unique for a given cluster. In addition, the following restrictions apply:</p>
    ///             <ul>
    ///                <li>
    ///                   <p>Each tag key must be unique. If you add a tag with a key that's already in
    ///                   use, your new tag overwrites the existing key-value pair. </p>
    ///                </li>
    ///                <li>
    ///                   <p>You can't start a tag key with aws: because this prefix is reserved for use
    ///                   by  AWS.  AWS creates tags that begin with this prefix on your behalf, but
    ///                   you can't edit or delete them.</p>
    ///                </li>
    ///                <li>
    ///                   <p>Tag keys must be between 1 and 128 Unicode characters in length.</p>
    ///                </li>
    ///                <li>
    ///                   <p>Tag keys must consist of the following characters: Unicode letters, digits,
    ///                   white space, and the following special characters: _ . / = + -
    ///                      @.</p>
    ///                </li>
    ///             </ul>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateBrokerCountInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBrokerCountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerCountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerCountInput>
    public typealias MOutput = OperationOutput<UpdateBrokerCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerCountOutputError>
}

extension UpdateBrokerCountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBrokerCountInput(clusterArn: \(String(describing: clusterArn)), currentVersion: \(String(describing: currentVersion)), targetNumberOfBrokerNodes: \(String(describing: targetNumberOfBrokerNodes)))"}
}

extension UpdateBrokerCountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "currentVersion"
        case targetNumberOfBrokerNodes = "targetNumberOfBrokerNodes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if targetNumberOfBrokerNodes != 0 {
            try encodeContainer.encode(targetNumberOfBrokerNodes, forKey: .targetNumberOfBrokerNodes)
        }
    }
}

public struct UpdateBrokerCountInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBrokerCountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerCountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerCountInput>
    public typealias MOutput = OperationOutput<UpdateBrokerCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerCountOutputError>
}

public struct UpdateBrokerCountInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBrokerCountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerCountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerCountInput>
    public typealias MOutput = OperationOutput<UpdateBrokerCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerCountOutputError>
}

public struct UpdateBrokerCountInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    public let clusterArn: String?
    /// <p>The version of cluster to update from. A successful operation will then generate a new version.</p>
    public let currentVersion: String?
    /// <p>The number of broker nodes that you want the cluster to have after this operation completes successfully.</p>
    public let targetNumberOfBrokerNodes: Int

    public init (
        clusterArn: String? = nil,
        currentVersion: String? = nil,
        targetNumberOfBrokerNodes: Int = 0
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetNumberOfBrokerNodes = targetNumberOfBrokerNodes
    }
}

struct UpdateBrokerCountInputBody: Equatable {
    public let currentVersion: String?
    public let targetNumberOfBrokerNodes: Int
}

extension UpdateBrokerCountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "currentVersion"
        case targetNumberOfBrokerNodes = "targetNumberOfBrokerNodes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetNumberOfBrokerNodesDecoded = try containerValues.decode(Int.self, forKey: .targetNumberOfBrokerNodes)
        targetNumberOfBrokerNodes = targetNumberOfBrokerNodesDecoded
    }
}

extension UpdateBrokerCountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBrokerCountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBrokerCountOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBrokerCountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBrokerCountOutputResponse(clusterArn: \(String(describing: clusterArn)), clusterOperationArn: \(String(describing: clusterOperationArn)))"}
}

extension UpdateBrokerCountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBrokerCountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateBrokerCountOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterArn: String?
    /// <p>The Amazon Resource Name (ARN) of the cluster operation.</p>
    public let clusterOperationArn: String?

    public init (
        clusterArn: String? = nil,
        clusterOperationArn: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateBrokerCountOutputResponseBody: Equatable {
    public let clusterArn: String?
    public let clusterOperationArn: String?
}

extension UpdateBrokerCountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateBrokerStorageInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBrokerStorageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerStorageInput>
    public typealias MOutput = OperationOutput<UpdateBrokerStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerStorageOutputError>
}

extension UpdateBrokerStorageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBrokerStorageInput(clusterArn: \(String(describing: clusterArn)), currentVersion: \(String(describing: currentVersion)), targetBrokerEBSVolumeInfo: \(String(describing: targetBrokerEBSVolumeInfo)))"}
}

extension UpdateBrokerStorageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "currentVersion"
        case targetBrokerEBSVolumeInfo = "targetBrokerEBSVolumeInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfo {
            var targetBrokerEBSVolumeInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBrokerEBSVolumeInfo)
            for __listofbrokerebsvolumeinfo0 in targetBrokerEBSVolumeInfo {
                try targetBrokerEBSVolumeInfoContainer.encode(__listofbrokerebsvolumeinfo0)
            }
        }
    }
}

public struct UpdateBrokerStorageInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBrokerStorageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerStorageInput>
    public typealias MOutput = OperationOutput<UpdateBrokerStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerStorageOutputError>
}

public struct UpdateBrokerStorageInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBrokerStorageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerStorageInput>
    public typealias MOutput = OperationOutput<UpdateBrokerStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerStorageOutputError>
}

public struct UpdateBrokerStorageInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    public let clusterArn: String?
    /// <p>The version of cluster to update from. A successful operation will then generate a new version.</p>
    public let currentVersion: String?
    /// <p>Describes the target volume size and the ID of the broker to apply the update to.</p>
    public let targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]?

    public init (
        clusterArn: String? = nil,
        currentVersion: String? = nil,
        targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfo
    }
}

struct UpdateBrokerStorageInputBody: Equatable {
    public let currentVersion: String?
    public let targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]?
}

extension UpdateBrokerStorageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "currentVersion"
        case targetBrokerEBSVolumeInfo = "targetBrokerEBSVolumeInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetBrokerEBSVolumeInfoContainer = try containerValues.decodeIfPresent([BrokerEBSVolumeInfo?].self, forKey: .targetBrokerEBSVolumeInfo)
        var targetBrokerEBSVolumeInfoDecoded0:[BrokerEBSVolumeInfo]? = nil
        if let targetBrokerEBSVolumeInfoContainer = targetBrokerEBSVolumeInfoContainer {
            targetBrokerEBSVolumeInfoDecoded0 = [BrokerEBSVolumeInfo]()
            for structure0 in targetBrokerEBSVolumeInfoContainer {
                if let structure0 = structure0 {
                    targetBrokerEBSVolumeInfoDecoded0?.append(structure0)
                }
            }
        }
        targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfoDecoded0
    }
}

extension UpdateBrokerStorageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBrokerStorageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBrokerStorageOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBrokerStorageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBrokerStorageOutputResponse(clusterArn: \(String(describing: clusterArn)), clusterOperationArn: \(String(describing: clusterOperationArn)))"}
}

extension UpdateBrokerStorageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBrokerStorageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateBrokerStorageOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterArn: String?
    /// <p>The Amazon Resource Name (ARN) of the cluster operation.</p>
    public let clusterOperationArn: String?

    public init (
        clusterArn: String? = nil,
        clusterOperationArn: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateBrokerStorageOutputResponseBody: Equatable {
    public let clusterArn: String?
    public let clusterOperationArn: String?
}

extension UpdateBrokerStorageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateBrokerTypeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBrokerTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerTypeInput>
    public typealias MOutput = OperationOutput<UpdateBrokerTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerTypeOutputError>
}

extension UpdateBrokerTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBrokerTypeInput(clusterArn: \(String(describing: clusterArn)), currentVersion: \(String(describing: currentVersion)), targetInstanceType: \(String(describing: targetInstanceType)))"}
}

extension UpdateBrokerTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "currentVersion"
        case targetInstanceType = "targetInstanceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let targetInstanceType = targetInstanceType {
            try encodeContainer.encode(targetInstanceType, forKey: .targetInstanceType)
        }
    }
}

public struct UpdateBrokerTypeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBrokerTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerTypeInput>
    public typealias MOutput = OperationOutput<UpdateBrokerTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerTypeOutputError>
}

public struct UpdateBrokerTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBrokerTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerTypeInput>
    public typealias MOutput = OperationOutput<UpdateBrokerTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerTypeOutputError>
}

public struct UpdateBrokerTypeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    public let clusterArn: String?
    /// <p>The cluster version that you want to change. After this operation completes successfully, the cluster will have a new version.</p>
    public let currentVersion: String?
    /// <p>The Amazon MSK broker type that you want all of the brokers in this cluster to be.</p>
    public let targetInstanceType: String?

    public init (
        clusterArn: String? = nil,
        currentVersion: String? = nil,
        targetInstanceType: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetInstanceType = targetInstanceType
    }
}

struct UpdateBrokerTypeInputBody: Equatable {
    public let currentVersion: String?
    public let targetInstanceType: String?
}

extension UpdateBrokerTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "currentVersion"
        case targetInstanceType = "targetInstanceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetInstanceType)
        targetInstanceType = targetInstanceTypeDecoded
    }
}

extension UpdateBrokerTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBrokerTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBrokerTypeOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBrokerTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBrokerTypeOutputResponse(clusterArn: \(String(describing: clusterArn)), clusterOperationArn: \(String(describing: clusterOperationArn)))"}
}

extension UpdateBrokerTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBrokerTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateBrokerTypeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterArn: String?
    /// <p>The Amazon Resource Name (ARN) of the cluster operation.</p>
    public let clusterOperationArn: String?

    public init (
        clusterArn: String? = nil,
        clusterOperationArn: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateBrokerTypeOutputResponseBody: Equatable {
    public let clusterArn: String?
    public let clusterOperationArn: String?
}

extension UpdateBrokerTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateClusterConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateClusterConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateClusterConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterConfigurationOutputError>
}

extension UpdateClusterConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClusterConfigurationInput(clusterArn: \(String(describing: clusterArn)), configurationInfo: \(String(describing: configurationInfo)), currentVersion: \(String(describing: currentVersion)))"}
}

extension UpdateClusterConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationInfo = configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }
}

public struct UpdateClusterConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateClusterConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateClusterConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterConfigurationOutputError>
}

public struct UpdateClusterConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateClusterConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateClusterConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterConfigurationOutputError>
}

public struct UpdateClusterConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    public let clusterArn: String?
    /// <p>Represents the configuration that you want MSK to use for the brokers in a cluster.</p>
    public let configurationInfo: ConfigurationInfo?
    /// <p>The version of the cluster that needs to be updated.</p>
    public let currentVersion: String?

    public init (
        clusterArn: String? = nil,
        configurationInfo: ConfigurationInfo? = nil,
        currentVersion: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.configurationInfo = configurationInfo
        self.currentVersion = currentVersion
    }
}

struct UpdateClusterConfigurationInputBody: Equatable {
    public let configurationInfo: ConfigurationInfo?
    public let currentVersion: String?
}

extension UpdateClusterConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationInfoDecoded = try containerValues.decodeIfPresent(ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension UpdateClusterConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClusterConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClusterConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClusterConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClusterConfigurationOutputResponse(clusterArn: \(String(describing: clusterArn)), clusterOperationArn: \(String(describing: clusterOperationArn)))"}
}

extension UpdateClusterConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateClusterConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateClusterConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterArn: String?
    /// <p>The Amazon Resource Name (ARN) of the cluster operation.</p>
    public let clusterOperationArn: String?

    public init (
        clusterArn: String? = nil,
        clusterOperationArn: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateClusterConfigurationOutputResponseBody: Equatable {
    public let clusterArn: String?
    public let clusterOperationArn: String?
}

extension UpdateClusterConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateClusterKafkaVersionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateClusterKafkaVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterKafkaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterKafkaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterKafkaVersionInput>
    public typealias MOutput = OperationOutput<UpdateClusterKafkaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterKafkaVersionOutputError>
}

extension UpdateClusterKafkaVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClusterKafkaVersionInput(clusterArn: \(String(describing: clusterArn)), configurationInfo: \(String(describing: configurationInfo)), currentVersion: \(String(describing: currentVersion)), targetKafkaVersion: \(String(describing: targetKafkaVersion)))"}
}

extension UpdateClusterKafkaVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
        case targetKafkaVersion = "targetKafkaVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationInfo = configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let targetKafkaVersion = targetKafkaVersion {
            try encodeContainer.encode(targetKafkaVersion, forKey: .targetKafkaVersion)
        }
    }
}

public struct UpdateClusterKafkaVersionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateClusterKafkaVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterKafkaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterKafkaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterKafkaVersionInput>
    public typealias MOutput = OperationOutput<UpdateClusterKafkaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterKafkaVersionOutputError>
}

public struct UpdateClusterKafkaVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateClusterKafkaVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterKafkaVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterKafkaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterKafkaVersionInput>
    public typealias MOutput = OperationOutput<UpdateClusterKafkaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterKafkaVersionOutputError>
}

public struct UpdateClusterKafkaVersionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
    public let clusterArn: String?
    /// <p>The custom configuration that should be applied on the new version of cluster.</p>
    public let configurationInfo: ConfigurationInfo?
    /// <p>Current cluster version.</p>
    public let currentVersion: String?
    /// <p>Target Kafka version.</p>
    public let targetKafkaVersion: String?

    public init (
        clusterArn: String? = nil,
        configurationInfo: ConfigurationInfo? = nil,
        currentVersion: String? = nil,
        targetKafkaVersion: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.configurationInfo = configurationInfo
        self.currentVersion = currentVersion
        self.targetKafkaVersion = targetKafkaVersion
    }
}

struct UpdateClusterKafkaVersionInputBody: Equatable {
    public let configurationInfo: ConfigurationInfo?
    public let currentVersion: String?
    public let targetKafkaVersion: String?
}

extension UpdateClusterKafkaVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
        case targetKafkaVersion = "targetKafkaVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationInfoDecoded = try containerValues.decodeIfPresent(ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetKafkaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetKafkaVersion)
        targetKafkaVersion = targetKafkaVersionDecoded
    }
}

extension UpdateClusterKafkaVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClusterKafkaVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClusterKafkaVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClusterKafkaVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClusterKafkaVersionOutputResponse(clusterArn: \(String(describing: clusterArn)), clusterOperationArn: \(String(describing: clusterOperationArn)))"}
}

extension UpdateClusterKafkaVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateClusterKafkaVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateClusterKafkaVersionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterArn: String?
    /// <p>The Amazon Resource Name (ARN) of the cluster operation.</p>
    public let clusterOperationArn: String?

    public init (
        clusterArn: String? = nil,
        clusterOperationArn: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateClusterKafkaVersionOutputResponseBody: Equatable {
    public let clusterArn: String?
    public let clusterOperationArn: String?
}

extension UpdateClusterKafkaVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationOutputError>
}

extension UpdateConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationInput(arn: \(String(describing: arn)), description: \(String(describing: description)), serverProperties: \(String(describing: serverProperties)))"}
}

extension UpdateConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case serverProperties = "serverProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let serverProperties = serverProperties {
            try encodeContainer.encode(serverProperties.base64EncodedString(), forKey: .serverProperties)
        }
    }
}

public struct UpdateConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationOutputError>
}

public struct UpdateConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationOutputError>
}

public struct UpdateConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
    public let arn: String?
    /// <p>The description of the configuration revision.</p>
    public let description: String?
    /// <p>Contents of the <filename>server.properties</filename> file. When using the API, you must ensure that the contents of the file are base64 encoded.
    ///                When using the AWS Management Console, the SDK, or the AWS CLI, the contents of <filename>server.properties</filename> can be in plaintext.</p>
    public let serverProperties: Data?

    public init (
        arn: String? = nil,
        description: String? = nil,
        serverProperties: Data? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.serverProperties = serverProperties
    }
}

struct UpdateConfigurationInputBody: Equatable {
    public let description: String?
    public let serverProperties: Data?
}

extension UpdateConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case serverProperties = "serverProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let serverPropertiesDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .serverProperties)
        serverProperties = serverPropertiesDecoded
    }
}

extension UpdateConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationOutputResponse(arn: \(String(describing: arn)), latestRevision: \(String(describing: latestRevision)))"}
}

extension UpdateConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.latestRevision = output.latestRevision
        } else {
            self.arn = nil
            self.latestRevision = nil
        }
    }
}

public struct UpdateConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
    public let arn: String?
    /// <p>Latest revision of the configuration.</p>
    public let latestRevision: ConfigurationRevision?

    public init (
        arn: String? = nil,
        latestRevision: ConfigurationRevision? = nil
    )
    {
        self.arn = arn
        self.latestRevision = latestRevision
    }
}

struct UpdateConfigurationOutputResponseBody: Equatable {
    public let arn: String?
    public let latestRevision: ConfigurationRevision?
}

extension UpdateConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case latestRevision = "latestRevision"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
    }
}

public struct UpdateMonitoringInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMonitoringInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMonitoringInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMonitoringInput>
    public typealias MOutput = OperationOutput<UpdateMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMonitoringOutputError>
}

extension UpdateMonitoringInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMonitoringInput(clusterArn: \(String(describing: clusterArn)), currentVersion: \(String(describing: currentVersion)), enhancedMonitoring: \(String(describing: enhancedMonitoring)), loggingInfo: \(String(describing: loggingInfo)), openMonitoring: \(String(describing: openMonitoring)))"}
}

extension UpdateMonitoringInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "currentVersion"
        case enhancedMonitoring = "enhancedMonitoring"
        case loggingInfo = "loggingInfo"
        case openMonitoring = "openMonitoring"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let openMonitoring = openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
    }
}

public struct UpdateMonitoringInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMonitoringInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMonitoringInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMonitoringInput>
    public typealias MOutput = OperationOutput<UpdateMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMonitoringOutputError>
}

public struct UpdateMonitoringInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMonitoringInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMonitoringInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMonitoringInput>
    public typealias MOutput = OperationOutput<UpdateMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMonitoringOutputError>
}

/// Request body for UpdateMonitoring.
public struct UpdateMonitoringInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    public let clusterArn: String?
    /// <p>The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.</p>
    public let currentVersion: String?
    /// <p>Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.</p>
    public let enhancedMonitoring: EnhancedMonitoring?
    public let loggingInfo: LoggingInfo?
    /// <p>The settings for open monitoring.</p>
    public let openMonitoring: OpenMonitoringInfo?

    public init (
        clusterArn: String? = nil,
        currentVersion: String? = nil,
        enhancedMonitoring: EnhancedMonitoring? = nil,
        loggingInfo: LoggingInfo? = nil,
        openMonitoring: OpenMonitoringInfo? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.enhancedMonitoring = enhancedMonitoring
        self.loggingInfo = loggingInfo
        self.openMonitoring = openMonitoring
    }
}

struct UpdateMonitoringInputBody: Equatable {
    public let currentVersion: String?
    public let enhancedMonitoring: EnhancedMonitoring?
    public let openMonitoring: OpenMonitoringInfo?
    public let loggingInfo: LoggingInfo?
}

extension UpdateMonitoringInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "currentVersion"
        case enhancedMonitoring = "enhancedMonitoring"
        case loggingInfo = "loggingInfo"
        case openMonitoring = "openMonitoring"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(OpenMonitoringInfo.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
    }
}

extension UpdateMonitoringOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMonitoringOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMonitoringOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMonitoringOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMonitoringOutputResponse(clusterArn: \(String(describing: clusterArn)), clusterOperationArn: \(String(describing: clusterOperationArn)))"}
}

extension UpdateMonitoringOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateMonitoringOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateMonitoringOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the cluster.</p>
    public let clusterArn: String?
    /// <p>The Amazon Resource Name (ARN) of the cluster operation.</p>
    public let clusterOperationArn: String?

    public init (
        clusterArn: String? = nil,
        clusterOperationArn: String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateMonitoringOutputResponseBody: Equatable {
    public let clusterArn: String?
    public let clusterOperationArn: String?
}

extension UpdateMonitoringOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

extension ZookeeperNodeInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachedENIId = "attachedENIId"
        case clientVpcIpAddress = "clientVpcIpAddress"
        case endpoints = "endpoints"
        case zookeeperId = "zookeeperId"
        case zookeeperVersion = "zookeeperVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedENIId = attachedENIId {
            try encodeContainer.encode(attachedENIId, forKey: .attachedENIId)
        }
        if let clientVpcIpAddress = clientVpcIpAddress {
            try encodeContainer.encode(clientVpcIpAddress, forKey: .clientVpcIpAddress)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for __listof__string0 in endpoints {
                try endpointsContainer.encode(__listof__string0)
            }
        }
        if zookeeperId != 0.0 {
            try encodeContainer.encode(zookeeperId, forKey: .zookeeperId)
        }
        if let zookeeperVersion = zookeeperVersion {
            try encodeContainer.encode(zookeeperVersion, forKey: .zookeeperVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedENIIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachedENIId)
        attachedENIId = attachedENIIdDecoded
        let clientVpcIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientVpcIpAddress)
        clientVpcIpAddress = clientVpcIpAddressDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .endpoints)
        var endpointsDecoded0:[String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [String]()
            for string0 in endpointsContainer {
                if let string0 = string0 {
                    endpointsDecoded0?.append(string0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let zookeeperIdDecoded = try containerValues.decode(Double.self, forKey: .zookeeperId)
        zookeeperId = zookeeperIdDecoded
        let zookeeperVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .zookeeperVersion)
        zookeeperVersion = zookeeperVersionDecoded
    }
}

extension ZookeeperNodeInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZookeeperNodeInfo(attachedENIId: \(String(describing: attachedENIId)), clientVpcIpAddress: \(String(describing: clientVpcIpAddress)), endpoints: \(String(describing: endpoints)), zookeeperId: \(String(describing: zookeeperId)), zookeeperVersion: \(String(describing: zookeeperVersion)))"}
}

/// <p>Zookeeper node information.</p>
public struct ZookeeperNodeInfo: Equatable {
    /// <p>The attached elastic network interface of the broker.</p>
    public let attachedENIId: String?
    /// <p>The virtual private cloud (VPC) IP address of the client.</p>
    public let clientVpcIpAddress: String?
    /// <p>Endpoints for accessing the ZooKeeper.</p>
    public let endpoints: [String]?
    /// <p>The role-specific ID for Zookeeper.</p>
    public let zookeeperId: Double
    /// <p>The version of Zookeeper.</p>
    public let zookeeperVersion: String?

    public init (
        attachedENIId: String? = nil,
        clientVpcIpAddress: String? = nil,
        endpoints: [String]? = nil,
        zookeeperId: Double = 0.0,
        zookeeperVersion: String? = nil
    )
    {
        self.attachedENIId = attachedENIId
        self.clientVpcIpAddress = clientVpcIpAddress
        self.endpoints = endpoints
        self.zookeeperId = zookeeperId
        self.zookeeperVersion = zookeeperVersion
    }
}
