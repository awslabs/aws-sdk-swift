// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have permission to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteReportDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReportDefinitionInput(reportId: \(String(describing: reportId)))"}
}

extension DeleteReportDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteReportDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReportDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReportDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReportDefinitionOutputError>
}

public struct DeleteReportDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReportDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReportDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReportDefinitionOutputError>
}

public struct DeleteReportDefinitionInput: Equatable {
    /// <p>Required. ID of the report to delete.</p>
    public let reportId: String?

    public init (
        reportId: String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct DeleteReportDefinitionInputBody: Equatable {
}

extension DeleteReportDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteReportDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReportDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReportDefinitionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReportDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReportDefinitionOutputResponse(reportId: \(String(describing: reportId)))"}
}

extension DeleteReportDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct DeleteReportDefinitionOutputResponse: Equatable {
    /// <p>ID of the report that was deleted.</p>
    public let reportId: String?

    public init (
        reportId: String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct DeleteReportDefinitionOutputResponseBody: Equatable {
    public let reportId: String?
}

extension DeleteReportDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

public enum Format {
    case csv
    case parquet
    case sdkUnknown(String)
}

extension Format : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Format] {
        return [
            .csv,
            .parquet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .parquet: return "PARQUET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
    }
}

extension GetReportDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReportDefinitionInput(reportId: \(String(describing: reportId)))"}
}

extension GetReportDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetReportDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetReportDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReportDefinitionInput>
    public typealias MOutput = OperationOutput<GetReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReportDefinitionOutputError>
}

public struct GetReportDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetReportDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReportDefinitionInput>
    public typealias MOutput = OperationOutput<GetReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReportDefinitionOutputError>
}

public struct GetReportDefinitionInput: Equatable {
    /// <p>ID of the report to retrieve.</p>
    public let reportId: String?

    public init (
        reportId: String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct GetReportDefinitionInputBody: Equatable {
}

extension GetReportDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetReportDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReportDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReportDefinitionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReportDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReportDefinitionOutputResponse(createdAt: \(String(describing: createdAt)), destinationS3Location: \(String(describing: destinationS3Location)), format: \(String(describing: format)), lastUpdated: \(String(describing: lastUpdated)), reportDescription: \(String(describing: reportDescription)), reportFrequency: \(String(describing: reportFrequency)), reportId: \(String(describing: reportId)))"}
}

extension GetReportDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.destinationS3Location = output.destinationS3Location
            self.format = output.format
            self.lastUpdated = output.lastUpdated
            self.reportDescription = output.reportDescription
            self.reportFrequency = output.reportFrequency
            self.reportId = output.reportId
        } else {
            self.createdAt = nil
            self.destinationS3Location = nil
            self.format = nil
            self.lastUpdated = nil
            self.reportDescription = nil
            self.reportFrequency = nil
            self.reportId = nil
        }
    }
}

public struct GetReportDefinitionOutputResponse: Equatable {
    /// <p>Timestamp (milliseconds) when this report definition was created.</p>
    public let createdAt: Date?
    /// <p>Amazon Simple Storage Service (Amazon S3) location where the report is uploaded.</p>
    public let destinationS3Location: S3Location?
    /// <p>Format of the generated report.</p>
    public let format: Format?
    /// <p>Timestamp (milliseconds) when this report definition was last updated.</p>
    public let lastUpdated: Date?
    /// <p>Description of the report.</p>
    public let reportDescription: String?
    /// <p>Cadence used to generate the report.</p>
    public let reportFrequency: ReportFrequency?
    /// <p>ID of the report retrieved.</p>
    public let reportId: String?

    public init (
        createdAt: Date? = nil,
        destinationS3Location: S3Location? = nil,
        format: Format? = nil,
        lastUpdated: Date? = nil,
        reportDescription: String? = nil,
        reportFrequency: ReportFrequency? = nil,
        reportId: String? = nil
    )
    {
        self.createdAt = createdAt
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.lastUpdated = lastUpdated
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct GetReportDefinitionOutputResponseBody: Equatable {
    public let reportId: String?
    public let reportDescription: String?
    public let reportFrequency: ReportFrequency?
    public let format: Format?
    public let destinationS3Location: S3Location?
    public let createdAt: Date?
    public let lastUpdated: Date?
}

extension GetReportDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case destinationS3Location
        case format
        case lastUpdated
        case reportDescription
        case reportFrequency
        case reportId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

public struct ImportApplicationUsageInputBodyMiddleware: Middleware {
    public let id: String = "ImportApplicationUsageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportApplicationUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportApplicationUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportApplicationUsageInput>
    public typealias MOutput = OperationOutput<ImportApplicationUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportApplicationUsageOutputError>
}

extension ImportApplicationUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportApplicationUsageInput(sourceS3Location: \(String(describing: sourceS3Location)))"}
}

extension ImportApplicationUsageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceS3Location
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceS3Location = sourceS3Location {
            try encodeContainer.encode(sourceS3Location, forKey: .sourceS3Location)
        }
    }
}

public struct ImportApplicationUsageInputHeadersMiddleware: Middleware {
    public let id: String = "ImportApplicationUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportApplicationUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportApplicationUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportApplicationUsageInput>
    public typealias MOutput = OperationOutput<ImportApplicationUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportApplicationUsageOutputError>
}

public struct ImportApplicationUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportApplicationUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportApplicationUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportApplicationUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportApplicationUsageInput>
    public typealias MOutput = OperationOutput<ImportApplicationUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportApplicationUsageOutputError>
}

public struct ImportApplicationUsageInput: Equatable {
    /// <p>Amazon S3 location to import application usage data from.</p>
    public let sourceS3Location: SourceS3Location?

    public init (
        sourceS3Location: SourceS3Location? = nil
    )
    {
        self.sourceS3Location = sourceS3Location
    }
}

struct ImportApplicationUsageInputBody: Equatable {
    public let sourceS3Location: SourceS3Location?
}

extension ImportApplicationUsageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceS3Location
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceS3LocationDecoded = try containerValues.decodeIfPresent(SourceS3Location.self, forKey: .sourceS3Location)
        sourceS3Location = sourceS3LocationDecoded
    }
}

extension ImportApplicationUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportApplicationUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportApplicationUsageOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportApplicationUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportApplicationUsageOutputResponse(importId: \(String(describing: importId)))"}
}

extension ImportApplicationUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportApplicationUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.importId = output.importId
        } else {
            self.importId = nil
        }
    }
}

public struct ImportApplicationUsageOutputResponse: Equatable {
    /// <p>ID of the import request.</p>
    public let importId: String?

    public init (
        importId: String? = nil
    )
    {
        self.importId = importId
    }
}

struct ImportApplicationUsageOutputResponseBody: Equatable {
    public let importId: String?
}

extension ImportApplicationUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importId)
        importId = importIdDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal server error occurred. Retry your request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListReportDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReportDefinitionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListReportDefinitionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListReportDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListReportDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReportDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReportDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReportDefinitionsInput>
    public typealias MOutput = OperationOutput<ListReportDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReportDefinitionsOutputError>
}

public struct ListReportDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReportDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReportDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReportDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReportDefinitionsInput>
    public typealias MOutput = OperationOutput<ListReportDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReportDefinitionsOutputError>
}

public struct ListReportDefinitionsInput: Equatable {
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token value from a previous call to access the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReportDefinitionsInputBody: Equatable {
}

extension ListReportDefinitionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListReportDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReportDefinitionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReportDefinitionsOutputResponse(nextToken: \(String(describing: nextToken)), reportDefinitions: \(String(describing: reportDefinitions)))"}
}

extension ListReportDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReportDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.reportDefinitions = output.reportDefinitions
        } else {
            self.nextToken = nil
            self.reportDefinitions = nil
        }
    }
}

public struct ListReportDefinitionsOutputResponse: Equatable {
    /// <p>The value of the next token, if it exists. Null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The retrieved reports.</p>
    public let reportDefinitions: [ReportDefinition]?

    public init (
        nextToken: String? = nil,
        reportDefinitions: [ReportDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportDefinitions = reportDefinitions
    }
}

struct ListReportDefinitionsOutputResponseBody: Equatable {
    public let reportDefinitions: [ReportDefinition]?
    public let nextToken: String?
}

extension ListReportDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case reportDefinitions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDefinitionsContainer = try containerValues.decodeIfPresent([ReportDefinition?].self, forKey: .reportDefinitions)
        var reportDefinitionsDecoded0:[ReportDefinition]? = nil
        if let reportDefinitionsContainer = reportDefinitionsContainer {
            reportDefinitionsDecoded0 = [ReportDefinition]()
            for structure0 in reportDefinitionsContainer {
                if let structure0 = structure0 {
                    reportDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        reportDefinitions = reportDefinitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct PutReportDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "PutReportDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutReportDefinitionInput>
    public typealias MOutput = OperationOutput<PutReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutReportDefinitionOutputError>
}

extension PutReportDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutReportDefinitionInput(destinationS3Location: \(String(describing: destinationS3Location)), format: \(String(describing: format)), reportDescription: \(String(describing: reportDescription)), reportFrequency: \(String(describing: reportFrequency)), reportId: \(String(describing: reportId)))"}
}

extension PutReportDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
        case reportId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationS3Location = destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let reportDescription = reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
        if let reportId = reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }
}

public struct PutReportDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "PutReportDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutReportDefinitionInput>
    public typealias MOutput = OperationOutput<PutReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutReportDefinitionOutputError>
}

public struct PutReportDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutReportDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutReportDefinitionInput>
    public typealias MOutput = OperationOutput<PutReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutReportDefinitionOutputError>
}

public struct PutReportDefinitionInput: Equatable {
    /// <p>Required. Amazon Simple Storage Service (Amazon S3) location where Application Cost Profiler uploads the
    ///       report.</p>
    public let destinationS3Location: S3Location?
    /// <p>Required. The format to use for the generated report.</p>
    public let format: Format?
    /// <p>Required. Description of the report.</p>
    public let reportDescription: String?
    /// <p>Required. The cadence to generate the report.</p>
    public let reportFrequency: ReportFrequency?
    /// <p>Required. ID of the report. You can choose any valid string matching the pattern for the
    ///       ID.</p>
    public let reportId: String?

    public init (
        destinationS3Location: S3Location? = nil,
        format: Format? = nil,
        reportDescription: String? = nil,
        reportFrequency: ReportFrequency? = nil,
        reportId: String? = nil
    )
    {
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct PutReportDefinitionInputBody: Equatable {
    public let reportId: String?
    public let reportDescription: String?
    public let reportFrequency: ReportFrequency?
    public let format: Format?
    public let destinationS3Location: S3Location?
}

extension PutReportDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
        case reportId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
    }
}

extension PutReportDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutReportDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutReportDefinitionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutReportDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutReportDefinitionOutputResponse(reportId: \(String(describing: reportId)))"}
}

extension PutReportDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct PutReportDefinitionOutputResponse: Equatable {
    /// <p>ID of the report.</p>
    public let reportId: String?

    public init (
        reportId: String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct PutReportDefinitionOutputResponseBody: Equatable {
    public let reportId: String?
}

extension PutReportDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension ReportDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case destinationS3Location
        case format
        case lastUpdatedAt
        case reportDescription
        case reportFrequency
        case reportId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let destinationS3Location = destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let reportDescription = reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
        if let reportId = reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension ReportDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportDefinition(createdAt: \(String(describing: createdAt)), destinationS3Location: \(String(describing: destinationS3Location)), format: \(String(describing: format)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), reportDescription: \(String(describing: reportDescription)), reportFrequency: \(String(describing: reportFrequency)), reportId: \(String(describing: reportId)))"}
}

/// <p>The configuration of a report in AWS Application Cost Profiler.</p>
public struct ReportDefinition: Equatable {
    /// <p>Timestamp (milliseconds) when this report definition was created.</p>
    public let createdAt: Date?
    /// <p>The location in Amazon Simple Storage Service (Amazon S3) the reports should be saved to.</p>
    public let destinationS3Location: S3Location?
    /// <p>The format used for the generated reports.</p>
    public let format: Format?
    /// <p>Timestamp (milliseconds) when this report definition was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>Description of the report</p>
    public let reportDescription: String?
    /// <p>The cadence at which the report is generated.</p>
    public let reportFrequency: ReportFrequency?
    /// <p>The ID of the report.</p>
    public let reportId: String?

    public init (
        createdAt: Date? = nil,
        destinationS3Location: S3Location? = nil,
        format: Format? = nil,
        lastUpdatedAt: Date? = nil,
        reportDescription: String? = nil,
        reportFrequency: ReportFrequency? = nil,
        reportId: String? = nil
    )
    {
        self.createdAt = createdAt
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.lastUpdatedAt = lastUpdatedAt
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

public enum ReportFrequency {
    case all
    case daily
    case monthly
    case sdkUnknown(String)
}

extension ReportFrequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportFrequency] {
        return [
            .all,
            .daily,
            .monthly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .daily: return "DAILY"
        case .monthly: return "MONTHLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportFrequency(rawValue: rawValue) ?? ReportFrequency.sdkUnknown(rawValue)
    }
}

public enum S3BucketRegion {
    case afSouth1
    case apEast1
    case euSouth1
    case meSouth1
    case sdkUnknown(String)
}

extension S3BucketRegion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3BucketRegion] {
        return [
            .afSouth1,
            .apEast1,
            .euSouth1,
            .meSouth1,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .afSouth1: return "af-south-1"
        case .apEast1: return "ap-east-1"
        case .euSouth1: return "eu-south-1"
        case .meSouth1: return "me-south-1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3BucketRegion(rawValue: rawValue) ?? S3BucketRegion.sdkUnknown(rawValue)
    }
}

extension S3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case prefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension S3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Location(bucket: \(String(describing: bucket)), prefix: \(String(describing: prefix)))"}
}

/// <p>Represents the Amazon Simple Storage Service (Amazon S3) location where AWS Application Cost Profiler
///       reports are generated and then written to.</p>
public struct S3Location: Equatable {
    /// <p>Name of the S3 bucket.</p>
    public let bucket: String?
    /// <p>Prefix for the location to write to.</p>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.prefix = prefix
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request exceeds one or more of the service quotas.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceS3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case key
        case region
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let region = region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let regionDecoded = try containerValues.decodeIfPresent(S3BucketRegion.self, forKey: .region)
        region = regionDecoded
    }
}

extension SourceS3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceS3Location(bucket: \(String(describing: bucket)), key: \(String(describing: key)), region: \(String(describing: region)))"}
}

/// <p>Represents the Amazon Simple Storage Service (Amazon S3) location where usage data is read
///       from.</p>
public struct SourceS3Location: Equatable {
    /// <p>Name of the bucket.</p>
    public let bucket: String?
    /// <p>Key of the object.</p>
    public let key: String?
    /// <p>Region of the bucket. Only required for Regions that are disabled by default.
    ///         For more infomration about Regions that are disabled by default, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande-manage.html#rande-manage-enable">
    ///           Enabling a Region</a> in the <i>AWS General Reference guide</i>.</p>
    public let region: S3BucketRegion?

    public init (
        bucket: String? = nil,
        key: String? = nil,
        region: S3BucketRegion? = nil
    )
    {
        self.bucket = bucket
        self.key = key
        self.region = region
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The calls to AWS Application Cost Profiler API are throttled. The request was denied.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateReportDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateReportDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReportDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReportDefinitionOutputError>
}

extension UpdateReportDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReportDefinitionInput(destinationS3Location: \(String(describing: destinationS3Location)), format: \(String(describing: format)), reportDescription: \(String(describing: reportDescription)), reportFrequency: \(String(describing: reportFrequency)), reportId: \(String(describing: reportId)))"}
}

extension UpdateReportDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationS3Location = destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let reportDescription = reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
    }
}

public struct UpdateReportDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateReportDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReportDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReportDefinitionOutputError>
}

public struct UpdateReportDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateReportDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReportDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReportDefinitionOutputError>
}

public struct UpdateReportDefinitionInput: Equatable {
    /// <p>Required. Amazon Simple Storage Service (Amazon S3) location where Application Cost Profiler uploads the
    ///       report.</p>
    public let destinationS3Location: S3Location?
    /// <p>Required. The format to use for the generated report.</p>
    public let format: Format?
    /// <p>Required. Description of the report.</p>
    public let reportDescription: String?
    /// <p>Required. The cadence to generate the report.</p>
    public let reportFrequency: ReportFrequency?
    /// <p>Required. ID of the report to update.</p>
    public let reportId: String?

    public init (
        destinationS3Location: S3Location? = nil,
        format: Format? = nil,
        reportDescription: String? = nil,
        reportFrequency: ReportFrequency? = nil,
        reportId: String? = nil
    )
    {
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct UpdateReportDefinitionInputBody: Equatable {
    public let reportDescription: String?
    public let reportFrequency: ReportFrequency?
    public let format: Format?
    public let destinationS3Location: S3Location?
}

extension UpdateReportDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
    }
}

extension UpdateReportDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReportDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReportDefinitionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReportDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReportDefinitionOutputResponse(reportId: \(String(describing: reportId)))"}
}

extension UpdateReportDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct UpdateReportDefinitionOutputResponse: Equatable {
    /// <p>ID of the report.</p>
    public let reportId: String?

    public init (
        reportId: String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct UpdateReportDefinitionOutputResponseBody: Equatable {
    public let reportId: String?
}

extension UpdateReportDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints for the API.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
